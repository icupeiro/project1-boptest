package Modelica_StateGraph2
  "Modelica_StateGraph2 (Version 2.0.4) - Modeling of continuous-time state machines"

package Blocks
  "Input/output blocks that are designed for StateGraph2 but shall be included in the Modelica Standard Library"

  package BooleanFunctions
  "Functions with Boolean inputs (shall be included in Modelica Standard Library)"

    function anyTrue
      "Returns true, if at least on element of the Boolean input vector is true ('or')"

      extends Modelica.Icons.Function;
      input Boolean b[:];
      output Boolean result;
    algorithm
      result := false;
      for i in 1:size(b, 1) loop
        result := result or b[i];
      end for;
    end anyTrue;
  end BooleanFunctions;
  annotation (Documentation(info="<html>
<p>
An important practical aspect of state machines is the ability to assign values and expressions to variables depending on the state of the machine. In StateGraph2, a number of graphical components have been added in this package (= Modelica_StateGraph2.Blocks)
to facilitate usage in a safe and intuitive way. Since these are just input/output blocks and will also be useful in another context, it is planned to add them to the Modelica Standard Library.
Some usage examples are given
<a href=\"modelica://Modelica_StateGraph2.UsersGuide.Tutorial.Actions\">here</a>
in the tutorial, e.g., the example shown in the Figure below.
</p>

<blockquote>
<img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/MultiSwitch.png\">
</blockquote>

</html>"));
end Blocks;

package Internal "Internal utility models (should usually not be used by user)"

  package Interfaces "Connectors and partial models"

    record Node
      "Node of a state machine to communicate information between steps (for suspend/resume actions and to guarantee a valid graph)"
      Boolean suspend
        "= true, if the composite step is terminated via a suspend port";
      Boolean resume
        "= true, if the composite step is entered via a resume port";
      function equalityConstraint
        input Node node1;
        input Node node2;
        output Real residue[0];
      algorithm
        assert(node1.suspend == node2.suspend and node1.resume == node2.resume,
          "Internal error");
      end equalityConstraint;
    end Node;

    connector Step_in_base "Input port of a step without icon"
      input Boolean fire "true, if transition fires and step is activated"
        annotation (HideResult=true);

      Node node
        "Communicates suspend/resume flags and is used to check the correct connection structure."
        annotation (HideResult=true);

      // only for checking properties of the graph
      output Boolean checkUnaryConnection
        "Is used to guarantee that only 1:1 connections are possible"
        annotation (HideResult=true);

      input Boolean checkOneDelayedTransitionPerLoop
        "Is used to check that every connection loop has at least one delayed transition"
        annotation (__Dymola_BooleanLoopMessage="
Every loop of a StateGraph must have at least one delayed transition
(an instance of Components.Transition with parameter delayedTransition = true)
in order that infinite event looping cannot occur. Alternatively you can set
checkLoop=false in the Advanced tab of the Transition, provided you are
absolutely sure that this cannot happen.
", HideResult=true);

    end Step_in_base;

    connector Step_out_base "Output port of a step without icon"
      output Boolean available
        "= true, if step is active and firing is possible"
        annotation (HideResult=true);
      input Boolean fire "= true, if transition fires and step is deactivated"
        annotation (HideResult=true);

      Node node
        "Communicates suspend/resume flags and is used to check the correct connection structure."
        annotation (HideResult=true);

      // only for checking properties of the graph
      output Boolean checkOneDelayedTransitionPerLoop
        "Is used to check that every connection loop has at least one delayed transition"
        annotation (__Dymola_BooleanLoopMessage="
Every loop of a StateGraph must have at least one delayed transition
(an instance of Components.Transition with parameter delayedTransition = true)
in order that infinite event looping cannot occur. Alternatively you can set
checkLoop=false in the Advanced tab of the Transition, provided you are
absolutely sure that this cannot happen.
", HideResult=true);
    end Step_out_base;

    connector Step_in "Input port of a step"
      extends Step_in_base;

      annotation (
        defaultComponentName="inPort",
        Icon(coordinateSystem(extent={{-100,-100},{100,100}},
              preserveAspectRatio=false), graphics={Ellipse(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,0},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
              preserveAspectRatio=false), graphics={
            Rectangle(
              extent={{0,0},{0,0}},
              lineColor={0,0,0},
              fillColor={0,0,0},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-40,40},{40,-40}},
              lineColor={0,0,0},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{47,58},{112,20}},
              lineColor={0,0,0},
              textString="%name")}));
    end Step_in;

    connector Step_out "Output port of a step"
      extends Step_out_base;

      annotation (
        defaultComponentName="outPort",
        Icon(coordinateSystem(extent={{-100,-100},{100,100}},
              preserveAspectRatio=false), graphics={Polygon(
              points={{-100,100},{0,-100},{100,100},{-100,100}},
              lineColor={0,0,0},
              smooth=Smooth.None,
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
              preserveAspectRatio=false), graphics={
            Rectangle(
              extent={{0,0},{0,0}},
              lineColor={0,0,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Polygon(
              points={{-40,100},{0,20},{40,100},{-40,100}},
              lineColor={0,0,0},
              smooth=Smooth.None,
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{40,66},{116,30}},
              lineColor={0,0,0},
              textString="%name")}));
    end Step_out;

    connector Transition_in_base "Input port of a transition without an icon"
      input Boolean available
        "= true, if step connected to the transition input is active and firing is possible"
        annotation (HideResult=true);

      output Boolean fire
        "= true, if transition fires and the step connected to the transition input is deactivated"
        annotation (HideResult=true);

      Node node
        "Communicates suspend/resume flags and is used to check the correct connection structure."
        annotation (HideResult=true);

      // only for checking properties of the graph
      input Boolean checkOneDelayedTransitionPerLoop
        "Is used to check that every connection loop has at least one delayed transition"
        annotation (__Dymola_BooleanLoopMessage="
Every loop of a StateGraph must have at least one delayed transition
(an instance of Components.Transition with parameter delayedTransition = true)
in order that infinite event looping cannot occur. Alternatively you can set
checkLoop=false in the Advanced tab of the Transition, provided you are
absolutely sure that this cannot happen.
", HideResult=true);
    end Transition_in_base;

    connector Transition_out_base "Output port of a transition without icon"
      output Boolean fire
        "true, if transition fires and step connected to the transition output becomes active"
        annotation (HideResult=true);

      Node node
        "Communicates suspend/resume flags and is used to check the correct connection structure."
        annotation (HideResult=true);

      // only for checking properties of the graph
      input Boolean checkUnaryConnection
        "Is used to guarantee that only 1:1 connections are possible"
        annotation (HideResult=true);

      output Boolean checkOneDelayedTransitionPerLoop
        "Is used to check that every connection loop has at least one delayed transition"
        annotation (__Dymola_BooleanLoopMessage="
Every loop of a StateGraph must have at least one delayed transition
(an instance of Components.Transition with parameter delayedTransition = true)
in order that infinite event looping cannot occur. Alternatively you can set
checkLoop=false in the Advanced tab of the Transition, provided you are
absolutely sure that this cannot happen.
", HideResult=true);
    end Transition_out_base;

    connector Transition_in "Input port of a transition"
      extends Transition_in_base;

      annotation (
        defaultComponentName="inPort",
        Icon(coordinateSystem(extent={{-100,-100},{100,100}},
              preserveAspectRatio=false), graphics={Ellipse(
              extent={{-100,100},{100,-100}},
              lineColor={0,0,0},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
              preserveAspectRatio=false), graphics={Ellipse(
              extent={{-40,40},{40,-40}},
              lineColor={0,0,0},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid), Text(
              extent={{51,22},{134,-16}},
              lineColor={0,0,0},
              textString="%name")}),
        Documentation(info="<html>

</html>"));
    end Transition_in;

    connector Transition_out "Output port of a transition"
      extends Transition_out_base;

      annotation (
        defaultComponentName="outPort",
        Icon(coordinateSystem(extent={{-100,-100},{100,100}},
              preserveAspectRatio=false), graphics={Polygon(
              points={{-100,100},{0,-100},{100,100},{-100,100}},
              lineColor={0,0,0},
              smooth=Smooth.None,
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(extent={{-100,-100},{100,100}},
              preserveAspectRatio=false), graphics={Polygon(
              points={{-40,100},{0,20},{40,100},{-40,100}},
              lineColor={0,0,0},
              smooth=Smooth.None,
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid), Text(
              extent={{44,100},{138,68}},
              lineColor={0,0,0},
              textString="%name")}),
        Documentation(info="<html>

</html>"));
    end Transition_out;
  end Interfaces;

  package Utilities
  "Utility functions used to implement a Modelica_StateGraph2"

    function propagateLoopCheck "Propagate flag to check loop"
      extends Modelica.Icons.Function;
      input Boolean b[:];
      output Boolean result;
  protected
      Integer dummy;
    algorithm
      dummy := 0;
      result := true;
    end propagateLoopCheck;
  end Utilities;
end Internal;
annotation (
  uses(Modelica(version="3.2.3")),
  preferredView="info",
  version="2.0.4",
  versionBuild=1,
  versionDate="2019-03-20",
  dateModified="2019-03-20 15:00:00Z",
  revisionId="$Id::                                    ",
  Documentation(info="<html>
<p>
<img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/UsersGuide/StateGraphElements.png\" align=\"right\">
Library <b>Modelica_StateGraph2</b> is a <b>free</b> Modelica package providing
components to model <b>discrete event</b>, <b>reactive</b> and
<b>hybrid</b> systems in a convenient way with <b>deterministic hierarchical state diagrams</b>.
For convenience, the abbreviation \"StateGraph2\" will be
often used for this library. An example model constructed with this
library is shown in the figure to the right.
</p>

<p>
This library is inspired by Grafcet/Sequential Function Charts (SFC), Statecharts,
Safe State Machines (SSM) and Mode Automata, and utilizes Modelica as action language.
It has a similar modeling power as
these formalisms, e.g. synchronization of parallel executing branches
as in SFC (not easy in Statecharts), or suspending a hierarchical subgraph with one
transition and resuming at the same states afterwards when entering it again, as in Statechart (not possible in SFC). A StateGraph2 model is always deterministic due to
Modelicas \"single assignment rule\". Via special blocks in subpackage \"Blocks\",
actions can be defined in a graphical way depending on the active step.
</p>

<p>
In order to construct a new state machine, exactly one instance of either \"Step\"
or of \"Parallel\" must have parameter \"initialStep = <b>true</b>\".
The \"Parallel\" component is both used as \"composite step\" (so only one branch),
as well as \"parallel step\" (so several execution branches). The branches can be
synchronized (if parameter use_outPort = <b>true</b>) or can run unsynchronized
to each other (if parameter use_outPort = <b>false</b>).
</p>

<p>
For an introduction, have especially a look at:
</p>

<ul>
<li><a href=\"modelica://Modelica_StateGraph2.UsersGuide.Tutorial\">Tutorial</a>
     provides an overview of the library inside the User's Guide.</li>
<li><a href=\"modelica://Modelica_StateGraph2.Examples\">Examples</a>
     provides simple introductory examples as well as involved application examples.</li>
<li> <a href=\"modelica://Modelica_StateGraph2.UsersGuide.ComparisonWithStateGraph1\">ComparisonWithStateGraph1</a>
     summarizes the enhancements with respect to the previous version of
     Modelica.StateGraph.</li>
</ul>

<p>
This library is implemented with Modelica 3.1 and utilizes non-standard extensions to Modelica 3.1 as summarized
<a href=\"modelica://Modelica_StateGraph2.UsersGuide.UsedModelicaExtensions\">here</a>.
</p>

<p>
<b>Licensed by DLR and Dynasim under the Modelica License 2</b><br>
Copyright &copy; 2003-2013, DLR and 2007-2009, Dynasim AB
</p>

<p>
<i>This Modelica package is <u>free</u> software and
the use is completely at <u>your own risk</u>;
it can be redistributed and/or modified under the terms of the
Modelica license 2, see the license conditions (including the
disclaimer of warranty)
<a href=\"modelica://Modelica_StateGraph2.UsersGuide.ModelicaLicense2\">here</a></u>
or at
<a href=\"http://www.Modelica.org/licenses/ModelicaLicense2\">
http://www.Modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>

</html>"));
end Modelica_StateGraph2;

operator record Complex "Complex number with overloaded operators"

  replaceable Real re "Real part of complex number" annotation(Dialog);
  replaceable Real im "Imaginary part of complex number" annotation(Dialog);

  encapsulated operator 'constructor' "Constructor"
    function fromReal "Construct Complex from Real"
      import Complex;
      input Real re "Real part of complex number";
      input Real im=0 "Imaginary part of complex number";
      output Complex result(re=re, im=im) "Complex number";
    algorithm

      annotation(Inline=true, Documentation(info="<html>
<p>This function returns a Complex number defined by real part <em>re</em> and optional imaginary part <em>im</em> (default=0).</p>
</html>"));
    end fromReal;
    annotation (Documentation(info="<html>
<p>Here the constructor operator(s) is/are defined.</p>
</html>"), Icon(graphics={Rectangle(
            lineColor={200,200,200},
            fillColor={248,248,248},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25.0), Rectangle(
            lineColor={128,128,128},
            extent={{-100,-100},{100,100}},
            radius=25.0)}));
  end 'constructor';

  encapsulated operator function '0' "Zero-element of addition (= Complex(0))"
    import Complex;
    output Complex result "Complex(0)";
  algorithm
    result := Complex(0);
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the zero-element of Complex, that is, Complex(0) = 0 + j*0.</p>
</html>"));
  end '0';

  encapsulated operator '-' "Unary and binary minus"
    function negate "Unary minus (multiply complex number by -1)"
      import Complex;
      input Complex c1 "Complex number";
      output Complex c2 "= -c1";
    algorithm
      c2 := Complex(-c1.re, -c1.im);
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the binary minus of the given Complex number.</p>
</html>"));
    end negate;

    function subtract "Subtract two complex numbers"
      import Complex;
      input Complex c1 "Complex number 1";
      input Complex c2 "Complex number 2";
      output Complex c3 "= c1 - c2";
    algorithm
      c3 := Complex(c1.re - c2.re, c1.im - c2.im);
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the difference of two given Complex numbers.</p>
</html>"));
    end subtract;
    annotation (Documentation(info="<html>
<p>Here the unary and binary minus operator(s) is/are defined.</p>
</html>"), Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
              {100,100}}), graphics={
          Rectangle(
            lineColor={200,200,200},
            fillColor={248,248,248},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Rectangle(
            lineColor={128,128,128},
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Line(
            points={{-50,0},{50,0}})}));
  end '-';

  encapsulated operator '*' "Multiplication"
    function multiply "Multiply two complex numbers"
      import Complex;
      input Complex c1 "Complex number 1";
      input Complex c2 "Complex number 2";
      output Complex c3 "= c1*c2";
    algorithm
      c3 := Complex(c1.re*c2.re - c1.im*c2.im, c1.re*c2.im + c1.im*c2.re);

    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the product of two given Complex numbers.</p>
</html>"));
    end multiply;

    function scalarProduct "Scalar product c1*c2 of two complex vectors"
      import Complex;
      input Complex c1[:] "Vector of Complex numbers 1";
      input Complex c2[size(c1,1)] "Vector of Complex numbers 2";
      output Complex c3 "= c1*c2";
    algorithm
      c3 :=Complex(0);
      for i in 1:size(c1,1) loop
         c3 :=c3 + c1[i]*c2[i];
         /*
       c3 :=Complex(c3.re + c1[i].re*c2[i].re - c1[i].im*c2[i].im,
                    c3.im + c1[i].re*c2[i].im + c1[i].im*c2[i].re);
       */
      end for;

    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the scalar product of two given arrays of Complex numbers.</p>
</html>"));
    end scalarProduct;
    annotation (
      Documentation(info="<html>
<p>Here the multiplication operator(s) is/are defined.</p>
</html>"),
      Icon(coordinateSystem(
          preserveAspectRatio=false,
          extent={{-100,-100},{100,100}}),
          graphics={
          Rectangle(
            lineColor={200,200,200},
            fillColor={248,248,248},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Rectangle(
            lineColor={128,128,128},
            extent={{-100,-100},{100,100}},
            radius=25.0),
          Line(
            points={{-42,36},{39,-34}}),
          Line(
            points={{-42,-35},{39,37}}),
          Line(
            points={{-55,1},{52,1}}),
          Line(
            points={{-1.5,55},{-2,-53}})}));
  end '*';

  encapsulated operator function '+' "Add two complex numbers"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Complex c3 "= c1 + c2";
  algorithm
    c3 := Complex(c1.re + c2.re, c1.im + c2.im);
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the sum of two given Complex numbers.</p>
</html>"));
  end '+';

  encapsulated operator function '/' "Divide two complex numbers"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Complex c3 "= c1/c2";
  algorithm
    c3 := Complex((+c1.re*c2.re + c1.im*c2.im)/(c2.re*c2.re + c2.im*c2.im),
                  (-c1.re*c2.im + c1.im*c2.re)/(c2.re*c2.re + c2.im*c2.im));
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the quotient of two given Complex numbers.</p>
</html>"));
  end '/';

  encapsulated operator function '^' "Complex power of complex number"
    import Complex;
    input Complex c1 "Complex number";
    input Complex c2 "Complex exponent";
    output Complex c3 "= c1^c2";
  protected
    Real lnz=0.5*log(c1.re*c1.re + c1.im*c1.im);
    Real phi=atan2(c1.im, c1.re);
    Real re=lnz*c2.re - phi*c2.im;
    Real im=lnz*c2.im + phi*c2.re;
  algorithm
    c3 := Complex(exp(re)*cos(im), exp(re)*sin(im));
    annotation(Inline=true, Documentation(info="<html>
<p>This function returns the given Complex numbers c1 to the power of the Complex number c2.</p>
</html>"));
  end '^';

  encapsulated operator function '=='
    "Test whether two complex numbers are identical"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Boolean result "c1 == c2";
  algorithm
    result := c1.re == c2.re and c1.im == c2.im;
    annotation(Inline=true, Documentation(info="<html>
<p>This function tests whether two given Complex numbers are equal.</p>
</html>"));
  end '==';

  encapsulated operator function '<>'
    "Test whether two complex numbers are not identical"
    import Complex;
    input Complex c1 "Complex number 1";
    input Complex c2 "Complex number 2";
    output Boolean result "c1 <> c2";
  algorithm
    result := c1.re <> c2.re or c1.im <> c2.im;
    annotation(Inline=true, Documentation(info="<html>
    <p>This function tests whether two given Complex numbers are not equal.</p>
</html>"));
  end '<>';

  encapsulated operator function 'String'
    "Transform Complex number into a String representation"
    import Complex;
    input Complex c
      "Complex number to be transformed in a String representation";
    input String name="j"
      "Name of variable representing sqrt(-1) in the string";
    input Integer significantDigits=6
      "Number of significant digits that are shown";
    output String s="";
  algorithm
    s := String(c.re, significantDigits=significantDigits);
    if c.im <> 0 then
      if c.im > 0 then
        s := s + " + ";
      else
        s := s + " - ";
      end if;
      s := s + String(abs(c.im), significantDigits=significantDigits) + "*" + name;
    end if;
    annotation(Inline=true, Documentation(info="<html>
<p>This function converts a given Complex number to String representation.</p>
</html>"));
  end 'String';


annotation (
version="3.2.3",
versionBuild=2,
versionDate="2019-01-23",
dateModified = "2019-03-20 12:00:00Z",
revisionId="8f65f621a 2019-03-20 09:22:19 +0100",
conversion(
 noneFromVersion="3.2.2",
 noneFromVersion="3.2.1",
 noneFromVersion="1.0",
 noneFromVersion="1.1"),
Documentation(info="<html>
<p>Complex number defined as a record containing real and imaginary part, utilizing operator overloading.</p>
<p>
<strong>Licensed by the Modelica Association under the 3-Clause BSD License</strong><br>
Copyright &copy; 2010-2019, Modelica Association and <a href=\"modelica://Modelica.UsersGuide.Contact\">contributors</a>
</p>

<p>
<em>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the 3-Clause BSD license. For license conditions (including the disclaimer of warranty) visit <a href=\"https://modelica.org/licenses/modelica-3-clause-bsd\">https://modelica.org/licenses/modelica-3-clause-bsd</a>.</em>
</p></html>"),
    Icon(graphics={Rectangle(
          lineColor={160,160,164},
          fillColor={160,160,164},
          fillPattern=FillPattern.Solid,
          extent={{-100,-100},{100,100}},
          radius=25.0), Text(
          lineColor={255,255,255},
          extent={{-90,-50},{90,50}},
          textString="C")}));

end Complex;

package IBPSA "Library with models for building energy and control systems"
  extends Modelica.Icons.Package;

  package Fluid "Package with models for fluid flow systems"
    extends Modelica.Icons.Package;

    package FixedResistances "Package with models for fixed flow resistances"
      extends Modelica.Icons.VariantsPackage;

      model PressureDrop
        "Fixed flow resistance with dp and m_flow as parameter"
        extends IBPSA.Fluid.BaseClasses.PartialResistance(
          final m_flow_turbulent = if computeFlowResistance then deltaM * m_flow_nominal_pos else 0);

        parameter Real deltaM(min=1E-6) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Evaluate=true,
                        Dialog(group = "Transition to laminar",
                               enable = not linearized));

        final parameter Real k = if computeFlowResistance then
              m_flow_nominal_pos / sqrt(dp_nominal_pos) else 0
          "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
    protected
        final parameter Boolean computeFlowResistance=(dp_nominal_pos > Modelica.Constants.eps)
          "Flag to enable/disable computation of flow resistance"
         annotation(Evaluate=true);
        final parameter Real coeff=
          if linearized and computeFlowResistance
          then if from_dp then k^2/m_flow_nominal_pos else m_flow_nominal_pos/k^2
          else 0
          "Precomputed coefficient to avoid division by parameter";
      initial equation
       if computeFlowResistance then
         assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
       end if;

       assert(m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
      equation
        // Pressure drop calculation
        if computeFlowResistance then
          if linearized then
            if from_dp then
              m_flow = dp*coeff;
            else
              dp = m_flow*coeff;
            end if;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(
                  actual=IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                    dp=dp,
                    k=k,
                    m_flow_turbulent=m_flow_turbulent),
                  simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                dp=homotopy(
                  actual=IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                    m_flow=m_flow,
                    k=k,
                    m_flow_turbulent=m_flow_turbulent),
                  simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
               end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                  dp=dp,
                  k=k,
                  m_flow_turbulent=m_flow_turbulent);
              else
                dp=IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                  m_flow=m_flow,
                  k=k,
                  m_flow_turbulent=m_flow_turbulent);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        else // do not compute flow resistance
          dp = 0;
        end if;  // computeFlowResistance

        annotation (defaultComponentName="res",
      Documentation(info="<html>
<p>
Model of a flow resistance with a fixed flow coefficient.
The mass flow rate is
</p>
<p align=\"center\" style=\"font-style:italic;\">
m&#775; = k
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>,
</p>
<p>
where
<i>k</i> is a constant and
<i>&Delta;P</i> is the pressure drop.
The constant <i>k</i> is equal to
<code>k=m_flow_nominal/sqrt(dp_nominal)</code>,
where <code>m_flow_nominal</code> and <code>dp_nominal</code>
are parameters.
</p>
<h4>Assumptions</h4>
<p>
In the region
<code>abs(m_flow) &lt; m_flow_turbulent</code>,
the square root is replaced by a differentiable function
with finite slope.
The value of <code>m_flow_turbulent</code> is
computed as
<code>m_flow_turbulent = deltaM * abs(m_flow_nominal)</code>,
where <code>deltaM=0.3</code> and
<code>m_flow_nominal</code> are parameters that can be set by the user.
</p>
<p>
The figure below shows the pressure drop for the parameters
<code>m_flow_nominal=5</code> kg/s,
<code>dp_nominal=10</code> Pa and
<code>deltaM=0.3</code>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/FixedResistances/PressureDrop.png\"/>
</p>
<h4>Important parameters</h4>
<p>
The parameter <code>from_dp</code> is used to determine
whether the mass flow rate is computed as a function of the
pressure drop (if <code>from_dp=true</code>), or vice versa.
This setting can affect the size of the nonlinear system of equations.
</p>
<p>
If the parameter <code>linearized</code> is set to <code>true</code>,
then the pressure drop is computed as a linear function of the
mass flow rate.
</p>
<p>
Setting <code>allowFlowReversal=false</code> can lead to simpler
equations. However, this should only be set to <code>false</code>
if one can guarantee that the flow never reverses its direction.
This can be difficult to guarantee, as pressure imbalance after
the initialization, or due to medium expansion and contraction,
can lead to reverse flow.
</p>
<p>
If the parameter
<code>show_T</code> is set to <code>true</code>,
then the model will compute the
temperature at its ports. Note that this can lead to state events
when the mass flow rate approaches zero,
which can increase computing time.
</p>
<h4>Notes</h4>
<p>
For more detailed models that compute the actual flow friction,
models from the package
<a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
can be used and combined with models from the
<code>IBPSA</code> library.
</p>
<p>
For a model that uses the hydraulic parameter and flow velocity at nominal conditions
as a parameter, use
<a href=\"modelica://IBPSA.Fluid.FixedResistances.HydraulicDiameter\">
IBPSA.Fluid.FixedResistances.HydraulicDiameter</a>.
</p>
<h4>Implementation</h4>
<p>
The pressure drop is computed by calling a function in the package
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels\">
IBPSA.Fluid.BaseClasses.FlowModels</a>,
This package contains regularized implementations of the equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
and its inverse function.
</p>
<p>
To decouple the energy equation from the mass equations,
the pressure drop is a function of the mass flow rate,
and not the volume flow rate.
This leads to simpler equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 21, 2018, by Michael Wetter:<br/>
Decrease value of <code>deltaM(min=...)</code> attribute.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1026\">#1026</a>.
</li>
<li>
February 3, 2018, by Filip Jorissen:<br/>
Revised implementation of pressure drop equation
such that it depends on <code>from_dp</code>
when <code>linearized=true</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/884\">#884</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Simplified model by removing the geometry dependent parameters into the new
model
<a href=\"modelica://IBPSA.Fluid.FixedResistances.HydraulicDiameter\">
IBPSA.Fluid.FixedResistances.HydraulicDiameter</a>.
</li>
<li>
November 23, 2016, by Filip Jorissen:<br/>
Removed <code>dp_nominal</code> and
<code>m_flow_nominal</code> labels from icon.
</li>
<li>
October 14, 2016, by Michael Wetter:<br/>
Updated comment for parameter <code>use_dh</code>.
</li>
<li>
November 26, 2014, by Michael Wetter:<br/>
Added the required <code>annotation(Evaluate=true)</code> so
that the system of nonlinear equations in
<a href=\"modelica://IBPSA.Fluid.FixedResistances.Validation.PressureDropsExplicit\">
IBPSA.Fluid.FixedResistances.Validation.PressureDropsExplicit</a>
remains the same.
</li>
<li>
November 20, 2014, by Michael Wetter:<br/>
Rewrote the warning message using an <code>assert</code> with
<code>AssertionLevel.warning</code>
as this is the proper way to write warnings in Modelica.
</li>
<li>
August 5, 2014, by Michael Wetter:<br/>
Corrected error in documentation of computation of <code>k</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IBPSA.Fluid.BaseClasses.PartialResistance</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IBPSA.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
May 30, 2008 by Michael Wetter:<br/>
Added parameters <code>use_dh</code> and <code>deltaM</code> for easier parameterization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PressureDrop;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for fixed flow resistances.
By fixed flow resistance, we mean resistances that do not change the
flow coefficient
</p>
<p align=\"center\" style=\"font-style:italic;\">
k = m &frasl;
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>.
</p>
<p>
For models of valves and air dampers, see
<a href=\"modelica://IBPSA.Fluid.Actuators\">
IBPSA.Fluid.Actuators</a>.
For models of flow resistances as part of the building constructions, see
<a href=\"modelica://IBPSA.Airflow.Multizone\">
IBPSA.Airflow.Multizone</a>.
</p>
<p>
The model
<a href=\"modelica://IBPSA.Fluid.FixedResistances.PressureDrop\">
IBPSA.Fluid.FixedResistances.PressureDrop</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and a nominal pressure drop. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://IBPSA.Fluid.FixedResistances.HydraulicDiameter\">
IBPSA.Fluid.FixedResistances.HydraulicDiameter</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and
a hydraulic diameter. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://IBPSA.Fluid.FixedResistances.LosslessPipe\">
IBPSA.Fluid.FixedResistances.LosslessPipe</a>
is an ideal pipe segment with no pressure drop. It is primarily used
in models in which the above pressure drop model need to be replaced by a model with no pressure drop.
</p>
<p>
The model
<a href=\"modelica://IBPSA.Fluid.FixedResistances.Junction\">
IBPSA.Fluid.FixedResistances.Junction</a>
can be used to model flow splitters or flow merges.
</p>
</html>"));
    end FixedResistances;

    package Geothermal "Package with models for geothermal heat exchange"
      extends Modelica.Icons.VariantsPackage;

      package Borefields "Package with borefield models"
        extends Modelica.Icons.VariantsPackage;

        model TwoUTubes
          "Borefield model containing double U-tube boreholes"
          extends
          IBPSA.Fluid.Geothermal.Borefields.BaseClasses.PartialBorefield(
            redeclare IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.TwoUTube borHol);
          annotation (
          defaultComponentName="borFie",
          Documentation(info="<html>
<p>
This model simulates a borefield containing one or many double U-tube boreholes
using the parameters in the <code>borFieDat</code> record.
</p>
<p>
Heat transfer to the soil is modeled using only one borehole heat exchanger. The
fluid mass flow rate into the borehole is divided to reflect the per-borehole
fluid mass flow rate. The borehole model calculates the dynamics within the
borehole itself using an axial discretization and a resistance-capacitance
network for the internal thermal resistances between the individual pipes and
between each pipe and the borehole wall.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 2018, by Alex Laferri&egrave;re:<br/>
Extended partial model and changed documentation to reflect the new approach
used by the borefield models.
</li>
<li>
July 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TwoUTubes;

        package Data
        "Collection of data records for ground heat exchanger models"
        extends Modelica.Icons.MaterialPropertiesPackage;

          package Borefield "Collection of borefield data records"
            extends Modelica.Icons.MaterialPropertiesPackage;

            record Template
              "Template for borefield data records"
              extends Modelica.Icons.Record;
              parameter IBPSA.Fluid.Geothermal.Borefields.Data.Filling.Template filDat
                "Filling data";
              parameter IBPSA.Fluid.Geothermal.Borefields.Data.Soil.Template soiDat
                "Soil data";
              parameter IBPSA.Fluid.Geothermal.Borefields.Data.Configuration.Template conDat
                "Configuration data";

              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="borFieDat",
            Documentation(
            info="<html>
<p>
This record is a template for the records in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.Data.Borefield\">
IBPSA.Fluid.Geothermal.Borefields.Data.Borefield</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
</li>
<li>
June 28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Template;
          annotation (Documentation(info="<html>
<p>
This package contains data records for use with ground heat exchanger models
in <a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields\">
IBPSA.Fluid.Geothermal.Borefields</a>.
The borefield data records
contain one of the
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.Data.Configuration\">
IBPSA.Fluid.Geothermal.Borefields.Data.Configuration</a> records, one of the
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.Data.Filling\">
IBPSA.Fluid.Geothermal.Borefields.Data.Filling</a> records, and one of the
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.Data.Soil\">
IBPSA.Fluid.Geothermal.Borefields.Data.Soil</a> records.
</p>
</html>"));
          end Borefield;

          package Configuration
          "Collection of records of configuration data of borefields"
            extends Modelica.Icons.MaterialPropertiesPackage;

            record Template
              "Template for configuration data records"
              extends Modelica.Icons.Record;

              parameter IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration borCon
                "Borehole configuration";

              parameter Boolean use_Rb = false
                "true if the value borehole thermal resistance Rb should be given and used";
              parameter Real Rb(unit="(m.K)/W") = 0.0
                "Borehole thermal resistance Rb. Only to fill in if known"
                annotation(Dialog(enable=use_Rb));
              parameter Modelica.SIunits.MassFlowRate mBor_flow_nominal
                "Nominal mass flow rate per borehole"
                annotation (Dialog(group="Nominal condition"));
              parameter Modelica.SIunits.MassFlowRate mBorFie_flow_nominal = mBor_flow_nominal*nBor
                "Nominal mass flow of borefield"
                annotation (Dialog(group="Nominal condition"));
              parameter Modelica.SIunits.Pressure dp_nominal(displayUnit="Pa")
                "Pressure losses for the entire borefield"
                annotation (Dialog(group="Nominal condition"));

              //------------------------- Geometrical parameters ---------------------------
              parameter Modelica.SIunits.Height hBor "Total height of the borehole"
                annotation (Dialog(group="Borehole"));
              parameter Modelica.SIunits.Radius rBor "Radius of the borehole"
                annotation (Dialog(group="Borehole"));
              parameter Modelica.SIunits.Height dBor "Borehole buried depth"
                annotation (Dialog(group="Borehole"));
              parameter Integer nBor = size(cooBor, 1) "Total number of boreholes"
                annotation (Dialog(group="Borehole"));

              parameter Modelica.SIunits.Length[:,2] cooBor
                "Cartesian coordinates of the boreholes in meters"
                annotation (Dialog(group="Borehole"));

              // -- Tube
              parameter Modelica.SIunits.Radius rTub "Outer radius of the tubes"
                annotation (Dialog(group="Tubes"));
              parameter Modelica.SIunits.ThermalConductivity kTub "Thermal conductivity of the tube"
                annotation (Dialog(group="Tubes"));

              parameter Modelica.SIunits.Length eTub "Thickness of a tube"
                annotation (Dialog(group="Tubes"));

              parameter Modelica.SIunits.Length xC
                "Shank spacing, defined as the distance between the center of a pipe and the center of the borehole"
                annotation (Dialog(group="Tubes"));

              //------------------------- Advanced parameters ------------------------------

              /*--------Flow: */
              parameter Modelica.SIunits.MassFlowRate mBor_flow_small(min=0) = 1E-4*abs(mBor_flow_nominal)
                "Small mass flow rate for regularization of zero flow"
                annotation (Dialog(tab="Advanced"));

              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="conDat",
                Documentation(
            info="<html>
<p>
This record is a template for the records in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.Data.Configuration\">
IBPSA.Fluid.Geothermal.Borefields.Data.Configuration</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
</li>
<li>
June 28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Template;
          annotation (Documentation(info="<html>
<p>
This package contains data records for use with ground heat exchanger models
in <a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields\">
IBPSA.Fluid.Geothermal.Borefields</a>. The configuration data
records contain the geometrical and operational characteristics of the borefield
and the boreholes.
</p>
</html>"));
          end Configuration;

          package Filling "Collection of records of filling data"
            extends Modelica.Icons.MaterialPropertiesPackage;

            record Template
              "Template for filling data records"
              extends Modelica.Icons.Record;
              parameter Modelica.SIunits.ThermalConductivity kFil
                "Thermal conductivity of the borehole filling material";
              parameter Modelica.SIunits.SpecificHeatCapacity cFil
                "Specific heat capacity of the borehole filling material";
              parameter Modelica.SIunits.Density dFil(displayUnit="kg/m3")
                "Density of the borehole filling material";
              parameter Boolean steadyState = (cFil < Modelica.Constants.eps or dFil < Modelica.Constants.eps)
                "Flag, if true, then material is computed using steady-state heat conduction"
                annotation(Evaluate=true);
              final parameter Modelica.SIunits.ThermalDiffusivity aFil = kFil/(dFil*cFil)
                "Heat diffusion coefficient of the borehole filling material";
              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="filDat",
            Documentation(
            info="<html>
<p>This record is a template for the records in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.Data.Filling\">
IBPSA.Fluid.Geothermal.Borefields.Data.Filling</a>.</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
Corrected check of real variable against zero which is not allowed in Modelica.
</li>
<li>
June 28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Template;
          annotation (Documentation(info="<html>
<p>
This package contains data records for use with ground heat exchanger models
in <a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields\">
IBPSA.Fluid.Geothermal.Borefields</a>. The filling data
records contain the heat transfer properties of the borehole filling material.
</p>
</html>"));
          end Filling;

          package Soil "Collection of records of soil data"
            extends Modelica.Icons.MaterialPropertiesPackage;

            record Template
              "Template for soil data records"
              extends Modelica.Icons.Record;
              parameter Modelica.SIunits.ThermalConductivity kSoi
                "Thermal conductivity of the soil material";
              parameter Modelica.SIunits.SpecificHeatCapacity cSoi
                "Specific heat capacity of the soil material";
              parameter Modelica.SIunits.Density dSoi(displayUnit="kg/m3")
                "Density of the soil material";
              parameter Boolean steadyState = (cSoi < Modelica.Constants.eps or dSoi < Modelica.Constants.eps)
                "Flag, if true, then material is computed using steady-state heat conduction"
                annotation(Evaluate=true);
              final parameter Modelica.SIunits.ThermalDiffusivity aSoi=kSoi/(dSoi*cSoi)
                "Heat diffusion coefficient of the soil material";
              annotation (
              defaultComponentPrefixes="parameter",
              defaultComponentName="soiDat",
            Documentation(
            info="<html>
<p>
This record is a template for the records in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.Data.Soil\">
IBPSA.Fluid.Geothermal.Borefields.Data.Soil</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Revised implementation, added <code>defaultComponentPrefixes</code> and
<code>defaultComponentName</code>.
Corrected check of real variable against zero which is not allowed in Modelica.
</li>
<li>
June28, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end Template;
          annotation (Documentation(info="<html>
<p>
This package contains data records for use with ground heat exchanger models
in <a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields\">
IBPSA.Fluid.Geothermal.Borefields</a>. The soil data
records contain the heat transfer properties of soil materials.
</p>
</html>"));
          end Soil;
        annotation (Documentation(info="<html>
<p>
This package contains data records for use with ground heat exchanger models
in <a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields\">
IBPSA.Fluid.Geothermal.Borefields</a>.
</p>
</html>"));
        end Data;

        package Types "Package with type definitions"
          extends Modelica.Icons.TypesPackage;

          type BoreholeConfiguration = enumeration(
            SingleUTube
            "Single U-tube configuration",
            DoubleUTubeParallel
            "Double U-tube configuration with pipes connected in parallel",
            DoubleUTubeSeries
            "Double U-tube configuration with pipes connected in series")
          "Enumaration to define the borehole configurations"
          annotation (Documentation(info="<html>
<p>
Enumeration that defines the pipe configuration in the borehole.
</p>
<p>
The following pipe configurations are available in this enumeration:
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Enumeration</th><th>Description</th></tr>
<tr><td>SingleUTube</td><td>Single U-tube configuration</td></tr>

<tr><td>DoubleUTubeParallel</td><td>Double U-tube configuration with pipes connected in parallel</td></tr>
<tr><td>DoubleUTubeSeries</td><td>Double U-tube configuration with pipes connected in series</td></tr>
</table>
</html>", revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          annotation (preferredView="info", Documentation(info="<html>
 <p>
 This package contains type definitions.
 </p>
 </html>"));
        end Types;

        package BaseClasses
        "Base classes used in IBPSA.Fluid.HeatExchangers.Ground"
        extends Modelica.Icons.BasesPackage;

          partial model PartialBorefield
            "Borefield model using single U-tube borehole heat exchanger configuration.Calculates the average fluid temperature T_fts of the borefield for a given (time dependent) load Q_flow"

            extends IBPSA.Fluid.Interfaces.PartialTwoPortInterface(
              final m_flow_nominal=borFieDat.conDat.mBorFie_flow_nominal);

            extends IBPSA.Fluid.Interfaces.TwoPortFlowResistanceParameters(
              final dp_nominal=borFieDat.conDat.dp_nominal,
              final computeFlowResistance=(borFieDat.conDat.dp_nominal > Modelica.Constants.eps));

            replaceable package Medium =
              Modelica.Media.Interfaces.PartialMedium                            "Medium in the component"
                annotation (choices(
                  choice(redeclare package Medium = IBPSA.Media.Water "Water"),
                  choice(redeclare package Medium =
                      IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                        property_T=293.15,
                        X_a=0.40)
                        "Propylene glycol water, 40% mass fraction")));

            constant Real mSenFac(min=1)=1
              "Factor for scaling the sensible thermal mass of the volume";

            // Assumptions
            parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
              "Type of energy balance: dynamic (3 initialization options) or steady state"
              annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

            // Initialization
            parameter Medium.AbsolutePressure p_start = Medium.p_default
              "Start value of pressure"
              annotation(Dialog(tab = "Initialization"));

            // Simulation parameters
            parameter Modelica.SIunits.Time tLoaAgg=300 "Time resolution of load aggregation";
            parameter Integer nCel(min=1)=5 "Number of cells per aggregation level";
            parameter Integer nSeg(min=1)=10
              "Number of segments to use in vertical discretization of the boreholes";
            parameter Boolean forceGFunCalc = false
              "Set to true to force the thermal response to be calculated at the start instead of checking whether this has been pre-computed"
              annotation (Dialog(tab="Advanced"));

            // General parameters of borefield
            parameter IBPSA.Fluid.Geothermal.Borefields.Data.Borefield.Template borFieDat "Borefield data"
              annotation (choicesAllMatching=true,Placement(transformation(extent={{-80,-80},{-60,-60}})));

            // Temperature gradient in undisturbed soil
            parameter Modelica.SIunits.Temperature TExt0_start=283.15
              "Initial far field temperature"
              annotation (Dialog(tab="Initialization", group="Soil"));
            parameter Modelica.SIunits.Temperature TExt_start[nSeg]=
              {if z[i] >= z0 then TExt0_start + (z[i] - z0)*dT_dz else TExt0_start for i in 1:nSeg}
              "Temperature of the undisturbed ground"
              annotation (Dialog(tab="Initialization", group="Soil"));

            parameter Modelica.SIunits.Temperature TGro_start[nSeg]=TExt_start
              "Start value of grout temperature"
              annotation (Dialog(tab="Initialization", group="Filling material"));

            parameter Modelica.SIunits.Temperature TFlu_start[nSeg]=TGro_start
              "Start value of fluid temperature"
              annotation (Dialog(tab="Initialization"));

            parameter Modelica.SIunits.Height z0=10
              "Depth below which the temperature gradient starts"
              annotation (Dialog(tab="Initialization", group="Temperature profile"));
            parameter Real dT_dz(final unit="K/m", min=0) = 0.01
              "Vertical temperature gradient of the undisturbed soil for h below z0"
              annotation (Dialog(tab="Initialization", group="Temperature profile"));

            // Dynamics of filling material
            parameter Boolean dynFil=true
              "Set to false to remove the dynamics of the filling material."
              annotation (Dialog(tab="Dynamics"));

            Modelica.Blocks.Interfaces.RealOutput TBorAve(final quantity="ThermodynamicTemperature",
                                                          final unit="K",
                                                          displayUnit = "degC",
                                                          start=TExt0_start)
              "Average borehole wall temperature in the borefield"
              annotation (Placement(transformation(extent={{100,34},{120,54}})));

            replaceable IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse groTemRes(
              final tLoaAgg=tLoaAgg,
              final nCel=nCel,
              final borFieDat=borFieDat,
              final forceGFunCalc=forceGFunCalc)
              "Ground temperature response"
              annotation (Placement(transformation(extent={{20,70},{40,90}})));

            replaceable IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.PartialBorehole borHol constrainedby
            IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.PartialBorehole(
              redeclare final package Medium = Medium,
              final borFieDat=borFieDat,
              final nSeg=nSeg,
              final m_flow_nominal=m_flow_nominal/borFieDat.conDat.nBor,
              final dp_nominal=dp_nominal,
              final allowFlowReversal=allowFlowReversal,
              final m_flow_small=m_flow_small,
              final show_T=show_T,
              final computeFlowResistance=computeFlowResistance,
              final from_dp=from_dp,
              final linearizeFlowResistance=linearizeFlowResistance,
              final deltaM=deltaM,
              final energyDynamics=energyDynamics,
              final p_start=p_start,
              final mSenFac=mSenFac,
              final dynFil=dynFil,
              final TFlu_start=TFlu_start,
              final TGro_start=TGro_start) "Borehole"
              annotation (Placement(transformation(extent={{-10,-50},{10,-30}})));

        protected
            parameter Modelica.SIunits.Height z[nSeg]={borFieDat.conDat.hBor/nSeg*(i - 0.5) for i in 1:nSeg}
              "Distance from the surface to the considered segment";

            IBPSA.Fluid.BaseClasses.MassFlowRateMultiplier masFloDiv(
              redeclare final package Medium = Medium,
              final k=borFieDat.conDat.nBor) "Division of flow rate"
              annotation (Placement(transformation(extent={{-60,-50},{-80,-30}})));

            IBPSA.Fluid.BaseClasses.MassFlowRateMultiplier masFloMul(
              redeclare final package Medium = Medium,
              final k=borFieDat.conDat.nBor) "Mass flow multiplier"
              annotation (Placement(transformation(extent={{60,-50},{80,-30}})));

            Modelica.Blocks.Math.Gain gaiQ_flow(k=borFieDat.conDat.nBor)
              "Gain to multiply the heat extracted by one borehole by the number of boreholes"
              annotation (Placement(transformation(extent={{-20,70},{0,90}})));
            IBPSA.Utilities.Math.Average AveTBor(nin=nSeg)
              "Average temperature of all the borehole segments"
              annotation (Placement(transformation(extent={{50,34},{70,54}})));

            Modelica.Blocks.Sources.Constant TSoiUnd[nSeg](
              k = TExt_start,
              y(each unit="K",
                each displayUnit="degC")) "Undisturbed soil temperature"
              annotation (Placement(transformation(extent={{-40,14},{-20,34}})));

            Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor QBorHol[nSeg]
              "Heat flow rate of all segments of the borehole"
              annotation (Placement(transformation(extent={{-10,10},{10,-10}},
                  rotation=90,
                  origin={0,-10})));

            Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature TemBorWal[nSeg]
              "Borewall temperature"
              annotation (Placement(transformation(extent={{50,6},{70,26}})));

            Modelica.Blocks.Math.Add TSoiDis[nSeg](each final k1=1, each final k2=1)
              "Addition of undisturbed soil temperature and change of soil temperature"
              annotation (Placement(transformation(extent={{10,20},{30,40}})));

            Modelica.Blocks.Math.Sum QTotSeg_flow(
              final nin=nSeg,
              final k = ones(nSeg))
              "Total heat flow rate for all segments of this borehole"
              annotation (Placement(transformation(extent={{-60,70},{-40,90}})));

            Modelica.Blocks.Routing.Replicator repDelTBor(final nout=nSeg)
              "Signal replicator for temperature difference of the borehole"
              annotation (Placement(transformation(extent={{60,70},{80,90}})));

          equation
            connect(masFloMul.port_b, port_b)
              annotation (Line(points={{80,-40},{90,-40},{90,0},{100,0}},
                                                               color={0,127,255}));
            connect(masFloDiv.port_b, port_a)
              annotation (Line(points={{-80,-40},{-90,-40},{-90,0},{-100,0}},
                                                          color={0,127,255}));
            connect(masFloDiv.port_a, borHol.port_a)
              annotation (Line(points={{-60,-40},{-10,-40}},     color={0,127,255}));
            connect(borHol.port_b, masFloMul.port_a)
              annotation (Line(points={{10,-40},{60,-40}},    color={0,127,255}));
            connect(QBorHol.port_a, borHol.port_wall)
              annotation (Line(points={{-4.44089e-16,-20},{0,-20},{0,-30}},
                                                                  color={191,0,0}));
            connect(QBorHol.Q_flow, QTotSeg_flow.u)
              annotation (Line(points={{-10,-10},{-86,-10},{-86,80},{-62,80}},
                                                                    color={0,0,127}));
            connect(groTemRes.delTBor, repDelTBor.u)
              annotation (Line(points={{41,80},{58,80}}, color={0,0,127}));
            connect(TSoiDis.u1, repDelTBor.y) annotation (Line(points={{8,36},{0,36},{0,
                    60},{90,60},{90,80},{81,80}},
                                  color={0,0,127}));
            connect(TSoiDis.u2, TSoiUnd.y) annotation (Line(points={{8,24},{-19,24}},
                                   color={0,0,127}));
            connect(QTotSeg_flow.y, gaiQ_flow.u)
              annotation (Line(points={{-39,80},{-22,80}}, color={0,0,127}));
            connect(gaiQ_flow.y, groTemRes.QBor_flow)
              annotation (Line(points={{1,80},{19,80}}, color={0,0,127}));
            connect(TSoiDis.y, TemBorWal.T)
              annotation (Line(points={{31,30},{36,30},{36,16},{48,16}},
                                                         color={0,0,127}));
            connect(QBorHol.port_b, TemBorWal.port) annotation (Line(points={{4.44089e-16,
                    0},{0,0},{0,4},{80,4},{80,16},{70,16}},   color={191,0,0}));
            connect(TSoiDis.y, AveTBor.u) annotation (Line(points={{31,30},{36,30},{36,44},
                    {48,44}}, color={0,0,127}));
            connect(AveTBor.y, TBorAve)
              annotation (Line(points={{71,44},{110,44}}, color={0,0,127}));
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                  graphics={
                  Rectangle(
                    extent={{-100,60},{100,-66}},
                    lineColor={0,0,0},
                    fillColor={234,210,210},
                    fillPattern=FillPattern.Solid),
                  Ellipse(
                    extent={{-88,-6},{-32,-62}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-82,-12},{-38,-56}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-88,54},{-32,-2}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-82,48},{-38,4}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-26,54},{30,-2}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-20,48},{24,4}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-28,-6},{28,-62}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{-22,-12},{22,-56}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{36,56},{92,0}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{42,50},{86,6}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{38,-4},{94,-60}},
                    lineColor={0,0,0},
                    fillColor={223,188,190},
                    fillPattern=FillPattern.Forward),
                  Ellipse(
                    extent={{44,-10},{88,-54}},
                    lineColor={0,0,0},
                    fillColor={0,0,255},
                    fillPattern=FillPattern.Forward)}),
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})),Documentation(info="<html>
<p>
This model simulates a borefield containing one or multiple boreholes
using the parameters in the <code>borFieDat</code> record.
</p>
<p>
Heat transfer to the soil is modeled using only one borehole heat exchanger
(To be added in an extended model). The
fluid mass flow rate into the borehole is divided to reflect the per-borehole
fluid mass flow rate. The borehole model calculates the dynamics within the
borehole itself using an axial discretization and a resistance-capacitance
network for the internal thermal resistances between the individual pipes and
between each pipe and the borehole wall.
</p>
<p>
The thermal interaction between the borehole wall and the surrounding soil
is modeled using
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse</a>,
which uses a cell-shifting load aggregation technique to calculate the borehole wall
temperature after calculating and/or read (from a previous calculation) the borefield's thermal response factor.
</p>
</html>",           revisions="<html>
<ul>
<li>
June 7, 2019, by Massimo Cimmino:<br/>
Converted instances that are not of interest to user to be <code>protected</code>.
</li>
<li>
June 4, 2019, by Massimo Cimmino:<br/>
Added an output for the average borehole wall temperature.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1107\">#1107</a>.
</li>
<li>
April 11, 2019, by Filip Jorissen:<br/>
Added <code>choicesAllMatching</code> for <code>borFieDat</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1117\">#1117</a>.
</li>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice to water and glycolWater.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 2018, by Alex Laferri&egrave;re:<br/>
Changed into a partial model and changed documentation to reflect the new approach
used by the borefield models.
</li>
<li>
July 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
          end PartialBorefield;

          package Boreholes "Package with borehole heat exchangers"
          extends Modelica.Icons.VariantsPackage;

            model TwoUTube "Double U-tube borehole heat exchanger"
              extends
              IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.PartialBorehole;

              IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.InternalHEXTwoUTube
                intHex[nSeg](
                redeclare each final package Medium = Medium,
                each final borFieDat=borFieDat,
                each final hSeg=borFieDat.conDat.hBor/nSeg,
                final dp1_nominal={if i == 1 and borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                     then dp_nominal elseif i == 1 and borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeSeries
                     then dp_nominal/2 else 0 for i in 1:nSeg},
                final dp3_nominal={if i == 1 and borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                     then dp_nominal elseif i == 1 and borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeSeries
                     then dp_nominal/2 else 0 for i in 1:nSeg},
                each final dp2_nominal=0,
                each final dp4_nominal=0,
                each final show_T=show_T,
                each final energyDynamics=energyDynamics,
                each final m1_flow_nominal=if borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                     then m_flow_nominal/2 else m_flow_nominal,
                each final m2_flow_nominal=if borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                     then m_flow_nominal/2 else m_flow_nominal,
                each final m3_flow_nominal=if borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                     then m_flow_nominal/2 else m_flow_nominal,
                each final m4_flow_nominal=if borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                     then m_flow_nominal/2 else m_flow_nominal,
                each final m1_flow_small=if borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                     then borFieDat.conDat.mBor_flow_small/2 else borFieDat.conDat.mBor_flow_small,
                each final m2_flow_small=if borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                     then borFieDat.conDat.mBor_flow_small/2 else borFieDat.conDat.mBor_flow_small,
                each final m3_flow_small=if borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                     then borFieDat.conDat.mBor_flow_small/2 else borFieDat.conDat.mBor_flow_small,
                each final m4_flow_small=if borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                     then borFieDat.conDat.mBor_flow_small/2 else borFieDat.conDat.mBor_flow_small,
                each final dynFil=dynFil,
                each final mSenFac=mSenFac,
                each final allowFlowReversal1=allowFlowReversal,
                each final allowFlowReversal2=allowFlowReversal,
                each final allowFlowReversal3=allowFlowReversal,
                each final allowFlowReversal4=allowFlowReversal,
                each final from_dp1=from_dp,
                each final linearizeFlowResistance1=linearizeFlowResistance,
                each final deltaM1=deltaM,
                each final from_dp2=from_dp,
                each final linearizeFlowResistance2=linearizeFlowResistance,
                each final deltaM2=deltaM,
                each final from_dp3=from_dp,
                each final linearizeFlowResistance3=linearizeFlowResistance,
                each final deltaM3=deltaM,
                each final from_dp4=from_dp,
                each final linearizeFlowResistance4=linearizeFlowResistance,
                each final deltaM4=deltaM,
                each final p1_start=p_start,
                each final p2_start=p_start,
                each final p3_start=p_start,
                each final p4_start=p_start,
                final TFlu_start=TFlu_start,
                final TGro_start=TGro_start) "Discretized borehole segments"
                annotation (Placement(transformation(extent={{-10,-30},{10,10}})));

            equation
              // Couple borehole port_a and port_b to first borehole segment.
              connect(port_a, intHex[1].port_a1) annotation (Line(
                  points={{-100,5.55112e-016},{-52,5.55112e-016},{-52,6},{-10,6}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(port_b, intHex[1].port_b4) annotation (Line(
                  points={{100,5.55112e-016},{28,5.55112e-016},{28,-40},{-32,-40},{-32,-27},
                      {-10,-27}},
                  color={0,127,255},
                  smooth=Smooth.None));
              if borFieDat.conDat.borCon == Types.BoreholeConfiguration.DoubleUTubeParallel then
                // 2U-tube in parallel: couple both U-tube to each other.
                connect(port_a, intHex[1].port_a3) annotation (Line(
                    points={{-100,5.55112e-016},{-52,5.55112e-016},{-52,-16.4},{-10,-16.4}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(port_b, intHex[1].port_b2) annotation (Line(
                    points={{100,5.55112e-016},{28,5.55112e-016},{28,-40},{-32,-40},{-32,-4},
                        {-10,-4}},
                    color={0,127,255},
                    smooth=Smooth.None));
              elseif borFieDat.conDat.borCon == Types.BoreholeConfiguration.DoubleUTubeSeries then
                // 2U-tube in serie: couple both U-tube to each other.
                connect(intHex[1].port_b2, intHex[1].port_a3) annotation (Line(
                    points={{-10,-4},{-24,-4},{-24,-16},{-18,-16},{-18,-16.4},{-10,-16.4}},
                    color={0,127,255},
                    smooth=Smooth.None));
              end if;

              // Couple each layer to the next one
              for i in 1:nSeg - 1 loop
                connect(intHex[i].port_b1, intHex[i + 1].port_a1) annotation (Line(
                    points={{10,6},{10,10},{-10,10},{-10,6}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(intHex[i].port_a2, intHex[i + 1].port_b2) annotation (Line(
                    points={{10,-4},{10,0},{-10,0},{-10,-4}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(intHex[i].port_b3, intHex[i + 1].port_a3) annotation (Line(
                    points={{10,-16.2},{10,-12},{-10,-12},{-10,-16.4}},
                    color={0,127,255},
                    smooth=Smooth.None));
                connect(intHex[i].port_a4, intHex[i + 1].port_b4) annotation (Line(
                    points={{10,-26},{10,-22},{-10,-22},{-10,-27}},
                    color={0,127,255},
                    smooth=Smooth.None));
              end for;

              // Close U-tube at bottom layer
              connect(intHex[nSeg].port_b1, intHex[nSeg].port_a2)
                annotation (Line(
                  points={{10,6},{16,6},{16,-4},{10,-4}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(intHex[nSeg].port_b3, intHex[nSeg].port_a4)
                annotation (Line(
                  points={{10,-16.2},{14,-16.2},{14,-16},{18,-16},{18,-26},{10,-26}},
                  color={0,127,255},
                  smooth=Smooth.None));

              connect(intHex.port_wall, port_wall)
                annotation (Line(points={{0,10},{0,10},{0,100}}, color={191,0,0}));

              annotation (
                defaultComponentName="borHol",
                Icon(coordinateSystem(
                    preserveAspectRatio=true,
                    extent={{-100,-100},{100,100}},
                    grid={2,2},
                    initialScale=0.5), graphics={
                    Rectangle(
                      extent={{58,88},{50,-92}},
                      lineColor={0,0,255},
                      pattern=LinePattern.None,
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-52,-92},{-44,88}},
                      lineColor={0,0,255},
                      pattern=LinePattern.None,
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-50,-84},{56,-92}},
                      lineColor={0,0,255},
                      pattern=LinePattern.None,
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{22,88},{14,-92}},
                      lineColor={0,0,255},
                      pattern=LinePattern.None,
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-10,88},{-18,-92}},
                      lineColor={0,0,255},
                      pattern=LinePattern.None,
                      fillColor={0,0,255},
                      fillPattern=FillPattern.Solid)}),
                Diagram(coordinateSystem(
                    preserveAspectRatio=false,
                    extent={{-100,-100},{100,100}},
                    grid={2,2},
                    initialScale=0.5), graphics={Text(
                      extent={{60,72},{84,58}},
                      lineColor={0,0,255},
                      textString=""), Text(
                      extent={{50,-32},{90,-38}},
                      lineColor={0,0,255},
                      textString="")}),
                Documentation(info="<html>
<p>
Model of a double U-tube borehole heat exchanger. 
The borehole heat exchanger is vertically discretized into
<i>n<sub>seg</sub></i> elements of height
<i>h=h<sub>Bor</sub>&frasl;n<sub>seg</sub></i>.
Each segment contains a model for the heat transfer in the borehole, 
with a uniform borehole wall boundary temperature given by the
<code>port_wall</code> port.
</p>
<p>
The heat transfer in the borehole is computed using a convective heat transfer
coefficient that depends on the fluid velocity, a heat resistance between each
pair of pipes, and a heat resistance between the pipes and the borehole wall.
The heat capacity of the fluid and the heat capacity of the grout are taken
into account. The vertical heat flow is assumed to be zero. 
</p>
</html>",             revisions="<html>
<ul>
<li>
July 2018, by Alex Laferri&egrave;re:<br/>
Following major changes to the structure of the IBPSA.Fluid.HeatExchangers.Ground package,
the documentation has been changed to reflect the new role of this model.
Additionally, this model now extends a partial borehole model.
</li>
<li>
July 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
            end TwoUTube;

            package BaseClasses "Base classes for Borehole"
            extends Modelica.Icons.BasesPackage;

              model InternalHEXTwoUTube
                "Internal heat exchanger of a borehole for a double U-tube configuration. In loop 1, fluid 1 streams from a1 to b1 and comes back from a2 to b2. In loop 2: fluid 2 streams from a3 to b3 and comes back from a4 to b4."

                extends
                IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.PartialInternalHEX;
                extends IBPSA.Fluid.Interfaces.EightPortHeatMassExchanger(
                  redeclare final package Medium1 = Medium,
                  redeclare final package Medium2 = Medium,
                  redeclare final package Medium3 = Medium,
                  redeclare final package Medium4 = Medium,
                  T1_start=TFlu_start,
                  T2_start=TFlu_start,
                  T3_start=TFlu_start,
                  T4_start=TFlu_start,
                  final tau1=VTubSeg*rho1_nominal/m1_flow_nominal,
                  final tau2=VTubSeg*rho2_nominal/m2_flow_nominal,
                  final tau3=VTubSeg*rho3_nominal/m3_flow_nominal,
                  final tau4=VTubSeg*rho4_nominal/m4_flow_nominal,
                  vol1(
                    final energyDynamics=energyDynamics,
                    final T(stateSelect=StateSelect.prefer),
                    final massDynamics=massDynamics,
                    final prescribedHeatFlowRate=false,
                    final allowFlowReversal=allowFlowReversal1,
                    final m_flow_small=m1_flow_small,
                    final V=VTubSeg,
                    final mSenFac=mSenFac),
                  vol2(
                    final energyDynamics=energyDynamics,
                    final T(stateSelect=StateSelect.prefer),
                    final massDynamics=massDynamics,
                    final prescribedHeatFlowRate=false,
                    final m_flow_small=m2_flow_small,
                    final V=VTubSeg,
                    final mSenFac=mSenFac),
                  vol3(
                    final energyDynamics=energyDynamics,
                    final T(stateSelect=StateSelect.prefer),
                    final massDynamics=massDynamics,
                    final prescribedHeatFlowRate=false,
                    final allowFlowReversal=allowFlowReversal3,
                    final m_flow_small=m3_flow_small,
                    final V=VTubSeg,
                    final mSenFac=mSenFac),
                  vol4(
                    final energyDynamics=energyDynamics,
                    final T(stateSelect=StateSelect.prefer),
                    final massDynamics=massDynamics,
                    final prescribedHeatFlowRate=false,
                    final m_flow_small=m4_flow_small,
                    final V=VTubSeg,
                    final mSenFac=mSenFac));

                Modelica.Blocks.Sources.RealExpression RVol1(y=
                  IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.convectionResistanceCircularPipe(
                    hSeg=hSeg,
                    rTub=borFieDat.conDat.rTub,
                    eTub=borFieDat.conDat.eTub,
                    kMed=kMed,
                    muMed=muMed,
                    cpMed=cpMed,
                    m_flow=m1_flow,
                    m_flow_nominal=m1_flow_nominal))
                  "Convective and thermal resistance at fluid 1"
                  annotation (Placement(transformation(extent={{-16,56},{-30,72}})));
                Modelica.Blocks.Sources.RealExpression RVol2(y=
                  IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.convectionResistanceCircularPipe(
                    hSeg=hSeg,
                    rTub=borFieDat.conDat.rTub,
                    eTub=borFieDat.conDat.eTub,
                    kMed=kMed,
                    muMed=muMed,
                    cpMed=cpMed,
                    m_flow=m2_flow,
                    m_flow_nominal=m2_flow_nominal))
                  "Convective and thermal resistance at fluid 2"
                  annotation (Placement(transformation(extent={{88,-8},{72,-26}})));
                Modelica.Blocks.Sources.RealExpression RVol3(y=
                  IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.convectionResistanceCircularPipe(
                    hSeg=hSeg,
                    rTub=borFieDat.conDat.rTub,
                    eTub=borFieDat.conDat.eTub,
                    kMed=kMed,
                    muMed=muMed,
                    cpMed=cpMed,
                    m_flow=m3_flow,
                    m_flow_nominal=m3_flow_nominal))
                  "Convective and thermal resistance at fluid 1"
                  annotation (Placement(transformation(extent={{-12,-60},{-26,-76}})));

                Modelica.Blocks.Sources.RealExpression RVol4(y=
                  IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.convectionResistanceCircularPipe(
                    hSeg=hSeg,
                    rTub=borFieDat.conDat.rTub,
                    eTub=borFieDat.conDat.eTub,
                    kMed=kMed,
                    muMed=muMed,
                    cpMed=cpMed,
                    m_flow=m1_flow,
                    m_flow_nominal=m4_flow_nominal))
                  "Convective and thermal resistance at fluid 1"
                  annotation (Placement(transformation(extent={{-68,12},{-54,28}})));
                IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.InternalResistancesTwoUTube intRes2UTub(
                  hSeg=hSeg,
                  borFieDat=borFieDat,
                  Rgb_val=Rgb_val,
                  Rgg1_val=Rgg1_val,
                  Rgg2_val=Rgg2_val,
                  RCondGro_val=RCondGro_val,
                  dynFil=dynFil,
                  energyDynamics=energyDynamics,
                  T_start=TGro_start)
                                 "Internal resistances for a double U-tube configuration"
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
                Modelica.Thermal.HeatTransfer.Components.ConvectiveResistor RConv1
                  "Pipe convective resistance" annotation (Placement(transformation(
                      extent={{-8,-8},{8,8}},
                      rotation=90,
                      origin={0,46})));

                Modelica.Thermal.HeatTransfer.Components.ConvectiveResistor RConv2
                  "Pipe convective resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=180,
                      origin={34,0})));
                Modelica.Thermal.HeatTransfer.Components.ConvectiveResistor RConv3
                  "Pipe convective resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=90,
                      origin={0,-32})));
                Modelica.Thermal.HeatTransfer.Components.ConvectiveResistor RConv4
                  "Pipe convective resistance" annotation (Placement(transformation(
                      extent={{-8,8},{8,-8}},
                      rotation=180,
                      origin={-34,0})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_wall
                  annotation (Placement(transformation(extent={{-10,90},{10,110}})));

            protected
                parameter Real Rgg1_val(fixed=false);
                parameter Real Rgg2_val(fixed=false);

              initial equation
                (x,Rgb_val,Rgg1_val,Rgg2_val,RCondGro_val) =
                  IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.internalResistancesTwoUTube(
                    hSeg=hSeg,
                    rBor=borFieDat.conDat.rBor,
                    rTub=borFieDat.conDat.rTub,
                    eTub=borFieDat.conDat.eTub,
                    sha=borFieDat.conDat.xC,
                    kFil=borFieDat.filDat.kFil,
                    kSoi=borFieDat.soiDat.kSoi,
                    kTub=borFieDat.conDat.kTub,
                    use_Rb=borFieDat.conDat.use_Rb,
                    Rb=borFieDat.conDat.Rb,
                    kMed=kMed,
                    muMed=muMed,
                    cpMed=cpMed,
                    m_flow_nominal=m1_flow_nominal,
                    printDebug=false);

              equation
                assert(borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel
                   or borFieDat.conDat.borCon == IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeSeries,
                  "This model should be used for double U-type borefield, not single U-type. 
  Check that the conDat record has been correctly parametrized");
                connect(RVol1.y, RConv1.Rc) annotation (Line(
                    points={{-30.7,64},{-34,64},{-34,46},{-8,46}},
                    color={0,0,127},
                    smooth=Smooth.None));

                connect(RConv1.fluid, vol1.heatPort) annotation (Line(
                    points={{4.44089e-016,54},{-14,54},{-14,70},{-10,70}},
                    color={191,0,0},
                    smooth=Smooth.None));


                connect(RConv1.solid, intRes2UTub.port_1)
                  annotation (Line(points={{0,38},{0,24},{0,10}}, color={191,0,0}));
                connect(RConv2.fluid, vol2.heatPort)
                  annotation (Line(points={{42,0},{46,0},{50,0}}, color={191,0,0}));
                connect(RConv2.solid, intRes2UTub.port_2)
                  annotation (Line(points={{26,0},{18,0},{10,0}}, color={191,0,0}));
                connect(RConv3.fluid, vol3.heatPort) annotation (Line(points={{0,-40},{-14,-40},
                        {-14,-60},{-10,-60}}, color={191,0,0}));
                connect(RConv3.solid, intRes2UTub.port_3)
                  annotation (Line(points={{0,-24},{0,-10}}, color={191,0,0}));
                connect(RConv4.fluid, vol4.heatPort)
                  annotation (Line(points={{-42,0},{-46,0},{-50,0}}, color={191,0,0}));
                connect(RConv4.solid, intRes2UTub.port_4)
                  annotation (Line(points={{-26,0},{-18,0},{-10,0}}, color={191,0,0}));
                connect(RVol4.y, RConv4.Rc)
                  annotation (Line(points={{-53.3,20},{-34,20},{-34,8}}, color={0,0,127}));
                connect(RVol3.y, RConv3.Rc) annotation (Line(points={{-26.7,-68},{-30,-68},{-30,
                        -32},{-8,-32}}, color={0,0,127}));
                connect(RVol2.y, RConv2.Rc)
                  annotation (Line(points={{71.2,-17},{34,-17},{34,-8}}, color={0,0,127}));
                connect(intRes2UTub.port_wall, port_wall) annotation (Line(points={{0,0},{6,0},
                        {6,20},{20,20},{20,100},{0,100}}, color={191,0,0}));
                annotation (
                  Diagram(coordinateSystem(preserveAspectRatio=false, initialScale=0.1)),
                  Icon(coordinateSystem(preserveAspectRatio=false, initialScale=0.1),
                      graphics={
                      Rectangle(
                        extent={{98,74},{-94,86}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,255},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{96,24},{-96,36}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,255},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{100,-38},{-92,-26}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,255},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{94,-88},{-98,-76}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,255},
                        fillPattern=FillPattern.Solid)}),
                  Documentation(info="<html>
<p>
Model for the heat transfer between the fluid and within the borehole filling. 
This model computes the dynamic response of the fluid in the tubes, 
the heat transfer between the fluid and the borehole filling, 
and the heat storage within the fluid and the borehole filling.
</p>
<p>
This model computes the different thermal resistances present 
in a single-U-tube borehole using the method of Bauer et al. (2011) 
and computing explicitely the fluid-to-ground thermal resistance 
<i>R<sub>b</sub></i> and the 
grout-to-grout resistance
<i>R<sub>a</sub></i> as defined by Claesson and Hellstrom (2011)
using the multipole method. 
</p>
<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
<p>
D. Bauer, W. Heidemann, H. M&uuml;ller-Steinhagen, and H.-J. G. Diersch.
<i>
Thermal resistance and capacity models for borehole heat exchangers
</i>.
International Journal Of Energy Research, 35:312-320, 2011.
</p>
</html>",               revisions="<html>
<ul>
<li>
July 10, 2018, by Alex Laferri&egrave;re:<br/>
Updated documentation following major changes to the IBPSA.Fluid.HeatExchangers.Ground package.
Additionally, implemented a partial InternalHex model.
<li>
June 18, 2014, by Michael Wetter:<br/>
Added initialization for temperatures and derivatives of <code>capFil1</code>
and <code>capFil2</code> to avoid a warning during translation.
</li>
<li>
February 14, 2014, by Michael Wetter:<br/>
Removed unused parameters <code>B0</code> and <code>B1</code>.
</li>
<li>
January 24, 2014, by Michael Wetter:<br/>
Revised implementation, added comments, replaced 
<code>HeatTransfer.Windows.BaseClasses.ThermalConductor</code>
with resistance models from the Modelica Standard Library.
</li>
<li>
January 23, 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"),        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                          100}}), graphics));
              end InternalHEXTwoUTube;

              model InternalResistancesTwoUTube
                "Internal resistance model for double U-tube borehole segments."
                extends
                IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.PartialInternalResistances;

                parameter Modelica.SIunits.ThermalResistance Rgg1_val
                  "Thermal resistance between two neightbouring grout capacities, as defined by Bauer et al (2010)";
                parameter Modelica.SIunits.ThermalResistance Rgg2_val
                  "Thermal resistance between two  grout capacities opposite to each other, as defined by Bauer et al (2010)";
                parameter Modelica.SIunits.HeatCapacity Co_fil=borFieDat.filDat.dFil*borFieDat.filDat.cFil*hSeg*Modelica.Constants.pi
                  *(borFieDat.conDat.rBor^2 - 4*borFieDat.conDat.rTub^2)
                  "Heat capacity of the whole filling material";

                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_3
                  "Thermal connection for borehole wall"
                  annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_4
                  "Thermal connection for borehole wall"
                  annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rpg1(R=RCondGro_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=90,
                      origin={0,80})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgb1(R=Rgb_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=90,
                      origin={0,30})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgg14(R=Rgg1_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=90,
                      origin={-50,30})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgg21(R=Rgg2_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=270,
                      origin={50,30})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgg11(R=Rgg1_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=90,
                      origin={90,30})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rpg2(R=RCondGro_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{-8,8},{8,-8}},
                      rotation=180,
                      origin={80,0})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgg12(R=Rgg1_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=90,
                      origin={50,-30})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgb2(R=Rgb_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=0,
                      origin={30,0})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgb3(R=Rgb_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{-8,8},{8,-8}},
                      rotation=90,
                      origin={0,-30})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgb4(R=Rgb_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=180,
                      origin={-30,0})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rpg4(R=RCondGro_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=180,
                      origin={-80,0})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgg13(R=Rgg2_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=90,
                      origin={-50,-30})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rpg3(R=RCondGro_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{-8,8},{8,-8}},
                      rotation=90,
                      origin={0,-68})));
                Modelica.Thermal.HeatTransfer.Components.ThermalResistor Rgg22(R=Rgg1_val)
                  "Grout thermal resistance" annotation (Placement(transformation(
                      extent={{8,-8},{-8,8}},
                      rotation=180,
                      origin={30,-84})));
                Modelica.Thermal.HeatTransfer.Components.HeatCapacitor capFil1(T(start=
                        T_start, fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)),
                    der_T(fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial)),
                  C=Co_fil/4) if  dynFil "Heat capacity of the filling material"
                                                          annotation (Placement(transformation(extent={{-8,-8},
                          {8,8}},
                      rotation=90,
                      origin={-22,64})));
                Modelica.Thermal.HeatTransfer.Components.HeatCapacitor capFil2(T(start=
                        T_start, fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)),
                    der_T(fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial)),
                  C=Co_fil/4) if  dynFil "Heat capacity of the filling material"
                                                          annotation (Placement(transformation(extent={{58,8},{
                          74,24}})));
                Modelica.Thermal.HeatTransfer.Components.HeatCapacitor capFil3(T(start=
                        T_start, fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)),
                    der_T(fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial)),
                  C=Co_fil/4) if  dynFil "Heat capacity of the filling material"
                                                          annotation (Placement(transformation(extent={{-8,-8},
                          {8,8}},
                      rotation=90,
                      origin={-26,-62})));
                Modelica.Thermal.HeatTransfer.Components.HeatCapacitor capFil4(T(start=
                        T_start, fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial)),
                    der_T(fixed=(energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial)),
                  C=Co_fil/4) if  dynFil "Heat capacity of the filling material"
                                                          annotation (Placement(transformation(extent={{-82,20},
                          {-66,36}})));
              equation
                connect(Rpg1.port_a, port_1)
                  annotation (Line(points={{0,88},{0,100},{0,100}}, color={191,0,0}));
                connect(Rpg1.port_b, Rgb1.port_a)
                  annotation (Line(points={{0,72},{0,72},{0,38}}, color={191,0,0}));
                connect(Rgb1.port_b, port_wall)
                  annotation (Line(points={{0,22},{0,22},{0,0}}, color={191,0,0}));
                connect(port_wall, Rgb3.port_b)
                  annotation (Line(points={{0,0},{0,0},{0,-22}}, color={191,0,0}));
                connect(Rpg3.port_a, port_3)
                  annotation (Line(points={{0,-76},{0,-100}}, color={191,0,0}));
                connect(Rpg2.port_a, port_2)
                  annotation (Line(points={{88,0},{100,0},{100,0}}, color={191,0,0}));
                connect(Rgb2.port_a, Rpg2.port_b)
                  annotation (Line(points={{38,0},{56,0},{72,0}}, color={191,0,0}));
                connect(port_wall, Rgb2.port_b)
                  annotation (Line(points={{0,0},{11,0},{22,0}}, color={191,0,0}));
                connect(port_wall, Rgb4.port_b)
                  annotation (Line(points={{0,0},{-12,0},{-22,0}}, color={191,0,0}));
                connect(Rgb4.port_a, Rpg4.port_b) annotation (Line(points={{-38,8.88178e-016},
                        {-56,8.88178e-016},{-56,0},{-72,0}}, color={191,0,0}));
                connect(Rpg4.port_a, port_4)
                  annotation (Line(points={{-88,0},{-94,0},{-100,0}}, color={191,0,0}));
                connect(Rgg14.port_b, Rpg4.port_b) annotation (Line(points={{-50,22},{-50,0},{
                        -56,8.88178e-016},{-56,0},{-72,0},{-72,-9.99201e-016}}, color={191,0,0}));
                connect(Rgg13.port_a, Rpg4.port_b) annotation (Line(points={{-50,-22},{-50,0},
                        {-56,8.88178e-016},{-56,0},{-72,0},{-72,-9.99201e-016}}, color={191,0,
                        0}));
                connect(Rgg13.port_b, Rpg3.port_b) annotation (Line(points={{-50,-38},{-50,-50},
                        {0,-50},{0,-60},{4.996e-016,-60}}, color={191,0,0}));
                connect(Rgg13.port_b, Rgb3.port_a) annotation (Line(points={{-50,-38},{-50,-38},
                        {-50,-50},{0,-50},{0,-38},{-4.44089e-016,-38}}, color={191,0,0}));
                connect(Rgg13.port_b, Rgg11.port_b) annotation (Line(points={{-50,-38},{-50,-38},
                        {-50,-50},{0,-50},{90,-50},{90,22}}, color={191,0,0}));
                connect(Rgg13.port_b, Rgg12.port_b) annotation (Line(points={{-50,-38},{-50,-38},
                        {-50,-50},{50,-50},{50,-38}}, color={191,0,0}));
                connect(Rgb2.port_a, Rgg12.port_a)
                  annotation (Line(points={{38,0},{38,0},{50,0},{50,-22}}, color={191,0,0}));
                connect(Rgg21.port_a, Rpg2.port_b) annotation (Line(points={{50,22},{50,0},{72,
                        0},{72,9.99201e-016}}, color={191,0,0}));
                connect(Rpg1.port_b, Rgg11.port_a) annotation (Line(points={{0,72},{0,72},{0,64},
                        {90,64},{90,38}}, color={191,0,0}));
                connect(Rpg1.port_b, Rgg21.port_b) annotation (Line(points={{0,72},{0,72},{0,46},
                        {50,46},{50,38}}, color={191,0,0}));
                connect(Rgg14.port_a, Rgb1.port_a) annotation (Line(points={{-50,38},{-50,46},
                        {0,46},{0,38},{4.996e-016,38}}, color={191,0,0}));
                connect(Rgg22.port_a, Rpg4.port_b) annotation (Line(points={{22,-84},{-66,-84},
                        {-66,0},{-72,0},{-72,-9.99201e-016}}, color={191,0,0}));
                connect(Rgg22.port_b, Rpg2.port_b) annotation (Line(points={{38,-84},{66,-84},
                        {66,0},{72,0},{72,9.99201e-016}}, color={191,0,0}));
                connect(capFil1.port, Rgb1.port_a) annotation (Line(points={{-14,64},{0,64},{0,
                        38},{4.996e-016,38}}, color={191,0,0}));
                connect(capFil2.port, Rpg2.port_b) annotation (Line(points={{66,8},{66,0},{72,
                        0},{72,9.99201e-016}}, color={191,0,0}));
                connect(capFil3.port, Rpg3.port_b) annotation (Line(points={{-18,-62},{-12,-62},
                        {-12,-50},{0,-50},{0,-60},{4.996e-016,-60}}, color={191,0,0}));
                connect(capFil4.port, Rpg4.port_b) annotation (Line(points={{-74,20},{-74,12},
                        {-66,12},{-66,0},{-72,0},{-72,-9.99201e-016}}, color={191,0,0}));
                annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                      Line(
                        points={{0,-50},{0,-40},{-10,-30},{10,-10},{-10,10},{10,30},{0,40},{0,
                            50}},
                        color={0,0,0},
                        origin={-50,0},
                        rotation=-90,
                        thickness=0.5),
                      Line(
                        points={{0,-50},{0,-40},{-10,-30},{10,-10},{-10,10},{10,30},{0,40},{0,
                            50}},
                        color={0,0,0},
                        origin={0,-50},
                        rotation=360,
                        thickness=0.5),
                      Line(
                        points={{0,-70.7107},{0,-40},{-10,-30},{10,-10},{-10,10},{10,30},{0,
                            40},{-7.10543e-015,70.7107}},
                        color={0,0,0},
                        origin={-50,-50},
                        rotation=45,
                        thickness=0.5),
                      Line(
                        points={{7.10543e-015,-70.7107},{0,-40},{-10,-30},{9.99997,-9.99997},
                            {-9.99997,9.99997},{10,30},{0,40},{-7.10543e-015,70.7107}},
                        color={0,0,0},
                        origin={-50,50},
                        rotation=135,
                        thickness=0.5),
                      Line(
                        points={{7.10543e-015,-70.7107},{0,-40},{-10,-30},{9.99997,-9.99997},
                            {-9.99997,9.99997},{10,30},{0,40},{-7.10543e-015,70.7107}},
                        color={0,0,0},
                        origin={50,-50},
                        rotation=135,
                        thickness=0.5),        Text(
                        extent={{-100,144},{100,106}},
                        lineColor={0,0,255},
                        fillPattern=FillPattern.HorizontalCylinder,
                        fillColor={0,127,255},
                        textString="%name")}),                                 Diagram(
                      coordinateSystem(preserveAspectRatio=false)),
                      Documentation(info="<html>
<p>
This model simulates the internal thermal resistance network of a borehole segment in
the case of a double U-tube borehole using the method of Bauer et al. (2011) 
and computing explicitely the fluid-to-ground thermal resistance 
<i>R<sub>b</sub></i> and the 
grout-to-grout resistance
<i>R<sub>a</sub></i> as defined by Claesson and Hellstrom (2011)
using the multipole method. 
</p>
<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
<p>
D. Bauer, W. Heidemann, H. M&uuml;ller-Steinhagen, and H.-J. G. Diersch.
<i>
Thermal resistance and capacity models for borehole heat exchangers
</i>.
International Journal Of Energy Research, 35:312-320, 2011.
</p>
</html>",               revisions="<html>
<ul>
<li>
July 5, 2018, by Alex Laferri&egrave;re:<br/>
Extended the model from a partial class.
</li>
<li>
June, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
              end InternalResistancesTwoUTube;

              partial model PartialBorehole
                "Partial model to implement multi-segment boreholes"
                extends IBPSA.Fluid.Interfaces.PartialTwoPortInterface;

                extends IBPSA.Fluid.Interfaces.TwoPortFlowResistanceParameters(
                  computeFlowResistance=dp_nominal > Modelica.Constants.eps);

                replaceable package Medium =
                  Modelica.Media.Interfaces.PartialMedium "Medium in the component"
                    annotation (choices(
                      choice(redeclare package Medium = IBPSA.Media.Water "Water"),
                      choice(redeclare package Medium =
                          IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                            property_T=293.15,
                            X_a=0.40)
                            "Propylene glycol water, 40% mass fraction")));

                constant Real mSenFac(min=1)=1
                 "Factor for scaling the sensible thermal mass of the volume";

                parameter Integer nSeg(min=1) = 10
                  "Number of segments to use in vertical discretization of the boreholes";
                parameter Modelica.SIunits.Temperature TGro_start[nSeg]
                  "Start value of grout temperature"
                  annotation (Dialog(tab="Initialization"));

                parameter Modelica.SIunits.Temperature TFlu_start[nSeg] = TGro_start
                  "Start value of fluid temperature"
                  annotation (Dialog(tab="Initialization"));

                // Assumptions
                parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
                  "Type of energy balance: dynamic (3 initialization options) or steady state"
                  annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

                // Initialization
                parameter Medium.AbsolutePressure p_start = Medium.p_default
                  "Start value of pressure"
                  annotation(Dialog(tab = "Initialization"));

                parameter Boolean dynFil=true
                    "Set to false to remove the dynamics of the filling material"
                    annotation (Dialog(tab="Dynamics"));
                parameter Data.Borefield.Template borFieDat "Borefield parameters"
                  annotation (Placement(transformation(extent={{-80,-80},{-60,-60}})));

                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_wall[nSeg]
                  "Thermal connection for borehole wall"
                  annotation (Placement(transformation(extent={{-10,90},{10,110}})));

                  annotation(Documentation(info="<html>
<p>
Partial model to implement models simulating geothermal U-tube boreholes modeled
as several borehole segments, with a uniform borehole wall boundary condition.
</p>
</html>",               revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice to water and glycolWater.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation of partial model.
</li>
<li>
July 2014, by Damien Picard:<br/>
First implementation.
</ul>
</html>"),    Icon(coordinateSystem(
                      preserveAspectRatio=true,
                      extent={{-100,-100},{100,100}},
                      grid={2,2},
                      initialScale=0.5), graphics={
                      Rectangle(
                        extent={{-68,76},{72,-84}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-60,-56},{64,-64}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-60,54},{64,50}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-60,2},{64,-4}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={0,0,0},
                        fillPattern=FillPattern.Solid),
                      Rectangle(
                        extent={{-70,76},{-60,-84}},
                        lineColor={0,0,0},
                        fillColor={192,192,192},
                        fillPattern=FillPattern.Backward),
                      Rectangle(
                        extent={{64,76},{74,-84}},
                        lineColor={0,0,0},
                        fillColor={192,192,192},
                        fillPattern=FillPattern.Backward)}));
              end PartialBorehole;

              partial model PartialInternalHEX
                "Partial model to implement the internal heat exchanger of a borehole segment"
                parameter IBPSA.Fluid.Geothermal.Borefields.Data.Borefield.Template
                  borFieDat "Borefield parameters"
                  annotation (Placement(transformation(extent={{-100,-100},{-80,-80}})));
                replaceable package Medium =
                  Modelica.Media.Interfaces.PartialMedium "Medium"
                  annotation (choices(
                      choice(redeclare package Medium = IBPSA.Media.Water "Water"),
                      choice(redeclare package Medium =
                          IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                            property_T=293.15,
                            X_a=0.40)
                            "Propylene glycol water, 40% mass fraction")));
                constant Real mSenFac=1
                  "Factor for scaling the sensible thermal mass of the volume";
                parameter Boolean dynFil=true
                  "Set to false to remove the dynamics of the filling material"
                  annotation (Dialog(tab="Dynamics"));
                parameter Modelica.SIunits.Length hSeg
                  "Length of the internal heat exchanger";
                parameter Modelica.SIunits.Volume VTubSeg = hSeg*Modelica.Constants.pi*(borFieDat.conDat.rTub-borFieDat.conDat.eTub)^2
                  "Fluid volume in each tube";
                parameter Modelica.SIunits.Temperature TFlu_start
                  "Start value of fluid temperature"
                  annotation (Dialog(tab="Initialization"));
                parameter Modelica.SIunits.Temperature TGro_start
                  "Start value of grout temperature"
                  annotation (Dialog(tab="Initialization"));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_wall
                  "Thermal connection for borehole wall"
                  annotation (Placement(transformation(extent={{-10,90},{10,110}})));
            protected
                parameter Modelica.SIunits.SpecificHeatCapacity cpMed=
                    Medium.specificHeatCapacityCp(Medium.setState_pTX(
                    Medium.p_default,
                    Medium.T_default,
                    Medium.X_default)) "Specific heat capacity of the fluid";
                parameter Modelica.SIunits.ThermalConductivity kMed=
                    Medium.thermalConductivity(Medium.setState_pTX(
                    Medium.p_default,
                    Medium.T_default,
                    Medium.X_default)) "Thermal conductivity of the fluid";
                parameter Modelica.SIunits.DynamicViscosity muMed=Medium.dynamicViscosity(
                    Medium.setState_pTX(
                    Medium.p_default,
                    Medium.T_default,
                    Medium.X_default)) "Dynamic viscosity of the fluid";
                parameter Real Rgb_val(fixed=false)
                  "Thermal resistance between grout zone and borehole wall";
                parameter Real RCondGro_val(fixed=false)
                  "Thermal resistance between: pipe wall to capacity in grout";
                parameter Real x(fixed=false) "Capacity location";
              initial equation
                assert(borFieDat.conDat.rBor > borFieDat.conDat.xC + borFieDat.conDat.rTub and
                       0 < borFieDat.conDat.xC - borFieDat.conDat.rTub,
                       "The borehole geometry is not physical. Check the borefield data record
         to ensure that the shank spacing is larger than the outer tube radius
         and that the borehole radius is sufficiently large.");
                annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                      Rectangle(
                        extent={{-70,80},{70,-80}},
                        lineColor={0,0,255},
                        pattern=LinePattern.None,
                        fillColor={95,95,95},
                        fillPattern=FillPattern.Solid)}),                      Diagram(
                      coordinateSystem(preserveAspectRatio=false)),
                Documentation(info="<html>
<p>
Partial model to implement models simulating the thermal and fluid behaviour of a borehole segment.
</p>
<p>
The thermodynamic properties of the fluid circulating in the borehole are calculated
as protected parameters in this partial model: <i>c<sub>p</sub></i> (<code>cpMed</code>),
<i>k</i> (<code>kMed</code>) and <i>&mu;</i> (<code>muMed</code>). Additionally, the
following parameters are already declared as protected parameters and thus do not
need to be declared in models which extend this partial model:
</p>
<ul>
<li>
<code>Rgb_val</code> (Thermal resistance between grout zone and borehole wall)
</li>
<li>
<code>RCondGro_val</code> (Thermal resistance between pipe wall and capacity in grout)
</li>
<li>
<code>x</code> (Grout capacity location)
</li>
</ul>
</html>",               revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice to water and glycolWater.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 10, 2018, by Alex Laferri&egrave;re:<br/>
First implementation of partial model.
</li>
<li>
June 18, 2014, by Michael Wetter:<br/>
Added initialization for temperatures and derivatives of <code>capFil1</code>
and <code>capFil2</code> to avoid a warning during translation.
</li>
<li>
February 14, 2014, by Michael Wetter:<br/>
Removed unused parameters <code>B0</code> and <code>B1</code>.
</li>
<li>
January 24, 2014, by Michael Wetter:<br/>
Revised implementation, added comments, replaced
<code>HeatTransfer.Windows.BaseClasses.ThermalConductor</code>
with resistance models from the Modelica Standard Library.
</li>
<li>
January 23, 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
              end PartialInternalHEX;

              partial model PartialInternalResistances
                "Partial model to implement borehole segment internal resistance models"
                parameter Modelica.SIunits.Length hSeg
                  "Length of the internal heat exchanger";
                parameter Modelica.SIunits.Temperature T_start
                  "Initial temperature of the filling material";
                parameter Data.Borefield.Template borFieDat "Borefield data"
                  annotation (Placement(transformation(extent={{-100,-100},{-80,-80}})));
                parameter Modelica.SIunits.ThermalResistance Rgb_val
                  "Thermal resistance between grout zone and borehole wall";
                parameter Modelica.SIunits.ThermalResistance RCondGro_val
                  "Thermal resistance between: pipe wall to capacity in grout";
                parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
                  "Type of energy balance: dynamic (3 initialization options) or steady state"
                  annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
                parameter Boolean dynFil=true
                    "Set to false to remove the dynamics of the filling material."
                    annotation (Dialog(tab="Dynamics"));

                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_1
                  "Thermal connection for pipe 1"
                  annotation (Placement(transformation(extent={{-10,90},{10,110}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_wall
                  "Thermal connection for pipe 2"
                  annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
                Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_2
                  "Thermal connection for borehole wall"
                  annotation (Placement(transformation(extent={{90,-10},{110,10}})));
                annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                      Rectangle(
                        extent={{-100,100},{100,-100}},
                        lineColor={0,0,0},
                        fillColor={255,255,255},
                        fillPattern=FillPattern.Solid),
                      Line(points={{0,0},{0,10},{-10,20},{10,40},{-10,60},{10,80},{0,90},{0,
                            100}},
                          color={0,0,0},
                        thickness=0.5),
                      Line(
                        points={{0,-70.7107},{0,-40},{-10,-30},{10,-10},{-10,10},{10,30},{0,
                            40},{-7.10543e-015,70.7107}},
                        color={0,0,0},
                        origin={50,50},
                        rotation=45,
                        thickness=0.5),
                      Line(
                        points={{0,-50},{0,-40},{-10,-30},{10,-10},{-10,10},{10,30},{0,40},{0,
                            50}},
                        color={0,0,0},
                        origin={50,0},
                        rotation=-90,
                        thickness=0.5)}),                                      Diagram(
                      coordinateSystem(preserveAspectRatio=false)),
                      Documentation(info="<html>
<p>
Partial model to implement the inner resistance network of a borehole segment.
</p>
<p>
The partial model uses a thermal port representing a uniform borehole wall for
that segment, and at least two other thermal ports (one for each tube going through the borehole
segment).
</p>
</html>",               revisions="<html>
<ul>
<li>
July 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation of partial class.
</li>
<li>
June, 2018, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
              end PartialInternalResistances;

              package Functions
              "Package with functions for evaluation of borehole thermal resistances"
              extends Modelica.Icons.VariantsPackage;

                function convectionResistanceCircularPipe
                  "Thermal resistance from the fluid in pipes and the grout zones (Bauer et al. 2011)"

                  // Geometry of the borehole
                  input Modelica.SIunits.Height hSeg "Height of the element";
                  input Modelica.SIunits.Radius rTub "Tube radius";
                  input Modelica.SIunits.Length eTub "Tube thickness";
                  // thermal properties
                  input Modelica.SIunits.ThermalConductivity kMed
                    "Thermal conductivity of the fluid";
                  input Modelica.SIunits.DynamicViscosity muMed
                    "Dynamic viscosity of the fluid";
                  input Modelica.SIunits.SpecificHeatCapacity cpMed
                    "Specific heat capacity of the fluid";
                  input Modelica.SIunits.MassFlowRate m_flow "Mass flow rate";
                  input Modelica.SIunits.MassFlowRate m_flow_nominal "Nominal mass flow rate";

                  // Outputs
                  output Modelica.SIunits.ThermalResistance RFluPip
                    "Convection resistance (or conduction in fluid if no mass flow)";

              protected
                  parameter Modelica.SIunits.Radius rTub_in = rTub - eTub
                    "Pipe inner radius";
                  Modelica.SIunits.CoefficientOfHeatTransfer h
                    "Convective heat transfer coefficient of the fluid";

                  Real k(unit="s/kg")
                    "Coefficient used in the computation of the convective heat transfer coefficient";
                  Modelica.SIunits.MassFlowRate m_flow_abs = IBPSA.Utilities.Math.Functions.spliceFunction(m_flow,-m_flow,m_flow,m_flow_nominal/30);
                  Real Re "Reynolds number";
                  Real NuTurb "Nusselt at Re=2400";
                  Real Nu "Nusselt";

                algorithm
                  // Convection resistance and Reynolds number
                  k := 2/(muMed*Modelica.Constants.pi*rTub_in);
                  Re := m_flow_abs*k;

                  if Re>=2400 then
                    // Turbulent, fully-developped flow in a smooth circular pipe with the
                    // Dittus-Boelter correlation: h = 0.023*k_f*Re*Pr/(2*rTub)
                    // Re = rho*v*DTub / mue_f
                    //    = m_flow/(pi r^2) * DTub/mue_f = 2*m_flow / ( mue*pi*rTub)
                    Nu := 0.023*(cpMed*muMed/kMed)^(0.35)*Re^(0.8);
                //       IBPSA.Utilities.Math.Functions.regNonZeroPower(
                //         x=Re,
                //         n=0.8,
                //         delta=0.01*m_flow_nominal*k);
                  else
                    // Laminar, fully-developped flow in a smooth circular pipe with uniform
                    // imposed temperature: Nu=3.66 for Re<=2300. For 2300<Re<2400, a smooth
                    // transition is created with the splice function.
                    NuTurb := 0.023*(cpMed*muMed/kMed)^(0.35)*(2400)^(0.8);
                    Nu := IBPSA.Utilities.Math.Functions.spliceFunction(NuTurb,3.66,Re-(2300+2400)/2,((2300+2400)/2)-2300);
                  end if;
                  h := Nu*kMed/(2*rTub_in);

                  RFluPip := 1/(2*Modelica.Constants.pi*rTub_in*hSeg*h);

                  annotation (Diagram(graphics), Documentation(info="<html>
<p>
This model computes the convection resistance in the pipes of a borehole segment 
with heigth <i>h<sub>Seg</sub></i> using correlations suggested by Bergman et al. (2011).
</p>
<p>
If the flow is laminar (<i>Re &le; 2300</i>, with <i>Re</i> being the Reynolds number of the flow),
the Nusselt number of the flow is assumed to be constant at 3.66. If the flow is turbulent (<i>Re &gt; 2300</i>),
the correlation of Dittus-Boelter is used to find the convection heat transfer coefficient as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Nu = 0.023 &nbsp; Re<sup>0.8</sup> &nbsp; Pr<sup>n</sup>,
</p>
<p>
where <i>Nu</i> is the Nusselt number and 
<i>Pr</i> is the Prandlt number.
A value of <i>n=0.35</i> is used, as the reference uses <i>n=0.4</i> for heating and 
<i>n=0.3</i> for cooling. To ensure that the function is continuously differentiable,
a smooth transition between the laminar and turbulent values is created for the
range <i>2300 &lt; Re &lt; 2400</i>.
</p>
<h4>References</h4>
<p>
Bergman, T. L., Incropera, F. P., DeWitt, D. P., &amp; Lavine, A. S. (2011). <i>Fundamentals of heat and mass
transfer</i> (7th ed.). New York: John Wiley &amp; Sons.
</p>
</html>",                 revisions="<html>
<ul>
<li>
July 10, 2018, by Alex Laferri&egrave;re:<br/>
Added laminar flow and smooth laminar-turbulent transition.
Revised documentation.
</li>
<li>
February 14, 2014, by Michael Wetter:<br/>
Removed unused input <code>rBor</code>.
Revised documentation.
</li>
<li>
January 24, 2014, by Michael Wetter:<br/>
Revised implementation. 
Changed <code>cpFluid</code> to <code>cpMed</code> to use consistent notation.
Added regularization for computation of convective heat transfer coefficient to
avoid an event and a non-differentiability.
</li>
<li>
January 23, 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
                end convectionResistanceCircularPipe;

                function internalResistancesTwoUTube
                  "Thermal resistances for double U-tube, according to Bauer et al (2011)"
                  extends
                  IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.partialInternalResistances;

                  // Outputs
                  output Modelica.SIunits.ThermalResistance Rgb
                    "Thermal resistance between a grout capacity and the borehole wall, as defined by Bauer et al (2010)";
                  output Modelica.SIunits.ThermalResistance Rgg1
                    "Thermal resistance between two neightbouring grout capacities, as defined by Bauer et al (2010)";
                  output Modelica.SIunits.ThermalResistance Rgg2
                    "Thermal resistance between two  grout capacities opposite to each other, as defined by Bauer et al (2010)";
                  output Modelica.SIunits.ThermalResistance RCondGro
                    "Thermal resistance between a pipe wall and the grout capacity, as defined by Bauer et al (2010)";
              protected
                  Real[4,4] RDelta(each unit="(m.K)/W") "Delta-circuit thermal resistances";
                  Real[4,4] R(each unit="(m.K)/W") "Internal thermal resistances";
                  Modelica.SIunits.Position[4] xPip = {-sha, sha, 0., 0.} "x-Coordinates of pipes";
                  Modelica.SIunits.Position[4] yPip = {0., 0., -sha, sha} "y-Coordinates of pipes";
                  Modelica.SIunits.Radius[4] rPip = {rTub, rTub, rTub, rTub} "Outer radius of pipes";
                  Real[4] RFluPip(each unit="(m.K)/W") = {RCondPipe+RConv, RCondPipe+RConv, RCondPipe+RConv, RCondPipe+RConv} "Fluid to pipe wall thermal resistances";

                  Real Ra( unit="(m.K)/W")
                    "Grout-to-grout resistance (2D) as defined by Hellstrom. Interaction between the different grout parts";

                  Modelica.SIunits.ThermalResistance Rg
                    "Thermal resistance between outer borehole wall and one tube";
                  Modelica.SIunits.ThermalResistance Rar1
                    "Thermal resistance between the two closest pipe outer walls";
                  Modelica.SIunits.ThermalResistance Rar2
                    "Thermal resistance between the two farthest pipe outer walls";

                algorithm
                  // Internal thermal resistances
                  (RDelta, R) :=
                    IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.multipoleThermalResistances(
                      4, 3, xPip, yPip, rBor, rPip, kFil, kSoi, RFluPip);

                  // Rb and Ra
                  Rb_multipole := 1./(1./RDelta[1,1] + 1./RDelta[2,2] + 1./RDelta[3,3] + 1./RDelta[4,4]);
                  Rb_internal := if use_Rb then Rb else Rb_multipole;
                  // The short-circuit resistance in weigthed by the ratio between the used
                  // value of Rb and the theoretical value
                  Ra := (R[1,1] + R[3,3] - 2*R[1,3])*Rb_internal/Rb_multipole;

                  // ------ Calculation according to Bauer et al. (2010)
                  Rg := (4*Rb_internal - RCondPipe - RConv)/hSeg;
                  Rar1 := ((2 + sqrt(2))*Rg*hSeg*(Ra - RCondPipe)/(Rg*hSeg + Ra - RCondPipe))/hSeg;
                  Rar2 := sqrt(2)*Rar1;

                  // If any of the internal delta-circuit resistances is negative, then
                  // the location (x) of the thermal capacity is set to zero to limit
                  // instabilities in the calculations. Otherwise, calculations follow the
                  // method of Bauer et al. (2011).
                  if (RDelta[1,2] < 0) or (RDelta[1,3] < 0) then
                    //Thermal resistance between the grout zone and borehole wall
                    Rgb := Rg;

                    //Conduction resistance in grout from pipe wall to capacity in grout
                    RCondGro := RCondPipe/hSeg;

                    //Thermal resistance between the two grout zones
                    Rgg1 := 2*Rgb*(Rar1)/(2*Rgb - Rar1);
                    Rgg2 := 2*Rgb*(Rar2)/(2*Rgb - Rar2);

                    test := true;
                  else
                    // ********** Resistances and capacity location according to Bauer **********
                    while test == false and i <= 16 loop
                      // Capacity location (with correction factor in case that the test is negative)
                      x := Modelica.Math.log(sqrt(rBor^2 + 4*rTub^2)/(2*sqrt(2)*rTub))/
                          Modelica.Math.log(rBor/(2*rTub))*((15 - i + 1)/15);

                      //Thermal resistance between the grout zone and borehole wall
                      Rgb := (1 - x)*Rg;

                      //Conduction resistance in grout from pipe wall to capacity in grout
                      RCondGro := x*Rg + RCondPipe/hSeg;

                      //Thermal resistance between the two grout zones
                      Rgg1 := 2*Rgb*(Rar1 - 2*x*Rg)/(2*Rgb - Rar1 + 2*x*Rg);
                      Rgg2 := 2*Rgb*(Rar2 - 2*x*Rg)/(2*Rgb - Rar2 + 2*x*Rg);

                      // Thermodynamic test to check if negative R values make sense. If not, decrease x-value.
                      test := (((1/Rgg1 + 1/2/Rgb)^(-1) > 0) and ((1/Rgg2 + 1/2/Rgb)^(-1) > 0));
                      i := i + 1;
                    end while;
                  end if;
                  assert(test,
                  "Maximum number of iterations exceeded. Check the borehole geometry.
  The tubes may be too close to the borehole wall.
  Input to the function
  IBPSA.Fluid.HeatExchangers.Boreholes.BaseClasses.doubleUTubeResistances
  is
            hSeg = "                 + String(hSeg) + " m
            rBor = "                 + String(rBor) + " m
            rTub = "                 + String(rTub) + " m
            eTub = "                 + String(eTub) + " m
            sha = "                 + String(sha) + " m
            kSoi = "                 + String(kSoi) + " W/m/K
            kFil = "                 + String(kFil) + " W/m/K
            kTub = "                 + String(kTub) + " W/m/K
  Computed x    = "                 + String(x) + " m
            Rgb  = "                 + String(Rgb) + " K/W
            Rgg1  = "                 + String(Rgg1) + " K/W
            Rgg2  = "                 + String(Rgg2) + " K/W");

                  if printDebug then
                    Modelica.Utilities.Streams.print("
      Rb = "                 + String(Rb_internal) + " m K / W
      RCondPipe = "                + String(RCondPipe) + " m K / W
      RConv = "                 +String(RConv) +"m K / W
      hSeg = "                 + String(hSeg) + " m
      Rg = "                +String(Rg) + " K / W
      Ra = "                 + String(Ra)  + " m K / W
      x = "                 + String(x) + "
      i = "                  + String(i));
                  end if;
                  annotation (Diagram(graphics), Documentation(info="<html>
<p>
This model computes the different thermal resistances present in a double U-tube
borehole using the method of Bauer et al. (2011).
It also computes the fluid-to-ground thermal resistance <i>R<sub>b</sub></i> 
and the grout-to-grout thermal resistance <i>R<sub>a</sub></i> 
as defined by Claesson and Hellstrom (2011) using the multipole method.
</p>

<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
<p>D. Bauer, W. Heidemann, H. M&uuml;ller-Steinhagen, and H.-J. G. Diersch. 
<i>Thermal resistance and capacity models for borehole heat exchangers</i>. 
International Journal of Energy Research, 35:312&ndash;320, 2011.</p>
</html>",                 revisions="<html>
<ul>
<li>
July 18, 2018 by Massimo Cimmino:<br/>
Implemented multipole method.
</li>
<li>
February 14, 2014 by Michael Wetter:<br/>
Added an assert statement to test for non-physical values.
</li>
<li>
February 12, 2014, by Damien Picard:<br/>
Remove the flow dependency of the resistances, as this function calculates the conduction resistances only.
</li>
<li>
January 24, 2014, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
January 23, 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
                end internalResistancesTwoUTube;

                function multipoleFluidTemperature "Fluid temperatures from multipole solution"
                  extends Modelica.Icons.Function;

                  input Integer nPip "Number of pipes";
                  input Integer J "Number of multipoles";
                  input Modelica.SIunits.Position xPip[nPip] "x-Coordinates of pipes";
                  input Modelica.SIunits.Position yPip[nPip] "y-Coordinates of pipes";
                  input Real QPip_flow[nPip](each unit="W/m") "Heat flow in pipes";
                  input Modelica.SIunits.Temperature TBor "Average borehole wall temperature";
                  input Modelica.SIunits.Radius rBor "Borehole radius";
                  input Modelica.SIunits.Radius rPip[nPip] "Outter radius of pipes";
                  input Modelica.SIunits.ThermalConductivity kFil "Thermal conductivity of grouting material";
                  input Modelica.SIunits.ThermalConductivity kSoi "Thermal conductivity of soil material";
                  input Real RFluPip[nPip](each unit="(m.K)/W") "Fluid to pipe wall thermal resistances";
                  input Real eps=1.0e-5 "Iteration relative accuracy";
                  input Integer it_max=100 "Maximum number of iterations";

                  output Modelica.SIunits.Temperature TFlu[nPip] "Fluid temperature in pipes";

              protected
                  Real pikFil(unit="(m.K)/W")=1/(2*Modelica.Constants.pi*kFil) "Coefficient based on grout thermal conductivity";
                  Real sigma=(kFil - kSoi)/(kFil + kSoi) "Thermal conductivity ratio";
                  Real betaPip[nPip]=2*Modelica.Constants.pi*kFil*RFluPip "Dimensionless fluid to outter pipe wall thermal resistance";
                  Complex zPip_i "Position of pipe i";
                  Complex zPip_j "Position of pipe j";
                  Complex P_nj "Multipole of order j for pipe n";
                  Real PRea[nPip,J] "Matrix of real part of multipoles";
                  Real PIma[nPip,J] "Matrix of imaginary part of multipole";
                  Complex P_nj_new "New value of multipole of order j for pipe n";
                  Real PRea_new[nPip,J] "New value of real part of multipoles";
                  Real PIma_new[nPip,J] "New value of imaginary part of multipoles";
                  Complex F_mk "Coefficient F of order k of pipe m";
                  Real FRea[nPip,J] "Real part of matrix F_mk";
                  Real FIma[nPip,J] "Imaginary part of matrix F_mk";
                  Real R0[nPip,nPip](each unit="(m.K)/W") "Line source approximation of thermal resistances";
                  Complex deltaTFlu "Fluid temperature difference with line source approximation";
                  Real rbm "Intermediate coefficient";
                  Modelica.SIunits.Distance dz "Pipe to pipe distance";
                  Real coeff[nPip,J] "Coefficient for multiplication with matrix F_mk";
                  Real diff "Difference in subsequent multipole evaluations";
                  Real diff_max "Maximum difference in subsequent multipole evaluations";
                  Real diff_min "Minimum difference in subsequent multipole evaluations";
                  Real diff0 "Difference in subsequent multipole evaluations";
                  Integer it "Iteration counter";
                  Real eps_max "Convergence variable";

                algorithm
                  // Thermal resistance matrix from 0th order multipole
                  for i in 1:nPip loop
                    zPip_i := Complex(xPip[i], yPip[i]);
                    rbm := rBor^2/(rBor^2 - Modelica.ComplexMath.'abs'(zPip_i)^2);
                    R0[i, i] := pikFil*(log(rBor/rPip[i]) + betaPip[i] + sigma*log(rbm));
                    for j in 1:nPip loop
                      zPip_j := Complex(xPip[j], yPip[j]);
                      if i <> j then
                        dz := Modelica.ComplexMath.'abs'(zPip_i - zPip_j);
                        rbm := rBor^2/Modelica.ComplexMath.'abs'(rBor^2 - zPip_j*
                          Modelica.ComplexMath.conj(zPip_i));
                        R0[i, j] := pikFil*(log(rBor/dz) + sigma*log(rbm));
                      end if;
                    end for;
                  end for;

                  // Initialize maximum error and iteration counter
                  eps_max := 1.0e99;
                  it := 0;
                  // Multipoles
                  if J > 0 then
                    for m in 1:nPip loop
                      for k in 1:J loop
                        coeff[m, k] := -(1 - k*betaPip[m])/(1 + k*betaPip[m]);
                        PRea[m, k] := 0;
                        PIma[m, k] := 0;
                      end for;
                    end for;
                    while eps_max > eps and it < it_max loop
                      it := it + 1;
                      (FRea, FIma) :=
                        IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.multipoleFmk(
                        nPip,
                        J,
                        QPip_flow,
                        PRea,
                        PIma,
                        rBor,
                        rPip,
                        xPip,
                        yPip,
                        kFil,
                        kSoi);
                      for p in 1:nPip loop
                        for q in 1:J loop
                          F_mk := Complex(FRea[p, q], FIma[p, q]);
                          P_nj_new := coeff[p, q]*Modelica.ComplexMath.conj(F_mk);
                          PRea_new[p, q] := Modelica.ComplexMath.real(P_nj_new);
                          PIma_new[p, q] := Modelica.ComplexMath.imag(P_nj_new);
                        end for;
                      end for;
                      diff_max := 0;
                      diff_min := 1e99;
                      for r in 1:nPip loop
                        for s in 1:J loop
                          P_nj := Complex(PRea[r, s], PIma[r, s]);
                          P_nj_new := Complex(PRea_new[r, s], PIma_new[r, s]);
                          diff_max := max(diff_max,
                                           Modelica.ComplexMath.'abs'(P_nj_new - P_nj));
                          diff_min := min(diff_min,
                                           Modelica.ComplexMath.'abs'(P_nj_new - P_nj));
                        end for;
                      end for;
                      diff := diff_max - diff_min;
                      if it == 1 then
                        diff0 :=diff;
                      end if;
                      eps_max := diff/diff0;
                      PRea := PRea_new;
                      PIma := PIma_new;
                    end while;
                  end if;

                  // Fluid Temperatures
                  TFlu := TBor .+ R0*QPip_flow;
                  if J > 0 then
                    for u in 1:nPip loop
                      zPip_i :=Complex(xPip[u], yPip[u]);
                      deltaTFlu := Complex(0, 0);
                      for v in 1:nPip loop
                        zPip_j :=Complex(xPip[v], yPip[v]);
                        for w in 1:J loop
                          P_nj := Complex(PRea[v, w], PIma[v, w]);
                          if v <> u then
                            // Second term
                            deltaTFlu := deltaTFlu + P_nj*(rPip[v]/(zPip_i - zPip_j))^w;
                          end if;
                          // Third term
                          deltaTFlu := deltaTFlu + sigma*P_nj*(rPip[v]*
                            Modelica.ComplexMath.conj(zPip_i)/(rBor^2 - zPip_j*
                            Modelica.ComplexMath.conj(zPip_i)))^w;
                        end for;
                      end for;
                      TFlu[u] := TFlu[u] + Modelica.ComplexMath.real(deltaTFlu);
                    end for;
                  end if;

                  annotation (Documentation(info="<html>
<p> This model evaluates the fluid temperatures using the multipole method of Claesson and Hellstrom (2011).
</p>
<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
</html>",                 revisions="<html>
<ul>
<li>
February 12, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
                end multipoleFluidTemperature;

                function multipoleFmk "Complex matrix F_mk from Claesson and Hellstrom (2011)"
                  extends Modelica.Icons.Function;

                  input Integer nPip "Number of pipes";
                  input Integer J "Number of multipoles";
                  input Real QPip_flow[nPip](each unit="W/m") "Heat flow in pipes";
                  input Real PRea[nPip,J] "Multipoles (Real part)";
                  input Real PIma[nPip,J] "Multipoles (Imaginary part)";
                  input Modelica.SIunits.Radius rBor "Borehole radius";
                  input Modelica.SIunits.Radius rPip[nPip] "Outter radius of pipes";
                  input Modelica.SIunits.Position xPip[nPip] "x-Coordinates of pipes";
                  input Modelica.SIunits.Position yPip[nPip] "y-Coordinates of pipes";
                  input Modelica.SIunits.ThermalConductivity kFil "Thermal conductivity of grouting material";
                  input Modelica.SIunits.ThermalConductivity kSoi "Thermal conductivity of soil material";

                  output Real FRea[nPip,J] "Multipole coefficients";
                  output Real FIma[nPip,J] "Multipole coefficients";

              protected
                  Complex zPip_i "Position of pipe i";
                  Complex zPip_j "Position of pipe j";
                  Complex P_nj "Multipole of order j for pipe n";
                  Real pikFil(unit="(m.K)/W")=1/(2*Modelica.Constants.pi*kFil) "Coefficient based on grout thermal conductivity";
                  Real sigma=(kFil - kSoi)/(kFil + kSoi) "Thermal conductivity ratio";
                  Complex f "Intermedia value of multipole coefficient";
                  Integer j_pend "Maximum loop index in fourth term";

                algorithm

                  for m in 1:nPip loop
                    zPip_i := Complex(xPip[m], yPip[m]);
                    for k in 1:J loop
                      f := Complex(0, 0);
                      for n in 1:nPip loop
                        zPip_j := Complex(xPip[n], yPip[n]);
                        // First term
                        if m <> n then
                          f := f + QPip_flow[n]*pikFil/k*(rPip[m]/(zPip_j - zPip_i))^k;
                        end if;
                        // Second term
                        f := f + sigma*QPip_flow[n]*pikFil/k*(rPip[m]*Modelica.ComplexMath.conj(
                          zPip_j)/(rBor^2 - zPip_i*Modelica.ComplexMath.conj(zPip_j)))^k;
                        for j in 1:J loop
                          P_nj := Complex(PRea[n, j], PIma[n, j]);
                          // Third term
                          if m <> n then
                            f := f + P_nj*IBPSA.Utilities.Math.Functions.binomial(j + k - 1, j -
                              1)*rPip[n]^j*(-rPip[m])^k/(zPip_i - zPip_j)^(j + k);
                          end if;
                          //Fourth term
                          j_pend := min(k, j);
                          for jp in 0:j_pend loop
                            f := f + sigma*Modelica.ComplexMath.conj(P_nj)*
                              IBPSA.Utilities.Math.Functions.binomial(j, jp)*
                              IBPSA.Utilities.Math.Functions.binomial(j + k - jp - 1, j - 1)*
                              rPip[n]^j*rPip[m]^k*zPip_i^(j - jp)*Modelica.ComplexMath.conj(
                              zPip_j)^(k - jp)/(rBor^2 - zPip_i*Modelica.ComplexMath.conj(
                              zPip_j))^(k + j - jp);
                          end for;
                        end for;
                      end for;
                      FRea[m, k] := Modelica.ComplexMath.real(f);
                      FIma[m, k] := Modelica.ComplexMath.imag(f);
                    end for;
                  end for;

                  annotation (Documentation(info="<html>
<p>This model evaluates the complex coefficient matrix F_mk from Claesson and Hellstrom (2011).
</p>
<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
</html>",                 revisions="<html>
<ul>
<li>
February 12, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
                end multipoleFmk;

                function multipoleThermalResistances
                  "Thermal resistances from multipole solution"
                  extends Modelica.Icons.Function;

                  input Integer nPip "Number of pipes";
                  input Integer J "Number of multipoles";
                  input Modelica.SIunits.Position xPip[nPip] "x-Coordinates of pipes";
                  input Modelica.SIunits.Position yPip[nPip] "y-Coordinates of pipes";
                  input Modelica.SIunits.Radius rBor "Borehole radius";
                  input Modelica.SIunits.Radius rPip[nPip] "Outter radius of pipes";
                  input Modelica.SIunits.ThermalConductivity kFil "Thermal conductivity of grouting material";
                  input Modelica.SIunits.ThermalConductivity kSoi "Thermal conductivity of soil material";
                  input Real RFluPip[nPip](each unit="(m.K)/W") "Fluid to pipe wall thermal resistances";
                  input Modelica.SIunits.Temperature TBor=0 "Average borehole wall temperature";

                  output Real RDelta[nPip,nPip](each unit="(m.K)/W") "Delta-circuit thermal resistances";
                  output Real R[nPip,nPip](each unit="(m.K)/W") "Internal thermal resistances";

              protected
                  Real QPip_flow[nPip](each unit="W/m") "Pipe heat transfer rates";
                  Modelica.SIunits.Temperature TFlu[nPip] "Fluid temperatures";
                  Real K[nPip,nPip](each unit="W/(m.K)") "Internal thermal conductances";

                algorithm
                  for m in 1:nPip loop
                    for n in 1:nPip loop
                      if n == m then
                        QPip_flow[n] := 1;
                      else
                        QPip_flow[n] := 0;
                      end if;
                    end for;
                    TFlu :=
                      IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.multipoleFluidTemperature(
                      nPip,
                      J,
                      xPip,
                      yPip,
                      QPip_flow,
                      TBor,
                      rBor,
                      rPip,
                      kFil,
                      kSoi,
                      RFluPip);
                    for p in 1:nPip loop
                      R[p, m] := TFlu[p];
                    end for;
                  end for;
                  K := -Modelica.Math.Matrices.inv(R);
                  for k in 1:nPip loop
                    K[k, k] := -K[k, k];
                    for j in 1:nPip loop
                      if k <> j then
                        K[k, k] := K[k, k] - K[k, j];
                      end if;
                    end for;
                  end for;
                  for q in 1:nPip loop
                    for r in 1:nPip loop
                      RDelta[q, r] := 1./K[q, r];
                    end for;
                  end for;

                  annotation (Documentation(info="<html>
<p>This model evaluates the delta-circuit borehole thermal resistances using the multipole method of Claesson and Hellstrom (2011).
</p>
<h4>References</h4>
<p>J. Claesson and G. Hellstrom. 
<i>Multipole method to calculate borehole thermal resistances in a borehole heat exchanger. 
</i>
HVAC&amp;R Research,
17(6): 895-911, 2011.</p>
</html>",                 revisions="<html>
<ul>
<li>
February 12, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
                end multipoleThermalResistances;

                partial function partialInternalResistances
                  "Partial model for borehole resistance calculation"
                  extends Modelica.Icons.Function;

                  // Geometry of the borehole
                  input Boolean use_Rb = false
                    "True if the value Rb should be used instead of calculated";
                  input Real Rb(unit="(m.K)/W") "Borehole thermal resistance";
                  input Modelica.SIunits.Height hSeg "Height of the element";
                  input Modelica.SIunits.Radius rBor "Radius of the borehole";
                  // Geometry of the pipe
                  input Modelica.SIunits.Radius rTub "Radius of the tube";
                  input Modelica.SIunits.Length eTub "Thickness of the tubes";
                  input Modelica.SIunits.Length sha
                    "Shank spacing, defined as the distance between the center of a pipe and the center of the borehole";

                  // Thermal properties
                  input Modelica.SIunits.ThermalConductivity kFil
                    "Thermal conductivity of the grout";
                  input Modelica.SIunits.ThermalConductivity kSoi
                    "Thermal conductivity of the soi";
                  input Modelica.SIunits.ThermalConductivity kTub
                    "Thermal conductivity of the tube";
                  input Modelica.SIunits.ThermalConductivity kMed
                    "Thermal conductivity of the fluid";
                  input Modelica.SIunits.DynamicViscosity muMed
                    "Dynamic viscosity of the fluid";
                  input Modelica.SIunits.SpecificHeatCapacity cpMed
                    "Specific heat capacity of the fluid";
                  input Modelica.SIunits.MassFlowRate m_flow_nominal "Nominal mass flow rate";

                  input Boolean printDebug=false
                    "Print resistances values in log for debug purposes.";

                  // Outputs
                  output Real x "Capacity location";

              protected
                  parameter Real pi = 3.141592653589793 "pi";

                  parameter Real rTub_in = rTub-eTub "Inner radius of tube";

                  Real RConv(unit="(m.K)/W")=
                    IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses.Functions.convectionResistanceCircularPipe(
                      hSeg=hSeg,
                      rTub=rTub,
                      eTub=eTub,
                      kMed=kMed,
                      muMed=muMed,
                      cpMed=cpMed,
                      m_flow=m_flow_nominal,
                      m_flow_nominal=m_flow_nominal)*hSeg;

                  Boolean test=false "thermodynamic test for R and x value";

                  Real RCondPipe(unit="(m.K)/W") =  Modelica.Math.log((rTub)/rTub_in)/(2*Modelica.Constants.pi*kTub)
                    "Thermal resistance of the pipe wall";

                  Real Rb_internal(unit="(m.K)/W")
                    "Resistance from the fluid in the pipe to the borehole wall";

                  Real Rb_multipole(unit="(m.K)/W")
                    "Theoretical Fluid-to-borehole-wall resistance evaluated from the multipole method";

                  Integer i=1 "Loop counter";

                  annotation (Diagram(graphics), Documentation(info="<html>
<p>
This partial function defines the common inputs to functions that calculate
the borehole internal resistances.
</p>
</html>",                 revisions="<html>
<ul>
<li>
July 18, 2018 by Massimo Cimmino:<br/>
Implemented multipole method.
</li>
<li>
February 14, 2014 by Michael Wetter:<br/>
Added an assert statement to test for non-physical values.
</li>
<li>
February 12, 2014, by Damien Picard:<br/>
Remove the flow dependency of the resistances, as this function calculates the conduction resistances only.
</li>
<li>
January 24, 2014, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
January 23, 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
                end partialInternalResistances;
              annotation (
              Documentation(info="<html>
<p>
This package contains functions to evaluate borehole internal resistances used by models in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes.BaseClasses</a>.
</p>
</html>"));
              end Functions;
            annotation (Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.Boreholes</a>.
</p>
</html>"));
            end BaseClasses;
          annotation (Documentation(info="<html>
<p>
This package contains models for borehole heat exchangers.
</p>
</html>"));
          end Boreholes;

          package HeatTransfer "Package with ground heat transfer models"
          extends Modelica.Icons.VariantsPackage;

            model GroundTemperatureResponse "Model calculating discrete load aggregation"
              parameter Modelica.SIunits.Time tLoaAgg(final min = Modelica.Constants.eps)=3600
                "Time resolution of load aggregation";
              parameter Integer nCel(min=1)=5 "Number of cells per aggregation level";
              parameter Boolean forceGFunCalc = false
                "Set to true to force the thermal response to be calculated at the start instead of checking whether it has been pre-computed";
              parameter IBPSA.Fluid.Geothermal.Borefields.Data.Borefield.Template borFieDat
                "Record containing all the parameters of the borefield model" annotation (
                 choicesAllMatching=true, Placement(transformation(extent={{-80,-80},{-60,-60}})));

              Modelica.Blocks.Interfaces.RealOutput delTBor(unit="K")
                "Temperature difference current borehole wall temperature minus initial borehole wall temperature"
                annotation (Placement(transformation(extent={{100,-14},{126,12}}),
                    iconTransformation(extent={{100,-10},{120,10}})));
              Modelica.Blocks.Interfaces.RealInput QBor_flow(unit="W")
                "Heat flow from all boreholes combined (positive if heat from fluid into soil)"
                annotation (Placement(transformation(extent={{-120,-10},{-100,10}}),
                    iconTransformation(extent={{-120,-10},{-100,10}})));

          protected
              constant Integer nSegMax = 1500 "Max total number of segments in g-function calculation";
              final parameter Integer nSeg = integer(if 12*borFieDat.conDat.nBor<nSegMax then 12 else floor(nSegMax/borFieDat.conDat.nBor))
                "Number of segments per borehole for g-function calculation";
              constant Integer nTimSho = 26 "Number of time steps in short time region";
              constant Integer nTimLon = 50 "Number of time steps in long time region";
              constant Real ttsMax = exp(5) "Maximum non-dimensional time for g-function calculation";
              constant Integer nTimTot = nTimSho+nTimLon
                "Total length of g-function vector";
              constant Real lvlBas = 2 "Base for exponential cell growth between levels";

              parameter String SHAgfun=
                IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.shaGFunction(
                  nBor=borFieDat.conDat.nBor,
                  cooBor=borFieDat.conDat.cooBor,
                  hBor=borFieDat.conDat.hBor,
                  dBor=borFieDat.conDat.dBor,
                  rBor=borFieDat.conDat.rBor,
                  aSoi=borFieDat.soiDat.aSoi,
                  nSeg=nSeg,
                  nTimSho=nTimSho,
                  nTimLon=nTimLon,
                  ttsMax=ttsMax) "String with encrypted g-function arguments";
              parameter Modelica.SIunits.Time timFin=
                (borFieDat.conDat.hBor^2/(9*borFieDat.soiDat.aSoi))*ttsMax
                "Final time for g-function calculation";
              parameter Integer i(min=1)=
                IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.countAggregationCells(
                  lvlBas=lvlBas,
                  nCel=nCel,
                  timFin=timFin,
                  tLoaAgg=tLoaAgg)
                  "Number of aggregation cells";
              final parameter Real[nTimTot,2] timSer(each fixed=false)
                "g-function input from matrix, with the second column as temperature Tstep";
              final parameter Modelica.SIunits.Time t_start(fixed=false) "Simulation start time";
              final parameter Modelica.SIunits.Time[i] nu(each fixed=false)
                "Time vector for load aggregation";
              final parameter Real[i] kappa(each fixed=false)
                "Weight factor for each aggregation cell";
              final parameter Real[i] rCel(each fixed=false) "Cell widths";

              discrete Modelica.SIunits.HeatFlowRate[i] QAgg_flow
                "Vector of aggregated loads";
              discrete Modelica.SIunits.HeatFlowRate[i] QAggShi_flow
                "Shifted vector of aggregated loads";
              discrete Integer curCel "Current occupied cell";

              discrete Modelica.SIunits.TemperatureDifference delTBor0
                "Previous time step's temperature difference current borehole wall temperature minus initial borehole temperature";
              discrete Real derDelTBor0(unit="K/s")
                "Derivative of wall temperature change from previous time steps";
              final parameter Real dTStepdt(fixed=false)
                "Time derivative of g/(2*pi*H*Nb*ks) within most recent cell";

              Modelica.SIunits.Heat U "Accumulated heat flow from all boreholes";
              discrete Modelica.SIunits.Heat U_old "Accumulated heat flow from all boreholes at last aggregation step";

            initial equation
              QAgg_flow = zeros(i);
              curCel = 1;
              delTBor = 0;
              QAggShi_flow = QAgg_flow;
              delTBor0 = 0;
              U = 0;
              U_old = 0;
              derDelTBor0 = 0;

              (nu,rCel) = IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.aggregationCellTimes(
                i=i,
                lvlBas=lvlBas,
                nCel=nCel,
                tLoaAgg=tLoaAgg,
                timFin=timFin);

              t_start = time;

              kappa = IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.aggregationWeightingFactors(
                i=i,
                nTimTot=nTimTot,
                TStep=timSer,
                nu=nu);

              dTStepdt = kappa[1]/tLoaAgg;

              timSer =
                IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.temperatureResponseMatrix(
                  nBor=borFieDat.conDat.nBor,
                  cooBor=borFieDat.conDat.cooBor,
                  hBor=borFieDat.conDat.hBor,
                  dBor=borFieDat.conDat.dBor,
                  rBor=borFieDat.conDat.rBor,
                  aSoi=borFieDat.soiDat.aSoi,
                  kSoi=borFieDat.soiDat.kSoi,
                  nSeg=nSeg,
                  nTimSho=nTimSho,
                  nTimLon=nTimLon,
                  nTimTot=nTimTot,
                  ttsMax=ttsMax,
                  sha=SHAgfun,
                  forceGFunCalc=forceGFunCalc);

            equation
              der(delTBor) = dTStepdt*QBor_flow + derDelTBor0;
              der(U) = QBor_flow;

              when sample(t_start, tLoaAgg) then
                // Assign average load since last aggregation step to the first cell of the
                // aggregation vector
                U_old = U;

                // Store (U - pre(U_old))/tLoaAgg in QAgg_flow[1], and pre(QAggShi_flow) in the other elements
                QAgg_flow = cat(1, {(U - pre(U_old))/tLoaAgg}, pre(QAggShi_flow[2:end]));
                // Shift loads in aggregation cells
                (curCel,QAggShi_flow) = IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.shiftAggregationCells(
                  i=i,
                  QAgg_flow=QAgg_flow,
                  rCel=rCel,
                  nu=nu,
                  curTim=(time - t_start));

                // Determine the temperature change at the next aggregation step (assuming
                // no loads until then)
                delTBor0 = IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.LoadAggregation.temporalSuperposition(
                  i=i,
                  QAgg_flow=QAggShi_flow,
                  kappa=kappa,
                  curCel=curCel);

                derDelTBor0 = (delTBor0-delTBor)/tLoaAgg;
              end when;

              annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                    Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={0,0,0},
                      fillColor={255,255,255},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-100,30},{100,-100}},
                      lineColor={0,0,0},
                      fillColor={127,127,0},
                      fillPattern=FillPattern.Solid),
                    Rectangle(
                      extent={{-52,30},{-94,-100}},
                      lineColor={0,0,0},
                      fillColor={135,135,135},
                      fillPattern=FillPattern.Solid),
                    Line(
                      points={{-66,-4},{72,-4}},
                      color={255,0,0},
                      arrow={Arrow.None,Arrow.Filled}),
                    Rectangle(
                      extent={{-100,30},{-94,-100}},
                      lineColor={0,0,0},
                      fillColor={0,128,255},
                      fillPattern=FillPattern.Solid),
                    Text(
                      extent={{-151,147},{149,107}},
                      lineColor={0,0,255},
                      fillPattern=FillPattern.HorizontalCylinder,
                      fillColor={0,127,255},
                        textString="%name")}),
              Diagram(
                    coordinateSystem(preserveAspectRatio=false)),
                    Documentation(info="<html>
<p>
This model calculates the ground temperature response to obtain the temperature
at the borehole wall in a geothermal system where heat is being injected into or
extracted from the ground.
</p>
<p>
A load-aggregation scheme based on that developed by Claesson and Javed (2012) is
used to calculate the borehole wall temperature response with the temporal superposition
of ground thermal loads. In its base form, the
load-aggregation scheme uses fixed-length aggregation cells to agglomerate
thermal load history together, with more distant cells (denoted with a higher cell and vector index)
representing more distant thermal history. The more distant the thermal load, the
less impactful it is on the borehole wall temperature change at the current time step.
Each cell has an <em>aggregation time</em> associated to it denoted by <code>nu</code>,
which corresponds to the simulation time (since the beginning of heat injection or
extraction) at which the cell will begin shifting its thermal load to more distant
cells. To determine <code>nu</code>, cells have a temporal size <i>r<sub>cel</sub></i>
(<code>rcel</code> in this model)
which follows the exponential growth
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_02.png\" />
</p>
<p>
where <i>n<sub>Cel</sub></i> is the number of consecutive cells which can have the same size.
Decreasing <i>r<sub>cel</sub></i> will generally decrease calculation times, at the cost of
precision in the temporal superposition. <code>rcel</code> is expressed in multiples
of the aggregation time resolution (via the parameter <code>tLoaAgg</code>).
Then, <code>nu</code> may be expressed as the sum of all <code>rcel</code> values
(multiplied by the aggregation time resolution) up to and including that cell in question.
</p>
<p>
To determine the weighting factors, the borefield's temperature
step response at the borefield wall is determined as
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_03.png\" />
</p>
<p>
where <i>g(&middot;)</i> is the borefield's thermal response factor known as the <em>g-function</em>,
<i>H</i> is the total length of all boreholes and <i>k<sub>s</sub></i> is the thermal
conductivity of the soil. The weighting factors <code>kappa</code> (<i>&kappa;</i> in the equation below)
for a given cell <i>i</i> are then expressed as follows.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_04.png\" />
</p>
<p>
where <i>&nu;</i> refers to the vector <code>nu</code> in this model and
<i>T<sub>step</sub>(&nu;<sub>0</sub>)</i>=0.
</p>
<p>
At every aggregation time step, a time event is generated to perform the load aggregation steps.
First, the thermal load is shifted. When shifting between cells of different size, total
energy is conserved. This operation is illustred in the figure below by Cimmino (2014).
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_01.png\" />
</p>
<p>
After the cell-shifting operation is performed, the first aggregation cell has its
value set to the average thermal load since the last aggregation step.
Temporal superposition is then applied by means
of a scalar product between the aggregated thermal loads <code>QAgg_flow</code> and the
weighting factors <i>&kappa;</i>.
</p>
<p>
Due to Modelica's variable time steps, the load aggregation scheme is modified by separating
the thermal response between the current aggregation time step and everything preceding it.
This is done according to
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_05.png\" />
<br/>
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_06.png\" />
</p>
<p>
where <i>T<sub>b</sub></i> is the borehole wall temperature,
<i>T<sub>g</sub></i>
is the undisturbed ground temperature,
<i>Q</i> is the ground thermal load per borehole length and <i>h = g/(2 &pi; k<sub>s</sub>)</i>
is a temperature response factor based on the g-function. <i>t<sub>k</sub></i>
is the last discrete aggregation time step, meaning that the current time <i>t</i>
satisfies <i>t<sub>k</sub>&le;t&le;t<sub>k+1</sub></i>.
<i>&Delta;t<sub>agg</sub>(=t<sub>k+1</sub>-t<sub>k</sub>)</i> is the
parameter <code>tLoaAgg</code> in the present model.
</p>
<p>
Thus,
<i>&Delta;T<sub>b</sub>*(t)</i>
is the borehole wall temperature change due to the thermal history prior to the current
aggregation step. At every aggregation time step, load aggregation and temporal superposition
are used to calculate its discrete value. Assuming no heat injection or extraction until
<i>t<sub>k+1</sub></i>, this term is assumed to have a linear
time derivative, which is given by the difference between <i>&Delta;T<sub>b</sub>*(t<sub>k+1</sub>)</i>
(the temperature change from load history at the next discrete aggregation time step, which
is constant over the duration of the ongoing aggregation time step) and the total
temperature change at the last aggregation time step, <i>&Delta;T<sub>b</sub>(t)</i>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_09.png\" />
</p>
<p>
The second term <i>&Delta;T<sub>b,q</sub>(t)</i> concerns the ongoing aggregation time step.
To obtain the time derivative of this term, the thermal response factor <i>h</i> is assumed
to vary linearly over the course of an aggregation time step. Therefore, because
the ongoing aggregation time step always concerns the first aggregation cell, its derivative (denoted
by the parameter <code>dTStepdt</code> in this model) can be calculated as
<code>kappa[1]</code>, the first value in the <code>kappa</code> vector,
divided by the aggregation time step <i>&Delta;t</i>.
The derivative of the temperature change at the borehole wall is then expressed
as the multiplication of <code>dTStepdt</code> (which only needs to be
calculated once at the start of the simulation) and the heat flow <i>Q</i> at
the borehole wall.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_10.png\" />
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_11.png\" />
</p>
<p>
With the two terms in the expression of <i>&Delta;T<sub>b</sub>(t)</i> expressed
as time derivatives, <i>&Delta;T<sub>b</sub>(t)</i> can itself also be
expressed as its time derivative and implemented as such directly in the Modelica
equations block with the <code>der()</code> operator.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_07.png\" />
<br/>
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/LoadAggregation_08.png\" />
</p>
<p>
This load aggregation scheme is validated in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.Validation.Analytic_20Years\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.Validation.Analytic_20Years</a>.
</p>
<h4>References</h4>
<p>
Cimmino, M. 2014. <i>D&eacute;veloppement et validation exp&eacute;rimentale de facteurs de r&eacute;ponse
thermique pour champs de puits g&eacute;othermiques</i>,
Ph.D. Thesis, &Eacute;cole Polytechnique de Montr&eacute;al.
</p>
<p>
Claesson, J. and Javed, S. 2012. <i>A load-aggregation method to calculate extraction temperatures of borehole heat exchangers</i>. ASHRAE Transactions 118(1): 530-539.
</p>
</html>",             revisions="<html>
<ul>
<li>
August 30, 2018, by Michael Wetter:<br/>
Refactored model to compute the temperature difference relative to the initial temperature,
because the model is independent of the initial temperature.
</li>
<li>
April 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
            end GroundTemperatureResponse;

            package LoadAggregation
            "Package with functions for load aggregation"
              extends Modelica.Icons.BasesPackage;

              function aggregationCellTimes
                "Function which builds the time and cell width vectors for aggregation"
                extends Modelica.Icons.Function;

                input Integer i "Size of time vector";
                input Real lvlBas "Base for growth between each level, e.g. 2";
                input Integer nCel "Number of cells of same size per level";
                input Modelica.SIunits.Time tLoaAgg(final min=Modelica.Constants.small) "Time resolution of load aggregation";
                input Modelica.SIunits.Time timFin "Total simulation max length";

                output Modelica.SIunits.Time nu[i] "Time vector nu of size i";
                output Real rCel[i](each unit="1") "Cell width vector of size i";

            protected
                Real width_j;

              algorithm
                width_j := 0;

                for j in 1:i loop
                  width_j := width_j + tLoaAgg*lvlBas^floor((j-1)/nCel);
                  nu[j] := width_j;

                  rCel[j] := lvlBas^floor((j-1)/nCel);
                end for;

                if nu[i]>timFin then
                  nu[i] := timFin;
                  rCel[i] := (nu[i]-nu[i-1])/tLoaAgg;
                end if;

                annotation (Documentation(info="<html>
<p>Simultaneously constructs both the <code>nu</code> vector, which is the
aggregation time of each cell, and the <code>rCel</code> vector, which
is the temporal size of each cell normalized with the time resolution of load
aggregation <code>tLoaAgg</code>.
</p>
</html>",               revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Added <code>min=Modelica.Constants.small</code> to <code>tLoaAgg</code>
so that a tool can infer that this quantity is non-zero.
</li>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end aggregationCellTimes;

              function aggregationWeightingFactors
                "Calculates the kappa vector for load aggregation"
                extends Modelica.Icons.Function;

                input Integer i "Size of aggregation vector";
                input Integer nTimTot "Size of g-function time table";
                input Modelica.SIunits.ThermalResistance TStep[nTimTot,2] "Time matrix with TStep";
                input Modelica.SIunits.Time nu[i] "Aggregation time vector nu";

                output Modelica.SIunits.ThermalResistance kappa[i] "Weighting factors vector";

            protected
                Modelica.SIunits.ThermalResistance prevT "Interpolated value of TStep at previous cell";
                Modelica.SIunits.ThermalResistance curT "Interpolated value of TStep at current cell";
                Integer curInt "Integer to select data interval";
                Real[size(TStep[:,1], 1)] d(each unit="K/J") "Derivatives at the support points";

              algorithm
                d := IBPSA.Utilities.Math.Functions.splineDerivatives(
                  x=TStep[:,1],
                  y=TStep[:,2],
                  ensureMonotonicity=false);

                for j in 1:i loop
                  if j==1 then
                    prevT := 0;
                  else
                    //Spline interpolation at nu[j-1]
                    for k in 1:size(TStep[:,1], 1) - 1 loop
                      if nu[j-1] > TStep[k,1] then
                        curInt := k;
                      end if;
                    end for;

                    prevT := IBPSA.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                      x=nu[j-1],
                      x1=TStep[curInt,1],
                      x2=TStep[curInt+1,1],
                      y1=TStep[curInt,2],
                      y2=TStep[curInt+1,2],
                      y1d=d[curInt],
                      y2d=d[curInt + 1]);
                  end if;

                  //Spline interpolation at nu[j]
                  for k in 1:size(TStep[:,1], 1) - 1 loop
                    if nu[j] > TStep[k,1] then
                      curInt := k;
                    end if;
                  end for;

                  curT := IBPSA.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                    x=nu[j],
                    x1=TStep[curInt,1],
                    x2=TStep[curInt+1,1],
                    y1=TStep[curInt,2],
                    y2=TStep[curInt+1,2],
                    y1d=d[curInt],
                    y2d=d[curInt + 1]);

                  kappa[j] := curT-prevT;
                end for;

                annotation (Documentation(info="<html>
<p>
This function uses spline interpolation to construct the weighting factors
vector <code>kappa</code> using the aggregation times <code>nu</code> and the
temperature step reponse (a time-series in the form of a matrix) of the
borefield as an input.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end aggregationWeightingFactors;

              function countAggregationCells
                "Function which returns the number of aggregation cells in the aggregation vector"
                extends Modelica.Icons.Function;

                input Real lvlBas "Base for growth between each level, e.g. 2";
                input Integer nCel(min=1) "Number of cells of same size per level";
                input Modelica.SIunits.Time timFin "Total simulation max length";
                input Modelica.SIunits.Time tLoaAgg "Time resolution of load aggregation";

                output Integer i(min=1) "Size of aggregation vectors";

            protected
                Modelica.SIunits.Duration width_i "Width of current aggregation cell";
                Modelica.SIunits.Time nu_i "End time of current aggregation cell";

              algorithm
                assert(timFin > 0, "Total simulation time must be bigger than 0.");
                width_i := 0;
                nu_i := 0;
                i := 0;

                while nu_i<timFin loop
                  i := i+1;
                  width_i := tLoaAgg*lvlBas^floor((i-1)/nCel);
                  nu_i := nu_i + width_i;
                end while;

              annotation (Documentation(info="<html>
<p>
Function that counts the required length of the aggregation time vector
<code>nu</code> and of the weighting factor vectors <code>kappa</code> based on
the maximum time for calculations related to the ground temperature response.
</p>
</html>",               revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Added <code>min=1</code> to <code>nCel</code>
so that a tool can infer that this quantity is non-zero.
</li>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end countAggregationCells;

              function shiftAggregationCells
                "Performs the shifting operation for load aggregation and determines the current cell"
                extends Modelica.Icons.Function;

                input Integer i "Number of aggregation cells";
                input Modelica.SIunits.HeatFlowRate QAgg_flow[i] "Vector of aggregated loads";
                input Real rCel[i](each min=Modelica.Constants.small) "Aggregation cell widths";
                input Modelica.SIunits.Time nu[i] "Cell aggregation times";
                input Modelica.SIunits.Time curTim "Current simulation time";

                output Integer curCel "Current occupied aggregation cell";
                output Modelica.SIunits.HeatFlowRate QAggShi_flow[i] "Shifted vector of aggregated loads";

              algorithm
                curCel := 1;
                for j in (i-1):-1:1 loop
                  if curTim>=nu[j+1] then
                    QAggShi_flow[j+1] := ((rCel[j+1] - 1)*QAgg_flow[j+1] + QAgg_flow[j])/rCel[j+1];
                    if j==(i-1) then
                      curCel := i;
                    end if;
                  elseif curTim>=nu[j] then
                    QAggShi_flow[j+1] := (rCel[j+1]*QAgg_flow[j+1] + QAgg_flow[j])/rCel[j+1];
                    curCel := j+1;
                  else
                    QAggShi_flow[j+1] := QAgg_flow[j+1];
                  end if;
                end for;

                QAggShi_flow[1] := 0;

                annotation (Documentation(info="<html>
<p>
Performs the shifting operation which propagates the thermal load history
towards the more distant aggregation cells, and then sets the current cell's
value at <i>0</i>. Additionally, this function also outputs the last filled load
aggregation cell.
</p>
</html>",               revisions="<html>
<ul>
<li>
July 15, 2018, by Michael Wetter:<br/>
Added <code>min=Modelica.Constants.small</code> to <code>rCel</code>
so that a tool can infer that this quantity is non-zero.
</li>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end shiftAggregationCells;

              function temperatureResponseMatrix
                "Reads and possibly writes a matrix with a time series of the borefield's temperature response"
                extends Modelica.Icons.Function;

                input Integer nBor "Number of boreholes";
                input Real cooBor[nBor, 2] "Borehole coordinates";
                input Modelica.SIunits.Height hBor "Borehole length";
                input Modelica.SIunits.Height dBor "Borehole buried depth";
                input Modelica.SIunits.Radius rBor "Borehole radius";
                input Modelica.SIunits.ThermalDiffusivity aSoi
                  "Thermal diffusivity of soil";
                input Modelica.SIunits.ThermalConductivity kSoi
                  "Thermal conductivity of soil";
                input Integer nSeg "Number of line source segments per borehole";
                input Integer nTimSho "Number of time steps in short time region";
                input Integer nTimLon "Number of time steps in long time region";
                input Integer nTimTot "Number of g-function points";
                input Real ttsMax "Maximum non-dimensional time for g-function calculation";
                input String sha "SHA-1 encryption of the g-function arguments";
                input Boolean forceGFunCalc
                  "Set to true to force the thermal response to be calculated at the start";

                output Modelica.SIunits.ThermalResistance TStep[nTimTot, 2] "Temperature step-response time series";

            protected
                String pathSave "Path of the folder used to save the g-function";
                Modelica.SIunits.Time[nTimTot] tGFun "g-function evaluation times";
                Real[nTimTot] gFun "g-function vector";
                Boolean writegFun = false "True if g-function was succesfully written to file";

              algorithm
                pathSave := "tmp/temperatureResponseMatrix/" + sha + "TStep.mat";

                if forceGFunCalc or not Modelica.Utilities.Files.exist(pathSave) then
                  (tGFun,gFun) :=
                    IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.gFunction(
                    nBor=nBor,
                    cooBor=cooBor,
                    hBor=hBor,
                    dBor=dBor,
                    rBor=rBor,
                    aSoi=aSoi,
                    nSeg=nSeg,
                    nTimSho=nTimSho,
                    nTimLon=nTimLon,
                    ttsMax=ttsMax);

                  for i in 1:nTimTot loop
                    TStep[i,1] := tGFun[i];
                    TStep[i,2] := gFun[i]/(2*Modelica.Constants.pi*hBor*nBor*kSoi);
                  end for;

                  //creation of a temporary folder in the simulation folder
                  Modelica.Utilities.Files.createDirectory("tmp");
                  Modelica.Utilities.Files.createDirectory("tmp/temperatureResponseMatrix");

                  writegFun := Modelica.Utilities.Streams.writeRealMatrix(
                    fileName=pathSave,
                    matrixName="TStep",
                    matrix=TStep,
                    append=false);
                end if;

                TStep := Modelica.Utilities.Streams.readRealMatrix(
                  fileName=pathSave,
                  matrixName="TStep",
                  nrow=nTimTot,
                  ncol=2);

                annotation (Documentation(info="<html>
<p>
This function uses the parameters required to calculate the borefield's thermal
response to build a SHA1-encrypted string unique to the borefield in question.
Then, if the <code>forceGFunCalc</code> input is <code>true</code> or if
there is no <code>.mat</code> file with the SHA1 hash as its filename in the
<code>tmp/temperatureResponseMatrix</code> folder,
the thermal response will be calculated and written as a 
<code>.mat</code> file. Otherwise, the
thermal response will simply be read from the 
<code>.mat</code> file. In the <code>.mat</code> file, the data
is saved in a matrix with the name <code>TStep</code>, where the first column is
the time (in seconds) and the second column is the temperature step response,
which is the g-function divided by <i>2 &pi; H k<sub>soi</sub></i>, with
<code>H</code> being the borehole length and <i>k<sub>soi</sub></i> being the thermal
conductivity of the soil.
</p>
</html>",               revisions="<html>
<ul>
<li>
August 27, 2018, by Michael Wetter:<br/>
Changed name of temporary directory so that it is clear for users
that this is a temporary directory.
</li>
<li>
July 15, 2018, by Michael Wetter:<br/>
Changed implementation to use matrix read and write from
the Modelica Standard Library.
</li>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end temperatureResponseMatrix;

              function temporalSuperposition
                "Performs temporal superposition for the load aggregation procedure"
                extends Modelica.Icons.Function;

                input Integer i "Number of aggregation cells";
                input Modelica.SIunits.HeatFlowRate QAgg_flow[i]
                  "Vector of aggregated loads";
                input Modelica.SIunits.ThermalResistance kappa[i]
                  "Weighting factors for each aggregation cell";
                input Integer curCel "Current occupied aggregation cell";

                output Modelica.SIunits.TemperatureDifference deltaTb "Delta T at wall";

              algorithm
                deltaTb := QAgg_flow[1:curCel]*kappa[1:curCel];

                annotation (
              Inline=true,
              Documentation(info="<html>
<p>
Performs the temporal superposition operation to obtain the temperature change
at the borehole wall at the current time step, which is the scalar product of
the aggregated load vector and the <code>kappa</code> step response vector. To
avoid unnecessary calculations, the current aggregation cell in the simulation
is used to truncate the values from the vectors that are not required.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 5, 2018, by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end temporalSuperposition;
            annotation (Documentation(info="<html>
<p>
This package contains functions for load aggregation. For further information,
consult the documentation of <a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse</a>.
</p>
</html>"));
            end LoadAggregation;

            package ThermalResponseFactors
            "Models for heat transfer outside boreholes"
            extends Modelica.Icons.BasesPackage;

              function cylindricalHeatSource
                "Cylindrical heat source solution from Carslaw and Jaeger"
                extends Modelica.Icons.Function;

                input Modelica.SIunits.Time t "Time";
                input Modelica.SIunits.ThermalDiffusivity aSoi "Ground thermal diffusivity";
                input Modelica.SIunits.Distance dis "Radial distance between borehole axes";
                input Modelica.SIunits.Radius rBor "Radius of emitting borehole";

                output Real G "Thermal response factor of borehole 1 on borehole 2";

            protected
                Real Fo = aSoi*t/rBor^2 "Fourier number";
                Real p = dis/rBor "Fourier number";

              algorithm
                G := Modelica.Math.Nonlinear.quadratureLobatto(
                    function IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource_Integrand(
                    Fo=Fo,
                    p=p),
                  a = 1e-12,
                  b = 100,
                  tolerance = 1e-6);

              annotation (
              Inline=true,
              Documentation(info="<html>
<p>
This function evaluates the cylindrical heat source solution. This solution
gives the relation between the constant heat transfer rate (per unit length)
injected by a cylindrical heat source of infinite length and the temperature
raise in the medium. The cylindrical heat source solution is defined by
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/CylindricalHeatSource_01.png\" />
</p>
<p>
where <i>&Delta;T(t,r)</i> is the temperature raise after a time <i>t</i> of
constant heat injection and at a distance <i>r</i> from the cylindrical source,
<i>Q'</i> is the heat injection rate per unit length, <i>k<sub>s</sub></i> is
the soil thermal conductivity, <i>Fo</i> is the Fourier number,
<i>aSoi<sub>s</sub></i> is the ground thermal diffusivity,
<i>r<sub>b</sub></i> is the radius of the cylindrical source and <i>G</i>
is the cylindrical heat source solution.
</p>
<p>
The cylindrical heat source solution is given by:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/CylindricalHeatSource_02.png\" />
</p>
<p>
The integral is solved numerically, with the integrand defined in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource_Integrand\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource_Integrand</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end cylindricalHeatSource;

              function cylindricalHeatSource_Integrand
                "Integrand function for cylindrical heat source evaluation"
                extends Modelica.Icons.Function;

                input Real u "Normalized integration variable";
                input Real Fo "Fourier number";
                input Real p "Ratio of distance over radius";

                output Real y "Value of integrand";

              algorithm
                y := 1.0/(u^2*Modelica.Constants.pi^2)*(exp(-u^2*Fo) - 1.0)
                  /(IBPSA.Utilities.Math.Functions.besselJ1(u)^2+IBPSA.Utilities.Math.Functions.besselY1(u)^2)
                  *(IBPSA.Utilities.Math.Functions.besselJ0(p*u)*IBPSA.Utilities.Math.Functions.besselY1(u)
                    -IBPSA.Utilities.Math.Functions.besselJ1(u)*IBPSA.Utilities.Math.Functions.besselY0(p*u));

              annotation (
              Inline=true,
              Documentation(info="<html>
<p>
Integrand of the cylindrical heat source solution for use in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end cylindricalHeatSource_Integrand;

              function finiteLineSource
                "Finite line source solution of Claesson and Javed"
                extends Modelica.Icons.Function;

                input Modelica.SIunits.Time t "Time";
                input Modelica.SIunits.ThermalDiffusivity aSoi "Ground thermal diffusivity";
                input Modelica.SIunits.Distance dis "Radial distance between borehole axes";
                input Modelica.SIunits.Height len1 "Length of emitting borehole";
                input Modelica.SIunits.Height burDep1 "Buried depth of emitting borehole";
                input Modelica.SIunits.Height len2 "Length of receiving borehole";
                input Modelica.SIunits.Height burDep2 "Buried depth of receiving borehole";
                input Boolean includeRealSource = true "True if contribution of real source is included";
                input Boolean includeMirrorSource = true "True if contribution of mirror source is included";

                output Real h_21 "Thermal response factor of borehole 1 on borehole 2";

            protected
                Real lowBou(unit="m-1") "Lower bound of integration";
                // Upper bound is infinite
                Real uppBou(unit="m-1") = max(100.0, 10.0/dis) "Upper bound of integration";
                Modelica.SIunits.Distance disMin
                  "Minimum distance between sources and receiving line";
                Modelica.SIunits.Time timTre "Time treshold for evaluation of the solution";

              algorithm

                h_21 := 0;
                if t > 0 and (includeRealSource or includeMirrorSource) then
                  // Find the minimum distance between the line source and the line where the
                  // finite line source solution is evaluated.
                  if includeRealSource then
                    if (burDep2 + len2) < burDep1 then
                      disMin := sqrt(dis^2 + (burDep1 - burDep2 - len2)^2);
                    elseif burDep2 > (burDep1 + len1) then
                      disMin := sqrt(dis^2 + (burDep1 - burDep2 + len1)^2);
                    else
                      disMin := dis;
                    end if;
                  else
                    disMin := sqrt(dis^2 + (burDep1 + burDep2)^2);
                  end if;
                  // The traveled distance of the temperature front is assumed to be:
                  // d = 5*sqrt(aSoi*t).
                  // The solution is only evaluated at times when the traveled distance is
                  // greater than the minimum distance.
                  timTre := disMin^2/(25*aSoi);

                  if t >= timTre then
                    lowBou := 1.0/sqrt(4*aSoi*t);
                    h_21 := Modelica.Math.Nonlinear.quadratureLobatto(
                      function
                        IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Integrand(
                        dis=dis,
                        len1=len1,
                        burDep1=burDep1,
                        len2=len2,
                        burDep2=burDep2,
                        includeRealSource=includeRealSource,
                        includeMirrorSource=includeMirrorSource),
                      lowBou,
                      uppBou,
                      1.0e-6);
                  else
                    // Linearize the solution at times below the time treshold.
                    lowBou := 1.0/sqrt(4*aSoi*t);
                    h_21 := Modelica.Math.Nonlinear.quadratureLobatto(
                      function
                        IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Integrand(
                        dis=dis,
                        len1=len1,
                        burDep1=burDep1,
                        len2=len2,
                        burDep2=burDep2,
                        includeRealSource=includeRealSource,
                        includeMirrorSource=includeMirrorSource),
                      lowBou,
                      uppBou,
                      1.0e-6);
              //       lowBou := 1.0/sqrt(4*aSoi*timTre);
              //       h_21 := t/timTre*Modelica.Math.Nonlinear.quadratureLobatto(
              //         function
              //           IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Integrand(
              //           dis=dis,
              //           len1=len1,
              //           burDep1=burDep1,
              //           len2=len2,
              //           burDep2=burDep2,
              //           includeRealSource=includeRealSource,
              //           includeMirrorSource=includeMirrorSource),
              //         lowBou,
              //         uppBou,
              //         1.0e-6);
                  end if;
                end if;

              annotation (
              Documentation(info="<html>
<p>
This function evaluates the finite line source solution. This solution
gives the relation between the constant heat transfer rate (per unit length)
injected by a line source of finite length <i>H<sub>1</sub></i> buried at a
distance <i>D<sub>1</sub></i> from a constant temperature surface
(<i>T=0</i>) and the average temperature raise over a line of finite length
<i>H<sub>2</sub></i> buried at a distance <i>D<sub>2</sub></i> from the constant
temperature surface.
The finite line source solution is defined by:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/FiniteLineSource_01.png\" />
</p>
<p>
where <i>&Delta;T<sub>1-2</sub>(t,r,H<sub>1</sub>,D<sub>1</sub>,H<sub>2</sub>,D<sub>2</sub>)</i>
is the temperature raise after a time <i>t</i> of constant heat injection and at
a distance <i>r</i> from the line heat source, <i>Q'</i> is the heat injection
rate per unit length, <i>k<sub>s</sub></i> is the soil thermal conductivity and
<i>h<sub>FLS</sub></i> is the finite line source solution.
</p>
<p>
The finite line source solution is given by:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/FiniteLineSource_02.png\" />
</p>
<p>
where <i>&alpha;<sub>s</sub></i> is the ground thermal diffusivity and
<i>erfint</i> is the integral of the error function, defined in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint\">IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_erfint</a>.
The integral is solved numerically, with the integrand defined in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Integrand\">IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Integrand</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 17, 2019, by Massimo Cimmino:<br/>
Modified the upper bound of integration to avoid underestimating the value of
the integral.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1107\">IBPSA, issue 1107</a>.
</li>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end finiteLineSource;

              function finiteLineSource_Erfint "Integral of the error function"
                extends
                Modelica.Math.Nonlinear.Interfaces.partialScalarFunction;

              algorithm
                y := u*Modelica.Math.Special.erf(u) - 1/sqrt(Modelica.Constants.pi)*(1 - exp(-u^2));

              annotation (
              Inline=true,
              Documentation(info="<html>
<p>
This function evaluates the integral of the error function, given by:
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/ErrorFunctionIntegral_01.png\" />
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end finiteLineSource_Erfint;

              function finiteLineSource_Integrand
                "Integrand function for finite line source evaluation"
                extends Modelica.Icons.Function;

                input Real u(unit="1/m") "Integration variable";
                input Modelica.SIunits.Distance dis "Radial distance between borehole axes";
                input Modelica.SIunits.Height len1 "Length of emitting borehole";
                input Modelica.SIunits.Height burDep1 "Buried depth of emitting borehole";
                input Modelica.SIunits.Height len2 "Length of receiving borehole";
                input Modelica.SIunits.Height burDep2 "Buried depth of receiving borehole";
                input Boolean includeRealSource = true "true if contribution of real source is included";
                input Boolean includeMirrorSource = true "true if contribution of mirror source is included";

                output Real y(unit="m") "Value of integrand";

            protected
                Real f "Intermediate variable";
              algorithm
                if includeRealSource then
                  f := sum({
                    +IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                     (burDep2 - burDep1 + len2)*u),
                    -IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                     (burDep2 - burDep1)*u),
                    +IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                     (burDep2 - burDep1 - len1)*u),
                    -IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                     (burDep2 - burDep1 + len2 - len1)*u)});
                else
                  f := 0;
                end if;
                if includeMirrorSource then
                  f := f + sum({
                    +IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                    (burDep2 + burDep1 + len2)*u),
                    -IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                    (burDep2 + burDep1)*u),
                    +IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                    (burDep2 + burDep1 + len1)*u),
                    -IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource_Erfint(
                    (burDep2 + burDep1 + len2 + len1)*u)});
                end if;

                y := 0.5/(len2*u^2)*f*exp(-dis^2*u^2);

              annotation (
              Documentation(info="<html>
<p>
Integrand of the cylindrical heat source solution for use in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
August 23, 2018 by Michael Wetter:<br/>
Reformulated function to use <code>sum</code>.
</li>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end finiteLineSource_Integrand;

              function gFunction "Evaluate the g-function of a bore field"
                extends Modelica.Icons.Function;

                input Integer nBor "Number of boreholes";
                input Modelica.SIunits.Position cooBor[nBor, 2] "Coordinates of boreholes";
                input Modelica.SIunits.Height hBor "Borehole length";
                input Modelica.SIunits.Height dBor "Borehole buried depth";
                input Modelica.SIunits.Radius rBor "Borehole radius";
                input Modelica.SIunits.ThermalDiffusivity aSoi "Ground thermal diffusivity used in g-function evaluation";
                input Integer nSeg "Number of line source segments per borehole";
                input Integer nTimSho "Number of time steps in short time region";
                input Integer nTimLon "Number of time steps in long time region";
                input Real ttsMax "Maximum adimensional time for gfunc calculation";
                input Real relTol = 0.02 "Relative tolerance on distance between boreholes";

                output Modelica.SIunits.Time tGFun[nTimSho+nTimLon] "Time of g-function evaluation";
                output Real g[nTimSho+nTimLon] "g-function";

            protected
                Modelica.SIunits.Time ts = hBor^2/(9*aSoi) "Characteristic time";
                Modelica.SIunits.Time tSho_min = 1 "Minimum time for short time calculations";
                Modelica.SIunits.Time tSho_max = 3600 "Maximum time for short time calculations";
                Modelica.SIunits.Time tLon_min = tSho_max "Minimum time for long time calculations";
                Modelica.SIunits.Time tLon_max = ts*ttsMax "Maximum time for long time calculations";
                Modelica.SIunits.Time tSho[nTimSho] "Time vector for short time calculations";
                Modelica.SIunits.Time tLon[nTimLon] "Time vector for long time calculations";
                Modelica.SIunits.Distance dis "Separation distance between boreholes";
                Modelica.SIunits.Distance dis_mn "Separation distance for comparison";
                Modelica.SIunits.Radius rLin=0.0005*hBor "Radius for evaluation of same-borehole line source solutions";
                Real hSegRea[nSeg] "Real part of the FLS solution";
                Real hSegMir[2*nSeg-1] "Mirror part of the FLS solution";
                Modelica.SIunits.Height dSeg "Buried depth of borehole segment";
                Integer Done[nBor, nBor] "Matrix for tracking of FLS evaluations";
                Real A[nSeg*nBor+1, nSeg*nBor+1] "Coefficient matrix for system of equations";
                Real B[nSeg*nBor+1] "Coefficient vector for system of equations";
                Real X[nSeg*nBor+1] "Solution vector for system of equations";
                Real FLS "Finite line source solution";
                Real ILS "Infinite line source solution";
                Real CHS "Cylindrical heat source solution";

              algorithm
                // Generate geometrically expanding time vectors
                tSho :=
                  IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.timeGeometric(
                  tSho_min,
                  tSho_max,
                  nTimSho);
                tLon :=
                  IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.timeGeometric(
                  tLon_min,
                  tLon_max,
                  nTimLon);
                // Concatenate the short- and long-term parts
                tGFun := cat(1, {0}, tSho[1:nTimSho - 1], tLon);

                // -----------------------
                // Short time calculations
                // -----------------------
                g[1] := 0.;
                for n in 1:nTimSho loop
                  // Finite line source solution
                  FLS :=
                    IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource(
                    tSho[n],
                    aSoi,
                    rLin,
                    hBor,
                    dBor,
                    hBor,
                    dBor);
                  // Infinite line source solution
                  ILS := 0.5*
                    IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.infiniteLineSource(
                    tSho[n],
                    aSoi,
                    rLin);
                  // Cylindrical heat source solution
                  CHS := 2*Modelica.Constants.pi*
                    IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource(
                    tSho[n],
                    aSoi,
                    rBor,
                    rBor);
                  // Correct finite line source solution for cylindrical geometry
                  g[n+1] := FLS + (CHS - ILS);
                end for;

                // ----------------------
                // Long time calculations
                // ----------------------
                // Initialize coefficient matrix A
                for m in 1:nBor loop
                  for l in 1:nSeg loop
                    // Tb coefficient in spatial superposition equations
                    A[(m-1)*nSeg+l,nBor*nSeg+1] := -1;
                    // Q coefficient in heat balance equation
                    A[nBor*nSeg+1,(m-1)*nSeg+l] := 1;
                  end for;
                end for;
                // Initialize coefficient vector B
                // The total heat extraction rate is constant
                B[nBor*nSeg+1] := nBor*nSeg;

                // Evaluate thermal response matrix at all times
                for k in 1:nTimLon-1 loop
                  for i in 1:nBor loop
                    for j in i:nBor loop
                      // Distance between boreholes
                      if i == j then
                        // If same borehole, distance is the radius
                        dis := rLin;
                      else
                        dis := sqrt((cooBor[i,1] - cooBor[j,1])^2 + (cooBor[i,2] - cooBor[j,2])^2);
                      end if;
                      // Only evaluate the thermal response factors if not already evaluated
                      if Done[i,j] < k then
                        // Evaluate Real and Mirror parts of FLS solution
                        // Real part
                        for u in 1:nSeg loop
                          hSegRea[u] :=
                            IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource(
                            tLon[k + 1],
                            aSoi,
                            dis,
                            hBor/nSeg,
                            dBor,
                            hBor/nSeg,
                            dBor + (u - 1)*hBor/nSeg,
                            includeMirrorSource=false);
                        end for;
                      // Mirror part
                        for v in 1:(2*nSeg-1) loop
                          hSegMir[v] :=
                            IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource(
                            tLon[k + 1],
                            aSoi,
                            dis,
                            hBor/nSeg,
                            dBor,
                            hBor/nSeg,
                            dBor + (v - 1)*hBor/nSeg,
                            includeRealSource=false);
                        end for;
                      // Apply to all pairs that have the same separation distance
                        for b in 1:nBor loop
                          for h in b:nBor loop
                            if b == h then
                              dis_mn := rLin;
                            else
                              dis_mn := sqrt((cooBor[b,1] - cooBor[h,1])^2 + (cooBor[b,2] - cooBor[h,2])^2);
                            end if;
                            if abs(dis_mn - dis) < relTol*dis then
                              // Add thermal response factor to coefficient matrix A
                              for w in 1:nSeg loop
                                for z in 1:nSeg loop
                                  A[(b-1)*nSeg+w,(h-1)*nSeg+z] := hSegRea[abs(w-z)+1] + hSegMir[w+z-1];
                                  A[(h-1)*nSeg+z,(b-1)*nSeg+w] := hSegRea[abs(w-z)+1] + hSegMir[w+z-1];
                                end for;
                              end for;
                              // Mark current pair as evaluated
                              Done[b,h] := k;
                              Done[h,b] := k;
                            end if;
                          end for;
                        end for;
                      end if;
                    end for;
                  end for;
                  // Solve the system of equations
                  X := Modelica.Math.Matrices.solve(A,B);
                  // The g-function is equal to the borehole wall temperature
                  g[nTimSho+k+1] := X[nBor*nSeg+1];
                end for;
                // Correct finite line source solution for cylindrical geometry
                for a in 2:nTimLon loop
                  // Infinite line source
                  ILS := 0.5*
                    IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.infiniteLineSource(
                    tLon[a],
                    aSoi,
                    rLin);
                  // Cylindrical heat source
                  CHS := 2*Modelica.Constants.pi*
                    IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource(
                    tLon[a],
                    aSoi,
                    rBor,
                    rBor);
                  g[nTimSho+a] := g[nTimSho+a] + (CHS - ILS);
                end for;

              annotation (
              Documentation(info="<html>
<p>
This function implements the <i>g</i>-function evaluation method introduced by
Cimmino and Bernier (see: Cimmino and Bernier (2014), and Cimmino (2018)) based
on the <i>g</i>-function function concept first introduced by Eskilson (1987).
The <i>g</i>-function gives the relation between the variation of the borehole
wall temperature at a time <i>t</i> and the heat extraction and injection rates
at all times preceding time <i>t</i> as
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/GFunction_01.png\" />
</p>
<p>
where <i>T<sub>b</sub></i> is the borehole wall temperature,
<i>T<sub>g</sub></i> is the undisturbed ground temperature, <i>Q</i> is the
heat injection rate into the ground through the borehole wall per unit borehole
length, <i>k<sub>s</sub></i> is the soil thermal conductivity and <i>g</i> is
the <i>g</i>-function.
</p>
<p>
The <i>g</i>-function is constructed from the combination of the combination of
the finite line source (FLS) solution (see
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.finiteLineSource</a>),
the cylindrical heat source (CHS) solution (see
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.cylindricalHeatSource</a>),
and the infinite line source (ILS) solution (see
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.infiniteLineSource\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.ThermalResponseFactors.infiniteLineSource</a>).
To obtain the <i>g</i>-function of a bore field, each borehole is divided into a
series of <code>nSeg</code> segments of equal length, each modeled as a line
source of finite length. The finite line source solution is superimposed in
space to obtain a system of equations that gives the relation between the heat
injection rate at each of the segments and the borehole wall temperature at each
of the segments. The system is solved to obtain the uniform borehole wall
temperature required at any time to maintain a constant total heat injection
rate (<i>Q<sub>tot</sub> = 2&pi;k<sub>s</sub>H<sub>tot</sub>)</i> into the bore
field. The uniform borehole wall temperature is then equal to the finite line
source based <i>g</i>-function.
</p>
<p>
Since this <i>g</i>-function is based on line sources of heat, rather than
cylinders, the <i>g</i>-function is corrected to consider the cylindrical
geometry. The correction factor is then the difference between the cylindrical
heat source solution and the infinite line source solution, as proposed by
Li et al. (2014) as
</p>
<p align=\"center\">
<i>g(t) = g<sub>FLS</sub> + (g<sub>CHS</sub> - g<sub>ILS</sub>)</i>
</p>
<h4>Implementation</h4>
<p>
The calculation of the <i>g</i>-function is separated into two regions: the
short-time region and the long-time region. In the short-time region,
corresponding to times <i>t</i> &lt; 1 hour, heat interaction between boreholes
and axial variations of heat injection rate are not considered. The
<i>g</i>-function is calculated using only one borehole and one segment. In the
long-time region, corresponding to times <i>t</i> &gt; 1 hour, all boreholes
are represented as series of <code>nSeg</code> line segments and the
<i>g</i>-function is evaluated as described above.
</p>
<h4>References</h4>
<p>
Cimmino, M. and Bernier, M. 2014. <i>A semi-analytical method to generate
g-functions for geothermal bore fields</i>. International Journal of Heat and
Mass Transfer 70: 641-650.
</p>
<p>
Cimmino, M. 2018. <i>Fast calculation of the g-functions of geothermal borehole
fields using similarities in the evaluation of the finite line source
solution</i>. Journal of Building Performance Simulation. DOI:
10.1080/19401493.2017.1423390.
</p>
<p>
Eskilson, P. 1987. <i>Thermal analysis of heat extraction boreholes</i>. Ph.D.
Thesis. Department of Mathematical Physics. University of Lund. Sweden.
</p>
<p>
Li, M., Li, P., Chan, V. and Lai, A.C.K. 2014. <i>Full-scale temperature
response function (G-function) for heat transfer by borehole heat exchangers
(GHEs) from sub-hour to decades</i>. Applied Energy 136: 197-205.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end gFunction;

              function infiniteLineSource
                "Infinite line source model for borehole heat exchangers"
                extends Modelica.Icons.Function;

                input Real t "Time";
                input Real aSoi "Ground thermal diffusivity";
                input Real dis "Radial distance between borehole axes";

                output Real h_ils "Thermal response factor of borehole 1 on borehole 2";

              algorithm
                h_ils := if t > 0.0 then
                            IBPSA.Utilities.Math.Functions.exponentialIntegralE1(dis^2/(4*aSoi*t))
                         else
                            0.0;
              annotation (
              Inline=true,
              Documentation(info="<html>
<p>
This function evaluates the infinite line source solution. This solution gives
the relation between the constant heat transfer rate (per unit length) injected
by a line heat source of infinite length and the temperature raise in the
medium. The infinite line source solution is defined by
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/InfiniteLineSource_01.png\" />
</p>
<p>
where <i>&Delta;T(t,r)</i> is the temperature raise after a time <i>t</i> of
constant heat injection and at a distance <i>r</i> from the line source,
<i>Q'</i> is the heat injection rate per unit length, <i>k<sub>s</sub></i> is
the soil thermal conductivity and <i>h<sub>ILS</sub></i> is the infinite line
source solution.
</p>
<p>
The infinite line source solution is given by the exponential integral
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/Geothermal/Borefields/InfiniteLineSource_02.png\" />
</p>
<p>
where <i>&alpha;<sub>s</sub></i> is the ground thermal diffusivity. The
exponential integral is implemented in
<a href=\"modelica://IBPSA.Utilities.Math.Functions.exponentialIntegralE1\">IBPSA.Utilities.Math.Functions.exponentialIntegralE1</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
March 22, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end infiniteLineSource;

              function shaGFunction
                "Returns a SHA1 encryption of the formatted arguments for the g-function generation"
                extends Modelica.Icons.Function;
                input Integer nBor "Number of boreholes";
                input Modelica.SIunits.Position cooBor[nBor, 2] "Coordinates of boreholes";
                input Modelica.SIunits.Height hBor "Borehole length";
                input Modelica.SIunits.Height dBor "Borehole buried depth";
                input Modelica.SIunits.Radius rBor "Borehole radius";
                input Modelica.SIunits.ThermalDiffusivity aSoi "Ground thermal diffusivity used in g-function evaluation";
                input Integer nSeg "Number of line source segments per borehole";
                input Integer nTimSho "Number of time steps in short time region";
                input Integer nTimLon "Number of time steps in long time region";
                input Real ttsMax "Maximum adimensional time for gfunc calculation";

                output String sha
                "SHA1 encryption of the g-function arguments";

            protected
                String formatStrGen =  "1.3e" "String format for general parameters";
                String formatStrCoo =  ".2f" "String format for coordinate";
              algorithm
                sha := IBPSA.Utilities.Cryptographics.sha(String(nBor, format=formatStrGen));
                sha := IBPSA.Utilities.Cryptographics.sha(sha + String(hBor, format=formatStrGen));
                sha := IBPSA.Utilities.Cryptographics.sha(sha + String(dBor, format=formatStrGen));
                sha := IBPSA.Utilities.Cryptographics.sha(sha + String(rBor, format=formatStrGen));
                sha := IBPSA.Utilities.Cryptographics.sha(sha + String(aSoi, format=formatStrGen));
                sha := IBPSA.Utilities.Cryptographics.sha(sha + String(nSeg, format=formatStrGen));
                sha := IBPSA.Utilities.Cryptographics.sha(sha + String(nTimSho, format=formatStrGen));
                sha := IBPSA.Utilities.Cryptographics.sha(sha + String(nTimLon, format=formatStrGen));
                sha := IBPSA.Utilities.Cryptographics.sha(sha + String(ttsMax, format=formatStrGen));
                for i in 1:nBor loop
                  sha := IBPSA.Utilities.Cryptographics.sha(sha + String(cooBor[i, 1], format=formatStrCoo));
                  sha := IBPSA.Utilities.Cryptographics.sha(sha + String(cooBor[i, 2], format=formatStrCoo));
                end for;

              annotation (
              Inline=false,
              Documentation(info="<html>
<p>
This function returns the SHA1 encryption of its arguments.
</p>
<h4>Implementation</h4>
<p>
Each argument is formatted in exponential notation
with four significant digits, for example <code>1.234e+001</code>, with no spaces or
other separating characters between each argument value.
To prevent too long strings that can cause buffer overflows,
the sha encoding of each argument is computed and added to the next string that
is parsed.
</p>
<p>
The SHA1 encryption is computed using
<a href=\"modelica://IBPSA.Utilities.Cryptographics.sha\">IBPSA.Utilities.Cryptographics.sha</a>.
</p>
</html>",               revisions="<html>
<ul>
<li>
September 11, 2018, by Michael Wetter:<br/>
Refactored implementation to avoid buffer overflow.
</li>
<li>
September 11, 2018 by Damien Picard:<br/>
Split long strings into small strings to avoid buffer overflow.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/pull/1018\">#1018</a>.
</li>
<li>
June 22, 2018 by Alex Laferri&egrave;re:<br/>
First implementation.
</li>
</ul>
</html>"));
              end shaGFunction;

              function timeGeometric "Geometric expansion of time steps"
                extends Modelica.Icons.Function;

                input Modelica.SIunits.Duration dt "Minimum time step";
                input Modelica.SIunits.Time t_max "Maximum value of time";
                input Integer nTim "Number of time values";

                output Real t[nTim] "Time vector";

            protected
                Real r(min=1.) "Expansion rate of time values";
                Real dr "Error on expansion rate evaluation";

              algorithm
                if t_max > nTim*dt then
                  // Determine expansion rate (r)
                  dr := 1e99;
                  r := 2;
                  while abs(dr) > 1e-10 loop
                    dr := (1+t_max/dt*(r-1))^(1/nTim) - r;
                    r := r + dr;
                  end while;
                  // Assign time values
                  for i in 1:nTim-1 loop
                    t[i] := dt*(1-r^i)/(1-r);
                  end for;
                    t[nTim] := t_max;

                else
                  // Number of time values too large for chosen parameters:
                  // Use a constant time step
                  for j in 1:nTim loop
                    t[j] := j*dt;
                  end for;

                end if;
              annotation (
              Documentation(info="<html>
<p>
This function attemps to build a vector of length <code>nTim</code> with a geometric
expansion of the time variable between <code>dt</code> and <code>t_max</code>.
</p>
<p>
If <code>t_max &gt; nTim*dt</code>, then a geometrically expanding vector is built as
</p>
<p align=\"center\">
<i>t = [dt, dt*(1-r<sup>2</sup>)/(1-r), ... , dt*(1-r<sup>n</sup>)/(1-r), ... , t<sub>max</sub>],</i>
</p>
<p>
where <i>r</i> is the geometric expansion factor.
</p>
<p>
If <code>t_max &lt; nTim*dt</code>, then a linearly expanding vector is built as
</p>
<p align=\"center\">
<i>t = [dt, 2*dt, ... , n*dt, ... , <code>nTim</code>*dt]</i>
</p>
</html>",               revisions="<html>
<ul>
<li>
June 28, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
              end timeGeometric;
            annotation (
            Documentation(info="<html>
<p>
This package contains functions to evaluate temperature response factors used by
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse</a>
to evaluate borehole wall temperatures.
</p>
</html>"));
            end ThermalResponseFactors;
          annotation (Documentation(info="<html>
<p>This package contains models and functions to solve ground heat transfer
around ground heat exchangers. For more information on the model implementation,
see the documentation of
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.HeatTransfer.GroundTemperatureResponse</a>.</p>
</html>"));
          end HeatTransfer;
        annotation (Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields\">IBPSA.Fluid.Geothermal.Borefields</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
Package with models for geothermal borefields.
</p>
</html>"));
      end Borefields;
    annotation (preferredView="info", Documentation(info="<html>
<p>
Package with models for geothermal heat exchange.
</p>
</html>"));
    end Geothermal;

    package HeatExchangers "Package with heat exchanger models"
      extends Modelica.Icons.VariantsPackage;

      model ConstantEffectiveness "Heat exchanger with constant effectiveness"
        extends IBPSA.Fluid.HeatExchangers.BaseClasses.PartialEffectiveness(
          sensibleOnly1 = true,
          sensibleOnly2 = true,
          final prescribedHeatFlowRate1=true,
          final prescribedHeatFlowRate2=true,
          Q1_flow = eps * QMax_flow,
          Q2_flow = -Q1_flow,
          mWat1_flow = 0,
          mWat2_flow = 0);

        parameter Modelica.SIunits.Efficiency eps(max=1) = 0.8
          "Heat exchanger effectiveness";

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-70,78},{70,-82}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid), Text(
                extent={{-56,-12},{54,-72}},
                lineColor={255,255,255},
                textString="eps=%eps")}),
                preferredView="info",
      defaultComponentName="hex",
      Documentation(info="<html>
<p>
Model for a heat exchanger with constant effectiveness.
</p>
<p>
This model transfers heat in the amount of
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q = Q<sub>max</sub> &epsilon;,
</p>
<p>
where <i>&epsilon;</i> is a constant effectiveness and
<i>Q<sub>max</sub></i> is the maximum heat that can be transferred.
</p>
<p>
For a heat and moisture exchanger, use
<a href=\"modelica://IBPSA.Fluid.MassExchangers.ConstantEffectiveness\">
IBPSA.Fluid.MassExchangers.ConstantEffectiveness</a>
instead of this model.
</p>
</html>",
      revisions="<html>
<ul>
<li>
August 13, 2013 by Michael Wetter:<br/>
Corrected error in the documentation.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Updated model to use new variable <code>mWat_flow</code>
in the base class.
</li>
<li>
January 28, 2010, by Michael Wetter:<br/>
Added regularization near zero flow.
</li>
<li>
October 2, 2009, by Michael Wetter:<br/>
Changed computation of inlet temperatures to use
<code>state_*_inflow</code> which is already known in base class.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ConstantEffectiveness;

      model DryCoilEffectivenessNTU
        "Heat exchanger with effectiveness - NTU relation and no moisture condensation"
        extends IBPSA.Fluid.HeatExchangers.BaseClasses.PartialEffectivenessNTU(
          UA = 1/(1/hA.hA_1 + 1/hA.hA_2));

        parameter Real r_nominal(
          min=0,
          max=1) = 2/3
          "Ratio between air-side and water-side convective heat transfer (hA-value) at nominal condition";

        IBPSA.Fluid.HeatExchangers.BaseClasses.HADryCoil hA(
          final r_nominal=r_nominal,
          final UA_nominal=UA_nominal,
          final m_flow_nominal_w=m1_flow_nominal,
          final m_flow_nominal_a=m2_flow_nominal,
          waterSideTemperatureDependent=false,
          airSideTemperatureDependent=false)
          "Model for convective heat transfer coefficient";

      equation
        // Convective heat transfer coefficient
        hA.m1_flow = m1_flow;
        hA.m2_flow = m2_flow;
        hA.T_1 = T_in1;
        hA.T_2 = T_in2;

        annotation (
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-70,78},{70,-82}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid)}),
          preferredView="info",
      defaultComponentName="hex",
          Documentation(info="<html>
<p>
Model of a coil without humidity condensation.
This model transfers heat in the amount of
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q&#775; = Q&#775;<sub>max</sub>  &epsilon;<br/>
  &epsilon; = f(NTU, Z, flowRegime),
</p>
<p>
where
<i>Q&#775;<sub>max</sub></i> is the maximum heat that can be transferred,
<i>&epsilon;</i> is the heat transfer effectiveness,
<i>NTU</i> is the Number of Transfer Units,
<i>Z</i> is the ratio of minimum to maximum capacity flow rate and
<i>flowRegime</i> is the heat exchanger flow regime.
such as
parallel flow, cross flow or counter flow.
</p>
<p>
The flow regimes depend on the heat exchanger configuration. All configurations
defined in
<a href=\"modelica://IBPSA.Fluid.Types.HeatExchangerConfiguration\">
IBPSA.Fluid.Types.HeatExchangerConfiguration</a>
are supported.
</p>
<p>
The convective heat transfer coefficients scale proportional to
<i>(m&#775;/m&#775;<sub>0</sub>)<sup>n</sup></i>, where
<i>m&#775;</i> is the mass flow rate,
<i>m&#775;<sub>0</sub></i> is the nominal mass flow rate, and
<i>n=0.8</i> on the air-side and <i>n=0.85</i> on the water side.
</p>
<p>
For a heat and moisture exchanger, use
<a href=\"modelica://IBPSA.Fluid.MassExchangers.ConstantEffectiveness\">
IBPSA.Fluid.MassExchangers.ConstantEffectiveness</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 25, 2018, by Michael Wetter:<br/>
Refactored model to use a common base class with
<a href=\"modelica://Buildings.Fluid.HeatExchangers.PlateHeatExchangerEffectivenessNTU\">
Buildings.Fluid.HeatExchangers.PlateHeatExchangerEffectivenessNTU</a>.
</li>
</ul>
</html>"));
      end DryCoilEffectivenessNTU;

      model EvaporatorCondenser
        "Evaporator or condenser with refrigerant experiencing constant temperature phase change"
        extends IBPSA.Fluid.Interfaces.TwoPortHeatMassExchanger(redeclare final
            IBPSA.Fluid.MixingVolumes.MixingVolume vol(final
              prescribedHeatFlowRate=false));

        parameter Modelica.SIunits.ThermalConductance UA
          "Thermal conductance of heat exchanger";
        parameter Modelica.SIunits.ThermalConductance UA_small=UA/10
          "Small thermal conductance for regularisation of heat transfer "
          annotation(Dialog(tab = "Advanced"));

        Modelica.Blocks.Interfaces.RealOutput Q_flow(unit="W")
          "Heat added to the fluid"
          annotation (Placement(transformation(extent={{100,30},{120,50}})));
        Modelica.Blocks.Interfaces.RealOutput T(unit="K") "Medium temperature"
          annotation (Placement(transformation(extent={{100,70},{120,90}})));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_ref
          "Temperature and heat flow from the refrigerant"
          annotation (Placement(transformation(extent={{-5,-55},{5,-65}}),
              iconTransformation(extent={{-5,-55},{5,-65}})));

        Modelica.SIunits.Efficiency NTU = UA /
          (IBPSA.Utilities.Math.Functions.smoothMax(abs(port_a.m_flow),m_flow_small,m_flow_small)*cp_default)
         "Number of transfer units of heat exchanger";

        Modelica.SIunits.Efficiency eps=
          IBPSA.Utilities.Math.Functions.smoothMin(
            IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(
            NTU,
            0,
            Integer(IBPSA.Fluid.Types.HeatExchangerFlowRegime.ConstantTemperaturePhaseChange)),
            0.999,
            1.0e-4)
          "Effectiveness of heat exchanger";

        Modelica.Blocks.Sources.RealExpression UAeff(
          final y=IBPSA.Utilities.Math.Functions.smoothMax(
            x1=UA,
            x2=eps*cp_default*abs(port_a.m_flow)/(1 - eps),
            deltaX=UA_small))
          "Effective heat transfer coefficient"
          annotation (Placement(transformation(extent={{-88,-80},{-68,-60}})));

    protected
        parameter Modelica.SIunits.SpecificHeatCapacity cp_default=
          Medium.specificHeatCapacityCp(sta_default)
           "Density, used to compute fluid volume";

        Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFlo
          "Heat flow sensor"
          annotation (
            Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-36,-40})));
        Modelica.Thermal.HeatTransfer.Components.Convection con
          "Convective heat transfer"
          annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-36,-70})));
        Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor senTem
          "Temperature sensor"
          annotation (Placement(transformation(extent={{0,20},{20,40}})));
      equation
        connect(heaFlo.port_b, vol.heatPort) annotation (Line(points={{-36,-30},{-36,
                -30},{-36,-10},{-9,-10}}, color={191,0,0}));
        connect(heaFlo.Q_flow, Q_flow) annotation (Line(points={{-26,-40},{-20,-40},{
                60,-40},{60,40},{110,40}}, color={0,0,127}));
        connect(port_ref, con.solid) annotation (Line(points={{0,-60},{0,-90},{-36,-90},
                {-36,-80}}, color={191,0,0}));
        connect(con.fluid, heaFlo.port_a)
          annotation (Line(points={{-36,-60},{-36,-56},{-36,-50}}, color={191,0,0}));
        connect(UAeff.y, con.Gc) annotation (Line(points={{-67,-70},{-46,-70}},
                       color={0,0,127}));
        connect(senTem.port, vol.heatPort)
          annotation (Line(points={{0,30},{-9,30},{-9,-10}}, color={191,0,0}));
        connect(senTem.T, T) annotation (Line(points={{20,30},{40,30},{40,80},{110,80}},
              color={0,0,127}));
        annotation (Icon(graphics={
              Rectangle(
                extent={{70,60},{100,58}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{72,94},{116,66}},
                lineColor={0,0,127},
                textString="Q_flow")}),
      defaultComponentName="evaCon",
      Documentation(info="<html>
<p>
Model for a constant temperature evaporator or condenser based on a &epsilon;-NTU
heat exchanger model.
</p>
<p>
The heat exchanger effectiveness is calculated from the number of transfer units
(NTU):
</p>
<p align=\"center\" style=\"font-style:italic;\">
&epsilon; = 1 - exp(UA &frasl; (m&#775; c<sub>p</sub>))
</p>
<p>
Optionally, this model can have a flow resistance.
If no flow resistance is requested, set <code>dp_nominal=0</code>.
</p>
<h4>Limitations</h4>
<p>
This model does not consider any superheating or supercooling on the refrigerant
side. The refrigerant is considered to exchange heat at a constant temperature
throughout the heat exchanger.
</p>
</html>",
      revisions="<html>
<ul>
<li>
May 27, 2017, by Filip Jorissen:<br/>
Regularised heat transfer around zero flow.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">#769</a>.
</li>
<li>
April 12, 2017, by Michael Wetter:<br/>
Corrected invalid syntax for computing the specific heat capacity.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/707\">#707</a>.
</li>
<li>
October 11, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
      end EvaporatorCondenser;

      package BaseClasses
      "Package with base classes for IBPSA.Fluid.HeatExchangers"
        extends Modelica.Icons.BasesPackage;

        model HADryCoil
          "Sensible convective heat transfer model for air to water coil"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.SIunits.ThermalConductance UA_nominal(min=0)
            "Thermal conductance at nominal flow"
                  annotation(Dialog(tab="General", group="Nominal condition"));

          parameter Modelica.SIunits.MassFlowRate m_flow_nominal_w
            "Water mass flow rate"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal_a "Air mass flow rate"
                  annotation(Dialog(tab="General", group="Nominal condition"));

          Modelica.Blocks.Interfaces.RealInput m1_flow(final unit="kg/s") "Mass flow rate medium 1"
            annotation (Placement(transformation(extent={{-120,60},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput m2_flow(final unit="kg/s") "Mass flow rate medium 2"
            annotation (Placement(transformation(extent={{-120,-80},{-100,-60}})));
          Modelica.Blocks.Interfaces.RealInput T_1(final unit="K") "Temperature medium 1"
            annotation (Placement(transformation(extent={{-120,20},{-100,40}})));
          Modelica.Blocks.Interfaces.RealInput T_2(final unit="K") "Temperature medium 2"
            annotation (Placement(transformation(extent={{-120,-40},{-100,-20}})));

          Modelica.Blocks.Interfaces.RealOutput hA_1(final unit="W/K")
            "Convective heat transfer medium 1" annotation (Placement(transformation(
                  extent={{100,60},{120,80}})));
          Modelica.Blocks.Interfaces.RealOutput hA_2(final unit="W/K")
            "Convective heat transfer medium 2" annotation (Placement(transformation(
                  extent={{100,-80},{120,-60}})));

          parameter Real r_nominal(min=0)=0.5
            "Ratio between air-side and water-side convective heat transfer coefficient"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.ThermalConductance hA_nominal_w(min=0)=UA_nominal * (r_nominal+1)/r_nominal
            "Water side convective heat transfer coefficient"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.ThermalConductance hA_nominal_a(min=0)=r_nominal * hA_nominal_w
            "Air side convective heat transfer coefficient, including fin resistance"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Real n_w(min=0, max=1)=0.85
            "Water-side exponent for convective heat transfer coefficient, h~m_flow^n";
          parameter Real n_a(min=0, max=1)=0.8
            "Air-side exponent for convective heat transfer coefficient, h~m_flow^n";
          parameter Modelica.SIunits.Temperature T0_w=
                  Modelica.SIunits.Conversions.from_degC(20) "Water temperature"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Modelica.SIunits.Temperature T0_a=
                  Modelica.SIunits.Conversions.from_degC(20) "Air temperature"
                  annotation(Dialog(tab="General", group="Nominal condition"));
          parameter Boolean waterSideFlowDependent=true
            "Set to false to make water-side hA independent of mass flow rate"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean airSideFlowDependent = true
            "Set to false to make air-side hA independent of mass flow rate"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean waterSideTemperatureDependent = true
            "Set to false to make water-side hA independent of temperature"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
          parameter Boolean airSideTemperatureDependent = true
            "Set to false to make air-side hA independent of temperature"
            annotation(Dialog(tab="Advanced", group="Modeling detail"), Evaluate=true);
      protected
          Real x_a(min=0)
            "Factor for air side temperature dependent variation of heat transfer coefficient";
          Real x_w(min=0)
            "Factor for water side temperature dependent variation of heat transfer coefficient";
          parameter Real s_w(min=0, fixed=false)
            "Coefficient for temperature dependence of water side heat transfer coefficient";
          Real fm_w "Fraction of actual to nominal mass flow rate";
          Real fm_a "Fraction of actual to nominal mass flow rate";
        initial equation
          s_w =  if waterSideTemperatureDependent then
                    0.014/(1+0.014*Modelica.SIunits.Conversions.to_degC(T0_w)) else
                      1;
        equation
          fm_w = if waterSideFlowDependent then
                      m1_flow / m_flow_nominal_w else 1;
          fm_a = if airSideFlowDependent then
                      m2_flow / m_flow_nominal_a else 1;
          x_w = if waterSideTemperatureDependent then
                 1 + s_w * (T_1-T0_w) else
                      1;
          x_a = if airSideTemperatureDependent then
                 1 + 7.8532E-4 * (T_2-T0_a) else
                      1;
          if waterSideFlowDependent then
            hA_1 = x_w * hA_nominal_w
                       * IBPSA.Utilities.Math.Functions.regNonZeroPower(fm_w, n_w, 0.1);
          else
            hA_1 = x_w * hA_nominal_w;
          end if;

          if airSideFlowDependent then
            hA_2 = x_a * hA_nominal_a
                       * IBPSA.Utilities.Math.Functions.regNonZeroPower(fm_a, n_a, 0.1);
          else
            hA_2 = x_a * hA_nominal_a;
          end if;
        annotation (Documentation(info="<html>
<p>
Model for sensible convective heat transfer coefficients for an air to water coil.
</p>
<p>
This model computes the convective heat transfer coefficient
for an air to water coil.
The parameters allow a user to enable or disable, individually
for each medium, the mass flow and/or the temperature dependence
of the convective heat transfer coefficients.
For a detailed explanation of the equation, see
the references below.
</p>
<h4>References</h4>
<ul>
<li>
Wetter Michael,
<a href=\"http://www.osti.gov/energycitations/product.biblio.jsp?osti_id=7353\">
Simulation model finned water-air-coil without condensation</a>,
LBNL-42355,
Lawrence Berkeley National Laboratory,
Berkeley, CA, 1999.
</li>
<li>
Wetter Michael,
<a href=\"http://www.osti.gov/energycitations/product.biblio.jsp?osti_id=7352\">
Simulation model air-to-air plate heat exchanger</a>,
LBNL-42354,
Lawrence Berkeley National Laboratory,
Berkeley, CA, 1999.
</li>
</ul>
</html>",
        revisions="<html>
<ul>
<li>
April 9, 2017, by Michael Wetter:<br/>
Corrected coefficient in Taylor expansion of <code>x_a</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/698\">#698</a>.
</li>
<li>
June 8, 2010, by Michael Wetter:<br/>
Fixed bug in computation of <code>s_w</code>.
The old implementation used the current inlet water temperature instead
of the design condition that corresponds to <code>UA_nominal</code>.
</li>
<li>
April 16, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={            Text(
                  extent={{-60,90},{66,0}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="hA"),
                Ellipse(
                  extent={{-32,-10},{-12,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{34,-10},{54,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{0,-10},{20,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-64,-10},{-44,-32}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-48,-40},{-28,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-16,-40},{4,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{16,-40},{36,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{50,-40},{70,-62}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-68,-66},{-48,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-36,-66},{-16,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-4,-66},{16,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{30,-66},{50,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
                      Icon(
              Rectangle(extent={{-36,-36},{-24,-72}},   style(
                  color=0,
                  fillColor=8,
                  fillPattern=8)),
              Line(points=[-12,-52; 26,-52],    style(color=42, fillColor=45)),
              Line(points=[-4,-40; -4,-68],    style(color=69, fillColor=47)),
              Line(points=[-4,-68; -10,-58],    style(color=69, fillColor=47)),
              Line(points=[-4,-68; 2,-58],      style(color=69, fillColor=47)),
              Line(points=[14,-58; 26,-52],    style(color=42, fillColor=45)),
              Line(points=[14,-46; 26,-52],    style(color=42, fillColor=45)),
              Line(points=[16,-40; 16,-68],    style(color=69, fillColor=47)),
              Line(points=[16,-68; 10,-58],     style(color=69, fillColor=47)),
              Line(points=[16,-68; 22,-58],     style(color=69, fillColor=47)),
              Rectangle(extent={{-36,66},{-24,30}},     style(
                  color=0,
                  fillColor=8,
                  fillPattern=8)),
              Line(points=[-12,50; 26,50],      style(color=42, fillColor=45)),
              Line(points=[-4,62; -4,34],      style(color=69, fillColor=47)),
              Line(points=[-4,34; -10,44],      style(color=69, fillColor=47)),
              Line(points=[-4,34; 2,44],        style(color=69, fillColor=47)),
              Line(points=[14,44; 26,50],      style(color=42, fillColor=45)),
              Line(points=[14,56; 26,50],      style(color=42, fillColor=45)),
              Line(points=[16,62; 16,34],      style(color=69, fillColor=47)),
              Line(points=[16,34; 10,44],       style(color=69, fillColor=47)),
              Line(points=[16,34; 22,44],       style(color=69, fillColor=47))));
        end HADryCoil;

        package Internal "Solve f(x, data) for x with given f"
          extends Modelica.Media.Common.OneNonLinearEquation;

          redeclare function extends f_nonlinear
          algorithm
          assert(x>0, "NTU needs to be strictly positive.
Received NTU = "         + String(x) + "
         Z   = "         + String(p));
          y := IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(
              NTU=x,
              Z=p,
              flowRegime=Integer(IBPSA.Fluid.Types.HeatExchangerFlowRegime.CrossFlowUnmixed));
          end f_nonlinear;
        annotation (
        Documentation(
        info="<html>
<p>
Function that internally solves a scalar equation.
</p>
</html>",
        revisions="<html>
<ul>
<li>
July 7, 2014, by Michael Wetter:<br/>
Changed the type of the input <code>flowRegime</code> from
<code>IBPSA.Fluid.Types.HeatExchangerFlowRegime</code>
to <code>Integer</code>.
</li>
<li>
August 10, 2011, by Michael Wetter:
<ul>
<li>
Changed implementation to use
<code>Modelica.Media.Common.OneNonLinearEquation</code> instead of
<code>Buildings.Utilities.Math.BaseClasses.OneNonLinearEquation</code>.
</li>
<li>
Added assert statement as <code>epsilon_ntuZ</code> computes <code>NTU^(-0.22)</code>.
</li>
</ul>
</li>
<li>
February 16, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Internal;

        partial model PartialEffectiveness
          "Partial model to implement heat exchangers based on effectiveness model"
          extends Fluid.Interfaces.StaticFourPortHeatMassExchanger(
            prescribedHeatFlowRate1=true,
            prescribedHeatFlowRate2=true,
            show_T=false);

          Medium1.Temperature T_in1 = if allowFlowReversal1 then
            fra_a1 * Medium1.temperature(state_a1_inflow) + fra_b1 * Medium1.temperature(state_b1_inflow) else
            Medium1.temperature(state_a1_inflow)
            "Inlet temperature medium 1";
          Medium2.Temperature T_in2 = if allowFlowReversal2 then
            fra_a2 * Medium2.temperature(state_a2_inflow) + fra_b2 * Medium2.temperature(state_b2_inflow) else
            Medium2.temperature(state_a2_inflow)
            "Inlet temperature medium 2";
          Modelica.SIunits.ThermalConductance C1_flow = abs(m1_flow)*
            ( if allowFlowReversal1 then
                   fra_a1 * Medium1.specificHeatCapacityCp(state_a1_inflow) +
                   fra_b1 * Medium1.specificHeatCapacityCp(state_b1_inflow) else
                Medium1.specificHeatCapacityCp(state_a1_inflow))
            "Heat capacity flow rate medium 1";
          Modelica.SIunits.ThermalConductance C2_flow = abs(m2_flow)*
            ( if allowFlowReversal2 then
                   fra_a2 * Medium2.specificHeatCapacityCp(state_a2_inflow) +
                   fra_b2 * Medium2.specificHeatCapacityCp(state_b2_inflow) else
                Medium2.specificHeatCapacityCp(state_a2_inflow))
            "Heat capacity flow rate medium 2";
          Modelica.SIunits.ThermalConductance CMin_flow(min=0) = min(C1_flow, C2_flow)
            "Minimum heat capacity flow rate";
          Modelica.SIunits.HeatFlowRate QMax_flow = CMin_flow*(T_in2 - T_in1)
            "Maximum heat flow rate into medium 1";
      protected
          parameter Real delta=1E-3 "Parameter used for smoothing";

          parameter Modelica.SIunits.SpecificHeatCapacity cp1_default(fixed=false)
            "Specific heat capacity of medium 1 at default medium state";
          parameter Modelica.SIunits.SpecificHeatCapacity cp2_default(fixed=false)
            "Specific heat capacity of medium 2 at default medium state";
          parameter Modelica.SIunits.ThermalConductance CMin_flow_small(fixed=false)
            "Small value for smoothing of minimum heat capacity flow rate";
          Real fra_a1(min=0, max=1) = if allowFlowReversal1
            then Modelica.Fluid.Utilities.regStep(
              m1_flow,
              1,
              0,
              m1_flow_small)
            else 1
            "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
          Real fra_b1(min=0, max=1) = if allowFlowReversal1
            then 1-fra_a1
            else 0
            "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
          Real fra_a2(min=0, max=1) = if allowFlowReversal2
            then Modelica.Fluid.Utilities.regStep(
              m2_flow,
              1,
              0,
              m2_flow_small)
            else 1
            "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
          Real fra_b2(min=0, max=1) = if allowFlowReversal2
            then 1-fra_a2
            else 0
            "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
        initial equation
          cp1_default = Medium1.specificHeatCapacityCp(Medium1.setState_pTX(
            Medium1.p_default,
            Medium1.T_default,
            Medium1.X_default));
          cp2_default = Medium2.specificHeatCapacityCp(Medium2.setState_pTX(
            Medium2.p_default,
            Medium2.T_default,
            Medium2.X_default));
          CMin_flow_small = min(m1_flow_small*cp1_default, m2_flow_small*cp2_default);

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-70,78},{70,-80}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Partial model to implement heat exchanger models.
</p>
<p>
Classes that extend this model need to implement heat and
mass balance equations in a form like
</p>
<pre>
  // transferred heat
  Q1_flow = eps * QMax_flow;
  // no heat loss to ambient
  0 = Q1_flow + Q2_flow;
  // no mass exchange
  mXi1_flow = zeros(Medium1.nXi);
  mXi2_flow = zeros(Medium2.nXi);
</pre>
<p>
Thus, if medium 1 is heated in this device, then <code>Q1_flow &gt; 0</code>
and <code>QMax_flow &gt; 0</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 21, 2019, by Filip Jorissen:<br/>
Revised implementation of all equations
such that a binding equation is used. 
I.e. we set the variable value at the variable definition
instead of using the equation section.
This allows overwriting the equation
when extending the model.<br/>
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1102\">#1102</a>.
</li>
<li>
April 30, 2018, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate1=true</code> and 
<code>prescribedHeatFlowRate2=true</code>.<br/>
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/907\">#907</a>.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Changed type of <code>T_in1</code> and <code>T_in2</code>
to <code>Medium1.Temperature</code> and <code>Medium2.Temperature</code>
to avoid an error because of conflicting start values if
<a href=\"modelica://IBPSA.Examples.ChillerPlant.BaseClasses.Controls.Examples.ChillerSetPointControl\">
Buildings.Examples.ChillerPlant.BaseClasses.Controls.Examples.ChillerSetPointControl</a>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
October 8, 2011, by Michael Wetter:<br/>
Set <code>show_T=false</code> to avoid state events near zero flow.
</li>
<li>
August 31, 2011, by Michael Wetter:<br/>
Removed unused variables <code>gai1</code> and <code>gai2</code>.
</li>
<li>
February 12, 2010, by Michael Wetter:<br/>
Changed model structure to implement effectiveness-NTU model.
</li>
<li>
January 28, 2010, by Michael Wetter:<br/>
Added regularization near zero flow.
</li>
<li>
October 2, 2009, by Michael Wetter:<br/>
Changed computation of inlet temperatures to use
<code>state_*_inflow</code> which is already known in base class.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialEffectiveness;

        model PartialEffectivenessNTU
          "Partial model for heat exchanger with effectiveness - NTU relation and no moisture condensation"
          extends IBPSA.Fluid.HeatExchangers.BaseClasses.PartialEffectiveness(
              sensibleOnly1=true,
              sensibleOnly2=true,
              Q1_flow = eps*QMax_flow,
              Q2_flow = -Q1_flow,
              mWat1_flow = 0,
              mWat2_flow = 0);
          import con = IBPSA.Fluid.Types.HeatExchangerConfiguration;
          import flo = IBPSA.Fluid.Types.HeatExchangerFlowRegime;

          parameter con configuration "Heat exchanger configuration"
            annotation (Evaluate=true);

          parameter Boolean use_Q_flow_nominal = true
            "Set to true to specify Q_flow_nominal and temperatures, or to false to specify effectiveness"
            annotation (Evaluate=true,
                        Dialog(group="Nominal thermal performance"));

          parameter Modelica.SIunits.HeatFlowRate Q_flow_nominal(fixed=use_Q_flow_nominal)
            "Nominal heat transfer"
            annotation (Dialog(group="Nominal thermal performance",
                               enable=use_Q_flow_nominal));
          parameter Modelica.SIunits.Temperature T_a1_nominal(fixed=use_Q_flow_nominal)
            "Nominal temperature at port a1"
            annotation (Dialog(group="Nominal thermal performance",
                               enable=use_Q_flow_nominal));
          parameter Modelica.SIunits.Temperature T_a2_nominal(fixed=use_Q_flow_nominal)
            "Nominal temperature at port a2"
            annotation (Dialog(group="Nominal thermal performance",
                               enable=use_Q_flow_nominal));

          parameter Real eps_nominal(fixed=not use_Q_flow_nominal)
            "Nominal heat transfer effectiveness"
            annotation (Dialog(group="Nominal thermal performance",
                               enable=not use_Q_flow_nominal));

          input Modelica.SIunits.ThermalConductance UA "UA value";

          Real eps(min=0, max=1) "Heat exchanger effectiveness";

          // NTU has been removed as NTU goes to infinity as CMin goes to zero.
          // This quantity is not good for modeling.
          //  Real NTU(min=0) "Number of transfer units";
          final parameter Modelica.SIunits.ThermalConductance UA_nominal(fixed=false)
            "Nominal UA value";
          final parameter Real NTU_nominal(min=0, fixed=false)
            "Nominal number of transfer units";

      protected
          final parameter Medium1.ThermodynamicState sta1_default = Medium1.setState_pTX(
             T=Medium1.T_default,
             p=Medium1.p_default,
             X=Medium1.X_default[1:Medium1.nXi]) "Default state for medium 1";
          final parameter Medium2.ThermodynamicState sta2_default = Medium2.setState_pTX(
             T=Medium1.T_default,
             p=Medium2.p_default,
             X=Medium2.X_default[1:Medium2.nXi]) "Default state for medium 2";

          parameter Modelica.SIunits.SpecificHeatCapacity cp1_nominal(fixed=false)
            "Specific heat capacity of medium 1 at nominal condition";
          parameter Modelica.SIunits.SpecificHeatCapacity cp2_nominal(fixed=false)
            "Specific heat capacity of medium 2 at nominal condition";
          parameter Modelica.SIunits.ThermalConductance C1_flow_nominal(fixed=false)
            "Nominal capacity flow rate of Medium 1";
          parameter Modelica.SIunits.ThermalConductance C2_flow_nominal(fixed=false)
            "Nominal capacity flow rate of Medium 2";
          parameter Modelica.SIunits.ThermalConductance CMin_flow_nominal(fixed=false)
            "Minimal capacity flow rate at nominal condition";
          parameter Modelica.SIunits.ThermalConductance CMax_flow_nominal(fixed=false)
            "Maximum capacity flow rate at nominal condition";
          parameter Real Z_nominal(
            min=0,
            max=1,
            fixed=false) "Ratio of capacity flow rate at nominal condition";
          parameter Modelica.SIunits.Temperature T_b1_nominal(fixed=false)
            "Nominal temperature at port b1";
          parameter Modelica.SIunits.Temperature T_b2_nominal(fixed=false)
            "Nominal temperature at port b2";
          parameter flo flowRegime_nominal(fixed=false)
            "Heat exchanger flow regime at nominal flow rates";
          flo flowRegime(fixed=false, start=flowRegime_nominal)
            "Heat exchanger flow regime";
        initial equation
          assert(m1_flow_nominal > 0,
            "m1_flow_nominal must be positive, m1_flow_nominal = " + String(
            m1_flow_nominal));
          assert(m2_flow_nominal > 0,
            "m2_flow_nominal must be positive, m2_flow_nominal = " + String(
            m2_flow_nominal));

          cp1_nominal = Medium1.specificHeatCapacityCp(sta1_default);
          cp2_nominal = Medium2.specificHeatCapacityCp(sta2_default);

          // Heat transferred from fluid 1 to 2 at nominal condition
          C1_flow_nominal = m1_flow_nominal*cp1_nominal;
          C2_flow_nominal = m2_flow_nominal*cp2_nominal;
          CMin_flow_nominal = min(C1_flow_nominal, C2_flow_nominal);
          CMax_flow_nominal = max(C1_flow_nominal, C2_flow_nominal);
          Z_nominal = CMin_flow_nominal/CMax_flow_nominal;
          Q_flow_nominal = m1_flow_nominal*cp1_nominal*(T_a1_nominal - T_b1_nominal);
          if use_Q_flow_nominal then
            Q_flow_nominal = -m2_flow_nominal*cp2_nominal*(T_a2_nominal - T_b2_nominal);
            eps_nominal = abs(Q_flow_nominal/((T_a1_nominal - T_a2_nominal)*
              CMin_flow_nominal));
          else
            T_a1_nominal = Medium1.T_default;
            T_a2_nominal = Medium2.T_default;
            T_b1_nominal = Medium1.T_default;
            T_b2_nominal = Medium2.T_default;
          end if;
          assert(eps_nominal > 0 and eps_nominal < 1,
            "eps_nominal out of bounds, eps_nominal = " + String(eps_nominal) +
            "\n  To achieve the required heat transfer rate at epsilon=0.8, set |T_a1_nominal-T_a2_nominal| = "
             + String(abs(Q_flow_nominal/0.8*CMin_flow_nominal)) +
            "\n  or increase flow rates. The current parameters result in " +
            "\n  CMin_flow_nominal = " + String(CMin_flow_nominal) +
            "\n  CMax_flow_nominal = " + String(CMax_flow_nominal));
          // Assign the flow regime for the given heat exchanger configuration and capacity flow rates
          if (configuration == con.CrossFlowStream1MixedStream2Unmixed) then
            flowRegime_nominal = if (C1_flow_nominal < C2_flow_nominal) then flo.CrossFlowCMinMixedCMaxUnmixed
               else flo.CrossFlowCMinUnmixedCMaxMixed;
          elseif (configuration == con.CrossFlowStream1UnmixedStream2Mixed) then
            flowRegime_nominal = if (C1_flow_nominal < C2_flow_nominal) then flo.CrossFlowCMinUnmixedCMaxMixed
               else flo.CrossFlowCMinMixedCMaxUnmixed;
          elseif (configuration == con.ParallelFlow) then
            flowRegime_nominal = flo.ParallelFlow;
          elseif (configuration == con.CounterFlow) then
            flowRegime_nominal = flo.CounterFlow;
          elseif (configuration == con.CrossFlowUnmixed) then
            flowRegime_nominal = flo.CrossFlowUnmixed;
          else
            // Invalid flow regime. Assign a value to flowRegime_nominal, and stop with an assert
            flowRegime_nominal = flo.CrossFlowUnmixed;
            assert(configuration >= con.ParallelFlow and configuration <= con.CrossFlowStream1UnmixedStream2Mixed,
              "Invalid heat exchanger configuration.");
          end if;
          // The equation sorter of Dymola 7.3 does not guarantee that the above assert is tested prior to the
          // function call on the next line. Thus, we add the test on eps_nominal to avoid an error in ntu_epsilonZ
          // for invalid input arguments
          NTU_nominal = if (eps_nominal > 0 and eps_nominal < 1) then
            IBPSA.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(
            eps=eps_nominal,
            Z=Z_nominal,
            flowRegime=Integer(flowRegime_nominal)) else 0;
          UA_nominal = NTU_nominal*CMin_flow_nominal;
        equation
          // Assign the flow regime for the given heat exchanger configuration and capacity flow rates
          if (configuration == con.ParallelFlow) then
            flowRegime = if (C1_flow*C2_flow >= 0) then flo.ParallelFlow else flo.CounterFlow;
          elseif (configuration == con.CounterFlow) then
            flowRegime = if (C1_flow*C2_flow >= 0) then flo.CounterFlow else flo.ParallelFlow;
          elseif (configuration == con.CrossFlowUnmixed) then
            flowRegime = flo.CrossFlowUnmixed;
          elseif (configuration == con.CrossFlowStream1MixedStream2Unmixed) then
            flowRegime = if (C1_flow < C2_flow) then flo.CrossFlowCMinMixedCMaxUnmixed
               else flo.CrossFlowCMinUnmixedCMaxMixed;
          else
            // have ( configuration == con.CrossFlowStream1UnmixedStream2Mixed)
            flowRegime = if (C1_flow < C2_flow) then flo.CrossFlowCMinUnmixedCMaxMixed
               else flo.CrossFlowCMinMixedCMaxUnmixed;
          end if;

          // Effectiveness
          eps = IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_C(
            UA=UA,
            C1_flow=C1_flow,
            C2_flow=C2_flow,
            flowRegime=Integer(flowRegime),
            CMin_flow_nominal=CMin_flow_nominal,
            CMax_flow_nominal=CMax_flow_nominal,
            delta=delta);

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-70,78},{70,-82}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
        defaultComponentName="hex",
            Documentation(info="<html>
<p>
Partial model of a heat exchanger without humidity condensation.
This model transfers heat in the amount of
</p>
<p align=\"center\" style=\"font-style:italic;\">
  Q = Q<sub>max</sub>  &epsilon;<br/>
  &epsilon; = f(NTU, Z, flowRegime),
</p>
<p>
where
<i>Q<sub>max</sub></i> is the maximum heat that can be transferred,
<i>&epsilon;</i> is the heat transfer effectiveness,
<i>NTU</i> is the Number of Transfer Units,
<i>Z</i> is the ratio of minimum to maximum capacity flow rate and
<i>flowRegime</i> is the heat exchanger flow regime.
such as
parallel flow, cross flow or counter flow.
</p>
<p>
The flow regimes depend on the heat exchanger configuration. All configurations
defined in
<a href=\"modelica://IBPSA.Fluid.Types.HeatExchangerConfiguration\">
IBPSA.Fluid.Types.HeatExchangerConfiguration</a>
are supported.
</p>
<p>
Models that extend from this partial model need to provide an assignment
for <code>UA</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 10, 2018 by Michael Wetter:<br/>
Removed variable <code>Z</code> that is not used.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1328\">issue 1328</a>.
</li>
<li>
January 10, 2018 by Filip Jorissen:<br/>
Corrected an error where the value of NTU was assigned to Z.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1328\">issue 1328</a>.
</li>
<li>
February 27, 2016 by Michael Wetter:<br/>
Introduced <code>sta1_default</code> and <code>sta2_default</code>
to enable translation under OpenModelica.
Removed <code>max=1</code> attribute for <code>Z</code>. This is needed as near
zero flow, <code>Z</code> can be larger than one due to the regularization.
As <code>Z</code> is not used in this model other than for reporting, this bound
need not be enforced (and the calculation of <code>eps</code> is fine at these small flow rates).
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/490\">issue 490</a>.
</li>
<li>
April 29, 2014 by Michael Wetter:<br/>
Changed <code>assert</code> statement to avoid comparing
enumeration with an integer, which triggers a warning
in Dymola 2015.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Updated model to use new variable <code>mWat_flow</code>
in the base class.
</li>
<li>
February 12, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialEffectivenessNTU;

        function epsilon_C
          "Computes heat exchanger effectiveness for given capacity flow rates and heat exchanger flow regime"
          input Modelica.SIunits.ThermalConductance UA "UA value";
          input Modelica.SIunits.ThermalConductance C1_flow
            "Enthalpy flow rate medium 1";
          input Modelica.SIunits.ThermalConductance C2_flow
            "Enthalpy flow rate medium 2";
          input Integer flowRegime
            "Heat exchanger flow regime, see  IBPSA.Fluid.Types.HeatExchangerFlowRegime";
          input Modelica.SIunits.ThermalConductance CMin_flow_nominal
            "Minimum enthalpy flow rate at nominal condition";
          input Modelica.SIunits.ThermalConductance CMax_flow_nominal
            "Maximum enthalpy flow rate at nominal condition";
          input Real delta = 1E-3 "Small value used for smoothing";
          output Real eps(min=0, max=1) "Heat exchanger effectiveness";

      protected
          Modelica.SIunits.ThermalConductance deltaCMin
            "Small number for capacity flow rate";
          Modelica.SIunits.ThermalConductance deltaCMax
            "Small number for capacity flow rate";
          Modelica.SIunits.ThermalConductance CMin_flow "Minimum capacity flow rate";
          Modelica.SIunits.ThermalConductance CMax_flow "Maximum capacity flow rate";
          Modelica.SIunits.ThermalConductance CMinNZ_flow
            "Minimum capacity flow rate, bounded away from zero";
          Modelica.SIunits.ThermalConductance CMaxNZ_flow
            "Maximum capacity flow rate, bounded away from zero";
          Real gaiEps(min=0, max=1)
            "Gain used to force UA to zero for very small flow rates";
          Real gaiNTU(min=1E-10, max=1)
            "Gain used to force NTU to a number slightly above zero for very small flow rates. Because NTU is used in NTU^-(0.22), it must not be zero.";
          Real NTU "Number of transfer units";
          Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";

        algorithm
          deltaCMin := delta*CMin_flow_nominal;
          deltaCMax := delta*CMax_flow_nominal;
          // effectiveness
          CMin_flow :=IBPSA.Utilities.Math.Functions.smoothMin(
            C1_flow,
            C2_flow,
            deltaCMin/4);
          CMax_flow :=IBPSA.Utilities.Math.Functions.smoothMax(
            C1_flow,
            C2_flow,
            deltaCMax/4);
          // CMin and CMax, constrained to be non-zero to compute eps-NTU-Z relationship
          CMinNZ_flow :=IBPSA.Utilities.Math.Functions.smoothMax(
            CMin_flow,
            deltaCMin,
            deltaCMin/4);
          CMaxNZ_flow :=IBPSA.Utilities.Math.Functions.smoothMax(
            CMax_flow,
            deltaCMax,
            deltaCMax/4);
          Z := CMin_flow/CMaxNZ_flow+1E-10*deltaCMin;
          // Gain that goes to zero as CMin_flow gets below deltaCMin
          // This is needed to allow zero flow
          gaiEps := IBPSA.Utilities.Math.Functions.spliceFunction(
                   pos=1,
                   neg=0,
                   x=CMin_flow-deltaCMin,
                   deltax=deltaCMin/2);
          gaiNTU := IBPSA.Utilities.Math.Functions.spliceFunction(
                   pos=1,
                   neg=delta,
                   x=CMin_flow-deltaCMin,
                   deltax=deltaCMin/2);

          NTU := gaiNTU*UA/CMinNZ_flow;
          eps := gaiEps*IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(
                          NTU=NTU,
                          Z=Z,
                          flowRegime=flowRegime);

          annotation (
          Inline=false,
          smoothOrder=1,
          Documentation(info="<html>
<p>
This function computes the heat exchanger effectiveness,
the Number of Transfer Units, and the capacity flow ratio
for given capacity flow rates.
</p>
<p>
The implementation allows for zero flow rate.
As <code>CMin_flow</code> crosses <code>delta*CMin_flow_nominal</code> from above,
the Number of Transfer Units and the heat exchanger effectiveness go to zero.
</p>
<p>
The different options for the flow regime are declared in
<a href=\"modelica://IBPSA.Fluid.Types.HeatExchangerFlowRegime\">
IBPSA.Fluid.Types.HeatExchangerFlowRegime</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 10, 2018, by Michael Wetter:<br/>
Removed outputs <code>Z</code> and <code>NTU</code> as they are not used by other models.
Removed <code>if</code> statement that can cause a discontinuous derivative.
</li>
<li>
July 7, 2014, by Michael Wetter:<br/>
Changed the type of the input <code>flowRegime</code> from
<code>IBPSA.Fluid.Types.HeatExchangerFlowRegime</code>
to <code>Integer</code>.
This was done to have the same argument list as
<a href=\"modelica://IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ\">
IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ</a>,
in which the type had to be changed.
</li>
<li>
July 6, 2014, by Michael Wetter:<br/>
Removed unused <code>import</code> statement.
</li>
<li>
February 20, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end epsilon_C;

        function epsilon_ntuZ
          "Computes heat exchanger effectiveness for given number of transfer units and heat exchanger flow regime"
          import f = IBPSA.Fluid.Types.HeatExchangerFlowRegime;
          input Real NTU "Number of transfer units";
          input Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";
          input Integer flowRegime
            "Heat exchanger flow regime, see  IBPSA.Fluid.Types.HeatExchangerFlowRegime";
          output Real eps(min=0, max=1) "Heat exchanger effectiveness";
      protected
          Real a "Auxiliary variable";
        algorithm
          if (flowRegime == Integer(f.ParallelFlow)) then // parallel flow
            a := 0;
            eps := (1 - Modelica.Math.exp(-NTU*(1 + Z)))/(1 + Z);
          elseif (flowRegime == Integer(f.CounterFlow)) then// counter flow
           // a is constraining Z since eps is not defined for Z=1.
            a := smooth(1, if Z < 0.97 then Z else
              IBPSA.Utilities.Math.Functions.smoothMin(
              x1=Z,
              x2=0.98,
              deltaX=0.01));
            eps := (1 - Modelica.Math.exp(-NTU*(1 - a)))/(1 - a*Modelica.Math.exp(-NTU*(
              1 - a)));
          elseif (flowRegime == Integer(f.CrossFlowUnmixed)) then
           a := NTU^(-0.22);
            eps := 1 - Modelica.Math.exp( ( Modelica.Math.exp( - NTU * Z * a)  - 1)  / (Z * a));
          elseif (flowRegime == Integer(f.CrossFlowCMinUnmixedCMaxMixed)) then
            // cross flow, (single pass), CMax mixed, CMin unmixed. (Coil with one row.)
            a := 0;
            eps := (1 - Modelica.Math.exp(-Z*(1 - Modelica.Math.exp(-NTU))))/Z;
          elseif (flowRegime == Integer(f.CrossFlowCMinMixedCMaxUnmixed)) then
            // cross flow, (single pass), CMin mixed, CMax unmixed.
            a := 0;
            eps := 1 - Modelica.Math.exp(-(1 - Modelica.Math.exp(-Z*NTU))/Z);
          elseif (flowRegime == Integer(f.ConstantTemperaturePhaseChange)) then
            // one side is experiencing constant temperature phase change
            // Z is unused
            a := 0;
            eps := 1 - Modelica.Math.exp(-NTU);
          else
            a := 0;
            eps := 0;
            assert(Integer(f.ParallelFlow) <= flowRegime and
                   flowRegime <= Integer(f.ConstantTemperaturePhaseChange),
                   "Flow regime is not implemented.");
          end if;
          annotation(preferredView="info",
                     inverse(NTU=IBPSA.Fluid.HeatExchangers.BaseClasses.ntu_epsilonZ(eps=eps, Z=Z, flowRegime=flowRegime)),
                   smoothOrder=1,
                   Documentation(info="<html>
<p>
This function computes the heat exchanger effectiveness for a given number of transfer units, capacity flow ratio and heat exchanger flow regime.
The different options for the flow regime are declared in
<a href=\"modelica://IBPSA.Fluid.Types.HeatExchangerFlowRegime\">
IBPSA.Fluid.Types.HeatExchangerFlowRegime</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 28, 2016, by Massimo Cimmino:<br/>
Added case for constant temperature phase change on one side of
the heat exchanger.
</li>
<li>
July 7, 2014, by Michael Wetter:<br/>
Changed the type of the input <code>flowRegime</code> from
<code>IBPSA.Fluid.Types.HeatExchangerFlowRegime</code>
to <code>Integer</code>.
This was required because this argument is passed in Dymola 2015 in the function
<a href=\"modelica://IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_C\">
IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_C</a>
as an integer. Without this change, a translation warning occurs.
</li>
<li>
September 25, 2013, by Michael Wetter:<br/>
Changed test in the <code>assert</code> statement as OpenModelica
had an error when comparing enumerations with integers.
</li>
<li>
February 11, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end epsilon_ntuZ;

        function ntu_epsilonZ
          "Computes number of transfer units for given heat exchanger effectiveness and heat exchanger flow regime"
          import f = IBPSA.Fluid.Types.HeatExchangerFlowRegime;
          input Real eps(min=0, max=0.999) "Heat exchanger effectiveness";
          input Real Z(min=0, max=1) "Ratio of capacity flow rate (CMin/CMax)";
          input Integer flowRegime
            "Heat exchanger flow regime";
          output Real NTU "Number of transfer units";

      protected
          Real a "Auxiliary variable";
          constant Modelica.Media.Common.OneNonLinearEquation.f_nonlinear_Data dummy
            "Dummy data for nonlinear function call";
        algorithm
          if (flowRegime == Integer(f.ParallelFlow)) then // parallel flow
            a := Z+1;
            assert(eps < 1/a,
              "Invalid input data. eps > 1/(1+Z) is physically not possible for parallel flow.
  Received eps = "         + String(eps) + "
             Z = "         + String(Z) + "
       1/(Z+1) = "         + String(1/a));
            NTU := -(Modelica.Math.log(1-eps*a))/(a);
          elseif (flowRegime == Integer(f.CounterFlow)) then// counter flow
           // a is constraining Z since eps is not defined for Z=1.
            a := smooth(1, if Z < 0.97 then Z else
              IBPSA.Utilities.Math.Functions.smoothMin(
              x1=Z,
              x2=0.98,
              deltaX=0.01));
            NTU := Modelica.Math.log((1-eps)/(1-eps*a)) / (a-1);

          elseif (flowRegime == Integer(f.CrossFlowUnmixed)) then
            a := 0;
            // The function Internal.solve evaluates epsilon_ntuZ at NTU=x_min-1e-10 and NTU=x_max+1e-10
            // when it solves iteratively epsilon_ntuZ for ntu
            // Therefore, we set x_min=1.5*1e-10 to prevent computing NTU^(-0.22)=(-1e-10)^(-0.22).
            NTU := IBPSA.Fluid.HeatExchangers.BaseClasses.Internal.solve(
              y_zero=eps,
              x_min=1.5*1e-10,
              x_max=1E6,
              pressure=Z,
              f_nonlinear_data=dummy);
          elseif (flowRegime == Integer(f.CrossFlowCMinUnmixedCMaxMixed)) then
            // cross flow, (single pass), CMax mixed, CMin unmixed. (Coil with one row.)
           a := smooth(1, if Z > 0.03 then Z else
              IBPSA.Utilities.Math.Functions.smoothMin(
              x1=0.02,
              x2=Z,
              deltaX=0.01));
            NTU := -Modelica.Math.log(1+(Modelica.Math.log(1-eps*a)/a));
          elseif (flowRegime == Integer(f.CrossFlowCMinMixedCMaxUnmixed)) then
            // cross flow, (single pass), CMin mixed, CMax unmixed.
           a := smooth(1, if Z > 0.03 then Z else
              IBPSA.Utilities.Math.Functions.smoothMin(
              x1=0.02,
              x2=Z,
              deltaX=0.01));
            NTU := -Modelica.Math.log(1+Z*Modelica.Math.log(1-eps))/Z;
          elseif (flowRegime == Integer(f.ConstantTemperaturePhaseChange)) then
            // one side is experiencing constant temperature phase change
            // Z is unused
            a := 0;
            NTU := -Modelica.Math.log((1-eps));
          else
            a := 0;
            NTU := 0;
            assert(Integer(f.ParallelFlow) <= flowRegime and
                   flowRegime <= Integer(f.ConstantTemperaturePhaseChange),
                   "Flow regime is not implemented.");
          end if;

          annotation (preferredView="info",
                     inverse(eps=IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ(NTU=NTU, Z=Z, flowRegime=flowRegime)),
                   smoothOrder=1,
        Documentation(info="<html>
<p>
This function computes the number of transfer units for a given heat exchanger effectiveness,
capacity flow ratio and heat exchanger flow regime.
The different options for the flow regime are declared in
<a href=\"modelica://IBPSA.Fluid.Types.HeatExchangerFlowRegime\">
IBPSA.Fluid.Types.HeatExchangerFlowRegime</a>.
</p>
<p>
Note that for the flow regime <code>CrossFlowUnmixed</code>, computing the
function requires the numerical solution of an equation in one variable.
This is handled internally and not exposed to the global solver.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 28, 2016, by Massimo Cimmino:<br/>
Added case for constant temperature phase change on one side of
the heat exchanger.
</li>
<li>
July 7, 2014, by Michael Wetter:<br/>
Changed the type of the input <code>flowRegime</code> from
<code>IBPSA.Fluid.Types.HeatExchangerFlowRegime</code>
to <code>Integer</code>.
This was done to have the same argument list as
<a href=\"modelica://IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ\">
IBPSA.Fluid.HeatExchangers.BaseClasses.epsilon_ntuZ</a>,
in which the type had to be changed.
</li>
<li>
April 29, 2013, by Michael Wetter:<br/>
Added dummy argument to function call of <code>Internal.solve</code>
to avoid a warning during model check in Dymola 2015.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Changed implementation to use
<code>Modelica.Media.Common.OneNonLinearEquation</code> instead of
<code>IBPSA.Utilities.Math.BaseClasses.OneNonLinearEquation</code>.
</li>
<li>
February 11, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ntu_epsilonZ;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Fluid.HeatExchangers\">IBPSA.Fluid.HeatExchangers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains models for heat exchangers with and without humidity condensation.
</html>"));
    end HeatExchangers;

    package HeatPumps "Package with models for heat pumps"
      extends Modelica.Icons.VariantsPackage;

      model ScrollWaterToWater
        "Model for a scroll water to water heat pump"
        extends IBPSA.Fluid.HeatPumps.BaseClasses.PartialWaterToWater(
          final UAEva=datHeaPum.UAEva*scaling_factor,
          final UACon=datHeaPum.UACon*scaling_factor,
          redeclare HeatPumps.Compressors.ScrollCompressor com(
            redeclare final package ref = ref,
            final volRat=datHeaPum.volRat,
            final V_flow_nominal=datHeaPum.V_flow_nominal*scaling_factor,
            final leaCoe=datHeaPum.leaCoe*scaling_factor,
            final etaEle=datHeaPum.etaEle,
            final PLos=datHeaPum.PLos*scaling_factor,
            final dTSup=datHeaPum.dTSup));

        parameter IBPSA.Fluid.HeatPumps.Data.ScrollWaterToWater.Generic datHeaPum
          "Heat pump data" annotation (choicesAllMatching=true, Placement(
              transformation(extent={{-98,78},{-78,98}})));

          annotation (Placement(transformation(extent={{100,-100},{120,-80}}),
              iconTransformation(extent={{100,-100},{120,-80}})),
                    defaultComponentName="heaPum",
          Documentation(info="<html>
<p>
Model for a water to water heat pump with a scroll compressor, as described
in Jin (2002). The thermodynamic heat pump cycle is represented below.
</p>
<p align=\"center\">
<img  alt=\"image\" src=\"modelica://IBPSA/Resources/Images/Fluid/HeatPumps/WaterToWater_Cycle.png\" border=\"1\"/>
</p>
<p>
The rate of heat transferred to the evaporator is given by:
</p>
<p align=\"center\" style=\"font-style:italic;\">
Q&#775;<sub>Eva</sub> = m&#775;<sub>ref</sub> ( h<sub>Vap</sub>(T<sub>Eva</sub>) - h<sub>Liq</sub>(T<sub>Con</sub>) ).
</p>
<p>
The power consumed by the compressor is given by a linear efficiency relation:
</p>
<p align=\"center\" style=\"font-style:italic;\">
P = P<sub>Theoretical</sub> / &eta; + P<sub>Loss,constant</sub>.
</p>
<p>
Heat transfer in the evaporator and condenser is calculated using an
&epsilon;-NTU method, assuming constant refrigerant temperature and constant heat
transfer coefficient between fluid and refrigerant.
</p>
<p>
Variable speed is achieved by multiplying the full load suction volume flow rate
by the normalized compressor speed. The power and heat transfer rates are forced
to zero if the resulting heat pump state has higher evaporating pressure than
condensing pressure.
</p>
<p>
The model parameters are obtained by calibration of the heat pump model to
manufacturer performance data. Calibrated model parameters for various heat
pumps from different manufacturers are found in
<a href=\"modelica://IBPSA.Fluid.HeatPumps.Data.ScrollWaterToWater\">
IBPSA.Fluid.HeatPumps.Data.ScrollWaterToWater</a>. The calibrated model is
located in
<a href=\"modelica://IBPSA.Fluid.HeatPumps.Calibration.ScrollWaterToWater\">
IBPSA.Fluid.HeatPumps.Calibration.ScrollWaterToWater</a>.
</p>
<h4>Options</h4>
<p>
Parameters <code>TConMax</code> and <code>TEvaMin</code>
may be used to set an upper or lower bound for the
condenser and evaporator.
The compressor is disabled when these conditions
are not satisfied, or when the
evaporator temperature is larger
than the condenser temperature.
This mimics the temperature protection
of heat pumps and moreover it avoids
non-converging algebraic loops of equations,
or freezing of evaporator medium.
This option can be disabled by setting
<code>enable_temperature_protection = false</code>.
</p>
<h4>Assumptions and limitations</h4>
<p>
The compression process is assumed isentropic. The thermal energy
of superheating is ignored in the evaluation of the heat transferred to the refrigerant
in the evaporator. There is no supercooling.
</p>
<h4>References</h4>
<p>
H. Jin.
<i>
Parameter estimation based models of water source heat pumps.
</i>
PhD Thesis. Oklahoma State University. Stillwater, Oklahoma, USA. 2012.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 30, 2017, by Filip Jorissen:<br/>
Revised documentation for temperature protection.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">#769</a>.
</li>
<li>
November 11, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ScrollWaterToWater;

      package Compressors "Package with compressor models"
        extends Modelica.Icons.VariantsPackage;

        model ScrollCompressor
          "Model for a scroll compressor, based on Jin (2002)"
          extends
          IBPSA.Fluid.HeatPumps.Compressors.BaseClasses.PartialCompressor;

          parameter Real volRat(
            min = 1.0,
            final unit = "1")
            "Built-in volume ratio";

          parameter Modelica.SIunits.VolumeFlowRate V_flow_nominal(min=0)
            "Refrigerant volume flow rate at suction at full load conditions";

          parameter Modelica.SIunits.MassFlowRate leaCoe(
            min = 0)
            "Leakage mass flow rate at a pressure ratio of 1";

          parameter Modelica.SIunits.Efficiency etaEle
            "Electro-mechanical efficiency of the compressor";

          parameter Modelica.SIunits.Power PLos(min = 0)
            "Constant part of the compressor power losses";

          parameter Modelica.SIunits.TemperatureDifference dTSup(min = 0)
            "Superheating at compressor suction";

          Modelica.SIunits.MassFlowRate m_flow
            "Refrigerant mass flow rate";

          Modelica.SIunits.MassFlowRate mLea_flow "Refrigerant leakage mass flow rate";

          Modelica.SIunits.Power PThe
            "Theoretical power consumed by the compressor";

          Modelica.SIunits.Efficiency COP(start=5)
            "Heating COP of the compressor";

      protected
          Modelica.SIunits.IsentropicExponent k(start = 1.2)
            "Isentropic exponent of the refrigerant";

          Real v_norm
            "Normalized refrigerant volume flow rate at
     suction at part load conditions";

          Real PRInt(start = 2.0)
            "Built-in pressure ratio";

        equation
          PRInt = volRat^k;

          // Limit compressor speed to the full load speed
          v_norm = IBPSA.Utilities.Math.Functions.smoothLimit(y, 0.0, 1.0, 0.001);

          if isOn then
            // Suction pressure
            pSuc = pEva;
            // Discharge pressure
            pDis = pCon;
            // Refrigerant mass flow rate
            mLea_flow = leaCoe*PR;
            m_flow = v_norm*
              IBPSA.Utilities.Math.Functions.smoothMax(
              V_flow_nominal/vSuc - mLea_flow,
              1e-5*V_flow_nominal/vSuc,
              1e-6*V_flow_nominal/vSuc);

            // Theoretical power of the compressor
            k = ref.isentropicExponentVap_Tv(TSuc, vSuc);
            // If the external pressure ratio does not match the built-in pressure ratio
            PThe = v_norm * k/(k - 1.0) * pSuc * V_flow_nominal
              * (((k - 1.0)/k) * PR/volRat + 1.0/k * PRInt^((k - 1.0)/k) - 1.0);
            // This equation reduces to the  equation for the built-in pressure ratio
            // if the external pressure ratio matches the built-in pressure ratio:
            // PThe = v_norm * k/(k - 1.0) * pSuc*v_flow * ((PRInt)^((k - 1.0)/k) - 1.0)

            // Temperature at suction of the compressor
            TSuc = port_a.T + dTSup;

            // Power consumed by the compressor
            P = (PThe/etaEle + PLos);

            // Energy balance of the compressor
             port_a.Q_flow = m_flow * (hEva - hCon);
             port_b.Q_flow = - (port_a.Q_flow + P);
             -port_b.Q_flow = P * COP;
          else
            // Heat pump is turned off
            k = 1.0;
            pSuc = pEva;
            pDis = pCon;
            mLea_flow = 0.0;
            m_flow = 0.0;
            PThe = 0.0;
            P = 0.0;
            TSuc = port_a.T;
            port_a.Q_flow = 0.0;
            port_b.Q_flow = 0.0;
            COP = 1.0;
          end if;

          annotation (    defaultComponentName="scrCom",
            Documentation(info="<html>
<p>
Model for a scroll processor, as detailed in Jin (2002). The rate of heat transferred to the evaporator is given by:
</p>
<p align=\"center\" style=\"font-style:italic;\">
Q&#775;<sub>Eva</sub> = m&#775;<sub>ref</sub> ( h<sub>Vap</sub>(T<sub>Eva</sub>) - h<sub>Liq</sub>(T<sub>Con</sub>) ).
</p>
<p>
The power consumed by the compressor is given by a linear efficiency relation:
</p>
<p align=\"center\" style=\"font-style:italic;\">
P = P<sub>Theoretical</sub> / &eta; + P<sub>Loss,constant</sub>.
</p>
<p>
Variable speed is achieved by multiplying the full load suction volume flow rate
by the normalized compressor speed. The power and heat transfer rates are forced
to zero if the resulting heat pump state has higher evaporating pressure than
condensing pressure.
</p>
<h4>Assumptions and limitations</h4>
<p>
The compression process is assumed isentropic. The thermal energy
of superheating is ignored in the evaluation of the heat transferred to the refrigerant
in the evaporator. There is no supercooling.
</p>
<h4>References</h4>
<p>
H. Jin.
<i>
Parameter estimation based models of water source heat pumps.
</i>
PhD Thesis. Oklahoma State University. Stillwater, Oklahoma, USA. 2012.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 25, 2019, by Michael Wetter:<br/>
Added start value to avoid warning in JModelica.
</li>
<li>
May 30, 2017, by Filip Jorissen:<br/>
Removed <code>pressure_error</code> as
this is replaced by
<a href=\"modelica://IBPSA.Fluid.HeatPumps.Compressors.BaseClasses.TemperatureProtection\">
IBPSA.Fluid.HeatPumps.Compressors.BaseClasses.TemperatureProtection</a>.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">#769</a>.
</li>
<li>
November 11, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ScrollCompressor;

        package BaseClasses "Package with base classes for compressors"
          extends Modelica.Icons.BasesPackage;

          partial model PartialCompressor "Partial compressor model"

            replaceable package ref = IBPSA.Media.Refrigerants.R410A
              "Refrigerant in the component"
              annotation (choicesAllMatching = true);

              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
                "Refrigerant connector a (corresponding to the evaporator)"
                annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
                "Refrigerant connector b (corresponding to the condenser)"
                annotation (Placement(transformation(extent={{110,-10},{90,10}})));

              Modelica.Blocks.Interfaces.RealInput y(final unit = "1")
               "Modulating signal for compressor frequency, equal to 1 at full load conditions"
                annotation (Placement(
                  transformation(
                    extent={{-120,70},{-100,50}},
                    rotation = -90)));

              Modelica.Blocks.Interfaces.RealOutput P(
                final quantity="Power",
                final unit="W") "Electric power consumed by compressor"
                annotation (Placement(transformation(extent={{100,50},{120,70}},
                    rotation=-90)));

            Modelica.SIunits.SpecificEnthalpy hEva
              "Specific enthalpy of saturated vapor at evaporator temperature";

            Modelica.SIunits.SpecificEnthalpy hCon
              "Specific enthalpy of saturated liquid at condenser temperature";

            Modelica.SIunits.AbsolutePressure pEva(start = 100e3)
              "Pressure of saturated vapor at evaporator temperature";

            Modelica.SIunits.AbsolutePressure pCon(start = 1000e3)
              "Pressure of saturated liquid at condenser temperature";

            Modelica.SIunits.AbsolutePressure pDis(start = 1000e3)
              "Discharge pressure of the compressor";

            Modelica.SIunits.AbsolutePressure pSuc(start = 100e3)
              "Suction pressure of the compressor";

            Modelica.SIunits.Temperature TSuc
              "Temperature at suction of the compressor";

            Boolean isOn(fixed=false)
              "State of the compressor, true if turned on";

            Modelica.SIunits.SpecificVolume vSuc(start = 1e-4, min = 0)
              "Specific volume of the refrigerant at suction of the compressor";

        protected
            Real PR(min = 0.0, unit = "1", start = 2.0)
              "Pressure ratio";

          initial equation
            pre(isOn) = if y > 0.01 then true else false;

          equation
            isOn = not pre(isOn) and y > 0.01 or pre(isOn) and y >= 0.005;

            PR = max(pDis/pSuc, 0);

            // The specific volume at suction of the compressor is calculated
            // from the Martin-Hou equation of state
            vSuc = ref.specificVolumeVap_pT(pSuc, TSuc);

            // Saturation pressure of refrigerant vapor at condenser temperature
            pCon = ref.pressureSatVap_T(port_b.T);

            // Specific enthaply of saturated liquid refrigerant at condenser temperature
            hCon = ref.enthalpySatLiq_T(port_b.T);

            // Saturation pressure of refrigerant vapor at evaporator temperature
            pEva = ref.pressureSatVap_T(port_a.T);

            // Specific enthaply of saturated refrigerant vapor at evaporator temperature
            hEva = ref.enthalpySatVap_T(port_a.T);

            // Assert statements to verify that the refrigerant temperatures are within
            // bounds of the property data in the refrigerant package
            assert(port_b.T > ref.T_min and port_b.T < ref.TCri,
              "Condensing temperature must be above the minimum refrigerant temperature
    and below the critical temperature.");
            assert(port_a.T > ref.T_min and port_a.T < ref.TCri,
              "Evaporating temperature must be above the minimum refrigerant temperature
    and below the critical temperature.");

            annotation (
            Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},
                      {100,100}}),       graphics={
                  Text(extent={{62,-82},{72,-98}},    textString="P",
                    lineColor={0,0,127}),
                  Text(extent={{62,98},{72,82}},
                    lineColor={0,0,127},
                    textString="y"),
                  Polygon(
                    points={{-70,-80},{-70,80},{70,60},{70,-60},{-70,-80}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-100,-5},{100,5}},
                    lineColor={255,0,0},
                    pattern=LinePattern.None,
                    fillColor={255,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(points={{60,-58},{60,-100}},        color={0,0,255}),
                  Line(points={{60,58},{60,100}},        color={0,0,0}),
                  Text(
                    extent={{-149,-114},{151,-154}},
                    lineColor={0,0,255},
                    textString="%name")}),
              defaultComponentName="com",
                Documentation(info="<html>
<p>
This is the base class for the compressor model.
</p>
<p>
The model evaluates the evaporating pressure of the refrigerant <i>p<sub>eva</sub></i>,
the specific enthalpy of the evaporating saturated refrigerant vapor <i>h<sub>eva</sub></i>,
the condensing pressure of the refrigerant <i>p<sub>con</sub></i>
and the specific enthalpy of the condensing saturated liquid refrigerant <i>h<sub>cond</sub></i>
at the evaporating temperature <i>T<sub>eva</sub></i> = <code>port_a.T</code>
and condensing temperature <i>T<sub>con</sub></i> = <code>port_b.T</code>.
</p>
<p>
Thermodynamic properties are evaluated from functions contained in the specified refrigerant package.
</p>
<h4>Assumptions and limitations</h4>
<p>
The model assumes isothermal condensation and evaporation, therefore
refrigerant mass flow is not accounted for and heat ports are used instead of fluid ports.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 30, 2017, by Filip Jorissen:<br/>
Removed <code>pressure_error</code> as
this is replaced by
<a href=\"modelica://IBPSA.Fluid.HeatPumps.Compressors.BaseClasses.TemperatureProtection\">
IBPSA.Fluid.HeatPumps.Compressors.BaseClasses.TemperatureProtection</a>.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">#769</a>.
</li>
<li>
May 26, 2017, by Michael Wetter and Thierry Nouidui:<br/>
Reformulated <code>isOn</code> to use the same construct as the hysteresis block,
and to work around a JModelica limitation.<br/>
This is for
<a href=\"modelica://https://github.com/lbl-srg/modelica-buildings/issues/774\">#774</a>.
</li>
<li>
April 25, 2017, by Michael Wetter:<br/>
Reformulated <code>when</code> conditions and moved common assignments
to this base class.<br/>
This is for
<a href=\"modelica://https://github.com/lbl-srg/modelica-buildings/issues/739\">#739</a>.
</li>
<li>
November 11, 2016, by Massimo Cimmino:<br/>
First implementation of this base class.
</li>
</ul>
</html>"));
          end PartialCompressor;

          model TemperatureProtection
            "Temperature protection for heat pump compressor"
            extends Modelica.Blocks.Icons.Block;
            parameter Modelica.SIunits.Temperature TConMax
              "Upper bound for condenser temperature";
            parameter Modelica.SIunits.Temperature TEvaMin
              "Lower bound for evaporator temperature";
            parameter Real dTHys(
              final unit="K",
              min=Modelica.Constants.small) = 5
              "Hysteresis interval width";
            parameter Boolean pre_y_start=false "Value of pre(y) of hysteresis at initial time";

            Modelica.Blocks.Interfaces.RealInput u "Compressor control signal"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

            Modelica.Blocks.Interfaces.RealInput TEva(
              unit="K",
              displayUnit="degC")
              "Evaporator temperature"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  origin={-120,-80})));
            Modelica.Blocks.Interfaces.RealInput TCon(
              unit="K",
              displayUnit="degC")
              "Condenser temperature" annotation (
               Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  origin={-120,80})));

            Modelica.Blocks.Interfaces.RealOutput y "Modified compressor control signal"
              annotation (Placement(transformation(extent={{100,-10},{120,10}})));

            Modelica.Blocks.Interfaces.BooleanOutput errHigPre
              "Error signal condenser upper bound temperature "
              annotation (Placement(transformation(extent={{100,40},{120,60}})));
            Modelica.Blocks.Interfaces.BooleanOutput errLowPre
              "Error signal evaporator lower bound temperature "
              annotation (Placement(transformation(extent={{100,80},{120,100}})));
            Modelica.Blocks.Interfaces.BooleanOutput errNegTemDif
              "Error signal if evaporator temperature is above condenser temperature"
              annotation (Placement(transformation(extent={{100,60},{120,80}})));
        protected
            Modelica.Blocks.Logical.Switch switch
              "Switches control signal off when conditions not satisfied"
              annotation (Placement(transformation(extent={{60,-10},{80,10}})));
            Modelica.Blocks.Logical.Hysteresis hysHig(uLow=0, uHigh=dTHys,
              final pre_y_start=pre_y_start)
              "Hysteresis for condenser upper bound temperature"
              annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
            Modelica.Blocks.Sources.Constant zero(final k=0)
              "Zero control signal when check fails"
              annotation (Placement(transformation(extent={{20,-40},{40,-20}})));
            Modelica.Blocks.Logical.Hysteresis hysLow(uLow=0, uHigh=dTHys,
              final pre_y_start=pre_y_start)
              "Hysteresis for evaporator lower bound temperature"
              annotation (Placement(transformation(extent={{-20,20},{0,40}})));
            Modelica.Blocks.Sources.Constant TMax(final k=TConMax)
              "Condenser maximum temperature"
              annotation (Placement(transformation(extent={{-92,-42},{-80,-30}})));
            Modelica.Blocks.Math.Add dTCon(k2=-1)
              "Difference between condenser temperature and its upper bound"
              annotation (Placement(transformation(extent={{-60,-20},{-40,-40}})));
            Modelica.Blocks.Math.Add dTEva(k1=-1)
              "Difference between evaporator temperature and its lower bound"
              annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
            Modelica.Blocks.Sources.Constant TMin(final k=TEvaMin)
              "Evaporator minimum temperature"
              annotation (Placement(transformation(extent={{-92,30},{-80,42}})));
            Modelica.Blocks.MathBoolean.And on(nu=3) "Compressor status"
              annotation (Placement(transformation(extent={{20,-10},{40,10}})));

            Modelica.Blocks.Logical.Hysteresis hysdTConEva(
              final uLow=0,
              final uHigh=dTHys,
              final pre_y_start=pre_y_start)
              "Hysteresis for temperature difference between evaporator and condenser"
              annotation (Placement(transformation(extent={{-20,-10},{0,10}})));
            Modelica.Blocks.Math.Add dTEvaCon(final k1=-1)
              "Difference between evaporator and condenser"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
            Modelica.Blocks.MathBoolean.Not notEva "Negation of signal"
              annotation (Placement(transformation(extent={{64,84},{76,96}})));
            Modelica.Blocks.MathBoolean.Not notdT "Negation of signal"
              annotation (Placement(transformation(extent={{64,64},{76,76}})));
            Modelica.Blocks.MathBoolean.Not notCon "Negation of signal"
              annotation (Placement(transformation(extent={{64,44},{76,56}})));
          equation
            connect(zero.y,switch. u3) annotation (Line(points={{41,-30},{50,-30},{50,-8},
                    {58,-8}},color={0,0,127}));
            connect(u, switch.u1) annotation (Line(points={{-120,0},{-96,0},{-96,60},{50,
                    60},{50,8},{58,8}}, color={0,0,127}));
            connect(switch.y, y)
              annotation (Line(points={{81,0},{110,0}},         color={0,0,127}));
            connect(TMax.y, dTCon.u1) annotation (Line(points={{-79.4,-36},{-79.4,-36},{-62,
                    -36}}, color={0,0,127}));
            connect(TMin.y, dTEva.u1) annotation (Line(points={{-79.4,36},{-62,36}},
                          color={0,0,127}));
            connect(dTEva.u2, TEva) annotation (Line(points={{-62,24},{-70,24},{-70,-80},
                    {-120,-80}},
                              color={0,0,127}));
            connect(dTCon.u2, TCon) annotation (Line(points={{-62,-24},{-76,-24},{-76,80},
                    {-120,80}},       color={0,0,127}));
            connect(dTEva.y, hysLow.u)
              annotation (Line(points={{-39,30},{-39,30},{-22,30}}, color={0,0,127}));
            connect(hysHig.u, dTCon.y)
              annotation (Line(points={{-22,-30},{-22,-30},{-39,-30}}, color={0,0,127}));
            connect(on.y, switch.u2)
              annotation (Line(points={{41.5,0},{41.5,0},{58,0}},
                                                              color={255,0,255}));
            connect(dTEvaCon.y, hysdTConEva.u)
              annotation (Line(points={{-39,0},{-32,0},{-22,0}}, color={0,0,127}));
            connect(dTEvaCon.u2, TCon) annotation (Line(points={{-62,-6},{-76,-6},{-76,80},
                    {-120,80}},             color={0,0,127}));
            connect(dTEvaCon.u1, TEva) annotation (Line(points={{-62,6},{-70,6},{-70,-80},
                    {-120,-80}},     color={0,0,127}));
            connect(hysLow.y, on.u[1]) annotation (Line(points={{1,30},{10,30},{10,4.66667},
                    {20,4.66667}},          color={255,0,255}));
            connect(hysdTConEva.y, on.u[2])
              annotation (Line(points={{1,0},{20,0}}, color={255,0,255}));
            connect(hysHig.y, on.u[3]) annotation (Line(points={{1,-30},{14,-30},{14,-4},{
                    18,-4},{18,-4.66667},{20,-4.66667}},
                                              color={255,0,255}));
            connect(hysLow.y, notEva.u) annotation (Line(points={{1,30},{10,30},{10,90},{61.6,
                    90}}, color={255,0,255}));
            connect(notEva.y, errLowPre)
              annotation (Line(points={{77.2,90},{94,90},{110,90}}, color={255,0,255}));
            connect(notdT.u, hysdTConEva.y) annotation (Line(points={{61.6,70},{12,70},{12,
                    0},{1,0}}, color={255,0,255}));
            connect(notdT.y, errNegTemDif)
              annotation (Line(points={{77.2,70},{110,70}}, color={255,0,255}));
            connect(notCon.y, errHigPre)
              annotation (Line(points={{77.2,50},{110,50},{110,50}}, color={255,0,255}));
            connect(notCon.u, hysHig.y) annotation (Line(points={{61.6,50},{14,50},{14,-30},
                    {1,-30}}, color={255,0,255}));
            annotation (    Documentation(revisions="<html>
<ul>
<li>
May 30, 2017, by Filip Jorissen:<br/>
First implementation.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">#769</a>.
</li>
</ul>
</html>", info="<html>
<p>
Temperature protection block for heat pumps.
This block overrides the heat pump control
signal when the condenser temperature is too high,
the evaporator temperature is too low,
or the temperature difference between
the condenser and evaporator is negative.
</p>
<h4>Typical use and important parameters</h4>
<p>
Temperature bounds are set using <code>TConMax</code>
and <code>TEvaMin</code>.
</p>
<h4>Options</h4>
<p>
Parameter <code>dTHys</code> may be used
to change the hysteresis interval.
</p>
</html>"));
          end TemperatureProtection;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Fluid.HeatPumps.Compressors\">
IBPSA.Fluid.HeatPumps.Compressors</a>.
</p>
</html>"));
        end BaseClasses;
        annotation (preferredView="info", Documentation(info="<html>
  <p>
  This package contains components models for compressors.
  </p>
  </html>"));
      end Compressors;

      package Data "Package with model parameters for heat pumps"
        extends Modelica.Icons.MaterialPropertiesPackage;

        package ScrollWaterToWater
        "Package with model parameters for scroll water to water heat pumps"
          extends Modelica.Icons.MaterialPropertiesPackage;

          record Generic "Record for scroll water to water heat pump"
            extends BaseClasses.HeatPumps;

            parameter Real volRat(
              min = 1.0,
              unit = "1")
              "Built-in volume ratio"
              annotation (Dialog(group="Compressor"));

            parameter Modelica.SIunits.VolumeFlowRate V_flow_nominal(min=0)
              "Refrigerant volume flow rate at suction"
              annotation (Dialog(group="Compressor"));

            parameter Modelica.SIunits.MassFlowRate leaCoe(min = 0)
              "Leakage coefficient"
              annotation (Dialog(group="Compressor"));

            annotation (
              defaultComponentPrefixes = "parameter",
              defaultComponentName="datHeaPum",
              preferredView="info",
            Documentation(info="<html>
<p>
This is the base record for scroll water to water heat pump models.
</p>
</html>", revisions="<html>
<ul>
<li>
December 6, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));

          end Generic;
        annotation (Documentation(info="<html>
<p>
Package with data for water to water heat pump models
<a href=\"modelica://IBPSA.Fluid.HeatPumps.ScrollWaterToWater\">
IBPSA.Fluid.HeatPumps.ScrollWaterToWater</a>
with scroll compressor.
</p>
</html>"));
        end ScrollWaterToWater;

        package BaseClasses "Base classes for package Data"
          extends Modelica.Icons.BasesPackage;

          partial record HeatPumps
            "Base record for calibrated heat pump models"
            extends Modelica.Icons.Record;

            parameter Modelica.SIunits.Efficiency etaEle
              "Electro-mechanical efficiency of the compressor"
              annotation (Dialog(group="Compressor"));

            parameter Modelica.SIunits.Power PLos(min = 0)
              "Constant part of the compressor power losses"
              annotation (Dialog(group="Compressor"));

            parameter Modelica.SIunits.TemperatureDifference dTSup(min = 0)
              "Superheating at compressor suction"
              annotation (Dialog(group="Evaporator"));

            parameter Modelica.SIunits.ThermalConductance UACon
              "Thermal conductance of condenser between water and refrigerant"
              annotation (Dialog(group="Condenser"));

            parameter Modelica.SIunits.ThermalConductance UAEva
              "Thermal conductance of evaporator between water and refrigerant"
              annotation (Dialog(group="Evaporator"));

            annotation (
              defaultComponentName="datHeaPum",
              preferredView="info",
            Documentation(info="<html>
<p>
This is the base record for heat pump models.
</p>
</html>", revisions="<html>
<ul>
<li>
December 6, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(graphics={
                  Text(
                    extent={{-95,53},{-12,-2}},
                    lineColor={0,0,255},
                    textString="etaEle"),
                  Text(
                    extent={{-95,-9},{-48,-48}},
                    lineColor={0,0,255},
                    textString="PLos"),
                  Text(
                    extent={{-95,-49},{-12,-104}},
                    lineColor={0,0,255},
                    textString="dTSup")}));
          end HeatPumps;
          annotation(preferredView="info",
          Documentation(info="<html>
This package contains the common parameters that are used
to specify the heat pump models in
<a href=\"IBPSA.Fluid.HeatPumps\">
IBPSA.Fluid.HeatPumps</a>.
</html>",         revisions="<html>
<ul>
<li>
December 6, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end BaseClasses;
        annotation (preferredView="info", Documentation(info="<html>
  Package with data for heat pump models.
</html>"));
      end Data;

      package BaseClasses "Package with base classes for IBPSA.Fluid.HeatPumps"
        extends Modelica.Icons.BasesPackage;

        partial model PartialWaterToWater
          "Partial model for water to water heat pumps and chillers"
          extends IBPSA.Fluid.Interfaces.PartialFourPortInterface;
          extends IBPSA.Fluid.Interfaces.FourPortFlowResistanceParameters(
            final computeFlowResistance1 = dp1_nominal > 0,
            final computeFlowResistance2 = dp2_nominal > 0);

          replaceable package ref = IBPSA.Media.Refrigerants.R410A
            "Refrigerant in the component"
            annotation (choicesAllMatching = true);

          parameter Boolean enable_variable_speed = true
            "Set to true to allow modulating of compressor speed";

          parameter Real scaling_factor = 1.0
            "Scaling factor for heat pump capacity";

          parameter Modelica.SIunits.ThermalConductance UACon
            "Thermal conductance of condenser";

          parameter Modelica.SIunits.ThermalConductance UAEva
            "Thermal conductance of evaporator";

          parameter Modelica.SIunits.Time tau1=60
            "Time constant at nominal flow rate (used if energyDynamics1 <> Modelica.Fluid.Types.Dynamics.SteadyState)"
            annotation (Dialog(tab="Dynamics", group="Condenser"));
          parameter Modelica.SIunits.Time tau2=60
            "Time constant at nominal flow rate (used if energyDynamics2 <> Modelica.Fluid.Types.Dynamics.SteadyState)"
            annotation (Dialog(tab="Dynamics", group="Evaporator"));

          parameter Modelica.SIunits.Temperature T1_start=Medium1.T_default
            "Initial or guess value of set point"
            annotation (Dialog(tab="Dynamics", group="Condenser"));
          parameter Modelica.SIunits.Temperature T2_start=Medium2.T_default
            "Initial or guess value of set point"
            annotation (Dialog(tab="Dynamics", group="Evaporator"));

          parameter Modelica.Fluid.Types.Dynamics energyDynamics=
            Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
            "Type of energy balance: dynamic (3 initialization options) or steady state"
            annotation (Dialog(tab="Dynamics", group="Evaporator and condenser"));

          parameter Boolean homotopyInitialization=true "= true, use homotopy method"
            annotation (Dialog(tab="Advanced"));
          parameter Boolean enable_temperature_protection = true
            "Enable temperature protection"
            annotation(Evaluate=true, Dialog(group="Temperature protection"));
          parameter Modelica.SIunits.Temperature TConMax = ref.TCri-5
            "Upper bound for condenser temperature"
            annotation(Dialog(enable=enable_temperature_protection, group="Temperature protection"));
          parameter Modelica.SIunits.Temperature TEvaMin = 275.15
            "Lower bound for evaporator temperature"
            annotation(Dialog(enable=enable_temperature_protection, group="Temperature protection"));
          parameter Real dTHys(unit="K",min=0) = 5
            "Hysteresis interval width"
            annotation(Dialog(enable=enable_temperature_protection, group="Temperature protection"));

          Modelica.Blocks.Interfaces.BooleanOutput errLowPre if enable_temperature_protection
            "if true, compressor disabled since evaporator temperature is above upper bound";
          Modelica.Blocks.Interfaces.BooleanOutput errHigPre if enable_temperature_protection
            "if true, compressor disabled since condenser temperature is below lower bound";
          Modelica.Blocks.Interfaces.BooleanOutput errNegTemDif if enable_temperature_protection
            "if true, compressor disabled since condenser temperature is below evaporator temperature";

          Modelica.Blocks.Interfaces.RealInput y(final unit = "1") if
            enable_variable_speed == true
            "Modulating signal for compressor frequency, equal to 1 at full load condition"
            annotation (Placement(transformation(extent={{-140,10},{-100,50}})));

          Modelica.Blocks.Interfaces.IntegerInput stage if
            enable_variable_speed == false
            "Current stage of the heat pump, equal to 1 at full load condition"
            annotation (Placement(transformation(extent={{-140,10},{-100,50}})));

          Modelica.Blocks.Interfaces.RealOutput QCon_flow(
            min = 0,
            final quantity="HeatFlowRate",
            final unit="W") "Actual heating heat flow rate added to fluid 1"
            annotation (Placement(transformation(extent={{100,80},{120,100}}),
                iconTransformation(extent={{100,80},{120,100}})));

          Modelica.Blocks.Interfaces.RealOutput P(
            min = 0,
            final quantity="Power",
            final unit="W") "Electric power consumed by compressor"
            annotation (Placement(transformation(extent={{100,-10},{120,10}}),
                iconTransformation(extent={{100,-10},{120,10}})));

          Modelica.Blocks.Interfaces.RealOutput QEva_flow(
            max = 0,
            final quantity="HeatFlowRate",
            final unit="W") "Actual cooling heat flow rate removed from fluid 2"
            annotation (Placement(transformation(extent={{100,-100},{120,-80}}),
                iconTransformation(extent={{100,-100},{120,-80}})));

          IBPSA.Fluid.HeatExchangers.EvaporatorCondenser con(
            redeclare final package Medium = Medium1,
            final allowFlowReversal=allowFlowReversal1,
            final m_flow_nominal=m1_flow_nominal,
            final m_flow_small=m1_flow_small,
            m_flow(start=m1_flow_nominal),
            final from_dp=from_dp1,
            final dp_nominal=dp1_nominal,
            final linearizeFlowResistance=linearizeFlowResistance1,
            final deltaM=deltaM1,
            final tau=tau1,
            final T_start=T1_start,
            final energyDynamics=energyDynamics,
            final homotopyInitialization=homotopyInitialization,
            final UA=UACon) "Condenser"
            annotation (Placement(transformation(extent={{40,50},{60,70}})));

          IBPSA.Fluid.HeatExchangers.EvaporatorCondenser eva(
            redeclare final package Medium = Medium2,
            final allowFlowReversal=allowFlowReversal2,
            final m_flow_nominal=m2_flow_nominal,
            final m_flow_small=m2_flow_small,
            m_flow(start=m2_flow_nominal),
            final from_dp=from_dp2,
            final dp_nominal=dp2_nominal,
            final linearizeFlowResistance=linearizeFlowResistance2,
            final deltaM=deltaM2,
            final tau=tau2,
            final T_start=T2_start,
            final energyDynamics=energyDynamics,
            final homotopyInitialization=homotopyInitialization,
            final UA=UAEva) "Evaporator"
            annotation (Placement(transformation(extent={{60,-50},{40,-70}})));

          replaceable IBPSA.Fluid.HeatPumps.Compressors.BaseClasses.PartialCompressor com
            "Compressor" annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,-6})));

      protected
          Modelica.Blocks.Math.IntegerToReal intToRea if
            enable_variable_speed == false "Conversion for stage signal"
            annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));

          Modelica.Blocks.Nonlinear.Limiter lim(final uMin=0, final uMax=1) if
            enable_variable_speed == false "Limiter for control signal"
            annotation (Placement(transformation(extent={{-50,-40},{-30,-20}})));

          Compressors.BaseClasses.TemperatureProtection temPro(
            final TConMax=TConMax,
            final TEvaMin=TEvaMin,
            final dTHys=dTHys) if enable_temperature_protection
            "Disables compressor when outside of allowed operation range"
            annotation (Placement(transformation(extent={{0,-10},{20,10}})));

        equation
          if enable_temperature_protection then
            connect(errLowPre, temPro.errLowPre);
            connect(errHigPre, temPro.errHigPre);
            connect(errNegTemDif, temPro.errNegTemDif);
          end if;
          connect(port_a1, con.port_a)
            annotation (Line(points={{-100,60},{40,60}},  color={0,127,255}));
          connect(con.port_b, port_b1)
            annotation (Line(points={{60,60},{60,60},{100,60}}, color={0,127,255}));
          connect(con.Q_flow, QCon_flow) annotation (Line(points={{61,64},{60,64},{60,90},
                  {110,90}}, color={0,0,127}));
          connect(eva.port_a, port_a2)
            annotation (Line(points={{60,-60},{100,-60}}, color={0,127,255}));
          connect(eva.port_b, port_b2)
            annotation (Line(points={{40,-60},{-100,-60}},  color={0,127,255}));
          connect(eva.Q_flow, QEva_flow) annotation (Line(points={{39,-64},{34,-64},{34,
                  -90},{110,-90}}, color={0,0,127}));
          connect(com.port_b, con.port_ref)
            annotation (Line(points={{50,4},{50,29},{50,54}},
                                                           color={191,0,0}));
          connect(com.port_a, eva.port_ref) annotation (Line(points={{50,-16},{50,-16},{
                  50,-54}},         color={191,0,0}));
          connect(com.P, P)
            annotation (Line(points={{61,0},{110,0}},         color={0,0,127}));
          if enable_variable_speed then
            if enable_temperature_protection then
              connect(y,temPro.u)
                annotation (Line(points={{-120,30},{-90,30},{-90,0},{-2,0}},
                color={0,0,127}));
            else
              connect(y,com.y)
                annotation (Line(points={{-120,30},{32,30},{32,14},{32,3.9968e-15},{36,
                      3.9968e-15},{39,3.9968e-15}},
                color={0,0,127}));
            end if;
          else
            if enable_temperature_protection then
              connect(lim.y, temPro.u)
                annotation (Line(points={{-29,-30},{-20,-30},{-20,0},{-2,0}},
                                                                       color={0,0,127}));
            else
              connect(lim.y, com.y)
                annotation (Line(points={{-29,-30},{32,-30},{32,0},{39,0},{39,0}},
                                                                       color={0,0,127}));
            end if;
          end if;
          connect(stage, intToRea.u) annotation (Line(points={{-120,30},{-120,30},{-90,30},
                  {-90,-16},{-90,-30},{-82,-30}}, color={255,127,0}));
          connect(intToRea.y, lim.u)
            annotation (Line(points={{-59,-30},{-52,-30}}, color={0,0,127}));
          connect(temPro.y, com.y)
            annotation (Line(points={{21,0},{39,0}},          color={0,0,127}));
          connect(temPro.TCon, con.T) annotation (Line(points={{-2,8},{-2,8},{-20,8},{
                  -20,76},{70,76},{70,68},{61,68}},
                                    color={0,0,127}));
          connect(temPro.TEva, eva.T)
            annotation (Line(points={{-2,-8},{-2,-8},{-12,-8},{-12,-68},{39,-68}},
                                                                    color={0,0,127}));
          annotation (
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},
                    {100,100}}),       graphics={
                Rectangle(
                  extent={{-70,80},{70,-80}},
                  lineColor={0,0,0},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Rectangle(
                  extent={{-56,68},{58,50}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-56,-52},{58,-70}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-103,64},{98,54}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-2,54},{98,64}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-101,-56},{100,-66}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-100,-66},{0,-56}},
                  lineColor={0,0,127},
                  pattern=LinePattern.None,
                  fillColor={0,0,127},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-42,0},{-52,-12},{-32,-12},{-42,0}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Polygon(
                  points={{-42,0},{-52,10},{-32,10},{-42,0}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Rectangle(
                  extent={{-44,50},{-40,10}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-44,-12},{-40,-52}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{38,50},{42,-52}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{18,22},{62,-20}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Polygon(
                  points={{40,22},{22,-10},{58,-10},{40,22}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{0,68},{0,90},{90,90},{100,90}},
                                                         color={0,0,255}),
                Line(points={{0,-70},{0,-90},{100,-90}}, color={0,0,255}),
                Line(points={{62,0},{100,0}},                 color={0,0,255})}),
            defaultComponentName="heaPum",
            Documentation(info="<html>
<p>
Partial model for a water to water heat pump, as detailed in Jin (2002). The
model for the compressor is a partial model and needs to be replaced by one of the
compressor models in
<a href = \"modelica://IBPSA.Fluid.HeatPumps.Compressors\">
IBPSA.Fluid.HeatPumps.Compressors</a>.
</p>
<h4>References</h4>
<p>
H. Jin.
<i>
Parameter estimation based models of water source heat pumps.
</i>
PhD Thesis. Oklahoma State University. Stillwater, Oklahoma, USA. 2012.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 30, 2017, by Filip Jorissen:<br/>
Added temperature protection block and
set <code>energyDynamics=DynamicFreeInitial</code>.
See <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/769\">
#769</a>.
</li>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialWaterToWater;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Fluid.HeatPumps\">IBPSA.Fluid.HeatPumps</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for heat pumps.
</p>
</html>"));
    end HeatPumps;

    package MixingVolumes "Package with mixing volumes"
      extends Modelica.Icons.VariantsPackage;

      model MixingVolume
        "Mixing volume with inlet and outlet ports (flow reversal is allowed)"
        extends IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          final initialize_p = not Medium.singleState,
          steBal(final use_C_flow = use_C_flow),
          dynBal(final use_C_flow = use_C_flow));

        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
          T(start=T_start)) "Heat port for heat exchange with the control volume"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if use_C_flow
          "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));

      equation
        connect(heaFloSen.port_a, heatPort)
          annotation (Line(points={{-90,0},{-96,0},{-100,0}}, color={191,0,0}));
        connect(C_flow, steBal.C_flow) annotation (Line(points={{-120,-60},{-80,-60},
                {12,-60},{12,6},{18,6}}, color={0,0,127}));
        connect(C_flow, dynBal.C_flow) annotation (Line(points={{-120,-60},{-52,-60},
                {52,-60},{52,6},{58,6}}, color={0,0,127}));
        annotation (
      defaultComponentName="vol",
      Documentation(info="<html>
<p>
This model represents an instantaneously mixed volume.
Potential and kinetic energy at the port are neglected,
and there is no pressure drop at the ports.
The volume can exchange heat through its <code>heatPort</code>.
</p>
<p>
The volume can be parameterized as a steady-state model or as
dynamic model.</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<h4>Options</h4>
<p>
The parameter <code>mSenFac</code> can be used to increase the thermal mass of this model
without increasing its volume. This way, species concentrations are still calculated
correctly even though the thermal mass increases. The additional thermal mass is calculated
based on the density and the value of the function <code>HeatCapacityCp</code>
of the medium state <code>state_default</code>. <br/>
This parameter can for instance be useful in a pipe model when the developer wants to
lump the pipe thermal mass to the fluid volume. By default <code>mSenFac = 1</code>, hence
the mass is unchanged. For higher values of <code>mSenFac</code>, the mass will be scaled proportionally.
</p>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector for the trace substance flow rate.
This allows to directly add or subtract trace substances such as
CO2 to the volume.
See
<a href=\"modelica://IBPSA.Fluid.Sensors.Examples.PPM\">IBPSA.Fluid.Sensors.Examples.PPM</a>
for an example.
</p>
<h4>Implementation</h4>
<p>
If the model is operated in steady-state and has two fluid ports connected,
then the same energy and mass balance implementation is used as in
steady-state component models, i.e., the use of <code>actualStream</code>
is not used for the properties at the port.
</p>
<p>
The implementation of these balance equations is done in the instances
<code>dynBal</code> for the dynamic balance and <code>steBal</code>
for the steady-state balance. Both models use the same input variables:
</p>
<ul>
<li>
The variable <code>Q_flow</code> is used to add sensible <i>and</i> latent heat to the fluid.
For example, <code>Q_flow</code> participates in the steady-state energy balance<pre>
    port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
</pre>
where <code>m_flowInv</code> approximates the expression <code>1/m_flow</code>.
</li>
<li>
The variable <code>mXi_flow</code> is used to add a species mass flow rate to the fluid.
</li>
</ul>
<p>
For the rationale of selecting different energy and mass balances, and for the
use of <code>prescribedHeatFlowRate</code>, see the documentation of
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume\">
IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://IBPSA.Fluid.HeatExchangers.HeaterCooler_u\">
IBPSA.Fluid.HeatExchangers.HeaterCooler_u</a> and
<a href=\"modelica://IBPSA.Fluid.Humidifiers.Humidifier_u\">
IBPSA.Fluid.Humidifiers.Humidifier_u</a>.
</p>

</html>",       revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Set <code>initialize_p</code> to <code>final</code> so that it does not
appear as a user-selectable parameter. This is done because
<code>initialize_p</code> has been changed from a <code>constant</code>
to a <code>parameter</code> for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Changed comment of heat port, as this needs to be the total heat flow
rate in order to be able to use this model for modeling steam humidifiers
and adiabatic humidifiers.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 19, 2016, by Michael Wetter:<br/>
Updated documentation due to the addition of an input for trace substance
in the mixing volume.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">
issue 372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Changed code for handling trace substance insertions using input <code>C_flow</code>.
</li>
<li>
May 1, 2015 by Michael Wetter<br/>
Set <code>final</code> keyword for <code>masExc(final k=0)</code>.
This addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/230\">
issue 230</a>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Redesigned implementation of latent and sensible heat flow rates
as port of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IBPSA.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations\">
IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
IBPSA.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-100,98},{100,-102}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={170,213,255}), Text(
                extent={{-58,14},{58,-18}},
                lineColor={0,0,0},
                textString="V=%V"),         Text(
                extent={{-152,100},{148,140}},
                textString="%name",
                lineColor={0,0,255})}));
      end MixingVolume;

      package BaseClasses
      "Package with base classes for IBPSA.Fluid.MixingVolumes"
        extends Modelica.Icons.BasesPackage;

        model PartialMixingVolume
          "Partial mixing volume with inlet and outlet ports (flow reversal is allowed)"

          extends IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations;
          parameter Boolean initialize_p = not Medium.singleState
            "= true to set up initial equations for pressure"
            annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

          // We set prescribedHeatFlowRate=false so that the
          // volume works without the user having to set this advanced parameter,
          // but to get high robustness, a user can set it to the appropriate value
          // as described in the info section.
          constant Boolean prescribedHeatFlowRate = false
            "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";

          constant Boolean simplify_mWat_flow = true
            "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          // Port definitions
          parameter Integer nPorts=0 "Number of ports"
            annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
          parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
            "Small mass flow rate for regularization of zero flow"
            annotation(Dialog(tab = "Advanced"));
          parameter Boolean allowFlowReversal = true
            "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports."
            annotation(Dialog(tab="Assumptions"), Evaluate=true);
          parameter Modelica.SIunits.Volume V "Volume";
          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
              redeclare each package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{-40,-10},{40,10}},
              origin={0,-100})));

          Medium.Temperature T = Medium.temperature_phX(p=p, h=hOut_internal, X=cat(1,Xi,{1-sum(Xi)}))
            "Temperature of the fluid";
          Modelica.Blocks.Interfaces.RealOutput U(unit="J")
            "Internal energy of the component";
          Modelica.SIunits.Pressure p = if nPorts > 0 then ports[1].p else p_start
            "Pressure of the fluid";
          Modelica.Blocks.Interfaces.RealOutput m(unit="kg") "Mass of the component";
          Modelica.SIunits.MassFraction Xi[Medium.nXi] = XiOut_internal
            "Species concentration of the fluid";
          Modelica.Blocks.Interfaces.RealOutput mXi[Medium.nXi](each unit="kg")
            "Species mass of the component";
          Medium.ExtraProperty C[Medium.nC](nominal=C_nominal) = COut_internal
            "Trace substance mixture content";
          Modelica.Blocks.Interfaces.RealOutput mC[Medium.nC](each unit="kg")
            "Trace substance mass of the component";

      protected
          IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation steBal(
            final simplify_mWat_flow = simplify_mWat_flow,
            redeclare final package Medium=Medium,
            final m_flow_nominal = m_flow_nominal,
            final allowFlowReversal = allowFlowReversal,
            final m_flow_small = m_flow_small,
            final prescribedHeatFlowRate=prescribedHeatFlowRate) if
                 useSteadyStateTwoPort "Model for steady-state balance if nPorts=2"
                annotation (Placement(transformation(extent={{20,0},{40,20}})));
          IBPSA.Fluid.Interfaces.ConservationEquation dynBal(
            final simplify_mWat_flow = simplify_mWat_flow,
            redeclare final package Medium = Medium,
            final energyDynamics=energyDynamics,
            final massDynamics=massDynamics,
            final p_start=p_start,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final C_nominal=C_nominal,
            final fluidVolume = V,
            final initialize_p = initialize_p,
            m(start=V*rho_start),
            nPorts=nPorts,
            final mSenFac=mSenFac) if
                 not useSteadyStateTwoPort "Model for dynamic energy balance"
            annotation (Placement(transformation(extent={{60,0},{80,20}})));

          // Density at start values, used to compute initial values and start guesses
          parameter Modelica.SIunits.Density rho_start=Medium.density(
           state=state_start) "Density, used to compute start and guess values";
          final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
              T=Medium.T_default,
              p=Medium.p_default,
              X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
          // Density at medium default values, used to compute the size of control volumes
          final parameter Modelica.SIunits.Density rho_default=Medium.density(
            state=state_default) "Density, used to compute fluid mass";
          final parameter Medium.ThermodynamicState state_start = Medium.setState_pTX(
              T=T_start,
              p=p_start,
              X=X_start[1:Medium.nXi]) "Medium state at start values";
          // See info section for why prescribedHeatFlowRate is used here.
          // The condition below may only be changed if StaticTwoPortConservationEquation
          // contains a correct solution for all foreseeable parameters/inputs.
          // See Buildings, issue 282 for a discussion.
          final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
              (prescribedHeatFlowRate or (not allowFlowReversal)) and (
              energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
            "Flag, true if the model has two ports only and uses a steady state balance"
            annotation (Evaluate=true);
          // Outputs that are needed to assign the medium properties
          Modelica.Blocks.Interfaces.RealOutput hOut_internal(unit="J/kg")
            "Internal connector for leaving temperature of the component";
          Modelica.Blocks.Interfaces.RealOutput XiOut_internal[Medium.nXi](each unit="1")
            "Internal connector for leaving species concentration of the component";
          Modelica.Blocks.Interfaces.RealOutput COut_internal[Medium.nC](each unit="1")
            "Internal connector for leaving trace substances of the component";

          Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature preTem
            "Port temperature"
            annotation (Placement(transformation(extent={{-40,-10},{-60,10}})));
          Modelica.Blocks.Sources.RealExpression portT(y=T) "Port temperature"
            annotation (Placement(transformation(extent={{-10,-10},{-30,10}})));
          Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloSen
            "Heat flow sensor"
            annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
        equation
          ///////////////////////////////////////////////////////////////////////////
          // asserts
          if not allowFlowReversal then
            assert(ports[1].m_flow > -m_flow_small,
        "Model has flow reversal, but the parameter allowFlowReversal is set to false.
  m_flow_small    = "         + String(m_flow_small) + "
  ports[1].m_flow = "         + String(ports[1].m_flow) + "
");       end if;
          // Actual definition of port variables.
          //
          // If the model computes the energy and mass balances as steady-state,
          // and if it has only two ports,
          // then we use the same base class as for all other steady state models.
          if useSteadyStateTwoPort then
          connect(steBal.port_a, ports[1]) annotation (Line(
              points={{20,10},{10,10},{10,-20},{0,-20},{0,-20},{0,-100}},
              color={0,127,255}));

          connect(steBal.port_b, ports[2]) annotation (Line(
              points={{40,10},{46,10},{46,-20},{0,-20},{0,-100}},
              color={0,127,255}));
            U=0;
            mXi=zeros(Medium.nXi);
            m=0;
            mC=zeros(Medium.nC);
            connect(hOut_internal,  steBal.hOut);
            connect(XiOut_internal, steBal.XiOut);
            connect(COut_internal,  steBal.COut);
          else
              connect(dynBal.ports, ports) annotation (Line(
              points={{70,0},{70,-80},{62,-80},{2.22045e-15,-80},{2.22045e-15,-90},{2.22045e-15,
                    -100}},
              color={0,127,255}));
            connect(U,dynBal.UOut);
            connect(mXi,dynBal.mXiOut);
            connect(m,dynBal.mOut);
            connect(mC,dynBal.mCOut);
            connect(hOut_internal,  dynBal.hOut);
            connect(XiOut_internal, dynBal.XiOut);
            connect(COut_internal,  dynBal.COut);
          end if;

          connect(portT.y, preTem.T)
            annotation (Line(points={{-31,0},{-38,0}},   color={0,0,127}));
          connect(heaFloSen.port_b, preTem.port)
            annotation (Line(points={{-70,0},{-65,0},{-60,0}},    color={191,0,0}));
          connect(heaFloSen.Q_flow, steBal.Q_flow) annotation (Line(points={{-80,-10},{
                  -80,-16},{6,-16},{6,18},{18,18}},
                                             color={0,0,127}));
          connect(heaFloSen.Q_flow, dynBal.Q_flow) annotation (Line(points={{-80,-10},{
                  -80,-10},{-80,-16},{6,-16},{6,24},{50,24},{50,16},{58,16}},
                                                                       color={0,0,127}));
          annotation (
        defaultComponentName="vol",
        Documentation(info="<html>
<p>
This is a partial model of an instantaneously mixed volume.
It is used as the base class for all fluid volumes of the package
<a href=\"modelica://IBPSA.Fluid.MixingVolumes\">
IBPSA.Fluid.MixingVolumes</a>.
</p>


<h4>Typical use and important parameters</h4>
<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
Set the constant <code>simplify_mWat_flow = true</code> to simplify the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
to
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector
for the trace substance flow rate.
</p>
<h4>Implementation</h4>
<p>
If the model is (i) operated in steady-state,
(ii) has two fluid ports connected, and
(iii) <code>prescribedHeatFlowRate=true</code> or <code>allowFlowReversal=false</code>,
then the model uses
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
in order to use
the same energy and mass balance implementation as is used as in
steady-state component models.
In this situation, the functions <code>inStream</code> are used for the two
flow directions rather than the function
<code>actualStream</code>, which is less efficient.
However, the use of <code>inStream</code> has the disadvantage
that <code>hOut</code> has to be computed, in
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>,
using
</p>
<pre>
if allowFlowReversal then
  hOut = IBPSA.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                    y2=port_a.h_outflow,
                                                    x=port_a.m_flow,
                                                    x_small=m_flow_small/1E3);
else
  hOut = port_b.h_outflow;
end if;
</pre>
<p>
Hence, for <code>allowFlowReversal=true</code>, if <code>hOut</code>
were to be used to compute the temperature that
drives heat transfer such as by conduction,
then the heat transfer would depend on upstream and the <i>downstream</i>
temperatures for small mass flow rates.
This can give wrong results. Consider for example a mass flow rate that is positive
but very close to zero. Suppose the upstream temperature is <i>20</i>&circ;C,
the downstream temperature is <i>10</i>&circ;C, and the heat port is
connected through a heat conductor to a boundary condition of <i>20</i>&circ;C.
Then, <code>hOut = (port_b.h_outflow + port_a.h_outflow)/2</code> and hence
the temperature <code>heatPort.T</code>
is <i>15</i>&circ;C. Therefore, heat is added to the component.
As the mass flow rate is by assumption very small, the fluid that leaves the component
will have a very high temperature, violating the 2nd law.
To avoid this situation, if
<code>prescribedHeatFlowRate=false</code>, then the model
<a href=\"modelica://IBPSA.Fluid.Interfaces.ConservationEquation\">
IBPSA.Fluid.Interfaces.ConservationEquation</a>
is used instead of
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://IBPSA.Fluid.MixingVolumes\">
IBPSA.Fluid.MixingVolumes</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
Removed <code>partial</code> keyword as this model is not partial.<br/>
Moved <code>C_flow</code> and <code>use_C_flow</code> to child classes.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Moved heat port to the extending classes to provide better comment.
Otherwise, the mixing volume without water input would have a comment
that says latent heat can be added at this port.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs U, m, mXi, mC for being able to
check conservation of quantities.
This if or <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Updated model to use the new parameter <code>use_mWat_flow</code>
rather than <code>sensibleOnly</code>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added conditional input <code>C_flow</code> for
handling trace substance insertions.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate=prescribedHeatflowRate</code> for
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
This results in equations that are solved more easily.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Set start value for <code>heatPort.T</code> and changed
type of <code>T</code> to <code>Medium.Temperature</code> rather than
<code>Modelica.SIunits.Temperature</code>
to avoid an
error because of conflicting start values if
<code>IBPSA.Fluid.Chillers.Carnot_y</code>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> to the actual model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Improved documentation and changed the test
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 prescribedHeatFlowRate and ...
</pre>
to
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 (prescribedHeatFlowRate or (not allowFlowReversal)) and ...
</pre>
The reason is that if there is no flow reversal, then
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
computes <code>hOut =  port_b.h_outflow;</code>, and hence
it is correct to use <code>hOut</code> to compute
temperature-driven heat flow, such as by conduction or convection.
See also the model documentation.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">
#412</a>.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
October 29, 2014, by Michael Wetter:<br/>
Made assignment of <code>mFactor</code> final, and changed computation of
density to use default medium states as are also used to compute the
specific heat capacity.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Removed <code>Q_flow</code> and added <code>QSen_flow</code>.
This was done to clarify what is sensible and total heat flow rate
as part of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to instance <code>steBal</code> as it has no longer this parameter.
</li>
<li>
September 13, 2013 by Michael Wetter:<br/>
Renamed <code>rho_nominal</code> to <code>rho_start</code>
because this quantity is computed using start values and not
nominal values.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the check of multiple connections to the same element
of a fluid port, as this check required the use of the deprecated
<code>cardinality</code> function.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IBPSA.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations\">
IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
This implementation also simplifies the implementation of
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort\">
IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</a>,
which now uses the same equations as this model.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
IBPSA.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Ellipse(
                  extent={{-100,98},{100,-102}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={170,213,255}), Text(
                  extent={{-58,14},{58,-18}},
                  lineColor={0,0,0},
                  textString="V=%V"),         Text(
                  extent={{-152,100},{148,140}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end PartialMixingVolume;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Fluid.MixingVolumes\">IBPSA.Fluid.MixingVolumes</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package contains models for completely mixed volumes.
</p>
<p>
For most situations, the model
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.MixingVolume\">
IBPSA.Fluid.MixingVolumes.MixingVolume</a> should be used.
The other models are only of interest if water should be added to
or subtracted from the fluid volume, such as in a
coil with water vapor condensation.
</p>
</html>"));
    end MixingVolumes;

    package Types "Package with type definitions"
      extends Modelica.Icons.TypesPackage;

      type HeatExchangerConfiguration = enumeration(
        ParallelFlow   "Parallel flow",
        CounterFlow   "Counter flow",
        CrossFlowUnmixed   "Cross flow, both streams unmixed",
        CrossFlowStream1MixedStream2Unmixed
            "Cross flow, stream 1 mixed, stream 2 unmixed",
        CrossFlowStream1UnmixedStream2Mixed
            "Cross flow, stream 1 unmixed, stream 2 mixed",
        ConstantTemperaturePhaseChange   "Constant temperature phase change in one stream")
        "Enumeration for heat exchanger construction"
      annotation(Documentation(info="<html>
<p>
 Enumeration that defines the heat exchanger construction.
</p>
<p>
The following heat exchanger configurations are available in this enumeration:
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Enumeration</th><th>Description</th></tr>
<tr><td>ParallelFlow</td><td>Parallel flow</td></tr>
<tr><td>CounterFlow</td><td>Counter flow</td></tr>
<tr><td>CrossFlowUnmixed</td><td>Cross flow, both streams unmixed</td></tr>
<tr><td>CrossFlowStream1MixedStream2Unmixed</td><td>Cross flow, stream 1 mixed, stream 2 unmixed</td></tr>
<tr><td>CrossFlowStream1UnmixedStream2Mixed</td><td>Cross flow, stream 1 unmixed, stream 2 mixed</td></tr>
<tr><td>ConstantTemperaturePhaseChange</td><td>Constant temperature phase change in one stream</td></tr>
</table>
<p>
Note that for a given heat exchanger, the
 <code>HeatExchangerConfiguration</code> is fixed. However, if the capacity
 flow rates change, then the
 <a href=\"modelica://IBPSA.Fluid.Types.HeatExchangerFlowRegime\">
 IBPSA.Fluid.Types.HeatExchangerFlowRegime</a> may change. For example,
 a counter flow heat exchanger has <code>HeatExchangerConfiguration=CounterFlow</code>,
 but the <a href=\"modelica://IBPSA.Fluid.Types.HeatExchangerFlowRegime\">
 IBPSA.Fluid.Types.HeatExchangerFlowRegime</a> can change to parallel flow if one of the two capacity flow rates reverts
 its direction.
 </p>
</html>",     revisions=
              "<html>
<ul>
<li>
March 27, 2017, by Michael Wetter:<br/>
Added <code>ConstantTemperaturePhaseChange</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/694\">
IBPSA #694</a>.
</li>
<li>
February 18, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type HeatExchangerFlowRegime = enumeration(
        ParallelFlow   "Parallel flow",
        CounterFlow   "Counter flow",
        CrossFlowUnmixed   "Cross flow, both streams unmixed",
        CrossFlowCMinMixedCMaxUnmixed   "Cross flow, CMin mixed,   CMax unmixed",
        CrossFlowCMinUnmixedCMaxMixed   "Cross flow, CMin unmixed, CMax mixed",
        ConstantTemperaturePhaseChange   "Constant temperature phase change in one stream")
        "Enumeration for heat exchanger flow configuration"
      annotation(Documentation(info="<html>
<p>
 Enumeration to define the heat exchanger flow regime.
</p>
<p>
This enumeration defines for the current capacity flow rate the kind of
heat transfer relation that will be used to compute the relation between
effectiveness and Number of Transfer Units.
</p>
<p>
The following heat exchanger flow regimes are available in this enumeration:
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Enumeration</th><th>Description</th></tr>
<tr><td>ParallelFlow</td><td>Parallel flow</td></tr>
<tr><td>CounterFlow</td><td>Counter flow</td></tr>
<tr><td>CrossFlowUnmixed</td><td>Cross flow, both streams unmixed</td></tr>
<tr><td>CrossFlowCMinMixedCMaxUnmixed</td><td>Cross flow, CMin mixed,   CMax unmixed</td></tr>
<tr><td>CrossFlowCMinUnmixedCMaxMixed</td><td>Cross flow, CMin unmixed, CMax mixed</td></tr>
<tr><td>ConstantTemperaturePhaseChange</td><td>Constant temperature phase change in one stream</td></tr>
</table>
</html>",     revisions="<html>
<ul>
<li>
March 27, 2017, by Michael Wetter:<br/>
Added <code>ConstantTemperaturePhaseChange</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/694\">
IBPSA #694</a>.
</li>
<li>
February 18, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
     annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>"));
    end Types;

    package Interfaces "Package with interfaces for fluid models"
      extends Modelica.Icons.InterfacesPackage;

      model ConservationEquation "Lumped volume with mass and energy balance"

        extends IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations;

        // Constants
        parameter Boolean initialize_p = not Medium.singleState
          "= true to set up initial equations for pressure"
          annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

        constant Boolean simplify_mWat_flow = true
          "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";

        // Port definitions
        parameter Integer nPorts=0 "Number of ports"
          annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));

        parameter Boolean use_mWat_flow = false
          "Set to true to enable input connector for moisture mass flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transferred into the medium"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       unit="kg/s") if
             use_mWat_flow "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if
             use_C_flow "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

        // Outputs that are needed in models that use this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                   start=hStart)
          "Leaving specific enthalpy of the component"
           annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));
        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));
        Modelica.Blocks.Interfaces.RealOutput UOut(unit="J")
          "Internal energy of the component" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={110,20})));
        Modelica.Blocks.Interfaces.RealOutput mXiOut[Medium.nXi](each min=0, each unit=
             "kg") "Species mass of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              origin={110,-20})));
        Modelica.Blocks.Interfaces.RealOutput mOut(min=0, unit="kg")
          "Mass of the component" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={110,60})));
        Modelica.Blocks.Interfaces.RealOutput mCOut[Medium.nC](each min=0, each unit="kg")
          "Trace substance mass of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              origin={110,-60})));

        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each final package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-40,-10},{40,10}},
            origin={0,-100})));

        // Set nominal attributes where literal values can be used.
        Medium.BaseProperties medium(
          p(start=p_start),
          h(start=hStart),
          T(start=T_start),
          Xi(start=X_start[1:Medium.nXi]),
          X(start=X_start),
          d(start=rho_start)) "Medium properties";

        Modelica.SIunits.Energy U(start=fluidVolume*rho_start*
          Medium.specificInternalEnergy(Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) +
          (T_start - Medium.reference_T)*CSen,
          nominal = 1E5) "Internal energy of fluid";

        Modelica.SIunits.Mass m(
          start=fluidVolume*rho_start,
          stateSelect=if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState
          then StateSelect.default else StateSelect.prefer)
          "Mass of fluid";

        Modelica.SIunits.Mass[Medium.nXi] mXi(
          start=fluidVolume*rho_start*X_start[1:Medium.nXi])
          "Masses of independent components in the fluid";
        Modelica.SIunits.Mass[Medium.nC] mC(
          start=fluidVolume*rho_start*C_start)
          "Masses of trace substances in the fluid";
        // C need to be added here because unlike for Xi, which has medium.Xi,
        // there is no variable medium.C
        Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
          "Trace substance mixture content";

        Modelica.SIunits.MassFlowRate mb_flow "Mass flows across boundaries";
        Modelica.SIunits.MassFlowRate[Medium.nXi] mbXi_flow
          "Substance mass flows across boundaries";
        Medium.ExtraPropertyFlowRate[Medium.nC] mbC_flow
          "Trace substance mass flows across boundaries";
        Modelica.SIunits.EnthalpyFlowRate Hb_flow
          "Enthalpy flow across boundaries or energy source/sink";

        // Parameters that need to be defined by an extending class
        parameter Modelica.SIunits.Volume fluidVolume "Volume";
        final parameter Modelica.SIunits.HeatCapacity CSen=
          (mSenFac - 1)*rho_default*cp_default*fluidVolume
          "Aditional heat capacity for implementing mFactor";
    protected
        Medium.EnthalpyFlowRate ports_H_flow[nPorts];
        Modelica.SIunits.MassFlowRate ports_mXi_flow[nPorts,Medium.nXi];
        Medium.ExtraPropertyFlowRate ports_mC_flow[nPorts,Medium.nC];
        parameter Modelica.SIunits.SpecificHeatCapacity cp_default=
        Medium.specificHeatCapacityCp(state=state_default)
          "Heat capacity, to compute additional dry mass";
        parameter Modelica.SIunits.Density rho_start=Medium.density(
         Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) "Density, used to compute fluid mass";

        // Parameter for avoiding extra overhead calculations when CSen==0
        final parameter Boolean computeCSen = abs(mSenFac-1) > Modelica.Constants.eps
          annotation(Evaluate=true);
        final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
        // Density at medium default values, used to compute the size of control volumes
        final parameter Modelica.SIunits.Density rho_default=Medium.density(
          state=state_default) "Density, used to compute fluid mass";
        // Parameter that is used to construct the vector mXi_flow
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(
                                                  string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";
        parameter Modelica.SIunits.SpecificEnthalpy hStart=
          Medium.specificEnthalpy_pTX(p_start, T_start, X_start)
          "Start value for specific enthalpy";

        // Set _simplify_mWat_flow == false for Glycol47; otherwise Dymola 2018FD01
        // cannot differentiate the equations.
        constant Boolean _simplify_mWat_flow = simplify_mWat_flow and Medium.nX > 1
         "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";

        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
          "Needed to connect to conditional connector";

      initial equation
        // Assert that the substance with name 'water' has been found.
        assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "In " + getInstanceName() + ":
         If Medium.nXi > 1, then substance 'water' must be present for one component of '"
               + Medium.mediumName + "'.
         Check medium model.");

        // Make sure that if energyDynamics is SteadyState, then
        // massDynamics is also SteadyState.
        // Otherwise, the system of ordinary differential equations may be inconsistent.
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          assert(massDynamics == energyDynamics, "In " + getInstanceName() + ":
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
        end if;

        // initialization of balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
            medium.T = T_start;
        else
          if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
              der(medium.T) = 0;
          end if;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          if initialize_p then
            medium.p = p_start;
          end if;
        else
          if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            if initialize_p then
              der(medium.p) = 0;
            end if;
          end if;
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          medium.Xi = X_start[1:Medium.nXi];
        else
          if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(medium.Xi) = zeros(Medium.nXi);
          end if;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          C = C_start[1:Medium.nC];
        else
          if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(C) = zeros(Medium.nC);
          end if;
        end if;

      equation
        // Conditional connectors
        connect(mWat_flow, mWat_flow_internal);
        if not use_mWat_flow then
          mWat_flow_internal = 0;
        end if;

        connect(C_flow, C_flow_internal);
        if not use_C_flow then
          C_flow_internal = zeros(Medium.nC);
        end if;

        // Total quantities
        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          m = fluidVolume*rho_start;
        else
          if _simplify_mWat_flow then
            // If moisture is neglected in mass balance, assume for computation
            // of the mass of air that the air is at Medium.X_default.
            m = fluidVolume*Medium.density(Medium.setState_phX(
              p = medium.p,
              h = hOut,
              X = Medium.X_default));
          else
            // Use actual density
            m = fluidVolume*medium.d;
          end if;
        end if;
        mXi = m*medium.Xi;
        if computeCSen then
          U = m*medium.u + CSen*(medium.T-Medium.reference_T);
        else
          U = m*medium.u;
        end if;
        mC = m*C;

        hOut = medium.h;
        XiOut = medium.Xi;
        COut = C;

        for i in 1:nPorts loop
          //The semiLinear function should be used for the equations below
          //for allowing min/max simplifications.
          //See https://github.com/ibpsa/modelica-ibpsa/issues/216 for a discussion and motivation
          ports_H_flow[i]     = semiLinear(ports[i].m_flow, inStream(ports[i].h_outflow), ports[i].h_outflow)
            "Enthalpy flow";
          for j in 1:Medium.nXi loop
            ports_mXi_flow[i,j] = semiLinear(ports[i].m_flow, inStream(ports[i].Xi_outflow[j]), ports[i].Xi_outflow[j])
              "Component mass flow";
          end for;
          for j in 1:Medium.nC loop
            ports_mC_flow[i,j]  = semiLinear(ports[i].m_flow, inStream(ports[i].C_outflow[j]),  ports[i].C_outflow[j])
              "Trace substance mass flow";
          end for;
        end for;

        for i in 1:Medium.nXi loop
          mbXi_flow[i] = sum(ports_mXi_flow[:,i]);
        end for;

        for i in 1:Medium.nC loop
          mbC_flow[i]  = sum(ports_mC_flow[:,i]);
        end for;

        mb_flow = sum(ports.m_flow);
        Hb_flow = sum(ports_H_flow);

        // Energy and mass balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = Hb_flow + Q_flow;
        else
          der(U) = Hb_flow + Q_flow;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
        else
          der(m) = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nXi) = mbXi_flow + mWat_flow_internal * s;
        else
          der(mXi) = mbXi_flow + mWat_flow_internal * s;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nC)  = mbC_flow + C_flow_internal;
        else
          der(mC)  = mbC_flow + C_flow_internal;
        end if;

        // Properties of outgoing flows
        for i in 1:nPorts loop
            ports[i].p          = medium.p;
            ports[i].h_outflow  = medium.h;
            ports[i].Xi_outflow = medium.Xi;
            ports[i].C_outflow  = C;
        end for;
        UOut=U;
        mXiOut=mXi;
        mOut=m;
        mCOut=mC;
        annotation (
          Documentation(info="<html>
<p>
Basic model for an ideally mixed fluid volume with the ability to store mass and energy.
It implements a dynamic or a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code> then adding
moisture does not increase the mass of the volume or the leaving mass flow rate.
It does however change the mass fraction <code>medium.Xi</code>.
This allows to decouple the moisture balance from the pressure drop equations.
If <code>simplify_mWat_flow = false</code>, then
the outlet mass flow rate is
<i>m<sub>out</sub> = m<sub>in</sub>  (1 + &Delta; X<sub>w</sub>)</i>,
where
<i>&Delta; X<sub>w</sub></i> is the change in water vapor mass
fraction across the component. In this case,
this component couples
the energy calculation to the
pressure drop versus mass flow rate calculations.
However, in typical building HVAC systems,
<i>&Delta; X<sub>w</sub></i> &lt; <i>0.005</i> kg/kg.
Hence, by tolerating a relative error of <i>0.005</i> in the mass balance,
one can decouple these equations.
Decoupling these equations avoids having
to compute the energy balance of the humidifier
and its upstream components when solving for the
pressure drop of downstream components.
Therefore, the default value is <code>simplify_mWat_flow = true</code>.
</p>
<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
The model
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling\">
IBPSA.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling</a>
shows that the relative error on the temperature difference between these
two options of <code>simplify_mWat_flow</code> is less than
<i>0.1%</i>.
</p>

<h4>Implementation</h4>
<p>
When extending or instantiating this model, the input
<code>fluidVolume</code>, which is the actual volume occupied by the fluid,
needs to be assigned.
For most components, this can be set to a parameter.
</p>
Input connectors of the model are
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can be used as a dynamic model or as a steady-state model.
However, for a steady-state model with exactly two fluid ports connected,
the model
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
provides a more efficient implementation.
</p>
<p>
For a model that instantiates this model, see
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.MixingVolume\">
IBPSA.Fluid.MixingVolumes.MixingVolume</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 26, 2019, by Filip Jorissen:<br/>
Returning <code>getInstanceName()</code> in asserts.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1133\">1133</a>.
</li>
<li>
April 16, 2019, by Michael Wetter:<br/>
Changed computation of <code>computeCSen</code> to avoid the volume to become
a structural parameter.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1122\">IBPSA, issue 1122</a>.
</li>
<li>
April 16, 2018, by Michael Wetter:<br/>
Reformulated mass calculation so that Dymola can differentiate the equations.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/910\">IBPSA, issue 910</a>.
</li>
<li>
November 3, 2017, by Michael Wetter:<br/>
Set <code>start</code> attributes.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/727\">727</a>.
</li>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
January 27, 2017, by Michael Wetter:<br/>
Added <code>stateSelect</code> for mass <code>m</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/642\">
Buildings, #642</a>.
</li>
<li>
December 22, 2016, by Michael Wetter:<br/>
Set nominal value for <code>U</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/637\">637</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs UOut, mOut, mXiOut, mCOut for being able to
check conservation of quantities.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Added <code>C_flow</code> to the steady-state trace substance balance,
and removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
</li>
<li>
September 3, 2015, by Filip Jorissen and Michael Wetter:<br/>
Revised implementation for allowing moisture mass flow rate
to be approximated using parameter <code>simplify_mWat_flow</code>.
This may lead to smaller algebraic loops.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
June 5, 2015 by Michael Wetter:<br/>
Removed <code>preferredMediumStates= false</code> in
the instance <code>medium</code> as the default
is already <code>false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015 by Filip Jorissen:<br/>
Removed <pre>
Xi(start=X_start[1:Medium.nXi],
       each stateSelect=if (not (substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState))
       then StateSelect.prefer else StateSelect.default),
</pre>
and set
<code>preferredMediumStates = false</code>
because the previous declaration led to more equations and
translation problems in large models.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> of <code>PartialMixingVolume</code>
to this model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
This revison also renames the protected variable
<code>rho_nominal</code> to <code>rho_start</code>
as it depends on the start values and not the nominal values.
</li>
<li>
May 22, 2015 by Michael Wetter:<br/>
Removed <pre>
p(stateSelect=if not (massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
then StateSelect.prefer else StateSelect.default)
</pre>
because the previous declaration led to the translation error
<pre>
The model requires derivatives of some inputs as listed below:
1 inlet.m_flow
1 inlet.p
</pre>
when translating
<code>Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.HeaterCooler_u</code>
with a dynamic energy balance.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
April 13, 2015, by Filip Jorissen:<br/>
Now using <code>semiLinear()</code> function for calculation of
<code>ports_H_flow</code>. This enables Dymola to simplify based on
the <code>min</code> and <code>max</code> attribute of the mass flow rate.
</li>
<li>
February 16, 2015, by Filip Jorissen:<br/>
Fixed SteadyState massDynamics implementation for compressible media.
Mass <code>m</code> is now constant.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Set start attributes in <code>medium</code> to avoid in OpenModelica the warning
alias set with several free start values.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>
September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.<br/>
Corrected the syntax error
<code>Medium.ExtraProperty C[Medium.nC](each nominal=C_nominal)</code>
to
<code>Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)</code>
because <code>C_nominal</code> is a vector.
This syntax error caused a compilation error in OpenModelica.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
July 31, 2011 by Michael Wetter:<br/>
Added test to stop model translation if the setting for
<code>energyBalance</code> and <code>massBalance</code>
can lead to inconsistent equations.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Removed the option to use <code>h_start</code>, as this
is not needed for building simulation.
Also removed the reference to <code>Modelica.Fluid.System</code>.
Moved parameters and medium to
<a href=\"IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations\">
IBPSA.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start value for medium density.
</li>
<li>
March 29, 2011 by Michael Wetter:<br/>
Changed default value for <code>substanceDynamics</code> and
<code>traceDynamics</code> from <code>energyDynamics</code>
to <code>massDynamics</code>.
</li>
<li>
September 28, 2010 by Michael Wetter:<br/>
Changed array index for nominal value of <code>Xi</code>.
</li>
<li>
September 13, 2010 by Michael Wetter:<br/>
Set nominal attributes for medium based on default medium values.
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added parameter <code>C_nominal</code> which is used as the nominal attribute for <code>C</code>.
Without this value, the ODE solver gives wrong results for concentrations around 1E-7.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li><i>February 6, 2010</i> by Michael Wetter:<br/>
Added to <code>Medium.BaseProperties</code> the initialization
<code>X(start=X_start[1:Medium.nX])</code>. Previously, the initialization
was only done for <code>Xi</code> but not for <code>X</code>, which caused the
medium to be initialized to <code>reference_X</code>, ignoring the value of <code>X_start</code>.
</li>
<li><i>October 12, 2009</i> by Michael Wetter:<br/>
Implemented first version in <code>Buildings</code> library, based on model from
<code>Modelica.Fluid 1.0</code>.
</li>
</ul>
</html>"),Icon(graphics={            Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-89,17},{-54,34}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-89,52},{-54,69}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-42,-28},{-6,-28},{18,4},{40,12},{66,14}},
                color={255,255,255},
                smooth=Smooth.Bezier),
              Text(
                extent={{-155,-120},{145,-160}},
                lineColor={0,0,255},
                textString="%name")}));
      end ConservationEquation;

      partial model EightPort "Partial model with eight ports"

        replaceable package Medium1 =
          Modelica.Media.Interfaces.PartialMedium "Medium 1 in the component"
            annotation (choices(
              choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
              choice(redeclare package Medium = IBPSA.Media.Water "Water"),
              choice(redeclare package Medium =
                  IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));
        replaceable package Medium2 =
          Modelica.Media.Interfaces.PartialMedium "Medium 2 in the component"
            annotation (choices(
              choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
              choice(redeclare package Medium = IBPSA.Media.Water "Water"),
              choice(redeclare package Medium =
                  IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));
        replaceable package Medium3 =
          Modelica.Media.Interfaces.PartialMedium "Medium 3 in the component"
            annotation (choices(
              choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
              choice(redeclare package Medium = IBPSA.Media.Water "Water"),
              choice(redeclare package Medium =
                  IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));
        replaceable package Medium4 =
          Modelica.Media.Interfaces.PartialMedium "Medium 4 in the component"
            annotation (choices(
              choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
              choice(redeclare package Medium = IBPSA.Media.Water "Water"),
              choice(redeclare package Medium =
                  IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal1 = true
          "= true to allow flow reversal in medium 1, false restricts to design direction (port_a -> port_b)"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Boolean allowFlowReversal2 = true
          "= true to allow flow reversal in medium 2, false restricts to design direction (port_a -> port_b)"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Boolean allowFlowReversal3 = true
          "= true to allow flow reversal in medium 3, false restricts to design direction (port_a -> port_b)"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Boolean allowFlowReversal4 = true
          "= true to allow flow reversal in medium 4, false restricts to design direction (port_a -> port_b)"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_a1_start = Medium1.h_default
          "Start value for enthalpy flowing out of port a1"
          annotation (Dialog(tab="Advanced", group="Initialization"));

        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_b1_start = Medium1.h_default
          "Start value for enthalpy flowing out of port b1"
          annotation (Dialog(tab="Advanced", group="Initialization"));

        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_a2_start = Medium2.h_default
          "Start value for enthalpy flowing out of port a2"
          annotation (Dialog(tab="Advanced", group="Initialization"));

        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_b2_start = Medium2.h_default
          "Start value for enthalpy flowing out of port b2"
          annotation (Dialog(tab="Advanced", group="Initialization"));

          parameter Modelica.SIunits.SpecificEnthalpy h_outflow_a3_start = Medium3.h_default
          "Start value for enthalpy flowing out of port a1"
          annotation (Dialog(tab="Advanced", group="Initialization"));

        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_b3_start = Medium3.h_default
          "Start value for enthalpy flowing out of port b1"
          annotation (Dialog(tab="Advanced", group="Initialization"));

          parameter Modelica.SIunits.SpecificEnthalpy h_outflow_a4_start = Medium4.h_default
          "Start value for enthalpy flowing out of port a1"
          annotation (Dialog(tab="Advanced", group="Initialization"));

        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_b4_start = Medium4.h_default
          "Start value for enthalpy flowing out of port b1"
          annotation (Dialog(tab="Advanced", group="Initialization"));

        Modelica.Fluid.Interfaces.FluidPort_a port_a1(
                           redeclare final package Medium = Medium1,
                           m_flow(min=if allowFlowReversal1 then -Modelica.Constants.inf else 0),
                           h_outflow(start=h_outflow_a1_start))
          "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{-110,70},{-90,90}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b1(
                           redeclare final package Medium = Medium1,
                           m_flow(max=if allowFlowReversal1 then +Modelica.Constants.inf else 0),
                           h_outflow(start=h_outflow_b1_start))
          "Fluid connector b1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{110,70},{90,90}}), iconTransformation(extent={{110,70},
                  {90,90}})));

        Modelica.Fluid.Interfaces.FluidPort_a port_a2(
                           redeclare final package Medium = Medium2,
                           m_flow(min=if allowFlowReversal2 then -Modelica.Constants.inf else 0),
                           h_outflow(start=h_outflow_a2_start))
          "Fluid connector a2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{90,20},{110,40}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b2(
                           redeclare final package Medium = Medium2,
                           m_flow(max=if allowFlowReversal2 then +Modelica.Constants.inf else 0),
                           h_outflow(start=h_outflow_b2_start))
          "Fluid connector b2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{-90,20},{-110,40}}),
                      iconTransformation(extent={{-90,20},{-110,40}})));

        Modelica.Fluid.Interfaces.FluidPort_a port_a3(
                           redeclare final package Medium = Medium3,
                           m_flow(min=if allowFlowReversal3 then -Modelica.Constants.inf else 0),
                           h_outflow(start=h_outflow_a3_start))
          "Fluid connector a1 (positive design flow direction is from port_a3 to port_b3)"
          annotation (Placement(transformation(extent={{-110,-42},{-90,-22}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b3(
                           redeclare final package Medium = Medium3,
                           m_flow(max=if allowFlowReversal3 then +Modelica.Constants.inf else 0),
                           h_outflow(start=h_outflow_b3_start))
          "Fluid connector b2 (positive design flow direction is from port_a3 to port_b3)"
          annotation (Placement(transformation(extent={{110,-40},{90,-20}}),
                      iconTransformation(extent={{110,-41},{90,-21}})));
        Modelica.Fluid.Interfaces.FluidPort_a port_a4(
                           redeclare final package Medium = Medium4,
                           m_flow(min=if allowFlowReversal4 then -Modelica.Constants.inf else 0),
                           h_outflow(start=h_outflow_a4_start))
          "Fluid connector a1 (positive design flow direction is from port_a4 to port_b4)"
          annotation (Placement(transformation(extent={{90,-90},{110,-70}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b4(
                           redeclare final package Medium = Medium4,
                           m_flow(max=if allowFlowReversal4 then +Modelica.Constants.inf else 0),
                           h_outflow(start=h_outflow_b4_start))
          "Fluid connector b2 (positive design flow direction is from port_a4 to port_b4)"
          annotation (Placement(transformation(extent={{-90,-90},{-110,-70}}),
                      iconTransformation(extent={{-90,-95},{-110,-75}})));
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>This model defines an interface for components with eight ports. The parameters <code>allowFlowReversal1,
</code> <code>allowFlowReversal2</code>, <code>allowFlowReversal3</code> and <code>allowFlowReversal4</code> 
may be used by models that extend this model to treat flow reversal. </p>
<p>This model is identical to <a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">Modelica.Fluid.Interfaces.PartialTwoPort</a>, except that it has eight ports. </p>
</html>",       revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>July 2014, by Damien Picard:<br/>First implementation. </li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={Text(
                extent={{-151,147},{149,107}},
                lineColor={0,0,255},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255},
                textString="%name")}),
          Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}),
                          graphics));
      end EightPort;

      model EightPortHeatMassExchanger
        "Model transporting four fluid streams between eight ports with storing mass or energy"
        extends IBPSA.Fluid.Interfaces.PartialEightPortInterface(
          final h_outflow_a1_start = h1_outflow_start,
          final h_outflow_b1_start = h1_outflow_start,
          final h_outflow_a2_start = h2_outflow_start,
          final h_outflow_b2_start = h2_outflow_start,
          final h_outflow_a3_start = h3_outflow_start,
          final h_outflow_b3_start = h3_outflow_start,
          final h_outflow_a4_start = h4_outflow_start,
          final h_outflow_b4_start = h4_outflow_start);

        extends IBPSA.Fluid.Interfaces.EightPortFlowResistanceParameters(
           final computeFlowResistance1=true, final computeFlowResistance2=true,final computeFlowResistance3=true, final computeFlowResistance4=true);

        parameter Modelica.SIunits.Time tau1 = 30 "Time constant at nominal flow"
           annotation (Dialog(tab = "Dynamics", group="Nominal condition"));
        parameter Modelica.SIunits.Time tau2 = 30 "Time constant at nominal flow"
           annotation (Dialog(tab = "Dynamics", group="Nominal condition"));
        parameter Modelica.SIunits.Time tau3 = 30 "Time constant at nominal flow"
           annotation (Dialog(tab = "Dynamics", group="Nominal condition"));
        parameter Modelica.SIunits.Time tau4 = 30 "Time constant at nominal flow"
           annotation (Dialog(tab = "Dynamics", group="Nominal condition"));

        // Advanced
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Formulation of energy balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Formulation of mass balance"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium1.AbsolutePressure p1_start = Medium1.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization", group = "Medium 1"));
        parameter Medium1.Temperature T1_start = Medium1.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization", group = "Medium 1"));
        parameter Medium1.MassFraction X1_start[Medium1.nX] = Medium1.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nXi > 0));
        parameter Medium1.ExtraProperty C1_start[Medium1.nC](
             quantity=Medium1.extraPropertiesNames)=fill(0, Medium1.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nC > 0));
        parameter Medium1.ExtraProperty C1_nominal[Medium1.nC](
             quantity=Medium1.extraPropertiesNames) = fill(1E-2, Medium1.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", group = "Medium 1", enable=Medium1.nC > 0));

        parameter Medium2.AbsolutePressure p2_start = Medium2.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization", group = "Medium 2"));
        parameter Medium2.Temperature T2_start = Medium2.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization", group = "Medium 2"));
        parameter Medium2.MassFraction X2_start[Medium2.nX] = Medium2.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nXi > 0));
        parameter Medium2.ExtraProperty C2_start[Medium2.nC](
             quantity=Medium2.extraPropertiesNames)=fill(0, Medium2.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nC > 0));
        parameter Medium2.ExtraProperty C2_nominal[Medium2.nC](
             quantity=Medium2.extraPropertiesNames) = fill(1E-2, Medium2.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", group = "Medium 2", enable=Medium2.nC > 0));

        parameter Medium3.AbsolutePressure p3_start = Medium3.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization", group = "Medium 3"));
        parameter Medium3.Temperature T3_start = Medium3.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization", group = "Medium 3"));
        parameter Medium3.MassFraction X3_start[Medium3.nX] = Medium3.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", group = "Medium 3", enable=Medium3.nXi > 0));
        parameter Medium3.ExtraProperty C3_start[Medium3.nC](
             quantity=Medium3.extraPropertiesNames)=fill(0, Medium3.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", group = "Medium 3", enable=Medium3.nC > 0));
        parameter Medium3.ExtraProperty C3_nominal[Medium3.nC](
             quantity=Medium3.extraPropertiesNames) = fill(1E-2, Medium3.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", group = "Medium 3", enable=Medium3.nC > 0));

        parameter Medium4.AbsolutePressure p4_start = Medium4.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization", group = "Medium 4"));
        parameter Medium4.Temperature T4_start = Medium4.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization", group = "Medium 4"));
        parameter Medium4.MassFraction X4_start[Medium4.nX] = Medium4.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", group = "Medium 4", enable=Medium4.nXi > 0));
        parameter Medium4.ExtraProperty C4_start[Medium4.nC](
             quantity=Medium4.extraPropertiesNames)=fill(0, Medium4.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", group = "Medium 4", enable=Medium4.nC > 0));
        parameter Medium4.ExtraProperty C4_nominal[Medium4.nC](
             quantity=Medium4.extraPropertiesNames) = fill(1E-2, Medium4.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", group = "Medium 4", enable=Medium4.nC > 0));

       Modelica.SIunits.HeatFlowRate Q1_flow = vol1.heatPort.Q_flow
          "Heat flow rate into medium 1";
        Modelica.SIunits.HeatFlowRate Q2_flow = vol2.heatPort.Q_flow
          "Heat flow rate into medium 2";
        Modelica.SIunits.HeatFlowRate Q3_flow = vol3.heatPort.Q_flow
          "Heat flow rate into medium 1";
        Modelica.SIunits.HeatFlowRate Q4_flow = vol4.heatPort.Q_flow
          "Heat flow rate into medium 2";

        IBPSA.Fluid.MixingVolumes.MixingVolume vol1(
          redeclare final package Medium = Medium1,
          nPorts = 2,
          V=m1_flow_nominal*tau1/rho1_nominal,
          final m_flow_nominal=m1_flow_nominal,
          energyDynamics=if tau1 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=if tau1 > Modelica.Constants.eps
                               then massDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          final p_start=p1_start,
          final T_start=T1_start,
          final X_start=X1_start,
          final C_start=C1_start,
          final C_nominal=C1_nominal) "Volume for fluid 1"
                                     annotation (Placement(transformation(extent={{-10,80},
                  {10,60}})));

        IBPSA.Fluid.MixingVolumes.MixingVolume vol2(
          redeclare final package Medium = Medium2,
          nPorts=2,
          energyDynamics=if tau2 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=if tau2 > Modelica.Constants.eps
                               then massDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          final p_start=p2_start,
          final T_start=T2_start,
          final X_start=X2_start,
          final C_start=C2_start,
          final C_nominal=C2_nominal,
          final m_flow_nominal=m2_flow_nominal,
          V=m2_flow_nominal*tau2/rho2_nominal) "Volume for fluid 2"
                                     annotation (Placement(transformation(extent={{50,10},
                  {70,-10}})));

        IBPSA.Fluid.MixingVolumes.MixingVolume vol3(
          redeclare final package Medium = Medium3,
          energyDynamics=if tau3 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=if tau3 > Modelica.Constants.eps
                               then massDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          final p_start=p3_start,
          final T_start=T3_start,
          final X_start=X3_start,
          final C_start=C3_start,
          final C_nominal=C3_nominal,
          final m_flow_nominal=m3_flow_nominal,
          V=m3_flow_nominal*tau3/rho3_nominal,
          nPorts=2) "Volume for fluid 3"
         annotation (Placement(transformation(
              origin={0,-60},
              extent={{10,10},{-10,-10}},
              rotation=180)));
        IBPSA.Fluid.MixingVolumes.MixingVolume vol4(
          redeclare final package Medium = Medium4,
          nPorts=2,
          energyDynamics=if tau4 > Modelica.Constants.eps
                               then energyDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=if tau4 > Modelica.Constants.eps
                               then massDynamics else
                               Modelica.Fluid.Types.Dynamics.SteadyState,
          final p_start=p4_start,
          final T_start=T4_start,
          final X_start=X4_start,
          final C_start=C4_start,
          final C_nominal=C4_nominal,
          final m_flow_nominal=m4_flow_nominal,
          V=m4_flow_nominal*tau4/rho4_nominal) "Volume for fluid 4"
                                     annotation (Placement(transformation(extent={{-50,-10},
                  {-70,10}})));

        IBPSA.Fluid.FixedResistances.PressureDrop preDro1(
          redeclare final package Medium = Medium1,
          final m_flow_nominal=m1_flow_nominal,
          final deltaM=deltaM1,
          final allowFlowReversal=allowFlowReversal1,
          final show_T=false,
          final from_dp=from_dp1,
          final linearized=linearizeFlowResistance1,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp1_nominal) "Pressure drop model for fluid 1"
          annotation (Placement(transformation(extent={{-80,70},{-60,90}})));

        IBPSA.Fluid.FixedResistances.PressureDrop preDro2(
          redeclare final package Medium = Medium2,
          final m_flow_nominal=m2_flow_nominal,
          final deltaM=deltaM2,
          final allowFlowReversal=allowFlowReversal2,
          final show_T=false,
          final from_dp=from_dp2,
          final linearized=linearizeFlowResistance2,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp2_nominal) "Pressure drop model for fluid 2"
          annotation (Placement(transformation(extent={{90,20},{70,40}})));
        IBPSA.Fluid.FixedResistances.PressureDrop preDro3(
          redeclare final package Medium = Medium3,
          final m_flow_nominal=m3_flow_nominal,
          final deltaM=deltaM3,
          final allowFlowReversal=allowFlowReversal3,
          final show_T=false,
          final from_dp=from_dp3,
          final linearized=linearizeFlowResistance3,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp3_nominal) "Pressure drop model for fluid 3"
          annotation (Placement(transformation(extent={{-90,-42},{-70,-22}})));

        IBPSA.Fluid.FixedResistances.PressureDrop preDro4(
          redeclare final package Medium = Medium4,
          final m_flow_nominal=m4_flow_nominal,
          final deltaM=deltaM4,
          final allowFlowReversal=allowFlowReversal4,
          final show_T=false,
          final from_dp=from_dp4,
          final linearized=linearizeFlowResistance4,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp4_nominal) "Pressure drop model for fluid 4"
          annotation (Placement(transformation(extent={{86,-90},{66,-70}})));
    protected
        parameter Medium1.ThermodynamicState sta1_nominal=Medium1.setState_pTX(
            T=Medium1.T_default, p=Medium1.p_default, X=Medium1.X_default);
        parameter Modelica.SIunits.Density rho1_nominal=Medium1.density(sta1_nominal)
          "Density, used to compute fluid volume";
        parameter Medium2.ThermodynamicState sta2_nominal=Medium2.setState_pTX(
            T=Medium2.T_default, p=Medium2.p_default, X=Medium2.X_default);
        parameter Modelica.SIunits.Density rho2_nominal=Medium2.density(sta2_nominal)
          "Density, used to compute fluid volume";
        parameter Medium1.ThermodynamicState sta3_nominal=Medium3.setState_pTX(
            T=Medium3.T_default, p=Medium3.p_default, X=Medium3.X_default);
        parameter Modelica.SIunits.Density rho3_nominal=Medium3.density(sta3_nominal)
          "Density, used to compute fluid volume";
        parameter Medium4.ThermodynamicState sta4_nominal=Medium4.setState_pTX(
            T=Medium4.T_default, p=Medium4.p_default, X=Medium4.X_default);
        parameter Modelica.SIunits.Density rho4_nominal=Medium4.density(sta4_nominal)
          "Density, used to compute fluid volume";

        parameter Medium1.ThermodynamicState sta1_start=Medium1.setState_pTX(
            T=T1_start, p=p1_start, X=X1_start);
        parameter Modelica.SIunits.SpecificEnthalpy h1_outflow_start = Medium1.specificEnthalpy(sta1_start)
          "Start value for outflowing enthalpy";
        parameter Medium2.ThermodynamicState sta2_start=Medium2.setState_pTX(
            T=T2_start, p=p2_start, X=X2_start);
        parameter Modelica.SIunits.SpecificEnthalpy h2_outflow_start = Medium2.specificEnthalpy(sta2_start)
          "Start value for outflowing enthalpy";
        parameter Medium3.ThermodynamicState sta3_start=Medium3.setState_pTX(
            T=T3_start, p=p3_start, X=X3_start);
        parameter Modelica.SIunits.SpecificEnthalpy h3_outflow_start = Medium3.specificEnthalpy(sta3_start)
          "Start value for outflowing enthalpy";
        parameter Medium4.ThermodynamicState sta4_start=Medium4.setState_pTX(
            T=T4_start, p=p4_start, X=X4_start);
        parameter Modelica.SIunits.SpecificEnthalpy h4_outflow_start = Medium4.specificEnthalpy(sta4_start)
          "Start value for outflowing enthalpy";

      initial algorithm
        // Check for tau1
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau1 > Modelica.Constants.eps,
      "The parameter tau1, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau1 = "       + String(tau1) + "\n");
        assert((massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau1 > Modelica.Constants.eps,
      "The parameter tau1, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau1 = "       + String(tau1) + "\n");

       // Check for tau2
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau2 > Modelica.Constants.eps,
      "The parameter tau2, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau2 = "       + String(tau2) + "\n");
        assert((massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau2 > Modelica.Constants.eps,
      "The parameter tau2, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau2 = "       + String(tau2) + "\n");

        // Check for tau1
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau3 > Modelica.Constants.eps,
      "The parameter tau3, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau3 = "       + String(tau3) + "\n");
        assert((massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau3 > Modelica.Constants.eps,
      "The parameter tau3, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau3 = "       + String(tau3) + "\n");

       // Check for tau2
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau4 > Modelica.Constants.eps,
      "The parameter tau4, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau4 = "       + String(tau4) + "\n");
        assert((massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau4 > Modelica.Constants.eps,
      "The parameter tau4, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau4 = "       + String(tau4) + "\n");


      equation
        connect(vol1.ports[2], port_b1) annotation (Line(
            points={{2,80},{100,80}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(port_a1, preDro1.port_a) annotation (Line(
            points={{-100,80},{-90,80},{-90,80},{-80,80}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(preDro1.port_b, vol1.ports[1]) annotation (Line(
            points={{-60,80},{-2,80}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(port_a2, preDro2.port_a) annotation (Line(
            points={{100,30},{90,30}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(preDro4.port_a, port_a4) annotation (Line(
            points={{86,-80},{100,-80}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(preDro4.port_b, vol4.ports[1]) annotation (Line(
            points={{66,-80},{-58,-80},{-58,-10}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(port_b4, vol4.ports[2]) annotation (Line(
            points={{-100,-80},{-62,-80},{-62,-10}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(port_a3, preDro3.port_a) annotation (Line(
            points={{-100,-32},{-90,-32}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(preDro3.port_b, vol3.ports[1]) annotation (Line(
            points={{-70,-32},{-54,-32},{-54,-76},{-2,-76},{-2,-70}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(port_b3, vol3.ports[2]) annotation (Line(
            points={{100,-30},{90,-30},{90,-66},{62,-66},{62,-76},{2,-76},{2,-70}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(port_b2, vol2.ports[1]) annotation (Line(
            points={{-100,30},{58,30},{58,10}},
            color={0,127,255},
            smooth=Smooth.None));
        connect(preDro2.port_b, vol2.ports[2]) annotation (Line(
            points={{70,30},{62,30},{62,10}},
            color={0,127,255},
            smooth=Smooth.None));
        annotation (
          Documentation(info="<html>
<p>This component transports four fluid streams between eight ports. It provides the basic model for implementing a dynamic heat exchanger. </p>
<p>The model can be used as-is, although there will be no heat or mass transfer between the four fluid streams. To add heat transfer, heat flow can be added to the heat port of the four volumes.</p>
<h4>Implementation</h4>
<p>The variable names follow the conventions used in <a href=\"modelica://Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX\">Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX</a>. </p>
</html>",       revisions="<html>
<ul>
<li>July 18, 2018, by Massimo Cimmino:
<br/>Remove start values of m_flow and dp variables.
</li>
</ul>
<ul>
<li>July 2014, by Damien Picard:<br/>First implementation. </li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,93},{69,-100}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-99,85},{102,75}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-98,35},{103,25}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-96,-27},{105,-37}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-101,-78},{100,-88}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
          Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics));
      end EightPortHeatMassExchanger;

      partial model PartialEightPortInterface
        "Partial model transporting fluid between eight ports without storing mass or energy"
        extends IBPSA.Fluid.Interfaces.EightPort;
        parameter Modelica.SIunits.MassFlowRate m1_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m2_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.MassFlowRate m3_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m4_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));

        parameter Medium1.MassFlowRate m1_flow_small(min=0) = 1E-4*abs(m1_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium2.MassFlowRate m2_flow_small(min=0) = 1E-4*abs(m2_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium3.MassFlowRate m3_flow_small(min=0) = 1E-4*abs(m3_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium4.MassFlowRate m4_flow_small(min=0) = 1E-4*abs(m4_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));

        // Diagnostics
        parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        Medium1.MassFlowRate m1_flow = port_a1.m_flow
          "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
        Modelica.SIunits.Pressure dp1(displayUnit="Pa")
          "Pressure difference between port_a1 and port_b1";
        Medium2.MassFlowRate m2_flow = port_a2.m_flow
          "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
        Modelica.SIunits.Pressure dp2(displayUnit="Pa")
          "Pressure difference between port_a2 and port_b2";

        Medium3.MassFlowRate m3_flow = port_a3.m_flow
          "Mass flow rate from port_a3 to port_b3 (m3_flow > 0 is design flow direction)";
        Modelica.SIunits.Pressure dp3(displayUnit="Pa")
          "Pressure difference between port_a3 and port_b3";
        Medium4.MassFlowRate m4_flow = port_a4.m_flow
          "Mass flow rate from port_a4 to port_b4 (m4_flow > 0 is design flow direction)";
        Modelica.SIunits.Pressure dp4(displayUnit="Pa")
          "Pressure difference between port_a4 and port_b4";

        Medium1.ThermodynamicState sta_a1=
            Medium1.setState_phX(port_a1.p,
                                 noEvent(actualStream(port_a1.h_outflow)),
                                 noEvent(actualStream(port_a1.Xi_outflow))) if
               show_T "Medium properties in port_a1";
        Medium1.ThermodynamicState sta_b1=
            Medium1.setState_phX(port_b1.p,
                                 noEvent(actualStream(port_b1.h_outflow)),
                                 noEvent(actualStream(port_b1.Xi_outflow))) if
               show_T "Medium properties in port_b1";
        Medium2.ThermodynamicState sta_a2=
            Medium2.setState_phX(port_a2.p,
                                 noEvent(actualStream(port_a2.h_outflow)),
                                 noEvent(actualStream(port_a2.Xi_outflow))) if
               show_T "Medium properties in port_a2";
        Medium2.ThermodynamicState sta_b2=
            Medium2.setState_phX(port_b2.p,
                                 noEvent(actualStream(port_b2.h_outflow)),
                                 noEvent(actualStream(port_b2.Xi_outflow))) if
               show_T "Medium properties in port_b2";

       Medium3.ThermodynamicState sta_a3=
            Medium3.setState_phX(port_a3.p,
                                 noEvent(actualStream(port_a3.h_outflow)),
                                 noEvent(actualStream(port_a3.Xi_outflow))) if
               show_T "Medium properties in port_a3";
        Medium3.ThermodynamicState sta_b3=
            Medium3.setState_phX(port_b3.p,
                                 noEvent(actualStream(port_b3.h_outflow)),
                                 noEvent(actualStream(port_b3.Xi_outflow))) if
               show_T "Medium properties in port_b3";
        Medium4.ThermodynamicState sta_a4=
            Medium4.setState_phX(port_a4.p,
                                 noEvent(actualStream(port_a4.h_outflow)),
                                 noEvent(actualStream(port_a4.Xi_outflow))) if
               show_T "Medium properties in port_a4";
        Medium4.ThermodynamicState sta_b4=
            Medium4.setState_phX(port_b4.p,
                                 noEvent(actualStream(port_b4.h_outflow)),
                                 noEvent(actualStream(port_b4.Xi_outflow))) if
               show_T "Medium properties in port_b4";
    protected
        Medium1.ThermodynamicState state_a1_inflow=
          Medium1.setState_phX(port_a1.p, inStream(port_a1.h_outflow), inStream(port_a1.Xi_outflow))
          "state for medium inflowing through port_a1";
        Medium1.ThermodynamicState state_b1_inflow=
          Medium1.setState_phX(port_b1.p, inStream(port_b1.h_outflow), inStream(port_b1.Xi_outflow))
          "state for medium inflowing through port_b1";
        Medium2.ThermodynamicState state_a2_inflow=
          Medium2.setState_phX(port_a2.p, inStream(port_a2.h_outflow), inStream(port_a2.Xi_outflow))
          "state for medium inflowing through port_a2";
        Medium2.ThermodynamicState state_b2_inflow=
          Medium2.setState_phX(port_b2.p, inStream(port_b2.h_outflow), inStream(port_b2.Xi_outflow))
          "state for medium inflowing through port_b2";
        Medium3.ThermodynamicState state_a3_inflow=
          Medium3.setState_phX(port_a3.p, inStream(port_a3.h_outflow), inStream(port_a3.Xi_outflow))
          "state for medium inflowing through port_a3";
        Medium3.ThermodynamicState state_b3_inflow=
          Medium3.setState_phX(port_b3.p, inStream(port_b3.h_outflow), inStream(port_b3.Xi_outflow))
          "state for medium inflowing through port_b3";
        Medium4.ThermodynamicState state_a4_inflow=
          Medium4.setState_phX(port_a4.p, inStream(port_a4.h_outflow), inStream(port_a4.Xi_outflow))
          "state for medium inflowing through port_a4";
        Medium4.ThermodynamicState state_b4_inflow=
          Medium4.setState_phX(port_b4.p, inStream(port_b4.h_outflow), inStream(port_b4.Xi_outflow))
          "state for medium inflowing through port_b4";
      equation
        dp1 = port_a1.p - port_b1.p;
        dp2 = port_a2.p - port_b2.p;
        dp3 = port_a3.p - port_b3.p;
        dp4 = port_a4.p - port_b4.p;
        annotation (
        preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models that transport four fluid streams between eight ports.
It is similar to <a href=\"modelica://IBPSA.Fluid.Interfaces.PartialTwoPortInterface\">IBPSA.Fluid.Interfaces.PartialTwoPortInterface</a>,
but it has eight ports instead of two. </p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 12, 2019, by Michael Wetter:<br/>
Corrected wrong medium in declaration of <code>m4_flow</code>.
</li>
<li>
July 2014, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}),
                          graphics),
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics));
      end PartialEightPortInterface;

      partial model PartialFourPort "Partial model with four ports"

        replaceable package Medium1 =
          Modelica.Media.Interfaces.PartialMedium "Medium 1 in the component"
            annotation (choices(
              choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
              choice(redeclare package Medium = IBPSA.Media.Water "Water"),
              choice(redeclare package Medium =
                  IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));
        replaceable package Medium2 =
          Modelica.Media.Interfaces.PartialMedium "Medium 2 in the component"
            annotation (choices(
              choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
              choice(redeclare package Medium = IBPSA.Media.Water "Water"),
              choice(redeclare package Medium =
                  IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal1 = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Boolean allowFlowReversal2 = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a1(
                           redeclare final package Medium = Medium1,
                           m_flow(min=if allowFlowReversal1 then -Modelica.Constants.inf else 0),
                           h_outflow(start = Medium1.h_default, nominal = Medium1.h_default))
          "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{-110,50},{-90,70}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b1(
                           redeclare final package Medium = Medium1,
                           m_flow(max=if allowFlowReversal1 then +Modelica.Constants.inf else 0),
                           h_outflow(start = Medium1.h_default, nominal = Medium1.h_default))
          "Fluid connector b1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{110,50},{90,70}})));

        Modelica.Fluid.Interfaces.FluidPort_a port_a2(
                           redeclare final package Medium = Medium2,
                           m_flow(min=if allowFlowReversal2 then -Modelica.Constants.inf else 0),
                           h_outflow(start = Medium2.h_default, nominal = Medium2.h_default))
          "Fluid connector a2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b2(
                           redeclare final package Medium = Medium2,
                           m_flow(max=if allowFlowReversal2 then +Modelica.Constants.inf else 0),
                           h_outflow(start = Medium2.h_default, nominal = Medium2.h_default))
          "Fluid connector b2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{-90,-70},{-110,-50}})));

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model defines an interface for components with four ports.
The parameters <code>allowFlowReversal1</code> and
<code>allowFlowReversal2</code> may be used by models that extend
this model to treat flow reversal.
</p>
<p>
This model is identical to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>, except for the
fowllowing:
</p>
<ol>
<li>it has four ports, and
</li>
<li>
the parameters <code>port_a_exposesState</code>,
<code>port_b_exposesState</code> and
<code>showDesignFlowDirection</code>
are not implemented.
</li>
</ol>
</html>",       revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Renamed model from <code>FourPort</code> to
<code>PartialFourPort</code>.
Removed parameters
<code>h_outflow_a1_start</code>,
<code>h_outflow_b1_start</code>,
<code>h_outflow_a2_start</code> and
<code>h_outflow_b2_start</code>.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/299\">#299</a>.
</li>
<li>
October 30, 2015, by Matthis Thorade:<br/>
Added <code>partial</code> keyword to model declaration.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
September 26, 2013 by Michael Wetter:<br/>
Added missing <code>each</code> keyword in declaration of nominal value for
<code>Xi_outflow</code>.
</li>
<li>
September 17, 2010 by Michael Wetter:<br/>
Fixed bug: The start value for <code>port_b1.h_outflow</code>
was set to <code>h_outflow_b2_start</code> instead of <code>h_outflow_b1_start</code>.
</li>
<li>
February 26, 2010 by Michael Wetter:<br/>
Added start values for outflowing enthalpy because they
are often iteration variables in nonlinear equation systems.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={Text(
                extent={{-151,147},{149,107}},
                lineColor={0,0,255},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255},
                textString="%name")}));
      end PartialFourPort;

      partial model PartialFourPortInterface
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends IBPSA.Fluid.Interfaces.PartialFourPort;
        parameter Modelica.SIunits.MassFlowRate m1_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m2_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Medium1.MassFlowRate m1_flow_small(min=0) = 1E-4*abs(m1_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium2.MassFlowRate m2_flow_small(min=0) = 1E-4*abs(m2_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
        parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));

        Medium1.MassFlowRate m1_flow = port_a1.m_flow
          "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
        Modelica.SIunits.PressureDifference dp1(displayUnit="Pa") = port_a1.p - port_b1.p
          "Pressure difference between port_a1 and port_b1";

        Medium2.MassFlowRate m2_flow = port_a2.m_flow
          "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
        Modelica.SIunits.PressureDifference dp2(displayUnit="Pa") = port_a2.p - port_b2.p
          "Pressure difference between port_a2 and port_b2";

        Medium1.ThermodynamicState sta_a1=
            Medium1.setState_phX(port_a1.p,
                                 noEvent(actualStream(port_a1.h_outflow)),
                                 noEvent(actualStream(port_a1.Xi_outflow))) if
               show_T "Medium properties in port_a1";
        Medium1.ThermodynamicState sta_b1=
            Medium1.setState_phX(port_b1.p,
                                 noEvent(actualStream(port_b1.h_outflow)),
                                 noEvent(actualStream(port_b1.Xi_outflow))) if
               show_T "Medium properties in port_b1";
        Medium2.ThermodynamicState sta_a2=
            Medium2.setState_phX(port_a2.p,
                                 noEvent(actualStream(port_a2.h_outflow)),
                                 noEvent(actualStream(port_a2.Xi_outflow))) if
               show_T "Medium properties in port_a2";
        Medium2.ThermodynamicState sta_b2=
            Medium2.setState_phX(port_b2.p,
                                 noEvent(actualStream(port_b2.h_outflow)),
                                 noEvent(actualStream(port_b2.Xi_outflow))) if
               show_T "Medium properties in port_b2";
    protected
        Medium1.ThermodynamicState state_a1_inflow=
          Medium1.setState_phX(port_a1.p, inStream(port_a1.h_outflow), inStream(port_a1.Xi_outflow))
          "state for medium inflowing through port_a1";
        Medium1.ThermodynamicState state_b1_inflow=
          Medium1.setState_phX(port_b1.p, inStream(port_b1.h_outflow), inStream(port_b1.Xi_outflow))
          "state for medium inflowing through port_b1";
        Medium2.ThermodynamicState state_a2_inflow=
          Medium2.setState_phX(port_a2.p, inStream(port_a2.h_outflow), inStream(port_a2.Xi_outflow))
          "state for medium inflowing through port_a2";
        Medium2.ThermodynamicState state_b2_inflow=
          Medium2.setState_phX(port_b2.p, inStream(port_b2.h_outflow), inStream(port_b2.Xi_outflow))
          "state for medium inflowing through port_b2";

        annotation (
        preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models that
transport two fluid streams between four ports.
It is similar to
<a href=\"modelica://IBPSA.Fluid.Interfaces.PartialTwoPortInterface\">
IBPSA.Fluid.Interfaces.PartialTwoPortInterface</a>,
but it has four ports instead of two.
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Removed assignment of <code>min</code> and <code>max</code>
attributes of port mass flow rates, as this is already
done in the base class.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a1</code>,
<code>sta_a2</code>, <code>sta_b1</code> and <code>sta_b2</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definitions of <code>dp1</code> and <code>dp2</code> because they cause some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Replaced the erroneous function call <code>Medium.density</code> with
<code>Medium1.density</code> and <code>Medium2.density</code>.
Changed condition to remove <code>sta_a1</code> and <code>sta_a2</code> to also
compute the states at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialFourPortInterface;

      partial model PartialTwoPort "Partial component with two ports"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choices(
              choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
              choice(redeclare package Medium = IBPSA.Media.Water "Water"),
              choice(redeclare package Medium =
                  IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a(
          redeclare final package Medium = Medium,
           m_flow(min=if allowFlowReversal then -Modelica.Constants.inf else 0),
           h_outflow(start = Medium.h_default, nominal = Medium.h_default))
          "Fluid connector a (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(
          redeclare final package Medium = Medium,
          m_flow(max=if allowFlowReversal then +Modelica.Constants.inf else 0),
           h_outflow(start = Medium.h_default, nominal = Medium.h_default))
          "Fluid connector b (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{110,-10},{90,10}})));

        annotation (
          Documentation(info="<html>
<p>
This partial model defines an interface for components with two ports.
The treatment of the design flow direction and of flow reversal are predefined based on the parameter <code>allowFlowReversal</code>.
The component may transport fluid and may have internal storage for a given fluid <code>Medium</code>.
</p>
<h4>Implementation</h4>
<p>
This model is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>
but it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed parameters
<code>port_a_exposesState</code> and
<code>port_b_exposesState</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/351\">#351</a>
and
<code>showDesignFlowDirection</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
November 13, 2015, by Michael Wetter:<br/>
Assinged <code>start</code> attribute for leaving
enthalpy at <code>port_a</code> and <code>port_b</code>.
This was done to make the model similar to
<a href=\"modelica://IBPSA.Fluid.Interfaces.PartialFourPort\">
IBPSA.Fluid.Interfaces.PartialFourPort</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Removed import statement.
</li>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
Declared medium in ports to be <code>final</code>.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Polygon(
                points={{20,-70},{60,-85},{20,-100},{20,-70}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=not allowFlowReversal),
              Line(
                points={{55,-85},{-60,-85}},
                color={0,128,255},
                visible=not allowFlowReversal),
              Text(
                extent={{-149,-114},{151,-154}},
                lineColor={0,0,255},
                textString="%name")}));
      end PartialTwoPort;

      partial model PartialTwoPortInterface
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends IBPSA.Fluid.Interfaces.PartialTwoPort(
          port_a(p(start=Medium.p_default)),
          port_b(p(start=Medium.p_default)));

        parameter Modelica.SIunits.MassFlowRate m_flow_nominal
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
         parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));

        Modelica.SIunits.MassFlowRate m_flow(start=_m_flow_start) = port_a.m_flow
          "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";

        Modelica.SIunits.PressureDifference dp(start=_dp_start, displayUnit="Pa") = port_a.p - port_b.p
          "Pressure difference between port_a and port_b";

        Medium.ThermodynamicState sta_a=
            Medium.setState_phX(port_a.p,
                                noEvent(actualStream(port_a.h_outflow)),
                                noEvent(actualStream(port_a.Xi_outflow))) if
               show_T "Medium properties in port_a";

        Medium.ThermodynamicState sta_b=
            Medium.setState_phX(port_b.p,
                                noEvent(actualStream(port_b.h_outflow)),
                                noEvent(actualStream(port_b.Xi_outflow))) if
                show_T "Medium properties in port_b";

    protected
        final parameter Modelica.SIunits.MassFlowRate _m_flow_start = 0
        "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window";
        final parameter Modelica.SIunits.PressureDifference _dp_start(displayUnit="Pa") = 0
        "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window";

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models that
transports a fluid between two ports. It is similar to
<a href=\"Modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>, but it does not
include the species balance
</p>
<pre>
  port_b.Xi_outflow = inStream(port_a.Xi_outflow);
</pre>
<p>
Thus, it can be used as a base class for a heat <i>and</i> mass transfer component
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations. See for example
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Renamed protected parameter <code>m_flow_start</code> to avoid
a name clash with
<a href=\"modelica://IBPSA.Fluid.Movers.FlowControlled_m_flow\">
IBPSA.Fluid.Movers.FlowControlled_m_flow</a>
which leads to an error as the definition were different,
and also renamed protected parameter <code>dp_start</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>
<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a</code> and <code>sta_b</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definition of <code>dp</code> because it causes some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Changed condition to remove <code>sta_a</code> to also
compute the state at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
March 11, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortInterface;

      model StaticFourPortHeatMassExchanger
        "Partial model transporting two fluid streams between four ports without storing mass or energy"
        extends IBPSA.Fluid.Interfaces.PartialFourPortInterface;
        extends IBPSA.Fluid.Interfaces.FourPortFlowResistanceParameters(
         final computeFlowResistance1=(dp1_nominal > Modelica.Constants.eps),
         final computeFlowResistance2=(dp2_nominal > Modelica.Constants.eps));

        constant Boolean prescribedHeatFlowRate1 = false
          "Set to true if the heat flow rate into fluid 1 is not a function of the component temperature";
        constant Boolean prescribedHeatFlowRate2 = false
          "Set to true if the heat flow rate into fluid 2 is not a function of the component temperature";

        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        // Q1_flow is sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q1_flow
          "Heat transferred into the medium 1";
        input Medium1.MassFlowRate mWat1_flow
          "Moisture mass flow rate added to the medium 1";
        // Q2_flow is sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q2_flow
          "Heat transferred into the medium 2";
        input Medium2.MassFlowRate mWat2_flow
          "Moisture mass flow rate added to the medium 2";
        constant Boolean sensibleOnly1
          "Set to true if sensible exchange only for medium 1";
        constant Boolean sensibleOnly2
          "Set to true if sensible exchange only for medium 2";

    protected
        IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal1(
          redeclare final package Medium=Medium1,
          final sensibleOnly = sensibleOnly1,
          final prescribedHeatFlowRate=prescribedHeatFlowRate1,
          final m_flow_nominal = m1_flow_nominal,
          final dp_nominal = dp1_nominal,
          final allowFlowReversal = allowFlowReversal1,
          final m_flow_small = m1_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final from_dp = from_dp1,
          final linearizeFlowResistance = linearizeFlowResistance1,
          final deltaM = deltaM1,
          final Q_flow = Q1_flow,
          final mWat_flow = mWat1_flow)
          "Model for heat, mass, species, trace substance and pressure balance of stream 1";
        IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal2(
          redeclare final package Medium=Medium2,
          final sensibleOnly = sensibleOnly2,
          final prescribedHeatFlowRate=prescribedHeatFlowRate2,
          final m_flow_nominal = m2_flow_nominal,
          final dp_nominal = dp2_nominal,
          final allowFlowReversal = allowFlowReversal2,
          final m_flow_small = m2_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final from_dp = from_dp2,
          final linearizeFlowResistance = linearizeFlowResistance2,
          final deltaM = deltaM2,
          final Q_flow = Q2_flow,
          final mWat_flow = mWat2_flow)
          "Model for heat, mass, species, trace substance and pressure balance of stream 2";
      equation
        connect(bal1.port_a, port_a1);
        connect(bal1.port_b, port_b1);
        connect(bal2.port_a, port_a2);
        connect(bal2.port_b, port_b2);
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component transports two fluid streams between four ports, without
storing mass or energy. It is similar to
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>,
but it has four ports instead of two.
</p>
<p>
If <code>dp<i>N</i>_nominal &gt; Modelica.Constants.eps</code>,
where <code><i>N</i></code> denotes the fluid <i>1</i> or <i>2</i>,
then the model computes
pressure drop due to flow friction in the respective fluid stream.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m<i>N</i>_flow_nominal, dp<i>N</i>_nominal)</code>.
At <code>|m<i>N</i>_flow| &lt; deltaM<i>N</i> * m<i>N</i>_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance<i>N</i></code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>

<h4>Implementation</h4>
<p>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned, where <code><i>N</i></code> denotes <code>1</code> or
<code>2</code>:</p>
<ul>
<li>
<code>Q<i>N</i>_flow</code>, which is the sensible and latent heat flow rate added to the medium <i>N</i>.
</li>
<li>
<code>mWat<i>N</i>_flow</code>, which is the moisture mass flow rate added to the medium <i>N</i>.
</li>
</ul>
<p>
Set the constant <code>sensibleOnly<i>N</i>=true</code> if the model that extends
or instantiates this model sets <code>mWat<i>N</i>_flow = 0</code>.
</p>
<p>
     Note that the model does not implement <code>0 = Q1_flow + Q2_flow</code> or
     <code>0 = mXi1_flow + mXi2_flow</code>. If there is no heat or mass transfer
     with the environment, then a model that extends this model needs to provide these
     equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 11, 2017, by Michael Wetter:<br/>
Updated documentation to make clear that <code>Q1_flow</code> and <code>Q2_flow</code>
include latent heat flow rate.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>bal1</code> and <code>bal2</code>
as this constant has been removed in
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Added parameter <code>homotopyInitialization</code> as
it has been removed in the base class.
</li>
<li>
November 13, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constants <code>sensibleOnly1</code> and
<code>sensibleOnly2</code> to
simplify species balance equations.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
March 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,65},{101,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}));
      end StaticFourPortHeatMassExchanger;

      model StaticTwoPortConservationEquation
        "Partial model for static energy and mass conservation equations"
        extends IBPSA.Fluid.Interfaces.PartialTwoPortInterface;

        constant Boolean simplify_mWat_flow = true
          "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

        constant Boolean prescribedHeatFlowRate = false
          "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";

        parameter Boolean use_mWat_flow = false
          "Set to true to enable input connector for moisture mass flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transferred into the medium"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       unit="kg/s") if
             use_mWat_flow "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if
             use_C_flow "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                   start=Medium.specificEnthalpy_pTX(
                                                           p=Medium.p_default,
                                                           T=Medium.T_default,
                                                           X=Medium.X_default))
          "Leaving specific enthalpy of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));

        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));

    protected
        final parameter Boolean use_m_flowInv=
          (prescribedHeatFlowRate or use_mWat_flow or use_C_flow)
          "Flag, true if m_flowInv is used in the model"
          annotation (Evaluate=true);
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";

        Real m_flowInv(unit="s/kg") "Regularization of 1/m_flow of port_a";

        Modelica.SIunits.MassFlowRate mXi_flow[Medium.nXi]
          "Mass flow rates of independent substances added to the medium";

        // Parameters for inverseXRegularized.
        // These are assigned here for efficiency reason.
        // Otherwise, they would need to be computed each time
        // the function is invocated.
        final parameter Real deltaReg = m_flow_small/1E3
          "Smoothing region for inverseXRegularized";

        final parameter Real deltaInvReg = 1/deltaReg
          "Inverse value of delta for inverseXRegularized";

        final parameter Real aReg = -15*deltaInvReg
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real bReg = 119*deltaInvReg^2
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real cReg = -361*deltaInvReg^3
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real dReg = 534*deltaInvReg^4
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real eReg = -380*deltaInvReg^5
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real fReg = 104*deltaInvReg^6
          "Polynomial coefficient for inverseXRegularized";

        final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
        // Density at medium default values, used to compute the size of control volumes
        final parameter Modelica.SIunits.SpecificHeatCapacity cp_default=
          Medium.specificHeatCapacityCp(state=state_default)
          "Specific heat capacity, used to verify energy conservation";
        constant Modelica.SIunits.TemperatureDifference dTMax(min=1) = 200
          "Maximum temperature difference across the StaticTwoPortConservationEquation";
        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
          "Needed to connect to conditional connector";
      initial equation
        // Assert that the substance with name 'water' has been found.
        assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "If Medium.nXi > 1, then substance 'water' must be present for one component.'"
               + Medium.mediumName + "'.\n"
               + "Check medium model.");

      equation
        // Conditional connectors
        connect(mWat_flow, mWat_flow_internal);
        if not use_mWat_flow then
          mWat_flow_internal = 0;
        end if;

        connect(C_flow, C_flow_internal);
        if not use_C_flow then
          C_flow_internal = zeros(Medium.nC);
        end if;

        // Species flow rate from connector mWat_flow
        mXi_flow = mWat_flow_internal * s;

        // Regularization of m_flow around the origin to avoid a division by zero
        // m_flowInv is only used if prescribedHeatFlowRate == true, or
        // if the input connectors mWat_flow or C_flow are enabled.
        if use_m_flowInv then
          m_flowInv = IBPSA.Utilities.Math.Functions.inverseXRegularized(
                             x=port_a.m_flow,
                             delta=deltaReg, deltaInv=deltaInvReg,
                             a=aReg, b=bReg, c=cReg, d=dReg, e=eReg, f=fReg);
        else
          // m_flowInv is not used.
          m_flowInv = 0;
        end if;

        if prescribedHeatFlowRate then
          assert(noEvent( abs(Q_flow) < dTMax*cp_default*max(m_flow_small/1E3, abs(m_flow))),
         "In " + getInstanceName() + ":
   The heat flow rate equals "       + String(Q_flow) +
         " W and the mass flow rate equals " + String(m_flow) + " kg/s,
   which results in a temperature difference "       +
         String(abs(Q_flow)/ (cp_default*max(m_flow_small/1E3, abs(m_flow)))) +
         " K > dTMax=" +String(dTMax) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
        end if;

        if allowFlowReversal then
          // Formulate hOut using spliceFunction. This avoids an event iteration.
          // The introduced error is small because deltax=m_flow_small/1e3
          hOut = IBPSA.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                          y2=port_a.h_outflow,
                                                          x=port_a.m_flow,
                                                          x_small=m_flow_small/1E3);
          XiOut = IBPSA.Utilities.Math.Functions.regStep(y1=port_b.Xi_outflow,
                                                           y2=port_a.Xi_outflow,
                                                           x=port_a.m_flow,
                                                           x_small=m_flow_small/1E3);
          COut = IBPSA.Utilities.Math.Functions.regStep(y1=port_b.C_outflow,
                                                          y2=port_a.C_outflow,
                                                          x=port_a.m_flow,
                                                          x_small=m_flow_small/1E3);
        else
          hOut =  port_b.h_outflow;
          XiOut = port_b.Xi_outflow;
          COut =  port_b.C_outflow;
        end if;

        //////////////////////////////////////////////////////////////////////////////////////////
        // Energy balance and mass balance

          // Mass balance (no storage)
          port_a.m_flow + port_b.m_flow = if simplify_mWat_flow then 0 else -mWat_flow_internal;

          // Substance balance
          // a) forward flow
          if use_m_flowInv then
            port_b.Xi_outflow = inStream(port_a.Xi_outflow) + mXi_flow * m_flowInv;
          else // no water is added
            assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for forward flow.");
            port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          end if;

          // b) backward flow
          if allowFlowReversal then
            if use_m_flowInv then
              port_a.Xi_outflow = inStream(port_b.Xi_outflow) - mXi_flow * m_flowInv;
            else // no water added
              assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for reverse flow.");
              port_a.Xi_outflow = inStream(port_b.Xi_outflow);
            end if;
          else // no  flow reversal
            port_a.Xi_outflow = Medium.X_default[1:Medium.nXi];
          end if;

          // Energy balance.
          // This equation is approximate since m_flow = port_a.m_flow is used for the mass flow rate
          // at both ports. Since mWat_flow_internal << m_flow, the error is small.
          if prescribedHeatFlowRate then
            port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
            if allowFlowReversal then
              port_a.h_outflow = inStream(port_b.h_outflow) - Q_flow * m_flowInv;
            else
              port_a.h_outflow = Medium.h_default;
            end if;
          else
            // Case with prescribedHeatFlowRate == false.
            // port_b.h_outflow is known and the equation needs to be solved for Q_flow.
            // Hence, we cannot use m_flowInv as for m_flow=0, any Q_flow would satisfiy
            // Q_flow * m_flowInv = 0.
            // The same applies for port_b.Xi_outflow and mXi_flow.
            port_a.m_flow * (inStream(port_a.h_outflow) - port_b.h_outflow)     = -Q_flow;
            if allowFlowReversal then
              port_a.m_flow * (inStream(port_b.h_outflow)  - port_a.h_outflow)  = +Q_flow;
            else
              // When allowFlowReversal = false, the downstream enthalpy does not matter.
              // Therefore a dummy value is used to avoid algebraic loops
              port_a.h_outflow = Medium.h_default;
            end if;
          end if;

        // Transport of trace substances
        if use_m_flowInv and use_C_flow then
          port_b.C_outflow =  inStream(port_a.C_outflow) + C_flow_internal * m_flowInv;
        else // no trace substance added.
          assert(not use_C_flow, "In " + getInstanceName() + ": Wrong implementation of trace substance balance for forward flow.");
          port_b.C_outflow =  inStream(port_a.C_outflow);
        end if;

        if allowFlowReversal then
          if use_C_flow then
            port_a.C_outflow = inStream(port_b.C_outflow) - C_flow_internal * m_flowInv;
          else
            port_a.C_outflow = inStream(port_b.C_outflow);
          end if;
        else
          port_a.C_outflow = zeros(Medium.nC);
        end if;

        ////////////////////////////////////////////////////////////////////////////
        // No pressure drop in this model
        port_a.p = port_b.p;

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model transports fluid between its two ports, without storing mass or energy.
It implements a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>

<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
<h4>Implementation</h4>
<p>
Input connectors of the model are
</p>
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can only be used as a steady-state model with two fluid ports.
For a model with a dynamic balance, and more fluid ports, use
<a href=\"modelica://IBPSA.Fluid.Interfaces.ConservationEquation\">
IBPSA.Fluid.Interfaces.ConservationEquation</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
February 12, 2019, by Filip Jorissen:<br/>
Removed obsolete division by <code>TMax</code> in assert.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1097\">#1097</a>.
</li>
<li>
June 23, 2018, by Filip Jorissen:<br/>
Added more details to energy conservation assert to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/962\">#962</a>.
</li>
<li>
March 30, 2018, by Filip Jorissen:<br/>
Added <code>getInstanceName()</code> in asserts to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/901\">#901</a>.
</li>
<li>
April 24, 2017, by Michael Wetter and Filip Jorissen:<br/>
Reimplemented check for energy conversion.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 24, 2017, by Michael Wetter:<br/>
Reverted change from April 21, 2017.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 21, 2017, by Filip Jorissen:<br/>
Revised test for energy conservation at small mass flow rates.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
October 23, 2016, by Filip Jorissen:<br/>
Added test for energy conservation at small mass flow rates.
</li>
<li>
March 17, 2016, by Michael Wetter:<br/>
Refactored model and implmented <code>regStep</code> instead of <code>spliceFunction</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>
and for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a>.
</li>
<li>
September 3, 2015, by Filip Jorissen:<br/>
Revised implementation of conservation of vapor mass.
Added new variable <code>mFlow_inv_b</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Removed <code>constant sensibleOnly</code> as this is no longer used because
the model uses <code>use_mWat_flow</code>.<br/>
Changed condition that determines whether <code>m_flowInv</code> needs to be
computed because the change from January 20 introduced an error in
<a href=\"modelica://IBPSA.Fluid.MassExchangers.Examples.ConstantEffectiveness\">
IBPSA.Fluid.MassExchangers.Examples.ConstantEffectiveness</a>.
</li>
<li>
January 20, 2016, by Filip Jorissen:<br/>
Removed if-else block in code for parameter <code>sensibleOnly</code>
since this is no longer needed to simplify the equations.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
September 14, 2015, by Filip Jorissen:<br/>
Rewrote some equations for better readability.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
Refactored implementation of
<a href=\"modelica://IBPSA.Utilities.Math.Functions.inverseXRegularized\">
IBPSA.Utilities.Math.Functions.inverseXRegularized</a>
to allow function to be inlined and to factor out the computation
of arguments that only depend on parameters.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Corrected bug for situation with latent heat exchange and flow reversal not
allowed.
The previous formulation was singular.
This caused some models to not translate.
The error was introduced in
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Revised implementation so that equations are always consistent
and do not lead to division by zero,
also when connecting a <code>prescribedHeatFlowRate</code>
to <code>MixingVolume</code> instances.
Renamed <code>use_safeDivision</code> into <code>prescribedHeatFlowRate</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>
for a discussion.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Corrected sign error in the equation that is used if <code>use_safeDivision=false</code>
and <code>sensibleOnly=true</code>.
This only affects internal numerical tests, but not any examples in the library
as the constant <code>use_safeDivision</code> is set to <code>true</code> by default.
</li>
<li>
September 25, 2013 by Michael Wetter:<br/>
Reformulated computation of outlet properties to avoid an event at zero mass flow rate.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.
</li>
<li>
May 7, 2013 by Michael Wetter:<br/>
Removed <code>for</code> loops for species balance and trace substance balance,
as they cause the error <code>Error: Operand port_a.Xi_outflow[1] to operator inStream is not a stream variable.</code>
in OpenModelica.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
June 22, 2012 by Michael Wetter:<br/>
Reformulated implementation with <code>m_flowInv</code> to use <code>port_a.m_flow * ...</code>
if <code>use_safeDivision=false</code>. This avoids a division by zero if
<code>port_a.m_flow=0</code>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IBPSA.Fluid.Interfaces</code>.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-93,72},{-58,89}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Text(
                extent={{-93,37},{-58,54}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-41,103},{-10,117}},
                lineColor={0,0,127},
                textString="hOut"),
              Text(
                extent={{10,103},{41,117}},
                lineColor={0,0,127},
                textString="XiOut"),
              Text(
                extent={{61,103},{92,117}},
                lineColor={0,0,127},
                textString="COut"),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{6,14},{6,-37}},     color={255,255,255}),
              Line(points={{54,14},{6,14}},     color={255,255,255}),
              Line(points={{6,-37},{-42,-37}},  color={255,255,255})}));
      end StaticTwoPortConservationEquation;

      model StaticTwoPortHeatMassExchanger
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends IBPSA.Fluid.Interfaces.PartialTwoPortInterface;
        extends IBPSA.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=(abs(dp_nominal) > Modelica.Constants.eps));

        constant Boolean sensibleOnly "Set to true if sensible exchange only";
        constant Boolean prescribedHeatFlowRate
          "Set to true if the heat flow rate is not a function of the component temperature";

        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        // Model inputs
        // Q_flow is the sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q_flow "Heat transferred into the medium";
        input Modelica.SIunits.MassFlowRate mWat_flow
          "Moisture mass flow rate added to the medium";

        // Models for conservation equations and pressure drop
        IBPSA.Fluid.Interfaces.StaticTwoPortConservationEquation vol(
          redeclare final package Medium = Medium,
          final use_mWat_flow = not sensibleOnly,
          final prescribedHeatFlowRate = prescribedHeatFlowRate,
          final m_flow_nominal = m_flow_nominal,
          final allowFlowReversal=allowFlowReversal,
          final m_flow_small=m_flow_small)
          "Control volume for steady-state energy and mass balance"
          annotation (Placement(transformation(extent={{15,-10}, {35,10}})));

        IBPSA.Fluid.FixedResistances.PressureDrop preDro(
          redeclare final package Medium = Medium,
          final m_flow_nominal=m_flow_nominal,
          final deltaM=deltaM,
          final allowFlowReversal=allowFlowReversal,
          final show_T=false,
          final from_dp=from_dp,
          final linearized=linearizeFlowResistance,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp_nominal) "Flow resistance"
          annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg")
          "Leaving temperature of the component";

        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component";
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component";

    protected
        Modelica.Blocks.Sources.RealExpression heaInp(y=Q_flow)
          "Block to set heat input into volume"
          annotation (Placement(transformation(extent={{-20,40},{0,60}})));
        Modelica.Blocks.Sources.RealExpression
          masExc(final y=mWat_flow) "Block to set moisture exchange in volume"
          annotation (Placement(transformation(extent={{-20,20},{0,40}})));
      equation
        connect(vol.hOut, hOut);
        connect(vol.XiOut, XiOut);
        connect(vol.COut, COut);
        connect(port_a,preDro. port_a) annotation (Line(
            points={{-100,0},{-50,0}},
            color={0,127,255}));
        connect(preDro.port_b, vol.port_a) annotation (Line(
            points={{-30,0},{15,0}},
            color={0,127,255}));

        connect(vol.port_b, port_b) annotation (Line(
            points={{35,0},{67,0},{100,5.55112e-16}},
            color={0,127,255}));

        connect(heaInp.y, vol.Q_flow) annotation (Line(
            points={{1,50},{6,50},{6,8},{13,8}},
            color={0,0,127}));
        connect(masExc.y, vol.mWat_flow) annotation (Line(
            points={{1,30},{4,30},{4,4},{13,4}},
            color={0,0,127}));
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without
storing mass or energy. It is based on
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a> but it does
use a different implementation for handling reverse flow because
in this component, mass flow rate can be added or removed from
the medium.
</p>
<p>
If <code>dp_nominal &gt; Modelica.Constants.eps</code>, this component computes
pressure drop due to flow friction.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m_flow_nominal, dp_nominal)</code>. At <code>|m_flow| &lt; deltaM * m_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance</code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>
<h4>Implementation</h4>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned:
<ul>
<li>
<code>Q_flow</code>, which is the sensible and latent heat flow rate added to the medium.
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium.
</li>
</ul>

<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 11, 2017, by Michael Wetter:<br/>
Updated documentation to make clear that <code>Q_flow</code>
includes latent heat flow rate.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>bal1</code> and <code>bal2</code>
as this constant has been removed in
<a href=\"modelica://IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IBPSA.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015 by Filip Jorissen:<br/>
Renamed <code>use_safeDivision</code> into
<code>prescribedHeatFlowRate</code>.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Added parameter <code>homotopyInitialization</code> as
it has been removed in the base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to pressure drop calculation, as this model no longer has
that parameter.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
February 8, 2012 by Michael Wetter:<br/>
Changed model to use graphical modeling.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end StaticTwoPortHeatMassExchanger;

      model TwoPortHeatMassExchanger
        "Partial model transporting one fluid stream with storing mass or energy"
        extends IBPSA.Fluid.Interfaces.PartialTwoPortInterface(
          port_a(h_outflow(start=h_outflow_start)),
          port_b(h_outflow(start=h_outflow_start)));
        extends IBPSA.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=true);

        parameter Modelica.SIunits.Time tau = 30
          "Time constant at nominal flow (if energyDynamics <> SteadyState)"
           annotation (Dialog(tab = "Dynamics", group="Nominal condition"));

        // Advanced
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        // Dynamics
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start = Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
          final quantity=Medium.substanceNames) = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
          final quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));

        replaceable IBPSA.Fluid.MixingVolumes.MixingVolume vol
        constrainedby IBPSA.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          redeclare final package Medium = Medium,
          nPorts = 2,
          V=m_flow_nominal*tau/rho_default,
          final allowFlowReversal=allowFlowReversal,
          final mSenFac=1,
          final m_flow_nominal = m_flow_nominal,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start) "Volume for fluid stream"
           annotation (Placement(transformation(extent={{-9,0},{11,-20}})));

        IBPSA.Fluid.FixedResistances.PressureDrop preDro(
          redeclare final package Medium = Medium,
          final m_flow_nominal=m_flow_nominal,
          final deltaM=deltaM,
          final allowFlowReversal=allowFlowReversal,
          final show_T=false,
          final from_dp=from_dp,
          final linearized=linearizeFlowResistance,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp_nominal) "Flow resistance"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));

    protected
        parameter Medium.ThermodynamicState sta_default=Medium.setState_pTX(
            T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.SIunits.Density rho_default=Medium.density(sta_default)
          "Density, used to compute fluid volume";
        parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
            T=T_start, p=p_start, X=X_start);
        parameter Modelica.SIunits.SpecificEnthalpy h_outflow_start = Medium.specificEnthalpy(sta_start)
          "Start value for outflowing enthalpy";

      initial algorithm
        assert((energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau > Modelica.Constants.eps,
      "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = "       + String(tau) + "\n");
        assert((massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) or
                tau > Modelica.Constants.eps,
      "The parameter tau, or the volume of the model from which tau may be derived, is unreasonably small.
 You need to set massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState to model steady-state.
 Received tau = "       + String(tau) + "\n");


      equation
        connect(vol.ports[2], port_b) annotation (Line(
            points={{1,0},{100,0}},
            color={0,127,255}));
        connect(port_a, preDro.port_a) annotation (Line(
            points={{-100,0},{-90,0},{-90,0},{-80,0},{-80,0},{-60,0}},
            color={0,127,255}));
        connect(preDro.port_b, vol.ports[1]) annotation (Line(
            points={{-40,0},{1,0}},
            color={0,127,255}));
        annotation (
          Documentation(info="<html>
<p>
This component transports one fluid stream.
It provides the basic model for implementing dynamic and steady-state
models that exchange heat and water vapor with the fluid stream.
The model also computes the pressure drop due to the flow resistance.
By setting the parameter <code>dp_nominal=0</code>, the computation
of the pressure drop can be avoided.
The variable <code>vol.heatPort.T</code> always has the value of
the temperature of the medium that leaves the component.
For the actual temperatures at the port, the variables <code>sta_a.T</code>
and <code>sta_b.T</code> can be used. These two variables are provided by
the base class
<a href=\"modelica://IBPSA.Fluid.Interfaces.PartialTwoPortInterface\">
IBPSA.Fluid.Interfaces.PartialTwoPortInterface</a>.
</p>

For models that extend this model, see for example
<ul>
<li>
the ideal heater or cooler
<a href=\"modelica://IBPSA.Fluid.HeatExchangers.HeaterCooler_u\">
IBPSA.Fluid.HeatExchangers.HeaterCooler_u</a>, and
</li>
<li>
the ideal humidifier
<a href=\"modelica://IBPSA.Fluid.Humidifiers.Humidifier_u\">
IBPSA.Fluid.Humidifiers.Humidifier_u</a>.
</li>
</ul>

<h4>Implementation</h4>
<p>
The variable names follow the conventions used in
<a href=\"modelica://Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX\">
Modelica.Fluid.Examples.HeatExchanger.BaseClasses.BasicHX
</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>final quantity=Medium.substanceNames</code> for <code>X_start</code>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Added missing propagation of <code>allowFlowReversal</code> to
instance <code>vol</code>.
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">#412</a>.
</li>
<li>
May 1, 2015, by Marcus Fuchs:<br/>
Fixed links in documentation.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in pressure drop element to be final.
</li>
<li>
May 28, 2014, by Michael Wetter:<br/>
Removed <code>annotation(Evaluate=true)</code> for parameter <code>tau</code>.
This is needed to allow changing the time constant after translation.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
October 17, 2012, by Michael Wetter:<br/>
Fixed broken link in documentation.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Removed assignment of <code>m_flow_small</code> as it is no
longer used in the pressure drop model.
</li>
<li>
January 15, 2011, by Michael Wetter:<br/>
Fixed wrong class reference in information section.
</li>
<li>
September 13, 2011, by Michael Wetter:<br/>
Changed assignment of <code>vol(mass/energyDynamics=...)</code> as the
previous assignment caused a non-literal start value that was ignored.
</li>
<li>
July 29, 2011, by Michael Wetter:<br/>
Added start value for outflowing enthalpy.
</li>
<li>
July 11, 2011, by Michael Wetter:<br/>
Changed parameterization of fluid volume so that steady-state balance is
used when <code>tau = 0</code>.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Removed temperature sensor and changed implementation of fluid volume
to allow use of this model for the steady-state and dynamic humidifier
<a href=\"modelica://IBPSA.Fluid.MassExchangers.HumidifierPrescribed\">
IBPSA.Fluid.MassExchangers.HumidifierPrescribed</a>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
January 29, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,60},{70,-60}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-101,5},{100,-4}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{0,-4},{100,5}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={255,0,0},
                fillPattern=FillPattern.Solid)}));
      end TwoPortHeatMassExchanger;

      record EightPortFlowResistanceParameters
        "Parameters for flow resistance for models with height ports"

        parameter Boolean computeFlowResistance1 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 1"));

        parameter Boolean from_dp1 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance1,
                      tab="Flow resistance", group="Medium 1"));
        parameter Modelica.SIunits.Pressure dp1_nominal(min=0, displayUnit="Pa")
          "Pressure" annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance1 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance1,
                     tab="Flow resistance", group="Medium 1"));
        parameter Real deltaM1 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance1,
                            tab="Flow resistance", group="Medium 1"));
        parameter Boolean computeFlowResistance2 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 2"));

        parameter Boolean from_dp2 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance2,
                      tab="Flow resistance", group="Medium 2"));
        parameter Modelica.SIunits.Pressure dp2_nominal(min=0, displayUnit="Pa")
          "Pressure" annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance2 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance2,
                     tab="Flow resistance", group="Medium 2"));
        parameter Real deltaM2 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance2,
                            tab="Flow resistance", group="Medium 2"));
        parameter Boolean computeFlowResistance3 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 3"));

        parameter Boolean from_dp3 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance3,
                      tab="Flow resistance", group="Medium 3"));
        parameter Modelica.SIunits.Pressure dp3_nominal(min=0, displayUnit="Pa")
          "Pressure" annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance3 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance3,
                     tab="Flow resistance", group="Medium 3"));
        parameter Real deltaM3 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance3,
                            tab="Flow resistance", group="Medium 3"));
        parameter Boolean computeFlowResistance4 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 4"));

        parameter Boolean from_dp4 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance4,
                      tab="Flow resistance", group="Medium 4"));
        parameter Modelica.SIunits.Pressure dp4_nominal(min=0, displayUnit="Pa")
          "Pressure" annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance4 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance4,
                     tab="Flow resistance", group="Medium 4"));
        parameter Real deltaM4 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance4,
                            tab="Flow resistance", group="Medium 4"));

      annotation (preferredView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in components that have four fluid streams.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://IBPSA.Fluid.Interfaces.PartialEightPortInterface\">
PartialHeightPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
January 28, 2015, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
      end EightPortFlowResistanceParameters;

      record FourPortFlowResistanceParameters
        "Parameters for flow resistance for models with four ports"

        parameter Boolean computeFlowResistance1 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 1"));

        parameter Boolean from_dp1 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance1,
                      tab="Flow resistance", group="Medium 1"));
        parameter Modelica.SIunits.PressureDifference dp1_nominal(min=0,
                                                                  displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance1 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance1,
                     tab="Flow resistance", group="Medium 1"));
        parameter Real deltaM1 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance1,
                            tab="Flow resistance", group="Medium 1"));
        parameter Boolean computeFlowResistance2 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 2"));

        parameter Boolean from_dp2 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance2,
                      tab="Flow resistance", group="Medium 2"));
        parameter Modelica.SIunits.PressureDifference dp2_nominal(min=0,
                                                                  displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance2 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance2,
                     tab="Flow resistance", group="Medium 2"));
        parameter Real deltaM2 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance2,
                            tab="Flow resistance", group="Medium 2"));
      annotation (preferredView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in components that have two fluid streams.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://IBPSA.Fluid.Interfaces.PartialFourPortInterface\">
PartialFourPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FourPortFlowResistanceParameters;

      record LumpedVolumeDeclarations "Declarations for lumped volumes"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choices(
              choice(redeclare package Medium = IBPSA.Media.Air "Moist air"),
              choice(redeclare package Medium = IBPSA.Media.Water "Water"),
              choice(redeclare package Medium =
                  IBPSA.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics substanceDynamics=energyDynamics
          "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics traceDynamics=energyDynamics
          "Type of trace substance balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start=Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
             quantity=Medium.substanceNames) = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
             quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Medium.ExtraProperty C_nominal[Medium.nC](
             quantity=Medium.extraPropertiesNames) = fill(1E-2, Medium.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Real mSenFac(min=1)=1
          "Factor for scaling the sensible thermal mass of the volume"
          annotation(Dialog(tab="Dynamics"));

      annotation (preferredView="info",
      Documentation(info="<html>
<p>
This class contains parameters and medium properties
that are used in the lumped  volume model, and in models that extend the
lumped volume model.
</p>
<p>
These parameters are used for example by
<a href=\"modelica://IBPSA.Fluid.Interfaces.ConservationEquation\">
IBPSA.Fluid.Interfaces.ConservationEquation</a>,
<a href=\"modelica://IBPSA.Fluid.MixingVolumes.MixingVolume\">
IBPSA.Fluid.MixingVolumes.MixingVolume</a> and
<a href=\"modelica://IBPSA.Fluid.HeatExchangers.Radiators.RadiatorEN442_2\">
IBPSA.Fluid.HeatExchangers.Radiators.RadiatorEN442_2</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
November 9, 2018 by Michael Wetter:<br/>
Limited choices of media that are displayed in the pull down menu of
graphical editors.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">issue 1050</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>quantity=Medium.substanceNames</code> for <code>X_start</code>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
August 2, 2011, by Michael Wetter:<br/>
Set <code>substanceDynamics</code> and <code>traceDynamics</code> to final
and equal to <code>energyDynamics</code>,
as there is no need to make them different from <code>energyDynamics</code>.
</li>
<li>
August 1, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.DynamicFreeInitial</code> because
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code> leads
to high order DAE that Dymola cannot reduce.
</li>
<li>
July 31, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LumpedVolumeDeclarations;

      record TwoPortFlowResistanceParameters
        "Parameters for flow resistance for models with two ports"

        parameter Boolean computeFlowResistance = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance"));

        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance,
                      tab="Flow resistance"));
        parameter Modelica.SIunits.PressureDifference dp_nominal(min=0,
                                                                 displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance,
                     tab="Flow resistance"));
        parameter Real deltaM = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance, tab="Flow resistance"));

      annotation (preferredView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in models that have one fluid stream.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://IBPSA.Fluid.Interfaces.PartialTwoPortInterface\">
PartialTwoPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TwoPortFlowResistanceParameters;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains basic classes that are used to build
component models that change the state of the
fluid. The classes are not directly usable, but can
be extended when building a new model.
</p>
</html>"));
    end Interfaces;

    package BaseClasses "Package with base classes for IBPSA.Fluid"
      extends Modelica.Icons.BasesPackage;

      model MassFlowRateMultiplier "Model that multiplies the mass flow rate"
        extends IBPSA.Fluid.Interfaces.PartialTwoPort;

        parameter Real k "Gain for mass flow rate";

      initial equation
        assert(k > Modelica.Constants.small or -k < -Modelica.Constants.small,
          "Gain must not be zero. Received k = " + String(k));
      equation
          // Pressure drop in design flow direction
        port_a.p = port_b.p;

        // Mass balance (mass is not conserved by this model!)
        port_b.m_flow = -k*port_a.m_flow;

        // Specific enthalpy flow rate
        port_a.h_outflow = inStream(port_b.h_outflow);
        port_b.h_outflow = inStream(port_a.h_outflow);
        // Transport of substances
        port_a.Xi_outflow = inStream(port_b.Xi_outflow);
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = inStream(port_b.C_outflow);
        port_b.C_outflow = inStream(port_a.C_outflow);

        annotation (Documentation(info="<html>
<p>
This model multiplies the mass flow rate so that
<code>0 = port_b.m_flow + k * port_a.m_flow</code>.
</p>
<p>
The specific enthalpy, the species concentration and the trace substance concentration
remain unchanged.
Therefore, this model does not conserve mass or energy.
It is used in
<a href=\"modelica://IBPSA.Fluid.Geothermal.Borefields.BaseClasses.PartialBorefield\">
IBPSA.Fluid.Geothermal.Borefields.BaseClasses.PartialBorefield</a>
and also in the Buildings library
to avoid having to instantiate circuits in parallel, with each
having the same mass flow rate and temperatures.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 27, 2013, by Michael Wetter:<br/>
Changed implementation to extend from <code>Modelica.Fluid</code>.
</li>
<li>
June 27, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,237,228},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
                                Polygon(
                points={{-100,8},{100,20},{100,-20},{-100,-8},{-100,8}},
                lineColor={0,0,255},
                smooth=Smooth.None,
                fillColor={0,0,255},
                fillPattern=FillPattern.Solid)}));
      end MassFlowRateMultiplier;

      partial model PartialResistance "Partial model for a hydraulic resistance"
          extends IBPSA.Fluid.Interfaces.PartialTwoPortInterface(
           show_T=false,
           dp(nominal=if dp_nominal_pos > Modelica.Constants.eps
                then dp_nominal_pos else 1),
           m_flow(
              nominal=if m_flow_nominal_pos > Modelica.Constants.eps
                then m_flow_nominal_pos else 1),
           final m_flow_small = 1E-4*abs(m_flow_nominal));

        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));

        parameter Modelica.SIunits.PressureDifference dp_nominal(displayUnit="Pa")
          "Pressure drop at nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        parameter Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
          "Turbulent flow if |m_flow| >= m_flow_turbulent";

    protected
        parameter Medium.ThermodynamicState sta_default=
           Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.SIunits.DynamicViscosity eta_default=Medium.dynamicViscosity(sta_default)
          "Dynamic viscosity, used to compute transition to turbulent flow regime";

        final parameter Modelica.SIunits.MassFlowRate m_flow_nominal_pos = abs(m_flow_nominal)
          "Absolute value of nominal flow rate";
        final parameter Modelica.SIunits.PressureDifference dp_nominal_pos(displayUnit="Pa") = abs(dp_nominal)
          "Absolute value of nominal pressure difference";
      equation
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
        port_b.h_outflow = inStream(port_a.h_outflow);

        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;

        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);

        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);

        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-42}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,22},{100,-24}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Rectangle(
                visible=linearized,
                extent={{-100,22},{100,-24}},
                fillPattern=FillPattern.Backward,
                fillColor={0,128,255},
                pattern=LinePattern.None,
                lineColor={255,255,255})}),
                defaultComponentName="res",
      Documentation(info="<html>
<p>
Partial model for a flow resistance, possible with variable flow coefficient.
Models that extend this class need to implement an equation that relates
<code>m_flow</code> and <code>dp</code>, and they need to assign the parameter
<code>m_flow_turbulent</code>.
</p>
<p>
See for example
<a href=\"modelica://IBPSA.Fluid.FixedResistances.PressureDrop\">
IBPSA.Fluid.FixedResistances.PressureDrop</a> for a model that extends
this base class.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start value for pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Avoided assignment of <code>dp(nominal=0)</code> if <code>dp_nominal_pos = 0</code>
and of <code>m_flow(nominal=0)</code> if <code>m_flow_nominal_pos = 0</code>
as nominal values are not allowed to be zero.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>,
<code>port_a.h_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">#281</a>.
</li>
<li>
January 13, 2015, by Marcus Fuchs:<br/>
Revised revisions section (there were two revisions statements)
</li>
<li>
November 20, 2014 by Michael Wetter:<br/>
Removed <code>start</code> attribute for <code>m_flow</code>
as this is already set in its base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to base class as it has no longer this parameter.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
February 12, 2012, by Michael Wetter:<br/>
Removed duplicate declaration of <code>m_flow_nominal</code>.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Made assignment of <code>m_flow_small</code> <code>final</code> as it is no
longer used in the base class.
</li>
<li>
January 16, 2012, by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IBPSA.Fluid.BaseClasses.PartialResistance</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IBPSA.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IBPSA.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 5, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
June 20, 2011, by Michael Wetter:<br/>
Set start values for <code>m_flow</code> and <code>dp</code> to zero, since
most HVAC systems start at zero flow. With this change, the start values
appear in the GUI and can be set by the user.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>m_flow_nominal_pos</code> and <code>dp_nominal_pos</code> to allow
providing negative nominal values which will be used, for example, to set start
values of flow splitters which may have negative flow rates and pressure drop
at the initial condition.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 23, 2011 by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 30, 2010 by Michael Wetter:<br/>
Changed base classes to allow easier initialization.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Extracted pressure drop computation and implemented it in the
new model
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.BasicFlowModel\">
IBPSA.Fluid.BaseClasses.FlowModels.BasicFlowModel</a>.
</li>
<li>
September 18, 2008, by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialResistance;

      package FlowModels "Flow models for pressure drop calculations"
        extends Modelica.Icons.BasesPackage;

        function basicFlowFunction_dp
          "Function that computes mass flow rate for given pressure drop"

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          output Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNorm=dp/dp_turbulent
            "Normalised pressure difference";
          Real dpNormSq=dpNorm^2
            "Square of normalised pressure difference";
        algorithm
           m_flow :=  if noEvent(abs(dp)>dp_turbulent)
                      then sign(dp)*k*sqrt(abs(dp))
                      else (1.40625  + (0.15625*dpNormSq - 0.5625)*dpNormSq)*m_flow_turbulent*dpNorm;
          annotation(Inline=false,
                   smoothOrder=2,
                   derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                     IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der,
                   inverse(dp=IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                     m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent)),
                   Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
March 19, 2016, by Michael Wetter:<br/>
Added <code>abs</code> function for
<code>IBPSA.Fluid.FixedResistances.Validation.PressureDropsExplicit</code>
to work in OpenModelica.
See <a href=\"https://trac.openmodelica.org/OpenModelica/ticket/3778\">
OpenModelica ticket 3778</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
January 9, 2014, by Michael Wetter:<br/>
Correct revision section, of which there were two.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>m_flow=0</code> if <code>dp=0</code>,
as this causes the derivative to be discontinuous at <code>dp=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2010 by Michael Wetter:<br/>
Changed implementation to allow <code>k=0</code>, which is
the case for a closed valve with no leakage
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_dp;

        function basicFlowFunction_dp_der
          "1st derivative of function that computes mass flow rate for given pressure drop"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real dp_der
            "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          output Real m_flow_der(unit="kg/s2")
            "Derivative of mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNormSq=(dp/dp_turbulent)^2
            "Square of normalised pressure difference";
        algorithm
         m_flow_der := (if noEvent(abs(dp)>dp_turbulent)
                        then 0.5*k/sqrt(abs(dp))
                        else (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*m_flow_turbulent/dp_turbulent)*dp_der;
         annotation (Inline=false,
                     smoothOrder=1,
                     derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                       IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2,
        Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
April 14, 2017, by Filip Jorissen:<br/>
Changed implementation such that it cannot lead to square roots
of negative numbers and reduced the number of required operations.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/723\">#723</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_dp_der;

        function basicFlowFunction_dp_der2
          "2nd derivative of flow function2nd derivative of function that computes mass flow rate for given pressure drop"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real dp_der
            "1st derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real dp_der2
            "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          output Real m_flow_der2
            "2nd derivative of mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNorm=dp/dp_turbulent
            "Normalised pressure difference";
          Real dpNormSq=dpNorm^2
            "Square of normalised pressure difference";
        algorithm
         m_flow_der2 := if noEvent(abs(dp)>dp_turbulent)
                         then 0.5*k/sqrt(abs(dp))*(-0.5/dp * dp_der^2 + dp_der2)
                         else m_flow_turbulent/dp_turbulent*(
                               (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*dp_der2
                             + (-3.375 + 3.125*dpNormSq)*dpNorm/dp_turbulent*dp_der^2);

         annotation (smoothOrder=0,
         Inline=false,
        Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_dp_der2;

        function basicFlowFunction_m_flow
          "Function that computes pressure drop for given mass flow rate"

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          output Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNorm = m_flow/m_flow_turbulent
            "Normalised mass flow rate";
          Real m_flowNormSq = m_flowNorm^2
            "Square of normalised mass flow rate";

        algorithm
         dp :=if noEvent(abs(m_flow)>m_flow_turbulent)
              then sign(m_flow)*(m_flow/k)^2
              else (0.375 + (0.75-0.125*m_flowNormSq)*m_flowNormSq)*dp_turbulent*m_flowNorm;

         annotation (Inline=false,
                     smoothOrder=2,
                     derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                       IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der,
                     inverse(m_flow=IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                       dp=dp, k=k, m_flow_turbulent=m_flow_turbulent)),
                     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = sign(m) (m &frasl; k)<sup>2</sup>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>dp=0</code> if <code>m_flow=0</code>,
as this causes the derivative to be discontinuous at <code>m_flow=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow;

        function basicFlowFunction_m_flow_der
          "1st derivative of function that computes pressure drop for given mass flow rate"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real m_flow_der(unit="kg/s2")
            "Derivative of mass flow rate in design flow direction";
          output Real dp_der
            "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNormSq = (m_flow/m_flow_turbulent)^2
            "Square of normalised mass flow rate";
        algorithm
         dp_der :=(if noEvent(abs(m_flow)>m_flow_turbulent)
                   then sign(m_flow)*2*m_flow/k^2
                   else (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*dp_turbulent/m_flow_turbulent)*m_flow_der;

         annotation (Inline=false,
                     smoothOrder=1,
                     derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                     IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2,
        Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow_der;

        function basicFlowFunction_m_flow_der2
          "2nd derivative of function that computes pressure drop for given mass flow rate"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real m_flow_der(unit="kg/s2")
            "1st derivative of mass flow rate in design flow direction";
          input Real m_flow_der2(unit="kg/s3")
            "2nd derivative of mass flow rate in design flow direction";
          output Real dp_der2
            "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNorm = m_flow/m_flow_turbulent
            "Normalised mass flow rate";
          Real m_flowNormSq = m_flowNorm^2
            "Square of normalised mass flow rate";
        algorithm
         dp_der2 :=if noEvent(abs(m_flow)>m_flow_turbulent)
                   then sign(m_flow)*2/k^2 * (m_flow_der^2 + m_flow * m_flow_der2)
                   else dp_turbulent/m_flow_turbulent*(
                         (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*m_flow_der2
                       + (4.5 - 2.5*m_flowNormSq)*m_flowNorm/m_flow_turbulent*m_flow_der^2);

         annotation (smoothOrder=0,
         Inline=false,
        Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow_der2;
      annotation (Documentation(info="<html>
<p>
This package contains a basic flow model that is used by the
various models that compute pressure drop.
</p>
<h4>Assumption and limitations</h4>
<p>
Because the density does not change signficantly in heating,
ventilation and air conditioning systems for buildings,
the flow models compute the pressure drop based on the mass flow
rate and not the volume flow rate. This typically leads to simpler
equations because it does not require
the mass density, which changes when the flow is reversed.
Although, for conceptual design of building energy system, there is
in general not enough information available that would warrant a more
detailed pressure drop calculation.
If a more detailed computation of the flow resistance is needed,
then a user can use models from the
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a> library.
</p>
<p>
All functions have an argument <code>m_flow_turbulent</code> that determines where the
flow transitions to fully turbulent flow. For smaller mass flow rates,
the quadratic relation is replaced by a function that has finite slope
near zero pressure drop. This is done for numerical reasons, and to approximate
laminar flow, although the implementation does not use a linear function.
</p>
<h4>Implementation</h4>
<p>
The two main functions are
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
and
<a href=\"modelica://IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IBPSA.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
that compute the mass flow rate or the pressure drop, respectively.
Both functions are two times continuously differentiable.
First and second order derivatives are provided
in the function that have the suffix <code>_der</code> and <code>_der2</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 10, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FlowModels;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Fluid\">IBPSA.Fluid</a>.
</p>
</html>"));
    end BaseClasses;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains components for fluid flow systems such as
pumps, valves and sensors. For other fluid flow models, see
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a>.
</html>"),
  Icon(graphics={
          Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}},
              lineColor={0,0,0}),
          Line(points={{2,42},{2,-10}}),
          Rectangle(
            extent={{-18,50},{22,42}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid)}));
  end Fluid;

  package Media "Package with medium models"
    extends Modelica.Icons.Package;

    package Refrigerants "Package with functions for refrigerant properties"
      extends Modelica.Icons.Package;

      package R410A "Refrigerant R410A"
        extends Modelica.Icons.VariantsPackage;

        function dPressureVap_dSpecificVolume_Tv
          "Derivative of the Martin-Hou equation of state with regards to specific volume"

          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
          output Real dpdv(
            final unit="Pa.kg/m3")
             "Derivative of pressure with regards to specific volume";

      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";

          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";

          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";

          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";

          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";

          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";

          Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";

          Modelica.SIunits.SpecificVolume v_abs
            "Smoothed specific volume";

          parameter Integer n = size(A, 1);

        algorithm

          v_abs := IBPSA.Utilities.Math.Functions.smoothMax(v, 1.01*b, 0.01*b);

          dpdv := -R*T/(v_abs-b)^2;
          for i in 1:n loop
            dpdv := dpdv - (i+1)*(A[i] + B[i]*T + C[i]*Modelica.Math.exp(-k*T/TCri))/(v_abs - b)^(i+2);
          end for;

        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the derivative of the Martin-Hou equation of for R410A
state with regards to specific volume.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",           revisions="<html>
<ul>
<li>
November 30, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end dPressureVap_dSpecificVolume_Tv;

        function dPressureVap_dTemperature_Tv
          "Derivative of the Martin-Hou equation of state with regards to temperature"

          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
          output Real dpdT(
            final unit="Pa/K")
             "Derivative of pressure with regards to temperature";

      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";

          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";

          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";

          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";

          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";

          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";

          Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";

          Modelica.SIunits.SpecificVolume v_abs
            "Smoothed specific volume";

          parameter Integer n = size(A, 1);

        algorithm

          v_abs := IBPSA.Utilities.Math.Functions.smoothMax(v, 1.01*b, 0.01*b);

          dpdT := R/(v_abs-b);
          for i in 1:n loop
            dpdT := dpdT + (B[i] - C[i]*k/TCri*Modelica.Math.exp(-k*T/TCri))/(v_abs - b)^(i+1);
          end for;

        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the derivative of the Martin-Hou equation of for R410A
state with regards to temperature.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",           revisions="<html>
<ul>
<li>
November 30, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end dPressureVap_dTemperature_Tv;

        function dSpecificVolumeVap_pT
          "Function that calculates the Jacobian of specific volume R410A vapor based on pressure and temperature"
          input Modelica.SIunits.AbsolutePressure p
            "Pressure of refrigerant vapor";
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Real dp(
            final unit="Pa/s")
            "Delta of pressure of refrigerant vapor";
          input Real dT(
            final unit="K/s")
            "Delta of temperature of refrigerant";
          output Real dv(
            final unit="m3/(kg.s)")
            "Delta of specific volume of refrigerant";

      protected
          Real dpdT(
            final unit="Pa/K")
             "Derivative of pressure with regards to temperature";

          Real dpdv(
            final unit="Pa.kg/m3")
             "Derivative of pressure with regards to specific volume";

          Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";

        algorithm

          v := IBPSA.Media.Refrigerants.R410A.specificVolumeVap_pT(p, T);
          dpdT := IBPSA.Media.Refrigerants.R410A.dPressureVap_dTemperature_Tv(T, v);
          dpdv := IBPSA.Media.Refrigerants.R410A.dPressureVap_dSpecificVolume_Tv(T, v);

          dv := dp/dpdv + dT*(dpdT/dpdv);

        annotation (preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the derivatives of
<a href=\"modelica://IBPSA.Media.Refrigerants.R410A.specificVolumeVap_pT\">
IBPSA.Media.Refrigerants.R410A.specificVolumeVap_pT</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
November 30, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end dSpecificVolumeVap_pT;

        function enthalpySatLiq_T
          "Function that calculates the enthalpy of saturated liquid R410A based on temperature"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          output Modelica.SIunits.SpecificEnthalpy h
            "Specific enthalpy of saturated liquid refrigerant";

      protected
          final Real a[:] = {221.1749, -514.9668, -631.625, -262.2749, 1052.0, 1596.0}
            "Coefficients for polynomial equation";

          final Real x0 = 0.5541498
            "x0 for saturation pressure of liquid refrigerant";

          final Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";

          Real x
            "Independent variable";

        algorithm
          // Independent variable
          x := IBPSA.Utilities.Math.Functions.smoothMax(1-T/TCri, 1e-4, 5e-3)^(1/3) - x0;
          // Pressure of saturated liquid refrigerant
          h := 1000*IBPSA.Utilities.Math.Functions.polynomial(a = a, x = x);

        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the enthalpy of saturated liquid R410A based on
temperature.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end enthalpySatLiq_T;

        function enthalpySatVap_T
          "Function that calculates the specific enthalpy of saturated R410A vapor based on temperature"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          output Modelica.SIunits.SpecificEnthalpy h
            "Specific enthalpy of saturated liquid refrigerant";

      protected
          final Real a[:] = {406.0598, -34.78156, 262.8079, 223.8549, -1162.627, 570.6635}
            "Coefficients for polynomial equation";

          final Real x0 = 0
            "x0 for saturation pressure of liquid refrigerant";

          final Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";

          Real x
            "Independent variable";

        algorithm
          // Independent variable
          x := IBPSA.Utilities.Math.Functions.smoothMax(1-T/TCri, 1e-4, 5e-3)^(1/3) - x0;
          // Pressure of saturated liquid refrigerant
          h := 1000*IBPSA.Utilities.Math.Functions.polynomial(a = a, x = x);

        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the specific enthalpy of saturated R410A vapor based
on temperature.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end enthalpySatVap_T;

        function isentropicExponentVap_Tv
          "Function that calculates the isentropic exponent of R410A vapor based on temperature and specific volume"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
          output Modelica.SIunits.IsentropicExponent k
            "Specific isobaric heat capacity";

      protected
          Modelica.SIunits.SpecificHeatCapacity cp
            "Specific isobaric heat capacity";

          Modelica.SIunits.SpecificHeatCapacity cv
            "Specific isochoric heat capacity";

        algorithm
          // Evaluate the specific isobaric and isochoric heat capacities
          cp := IBPSA.Media.Refrigerants.R410A.specificIsobaricHeatCapacityVap_Tv(T, v);
          cv := IBPSA.Media.Refrigerants.R410A.specificIsochoricHeatCapacityVap_Tv(T, v);

          k := cp / cv;

        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the isentropic exponent of R410A vapor based on temperature and specific volume. The isentropic exponent is equal to the ratio of specific heat capacities:
</p>
<p align=\"center\" style=\"font-style:italic;\">
k = c<sub>p</sub>/c<sub>v</sub>
</p>
<h4>References</h4>
<p>
F. de Monte. (2002).
Calculation of thermodynamic properties of R407C and
R410A by the Martin-Hou equation of state, part I:
theoretical development.
<i>
International Journal of Refrigeration.
</i>
25. 306-313.
</p>
<p>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 31, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isentropicExponentVap_Tv;

        function pressureSatVap_T
          "Function that calculates the pressure of saturated R410A vapor based on temperature"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          output Modelica.SIunits.AbsolutePressure p
            "Pressure of saturated refrigerant vapor";

      protected
          final Real a[:] = {-1.440004, -6.865265, -0.5354309, -3.749023, -3.521484, -7.75}
            "Coefficients for polynomial equation";

          final Real x0 = 0.2086902
            "x0 for saturation pressure of refrigerant vapor";

          final Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";

          final Modelica.SIunits.AbsolutePressure pCri = 4925.1e3
            "Critical pressure of refrigerant";

          Real x
            "Independent variable";

        algorithm
          // Independent variable
          x := IBPSA.Utilities.Math.Functions.smoothMax(1-T/TCri, 1e-4, 5e-3) - x0;
          // Pressure of saturated refrigerant vapor
          p := pCri*Modelica.Math.exp(TCri/T*IBPSA.Utilities.Math.Functions.polynomial(a = a, x = x));

        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the pressure of saturated R410A vapor based on temperature.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end pressureSatVap_T;

        function pressureVap_Tv
        "Function that calculates the pressure R410A vapor based on temperature and specific volume"
        input Modelica.SIunits.Temperature T
           "Temperature of refrigerant";
        input Modelica.SIunits.SpecificVolume v
           "Specific volume of refrigerant";
        output Modelica.SIunits.AbsolutePressure p
           "Pressure of refrigerant vapor";

      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";

          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";

          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";

          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";

          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";

          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";

          Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";

          Modelica.SIunits.SpecificVolume v_abs
            "Smoothed specific volume";

          parameter Integer n = size(A, 1);

        algorithm

          v_abs := IBPSA.Utilities.Math.Functions.smoothMax(v, 1.01*b, 0.01*b);

          p := R*T/(v_abs-b);
          for i in 1:n loop
            p := p + (A[i] + B[i]*T + C[i]*Modelica.Math.exp(-k*T/TCri))/(v_abs - b)^(i+1);
          end for;

        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the pressure R410A vapor based on temperature and
specific volume. The pressure is calculated from the Martin-Hou equation of
state.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",           revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end pressureVap_Tv;

        function specificIsobaricHeatCapacityVap_Tv
          "Function that calculates the specific isobaric heat capacity of R410A vapor based on temperature and specific volume"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
          output Modelica.SIunits.SpecificHeatCapacity cp
            "Specific isobaric heat capacity";

      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";

          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";

          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";

          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";

          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";

          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";

          Real dpdT
            "First derivative w.r.t. temperature of the Martin-Hou equation";

          Real dpdv
            "First derivative w.r.t. specific volume of the Martin-Hou equation";

          Modelica.SIunits.SpecificHeatCapacity cv
            "Specific isochoric heat capacity";

          Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";

          parameter Integer n = size(A, 1);

        algorithm

          cv := IBPSA.Media.Refrigerants.R410A.specificIsochoricHeatCapacityVap_Tv(T, v);
          dpdT := IBPSA.Media.Refrigerants.R410A.dPressureVap_dTemperature_Tv(T, v);
          dpdv := IBPSA.Media.Refrigerants.R410A.dPressureVap_dSpecificVolume_Tv(T, v);

          cp := cv - T * dpdT^2 / dpdv;

        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the specific isobaric heat capacity (<i>c<sub>p</sub></i>) of R410A vapor based on temperature and specific volume.
</p>
<p>
The specific isobaric heat capacity is evaluated from the partial derivatives of the Martin-Hou equation of state.
</p>
<h4>References</h4>
<p>
F. de Monte. (2002).
Calculation of thermodynamic properties of R407C and
R410A by the Martin-Hou equation of state, part I:
theoretical development.
<i>
International Journal of Refrigeration.
</i>
25. 306-313.
</p>
<p>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 31, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end specificIsobaricHeatCapacityVap_Tv;

        function specificIsochoricHeatCapacityVap_Tv
          "Function that calculates the specific isochoric heat capacity of R410A vapor
  based on temperature and specific volume"
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          input Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";
          output Modelica.SIunits.SpecificHeatCapacity cv
            "Specific isochoric heat capacity";

      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";

          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";

          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";

          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";

          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";

          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";

          Real a[:] = {2.676087e-1, 2.115353e-3, -9.848184e-7, 6.493781e-11}
            "Coefficients for ideal gas specific isobaric heat capacity";

          Real integral_of_d2pdT2
            "Integral over v of the second derivative w.r.t. temperature of the Martin-Hou equation";

          Modelica.SIunits.SpecificHeatCapacity cpo
            "Ideal gas specific isobaric heat capacity";

          Modelica.SIunits.SpecificHeatCapacity cvo
            "Ideal gas specific isochoric heat capacity";

          Modelica.SIunits.Temperature TCri = 345.25
            "Critical temperature of refrigerant";

          parameter Integer n = size(A, 1);

        algorithm
          // Ideal gas isobaric heat capacity from polynomial equation
          cpo := 1.0e3*IBPSA.Utilities.Math.Functions.polynomial(a = a, x = T);
          cvo := cpo - R;

          // Integral of second derivative of pressure w.r.t. temperature
          integral_of_d2pdT2 := 0.0;
          for i in 1:n loop
            integral_of_d2pdT2 := integral_of_d2pdT2 + C[i]*Modelica.Math.exp(-k*T/TCri)/(i*(v - b)^(i));
          end for;
          integral_of_d2pdT2 := integral_of_d2pdT2 * (k/TCri)^2;

          cv := cvo - T * integral_of_d2pdT2;

        annotation (smoothOrder=1,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the specific isochoric heat capacity
(<i>c<sub>v</sub></i>) of R410A vapor based on temperature and specific volume.
</p>
<p>
The specific isochoric heat capacity is evaluated from the partial derivatives
of the Martin-Hou equation of state.
</p>
<h4>References</h4>
<p>
F. de Monte. (2002).
Calculation of thermodynamic properties of R407C and
R410A by the Martin-Hou equation of state, part I:
theoretical development.
<i>
International Journal of Refrigeration.
</i>
25. 306-313.
</p>
<p>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 31, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end specificIsochoricHeatCapacityVap_Tv;

        function specificVolumeVap_pT
          "Function that calculates the specific volume R410A vapor based on pressure and temperature"
          input Modelica.SIunits.AbsolutePressure p
            "Pressure of refrigerant vapor";
          input Modelica.SIunits.Temperature T
            "Temperature of refrigerant";
          output Modelica.SIunits.SpecificVolume v
            "Specific volume of refrigerant";

      protected
          Modelica.SIunits.SpecificEntropy R = 114.55
            "Refrigerant gas constant for Martin-Hou equation of state";

          Real A[:] = {-1.721781e2, 2.381558e-1, -4.329207e-4, -6.241072e-7}
            "Coefficients A for Martin-Hou equation of state";

          Real B[:] = {1.646288e-1, -1.462803e-5, 0, 1.380469e-9}
            "Coefficients B for Martin-Hou equation of state";

          Real C[:] = {-6.293665e3, 1.532461e1, 0, 1.604125e-4}
            "Coefficients C for Martin-Hou equation of state";

          Real b = 4.355134e-4
            "Coefficient b for Martin-Hou equation of state";

          Real k = 5.75
            "Coefficient K for Martin-Hou equation of state";

          Modelica.SIunits.SpecificVolume dv
            "Error on specific volume of refrigerant";

          Modelica.SIunits.Pressure dp
            "Error on pressure of refrigerant";

          Real dpdv( final unit = "(Pa.kg)/m3");

          Integer m;

          parameter Integer n = size(A, 1);

        algorithm

          // Initial guess of specific volume
          v := R*T/p + b;
          dv := 1e99;
          m := 0;
          while abs(dv/v) > 1e-10 loop
            assert(m < 1E3,
              "Failed to converge in IBPSA.Media.Refrigerants.R410A.specificVolumeVap_pT");
            m := m + 1;

            // Evaluate first derivative of pressure w.r.t. specific volume
            dpdv := IBPSA.Media.Refrigerants.R410A.dPressureVap_dSpecificVolume_Tv(T, v);
            // Error on pressure
            dp := p - IBPSA.Media.Refrigerants.R410A.pressureVap_Tv(T, v);
            // Corresponding linear adjustment of specific volume
            dv := dp/dpdv;
            v := v + dv;

        end while;

        annotation (derivative=IBPSA.Media.Refrigerants.R410A.dSpecificVolumeVap_pT,
        preferredView="info",Documentation(info="<HTML>
<p>
Function that calculates the specific volume R410A vapor based on pressure and
temperature. The specific volume is evaluated iteratively by succesive
evaluations of the vapor pressure.
</p>
<p>
The initial guess is estimated by the first term in the Martin-Hou equation of
state.
</p>
<h4>References</h4>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end specificVolumeVap_pT;
        final constant Modelica.SIunits.SpecificEntropy R = 114.55
          "Gas constant for use in Martin-Hou equation of state";

        final constant Modelica.SIunits.Temperature TCri = 345.25
          "Critical temperature";

        final constant Modelica.SIunits.Temperature T_min = 173.15
          "Minimum temperature for correlated properties";

        final constant Modelica.SIunits.AbsolutePressure pCri = 4926.1e3
          "Critical pressure";

      annotation (preferredView="info",Documentation(info="<HTML>
<p>
This package contains function definitions for thermodynamic properties of R410A
based on data for commercial refrigerant Dupont Suva 410A. The methodology used
to evaluate the isentropic exponent is taken from de Monte (2002).
</p>
<h4>References</h4>
<p>
F. de Monte. (2002).
Calculation of thermodynamic properties of R407C and
R410A by the Martin-Hou equation of state, part I:
theoretical development.
<i>
International Journal of Refrigeration.
</i>
25. 306-313.
</p>
<p>
Thermodynamic properties of DuPont Suva 410A:
<a href=\"https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf\">
https://www.chemours.com/Refrigerants/en_US/assets/downloads/h64423_Suva410A_thermo_prop_si.pdf
</a>
</p>
</html>",       revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));

      end R410A;
    annotation (preferredView="info",Documentation(info="<HTML>
<p>
This library contains function definitions for refrigerant properties used in
compressor models contained in package
<a href=\"modelica://IBPSA.Fluid.HeatPumps.Compressors\">
IBPSA.Fluid.HeatPumps.Compressors</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 17, 2016, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"),    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
            graphics={
            Line(
              points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
              color={64,64,64},
              smooth=Smooth.Bezier),
            Line(
              points={{-40,20},{68,20}},
              color={175,175,175}),
            Line(
              points={{-40,20},{-44,88},{-44,88}},
              color={175,175,175}),
            Line(
              points={{68,20},{86,-58}},
              color={175,175,175}),
            Line(
              points={{-60,-28},{56,-28}},
              color={175,175,175}),
            Line(
              points={{-60,-28},{-74,84},{-74,84}},
              color={175,175,175}),
            Line(
              points={{56,-28},{70,-80}},
              color={175,175,175}),
            Line(
              points={{-76,-80},{38,-80}},
              color={175,175,175}),
            Line(
              points={{-76,-80},{-94,-16},{-94,-16}},
              color={175,175,175})}));
    end Refrigerants;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains media models for water and moist air.
The media models in this package are
compatible with
<a href=\"modelica://Modelica.Media\">
Modelica.Media</a>
but the implementation is in general simpler, which often
leads to more efficient simulation.
Due to the simplifications, the media model of this package
are generally accurate for a smaller temperature range than the
models in <a href=\"modelica://Modelica.Media\">
Modelica.Media</a>, but the smaller temperature range may often be
sufficient for building HVAC applications.
</p>
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Line(
            points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
            color={64,64,64},
            smooth=Smooth.Bezier),
          Line(
            points={{-40,20},{68,20}},
            color={175,175,175}),
          Line(
            points={{-40,20},{-44,88},{-44,88}},
            color={175,175,175}),
          Line(
            points={{68,20},{86,-58}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{56,-28}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{-74,84},{-74,84}},
            color={175,175,175}),
          Line(
            points={{56,-28},{70,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{38,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{-94,-16},{-94,-16}},
            color={175,175,175})}));
  end Media;

  package Utilities "Package with utility functions such as for I/O"
    extends Modelica.Icons.Package;

    package Cryptographics "Package with cryptographic functions"
      extends Modelica.Icons.VariantsPackage;

      function sha
        "SHA1 encryption of a String"
        extends Modelica.Icons.Function;
        input String str "String to be encrypted";
        output String sha1 "SHA1-encrypted string";

      external "C" sha1 = cryptographicsHash(str)
        annotation (
        Include="#include <cryptographicsHash.c>",
        IncludeDirectory="modelica://IBPSA/Resources/C-Sources");

      annotation (
          Documentation(info="<html>
<p>
This function takes a String input and, using an external function written in C,
outputs its SHA1 encryption. The input string can be of any length, though the output
will always be 40 hexadecimal characters.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 31, 2018 by Alex Laferri&egrave;re:<br/>
Changed the encryption to a SHA1 with a string array input (rather than a file
input).
</li>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Revised sha implementation to avoid buffer overflow in borefield.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/755\">
#755</a>.
</li>
</ul>
</html>"));
      end sha;
      annotation (
    preferredView="info", Documentation(info="<html>
<p>
This package contains utility models for performing cryptographic operations.
</p>
</html>"));
    end Cryptographics;

    package Math "Library with functions such as for smoothing"
      extends Modelica.Icons.Package;

      block Average "Average of a vector"
        extends Modelica.Blocks.Interfaces.MISO;
      equation
       y = IBPSA.Utilities.Math.Functions.average(u=u, nin=nin);
      annotation (defaultComponentName="ave",
      Documentation(info="<html>
<p>This block outputs the average of the vector. </p>
</html>",
      revisions="<html>
<ul>
<li>November 28, 2013, by Marcus Fuchs:<br/>
Changed block to use function average.
</li>
<li>
April 3, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={Text(
                extent={{-74,46},{66,-58}},
                lineColor={0,0,255},
                textString="ave")}));
      end Average;

      package Functions "Package with mathematical functions"
        extends Modelica.Icons.VariantsPackage;

        function average "Average of a vector"
          extends Modelica.Icons.Function;
          input Integer nin "Number of inputs";
          input Real u[nin] "Input vector";
          output Real y "Result";

        algorithm
          y := sum(u)/nin;

          annotation (Documentation(info="<html>
<p>This function outputs the average of the vector. </p>
</html>",         revisions="<html>
<ul>
<li>November 28, 2013, by Marcus Fuchs:<br/>
Implementation based on Michael Wetter&apos;s block
<a href=\"modelica://IBPSA.Utilities.Math.Average\">
IBPSA.Utilities.Math.Average</a>.
</li>
</ul>
</html>"));
        end average;

        function besselJ0 "Bessel function of the first kind of order 0, J0"
          extends Modelica.Icons.Function;

          input Real x "Independent variable";
          output Real J0 "Bessel function J0(x)";

      protected
          constant Real P[5] = {1.0,
                    -0.1098628627e-2,
                    0.2734510407e-4,
                    -0.2073370639e-5,
                    0.2093887211e-6};
          constant Real Q[5] = {-0.1562499995e-1,
                    0.1430488765e-3,
                    -0.6911147651e-5,
                    0.7621095161e-6,
                    -0.934945152e-7};
          constant Real R[6] = {57568490574.0,
                    -13362590354.0,
                    651619640.7,
                    -11214424.18,
                    77392.33017,
                    -184.9052456};
          constant Real S[6] = {57568490411.0,
                    1029532985.0,
                    9494680.718,
                    59272.64853,
                    267.8532712,
                    1.0};
          Real ax = abs(x);
          Real xx;
          Real y;
          Real z;
          Real coeff1;
          Real coeff2;

        algorithm
          if ax < 8.0 then
            y := x^2;
            coeff1 := R[6];
            coeff2 := S[6];
            for i in 1:5 loop
              coeff1 := R[6-i] + y*coeff1;
              coeff2 := S[6-i] + y*coeff2;
            end for;
            J0 := coeff1/coeff2;
          else
            z := 8/ax;
            y := z^2;
            xx := ax - 0.785398164;
            coeff1 := P[5];
            coeff2 := Q[5];
            for j in 1:4 loop
              coeff1 := P[5-j] + y*coeff1;
              coeff2 := Q[5-j] + y*coeff2;
            end for;
            J0 := sqrt(0.636619772/ax)*(cos(xx)*coeff1 - z*sin(xx)*coeff2);
          end if;

        annotation (
        Documentation(info="<html>
<p>
Evaluates the Bessel function of the first kind of order 0 (<i>J<sub>0</sub></i>), based
on the implementations of Press et al. (1986).
</p>
<h4>References</h4>
<p>
Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William T.
Vetterling. Numerical Recipes - The Art of Scientific Computing. Cambridge
University Press (1986): 988 p.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 21, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end besselJ0;

        function besselJ1 "Bessel function of the first kind of order 1, J1"
          extends Modelica.Icons.Function;

          input Real x "Independent variable";
          output Real J1 "Bessel function J1(x)";

      protected
          constant Real P[5] = {1.0,
                    0.183105e-2,
                    -0.3516396496e-4,
                    0.2457520174e-5,
                    -0.240337019e-6};
          constant Real Q[5] = {0.04687499995,
                    -0.2002690873e-3,
                    0.8449199096e-5,
                    -0.88228987e-6,
                    0.105787412e-6};
          constant Real R[6] = {72362614232.0,
                    -7895059235.0,
                    242396853.1,
                    -2972611.439,
                    15704.48260,
                    -30.16036606};
          constant Real S[6] = {144725228442.0,
                    2300535178.0,
                    18583304.74,
                    99447.43394,
                    376.9991397,
                    1.0};
          Real ax = abs(x);
          Real xx;
          Real y;
          Real z;
          Real coeff1;
          Real coeff2;

        algorithm
          if ax < 8.0 then
            y := x^2;
            coeff1 := R[6];
            coeff2 := S[6];
            for i in 1:5 loop
              coeff1 := R[6-i] + y*coeff1;
              coeff2 := S[6-i] + y*coeff2;
            end for;
            J1 := x*coeff1/coeff2;
          else
            z := 8/ax;
            y := z^2;
            xx := ax - 2.356194491;
            coeff1 := P[5];
            coeff2 := Q[5];
            for j in 1:4 loop
              coeff1 := P[5-j] + y*coeff1;
              coeff2 := Q[5-j] + y*coeff2;
            end for;
            J1 := sqrt(0.636619772/ax)*(cos(xx)*coeff1 - z*sin(xx)*coeff2)*sign(x);
          end if;

        annotation (
        Documentation(info="<html>
<p>
Evaluates the Bessel function of the first kind of order 1 (<i>J<sub>1</sub></i>), based
on the implementations of Press et al. (1986).
</p>
<h4>References</h4>
<p>
Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William T.
Vetterling. Numerical Recipes - The Art of Scientific Computing. Cambridge
University Press (1986): 988 p.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 21, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end besselJ1;

        function besselY0 "Bessel function of the second kind of order 0, Y0"
          extends Modelica.Icons.Function;

          input Real x "Independent variable";
          output Real Y0 "Bessel function Y0(x)";

      protected
          constant Real P[5] = {1.0,
                    -0.1098628627e-2,
                    0.2734510407e-4,
                    -0.2073370639e-5,
                    0.2093887211e-6};
          constant Real Q[5] = {-0.1562499995e-1,
                    0.1430488765e-3,
                    -0.6911147651e-5,
                    0.7621095161e-6,
                    -0.934945152e-7};
          constant Real R[6] = {-2957821389.0,
                    7062834065.0,
                    -512359803.6,
                    10879881.29,
                    -86327.92757,
                    228.5622733};
          constant Real S[6] = {40076544269.0,
                    745249964.8,
                    7189466.438,
                    47447.26470,
                    226.1030244,
                    1.0};
          Real ax = abs(x);
          Real xx;
          Real y;
          Real z;
          Real coeff1;
          Real coeff2;

        algorithm
          if ax < 8.0 then
            y := x^2;
            coeff1 := R[6];
            coeff2 := S[6];
            for i in 1:5 loop
              coeff1 := R[6-i] + y*coeff1;
              coeff2 := S[6-i] + y*coeff2;
            end for;
            Y0 := coeff1/coeff2 + 0.636619772*IBPSA.Utilities.Math.Functions.besselJ0(x)*log(x);
          else
            z := 8/ax;
            y := z^2;
            xx := ax - 0.785398164;
            coeff1 := P[5];
            coeff2 := Q[5];
            for j in 1:4 loop
              coeff1 := P[5-j] + y*coeff1;
              coeff2 := Q[5-j] + y*coeff2;
            end for;
            Y0 := sqrt(0.636619772/ax)*(sin(xx)*coeff1 + z*cos(xx)*coeff2);
          end if;

        annotation (
        Documentation(info="<html>
<p>
Evaluates the Bessel function of the second kind of order 0 (<i>Y<sub>0</sub></i>), based
on the implementations of Press et al. (1986).
</p>
<h4>References</h4>
<p>
Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William T.
Vetterling. Numerical Recipes - The Art of Scientific Computing. Cambridge
University Press (1986): 988 p.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 21, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end besselY0;

        function besselY1 "Bessel function of the second kind of order 1, Y1"
          extends Modelica.Icons.Function;

          input Real x "Independent variable";
          output Real Y1 "Bessel function J1(x)";

      protected
          constant Real P[5] = {1.0,
                    0.183105e-2,
                    -0.3516396496e-4,
                    0.2457520174e-5,
                    -0.240337019e-6};
          constant Real Q[5] = {0.04687499995,
                    -0.2002690873e-3,
                    0.8449199096e-5,
                    -0.88228987e-6,
                    0.105787412e-6};
          constant Real R[6] = {-0.4900604943e13,
                    0.1275274390e13,
                    -0.5153438139e11,
                    0.7349264551e9,
                    -0.4237922726e7,
                    0.8511937935e4};
          constant Real S[7] = {0.2499580570e14,
                    0.4244419664e12,
                    0.3733650367e10,
                    0.2245904002e8,
                    0.1020426050e6,
                    0.3549632885e3,
                    1.0};
          Real ax = abs(x);
          Real xx;
          Real y;
          Real z = 8/ax;
          Real coeff1;
          Real coeff2;

        algorithm
          if ax < 8.0 then
            y := x^2;
            coeff1 := R[6];
            coeff2 := S[6] + y*S[7];
            for i in 1:5 loop
              coeff1 := R[6-i] + y*coeff1;
              coeff2 := S[6-i] + y*coeff2;
            end for;
            Y1 := x*coeff1/coeff2 + 0.636619772*(IBPSA.Utilities.Math.Functions.besselJ1(x)*log(x) - 1.0/x);
          else
            y := z^2;
            xx := ax - 2.356194491;
            coeff1 := P[5];
            coeff2 := Q[5];
            for j in 1:4 loop
              coeff1 := P[5-j] + y*coeff1;
              coeff2 := Q[5-j] + y*coeff2;
            end for;
            Y1 := sqrt(0.636619772/ax)*(sin(xx)*coeff1 + z*cos(xx)*coeff2)*sign(x);
          end if;

        annotation (
        Documentation(info="<html>
<p>
Evaluates the Bessel function of the second kind of order 1 (<i>Y<sub>1</sub></i>), based
on the implementations of Press et al. (1986).
</p>
<h4>References</h4>
<p>
Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William T.
Vetterling. Numerical Recipes - The Art of Scientific Computing. Cambridge
University Press (1986): 988 p.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 21, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end besselY1;

        function binomial "Returns the binomial coefficient"
          extends Modelica.Icons.Function;

          input Integer n "Size of set";
          input Integer k(min=0) "Size of subsets";
          output Integer binom "Binomial coefficient";

        algorithm
          assert(n >= k, "n must be k or greater.");
          assert(k >= 0, "k must be 0 or greater.");
          if k <= 0.5*n then
            binom := integer(IBPSA.Utilities.Math.Functions.fallingFactorial(n,k)/IBPSA.Utilities.Math.Functions.factorial(k));
          else
            binom := integer(IBPSA.Utilities.Math.Functions.fallingFactorial(n,n-k)/IBPSA.Utilities.Math.Functions.factorial(n-k));
          end if;

        annotation (Documentation(info="<html>
<p>
Function that evaluates the binomial coefficient \"n choose k\".
</p>
</html>",         revisions="<html>
<ul>
<li>
February 9, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end binomial;

        function cubicHermiteLinearExtrapolation
          "Interpolate using a cubic Hermite spline with linear extrapolation"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real x1 "Lower abscissa value";
          input Real x2 "Upper abscissa value";
          input Real y1 "Lower ordinate value";
          input Real y2 "Upper ordinate value";
          input Real y1d "Lower gradient";
          input Real y2d "Upper gradient";
          output Real y "Interpolated ordinate value";
        algorithm
          if (x > x1 and x < x2) then
            y:=Modelica.Fluid.Utilities.cubicHermite(
              x=x,
              x1=x1,
              x2=x2,
              y1=y1,
              y2=y2,
              y1d=y1d,
              y2d=y2d);
          elseif x <= x1 then
            // linear extrapolation
            y:=y1 + (x - x1)*y1d;
          else
            y:=y2 + (x - x2)*y2d;
          end if;
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
For <i>x<sub>1</sub> &lt; x &lt; x<sub>2</sub></i>, this function interpolates
using cubic hermite spline. For <i>x</i> outside this interval, the function
linearly extrapolates.
</p>
<p>
For how to use this function, see
<a href=\"modelica://IBPSA.Utilities.Math.Functions.Examples.CubicHermite\">
IBPSA.Utilities.Math.Functions.Examples.CubicHermite</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end cubicHermiteLinearExtrapolation;

        function exponentialIntegralE1 "Exponential integral, E1"
          extends Modelica.Icons.Function;

          input Real x "Independent variable";
          output Real E1 "Exponential integral E1(x)";

      protected
          constant Real a1[6] = {-0.57721566, 0.99999193, -0.24991055, 0.05519968, -0.00976004, 0.00107857};
          constant Real a2[5] = {0.2677737343, 8.6347608925, 18.0590169730, 8.5733287401, 1.0};
          constant Real b2[5] = {3.9584969228, 21.0996530827, 25.6329561486, 9.5733223454, 1.0};

        algorithm

            E1 := if x < 1 then
                    IBPSA.Utilities.Math.Functions.polynomial(x, a1) - log(x)
                  else
                   IBPSA.Utilities.Math.Functions.polynomial(x, a2)/(IBPSA.Utilities.Math.Functions.polynomial(x, b2)*x*exp(x));

        annotation (
        Inline=true,
        Documentation(info="<html>
<p>
Evaluates the exponential integral (E<sub>1</sub>), based
on the polynomial and rational approximations of Abramowitz and Stegun (1964).
</p>
<h4>References</h4>
<p>
Abramowitz, Milton, and Irene A. Stegun. Handbook of Mathematical Functions
with Formulas, Graphs, and Mathematical Tables. National Bureau of Standards.
(1964): 1046 p.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 16, 2018 by Michael Wetter:<br/>
Inlined function.
</li>
<li>
March 21, 2018 by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end exponentialIntegralE1;

        function factorial "Returns the value n! as an integer"
          extends Modelica.Icons.Function;

          input Integer n(min=0, max=12) "Integer number";
          output Integer f "Factorial of n";

        algorithm
          assert(n >= 0, "n must be 0 or greater.");
          assert(n <= 12, "n must be 12 or less.");
          f := 1;
          for k in 1:n loop
            f := k*f;
          end for;

        annotation (Documentation(info="<html>
<p>
Function that returns the factorial <i>n!</i> for <i>0 &le; n &le; 12</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 9, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end factorial;

        function fallingFactorial "Returns the k-th falling factorial of n"
          extends Modelica.Icons.Function;
          input Integer n "Integer number";
          input Integer k "Falling factorial power";
          output Integer f "k-th falling factorial of n";
      protected
          Integer maxInt = 2147483646 "Max 32-bit integer";
        algorithm
          if k > n then
            f := 0;
          else
            f := 1;
            for i in 0:(k-1) loop
              assert(f <= maxInt/(n-i), "Integer overflow");
              f := f*(n-i);
            end for;
          end if;

        annotation (Documentation(info="<html>
<p>
Function that evaluates the falling factorial \"k-permutations of n\".
</p>
</html>",         revisions="<html>
<ul>
<li>
May 22, 2019, by Michael Wetter:<br/>
Changed upper limit for <code>maxInt</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1145\">issue 1145</a>.
</li>
<li>
February 9, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
        end fallingFactorial;

        function inverseXRegularized
          "Function that approximates 1/x by a twice continuously differentiable function"
          extends Modelica.Icons.Function;
         input Real x "Abscissa value";
         input Real delta(min=Modelica.Constants.eps)
            "Abscissa value below which approximation occurs";
         input Real deltaInv = 1/delta "Inverse value of delta";

         input Real a = -15*deltaInv "Polynomial coefficient";
         input Real b = 119*deltaInv^2 "Polynomial coefficient";
         input Real c = -361*deltaInv^3 "Polynomial coefficient";
         input Real d = 534*deltaInv^4 "Polynomial coefficient";
         input Real e = -380*deltaInv^5 "Polynomial coefficient";
         input Real f = 104*deltaInv^6 "Polynomial coefficient";

         output Real y "Function value";

        algorithm
          y :=if (x > delta or x < -delta) then 1/x elseif (x < delta/2 and x > -delta/2) then x/(delta*delta) else
            IBPSA.Utilities.Math.Functions.BaseClasses.smoothTransition(
               x=x,
               delta=delta, deltaInv=deltaInv,
               a=a, b=b, c=c, d=d, e=e, f=f);

          annotation (smoothOrder=2,
          derivative(order=1,
                  zeroDerivative=delta,
                  zeroDerivative=deltaInv,
                  zeroDerivative=a,
                  zeroDerivative=b,
                  zeroDerivative=c,
                  zeroDerivative=d,
                  zeroDerivative=e,
                  zeroDerivative=f)=IBPSA.Utilities.Math.Functions.BaseClasses.der_inverseXRegularized,
                      Inline=true,
        Documentation(info="<html>
<p>
Function that approximates <i>y=1 &frasl; x</i>
inside the interval <i>-&delta; &le; x &le; &delta;</i>.
The approximation is twice continuously differentiable with a bounded derivative on the whole
real line.
</p>
<p>
See the plot of
<a href=\"modelica://IBPSA.Utilities.Math.Functions.Examples.InverseXRegularized\">
IBPSA.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for the graph.
</p>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Typically, these coefficients only depend on parameters and hence
can be computed once.
They must be equal to their default values, otherwise the function
is not twice continuously differentiable.
By exposing these coefficients as function arguments, models
that call this function can compute them as parameters, and
assign these parameter values in the function call.
This avoids that the coefficients are evaluated for each time step,
as they would otherwise be if they were to be computed inside the
body of the function. However, assigning the values is optional
as otherwise, at the expense of efficiency, the values will be
computed each time the function is invoked.
See
<a href=\"modelica://IBPSA.Utilities.Math.Functions.Examples.InverseXRegularized\">
IBPSA.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for how to efficiently call this function.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 10, 2015, by Michael Wetter:<br/>
Removed dublicate entry <code>smoothOrder = 1</code>
and reimplmented the function so it is twice continuously differentiable.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 18, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end inverseXRegularized;

        function isMonotonic "Returns true if the argument is a monotonic sequence"
          extends Modelica.Icons.Function;
          input Real x[:] "Sequence to be tested";
          input Boolean strict=false "Set to true to test for strict monotonicity";
          output Boolean monotonic "True if x is monotonic increasing or decreasing";
      protected
          Integer n=size(x, 1) "Number of data points";

        algorithm
          if n == 1 then
            monotonic := true;
          else
            monotonic := true;
            if strict then
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] > x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for j in 1:n - 1 loop
                  if (not x[j] < x[j + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            else
              // not strict
              if (x[1] >= x[n]) then
                for k in 1:n - 1 loop
                  if (not x[k] >= x[k + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for l in 1:n - 1 loop
                  if (not x[l] <= x[l + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            end if;
            // strict
          end if;

          annotation (Documentation(info="<html>
<p>
This function returns <code>true</code> if its argument is
monotonic increasing or decreasing, and <code>false</code> otherwise.
If <code>strict=true</code>, then strict monotonicity is tested,
otherwise weak monotonicity is tested.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isMonotonic;

        function polynomial "Polynomial function"
          extends Modelica.Icons.Function;
         input Real x "Independent variable";
         input Real a[:] "Coefficients";
         output Real y "Result";
      protected
         parameter Integer n = size(a, 1)-1;
         Real xp[n+1] "Powers of x";
        algorithm
          xp[1] :=1;
          for i in 1:n loop
             xp[i+1] :=xp[i]*x;
          end for;
          y :=a*xp;
          annotation (Documentation(info="<html>
This function computes a polynomial of arbitrary order.
The polynomial has the form
<p align=\"center\" style=\"font-style:italic;\">
  y = a<sub>1</sub> + a<sub>2</sub> x + a<sub>3</sub> x<sup>2</sup> + ...
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 14, 2016, by Michael Wetter:<br/>
Removed derivative annotation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/602\">issue 602</a>.
</li>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
March 2, by Michael Wetter:<br/>
Removed redundant <code>smoothOrder</code> annotation.
</li>
<li>
February 29, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        smoothOrder=999);
        end polynomial;

        function regNonZeroPower
          "Power function, regularized near zero, but nonzero value for x=0"
          extends Modelica.Icons.Function;

         input Real x "Abscissa value";
         input Real n "Exponent";
         input Real delta = 0.01 "Abscissa value where transition occurs";
         output Real y "Function value";
      protected
          Real a1;
          Real a3;
          Real a5;
          Real delta2;
          Real x2;
          Real y_d "=y(delta)";
          Real yP_d "=dy(delta)/dx";
          Real yPP_d "=d^2y(delta)/dx^2";
        algorithm
          if abs(x) > delta then
           y := abs(x)^n;
          else
           delta2 :=delta*delta;
           x2 :=x*x;
           y_d :=delta^n;
           yP_d :=n*delta^(n - 1);
           yPP_d :=n*(n - 1)*delta^(n - 2);
           a1 := -(yP_d/delta - yPP_d)/delta2/8;
           a3 := (yPP_d - 12 * a1 * delta2)/2;
           a5 := (y_d - delta2 * (a3 + delta2 * a1));
           y := a5 + x2 * (a3 + x2 * a1);
           assert(a5>0, "Delta is too small for this exponent.");
          end if;
          annotation (
            Documentation(info="<html>

Function that approximates <i>y=|x|<sup>n</sup></i> where <i>n &gt; 0</i>
so that
<ul>
<li><i>y(0)</i> is not equal to zero.</li>
<li><i>dy/dx</i> is bounded and continuous everywhere.</li>
</ul>

<p>
This function replaces <i>y=|x|<sup>n</sup></i> in the interval
<i>-&delta;...+&delta;</i> by a 4-th order polynomial that has the same
function value and the first and second derivative at <i>x=&plusmn; &delta;</i>.
</p>
<p>
A typical use of this function is to replace the
function for the convective heat transfer
coefficient for forced or free convection that is of the form
<i>h=c |dT|<sup>n</sup></i> for some constant <i>c</i> and exponent
<i>0 &le; n &le; 1</i>.
By using this function, the original function
that has an infinite derivative near zero and that takes on zero
at the origin is replaced by a function with a bounded derivative and
a non-zero value at the origin. Physically,
the region <i>-&delta;...+&delta;</i> may be interpreted as the region
where heat conduction dominates convection in the boundary layer.
</p>
See the package <code>Examples</code> for the graph.
</html>",         revisions="<html>
<ul>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 14, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Inline=true,
                   smoothOrder=2,
                   derivative(zeroDerivative=n, zeroDerivative=delta)=BaseClasses.der_regNonZeroPower);
        end regNonZeroPower;

        function regStep
          "Approximation of a general step, such that the approximation is continuous and differentiable"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real y1 "Ordinate value for x > 0";
          input Real y2 "Ordinate value for x < 0";
          input Real x_small(min=0) = 1e-5
            "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
          output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
        algorithm
          y := smooth(1, if x >  x_small then y1 else
                         if x < -x_small then y2 else
                         if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);

          annotation(Inline=true,
          Documentation(revisions="<html>
<ul>
<li><i>February 18, 2016</i>
    by Marcus Fuchs:<br/>
    Add function with <code>Inline = true</code> in annotations to package for better performance,
    as suggested in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a> .</li>
<li><i>April 29, 2008</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br/>
    Designed and implemented.</li>
<li><i>August 12, 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",         info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <b>if</b> x &gt; 0 <b>then</b> y1 <b>else</b> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <b>smooth</b>(1, <b>if</b> x &gt;  x_small <b>then</b> y1 <b>else</b>
                 <b>if</b> x &lt; -x_small <b>then</b> y2 <b>else</b> f(y1, y2));
</pre>

<p>
In the region <code>-x_small &lt; x &lt; x_small</code> a 2nd order polynomial is used
for a smooth transition from <code>y1</code> to <code>y2</code>.
</p>
</html>"));
        end regStep;

        function smoothLimit
          "Once continuously differentiable approximation to the limit function"
          extends Modelica.Icons.Function;
          input Real x "Variable";
          input Real l "Low limit";
          input Real u "Upper limit";
          input Real deltaX "Width of transition interval";
          output Real y "Result";

      protected
          Real cor;
        algorithm
          cor :=deltaX/10;
          y := IBPSA.Utilities.Math.Functions.smoothMax(x,l+deltaX,cor);
          y := IBPSA.Utilities.Math.Functions.smoothMin(y,u-deltaX,cor);
          annotation (smoothOrder = 1,
          Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>limit(.,.)</code> function.
The output is bounded to be in <i>[l, u]</i>.
</p>
<p>
Note that the limit need not be respected, such as illustrated in
<a href=\"modelica://IBPSA.Utilities.Math.Examples.SmoothMin\">
IBPSA.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
Sept 1, 2010, by Michael Wetter:<br/>
Changed scaling to make sure that bounds are never violated.
</li>
<li>
July 14, 2010, by Wangda Zuo, Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothLimit;

        function smoothMax
          "Once continuously differentiable approximation to the maximum function"
          extends Modelica.Icons.Function;
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := IBPSA.Utilities.Math.Functions.regStep(
                 y1=x1, y2=x2, x=x1-x2, x_small=deltaX);
          annotation (
          Inline=true,
          smoothOrder=1,
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>max(.,.)</code> function.
</p>
<p>
Note that the maximum need not be respected, such as illustrated in
<a href=\"modelica://IBPSA.Utilities.Math.Examples.SmoothMin\">
IBPSA.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMax;

        function smoothMin
          "Once continuously differentiable approximation to the minimum function"
          extends Modelica.Icons.Function;
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := IBPSA.Utilities.Math.Functions.regStep(
                 y1=x1, y2=x2, x=x2-x1, x_small=deltaX);
          annotation (
          Inline=true,
          smoothOrder=1,
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>min(.,.)</code> function.
</p>
<p>
Note that the minimum need not be respected, such as illustrated in
<a href=\"modelica://IBPSA.Utilities.Math.Examples.SmoothMin\">
IBPSA.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMin;

        function spliceFunction
          extends Modelica.Icons.Function;
            input Real pos "Argument of x > 0";
            input Real neg "Argument of x < 0";
            input Real x "Independent value";
            input Real deltax "Half width of transition interval";
            output Real out "Smoothed value";
      protected
            Real scaledX1;
            Real y;
            constant Real asin1 = Modelica.Math.asin(1);
        algorithm
            scaledX1 := x/deltax;
            if scaledX1 <= -0.999999999 then
              out := neg;
            elseif scaledX1 >= 0.999999999 then
              out := pos;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX1*asin1)) + 1)/2;
              out := pos*y + (1 - y)*neg;
            end if;

            annotation (
        smoothOrder=1,
        derivative=BaseClasses.der_spliceFunction,
        Documentation(info="<html>
<p>
Function to provide a once continuously differentiable transition between
to arguments.
</p><p>
The function is adapted from
<a href=\"modelica://Modelica.Media.Air.MoistAir.Utilities.spliceFunction\">
Modelica.Media.Air.MoistAir.Utilities.spliceFunction</a> and provided here
for easier accessability to model developers.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
May 11, 2010, by Michael Wetter:<br/>
Removed default value for transition interval as this is problem dependent.
</li>
<li>
May 20, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end spliceFunction;

        function splineDerivatives
          "Function to compute the derivatives for cubic hermite spline interpolation"
          extends Modelica.Icons.Function;
          input Real x[:] "Support point, strict monotone increasing";
          input Real y[size(x, 1)] "Function values at x";
          input Boolean ensureMonotonicity=isMonotonic(y, strict=false)
            "Set to true to ensure monotonicity of the cubic hermite";
          output Real d[size(x, 1)] "Derivative at the support points";
      protected
          Integer n=size(x, 1) "Number of data points";
          Real delta[n - 1] "Slope of secant line between data points";
          Real alpha "Coefficient to ensure monotonicity";
          Real beta "Coefficient to ensure monotonicity";
          Real tau "Coefficient to ensure monotonicity";

        algorithm
          if (n>1) then
            assert(x[1] < x[n], "x must be strictly increasing.
  Received x[1] = "         + String(x[1]) + "
           x["         + String(n) + "] = " + String(x[n]));
          // Check data
            assert(isMonotonic(x, strict=true),
              "x-values must be strictly monontone increasing or decreasing.");
            if ensureMonotonicity then
              assert(isMonotonic(y, strict=false),
                "If ensureMonotonicity=true, y-values must be monontone increasing or decreasing.");
            end if;
          end if;

          // Compute derivatives at the support points
          if n == 1 then
            // only one data point
            d[1] :=0;
          elseif n == 2 then
            // linear function
            d[1] := (y[2] - y[1])/(x[2] - x[1]);
            d[2] := d[1];
          else
            // Slopes of the secant lines between i and i+1
            for i in 1:n - 1 loop
              delta[i] := (y[i + 1] - y[i])/(x[i + 1] - x[i]);
            end for;
            // Initial values for tangents at the support points.
            // End points use one-sided derivatives
            d[1] := delta[1];
            d[n] := delta[n - 1];

            for k in 2:n - 1 loop
              d[k] := (delta[k - 1] + delta[k])/2;
            end for;

          end if;
          // Ensure monotonicity
          if n > 2 and ensureMonotonicity then
            for u in 1:n - 1 loop
              if (abs(delta[u]) < Modelica.Constants.small) then
                d[u] := 0;
                d[u + 1] := 0;
              else
                alpha := d[u]/delta[u];
                beta := d[u + 1]/delta[u];
                // Constrain derivative to ensure monotonicity in this interval
                if (alpha^2 + beta^2) > 9 then
                  tau := 3/(alpha^2 + beta^2)^(1/2);
                  d[u] := delta[u]*alpha*tau;
                  d[u + 1] := delta[u]*beta*tau;
                end if;
              end if;
            end for;
          end if;
          annotation (Documentation(info="<html>
<p>
This function computes the derivatives at the support points <i>x<sub>i</sub></i>
that can be used as input for evaluating a cubic hermite spline.
</p>
<p>
If <code>ensureMonotonicity=true</code>, then the support points <i>y<sub>i</sub></i>
need to be monotone increasing (or increasing), and the computed derivatives
<i>d<sub>i</sub></i> are such that the cubic hermite is monotone increasing (or decreasing).
The algorithm to ensure monotonicity is based on the method described in Fritsch and Carlson (1980) for
<i>&rho; = &rho;<sub>2</sub></i>.
</p>
<p>
This function is typically used with
<a href=\"modelica://IBPSA.Utilities.Math.Functions.cubicHermiteLinearExtrapolation\">
IBPSA.Utilities.Math.Functions.cubicHermiteLinearExtrapolation</a>
which is used to evaluate the cubic spline.
Because in many applications, the shape of the spline depends on parameters,
this function has been implemented in such a way that all derivatives can be
computed at once and then stored for use during the time stepping,
in which the above function may be called.
</p>
<h4>References</h4>
<p>
F.N. Fritsch and R.E. Carlson, <a href=\"http://dx.doi.org/10.1137/0717021\">Monotone piecewise cubic interpolation</a>.
<i>SIAM J. Numer. Anal.</i>, 17 (1980), pp. 238-246.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 26, 2016 by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
September 29, 2011 by Michael Wetter:<br/>
Added special case for one data point and two data points.
</li>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end splineDerivatives;

        package BaseClasses
        "Package with base classes for IBPSA.Utilities.Math.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_2_regNonZeroPower
            "Power function, regularized near zero, but nonzero value for x=0"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           input Real der_2_x;
           output Real der_2_y "Function value";
        protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_2_y := n*(abs(x)^(n-1)*sign(x)*der_2_x
                        + (n-1)*abs(x)^(n-2)*der_x^2);
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;

             der_2_y := (12*a1*x2+2*a3)*der_x^2
                        +x * ( 4 * a1 * x2 + 2 * a3)*der_2_x;
            end if;
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the second derivative of the function
<a href=\"modelica://IBPSA.Utilities.Math.Functions.regNonZeroPower\">
IBPSA.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
August 17, 2015 by Michael Wetter:<br/>
Corrected wrong derivative implementation which omitted the <code>der_x</code> term.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/303\">issue 303</a>.
</li>
<li>
April 9, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_2_regNonZeroPower;

          function der_2_smoothTransition
            "Second order derivative of smoothTransition with respect to x"
            extends Modelica.Icons.Function;
            input Real x "Abscissa value";
            input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";

            input Real deltaInv "Inverse value of delta";
            input Real a "Polynomial coefficient";
            input Real b "Polynomial coefficient";
            input Real c "Polynomial coefficient";
            input Real d "Polynomial coefficient";
            input Real e "Polynomial coefficient";
            input Real f "Polynomial coefficient";

            input Real x_der "Derivative of x";
            input Real x_der2 "Second order derivative of x";
            output Real y_der2 "Second order derivative of function value";
        protected
            Real aX "Absolute value of x";
            Real ex "Intermediate expression";
          algorithm
           aX:= abs(x);
           ex     := 2*c + aX*(6*d + aX*(12*e + aX*20*f));
           y_der2 := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der2
                   + x_der*x_der*( if x > 0 then ex else -ex);

          annotation (
          Documentation(info="<html>
<p>
This function is the 2nd order derivative of
<a href=\"modelica://IBPSA.Utilities.Math.Functions.BaseClasses.smoothTransition\">
IBPSA.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_2_smoothTransition;

          function der_inverseXRegularized "Derivative of inverseXRegularised function"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
           input Real deltaInv = 1/delta "Inverse value of delta";

           input Real a = -15*deltaInv "Polynomial coefficient";
           input Real b = 119*deltaInv^2 "Polynomial coefficient";
           input Real c = -361*deltaInv^3 "Polynomial coefficient";
           input Real d = 534*deltaInv^4 "Polynomial coefficient";
           input Real e = -380*deltaInv^5 "Polynomial coefficient";
           input Real f = 104*deltaInv^6 "Polynomial coefficient";

           input Real x_der "Abscissa value";
           output Real y_der "Function value";

          algorithm
            y_der :=if (x > delta or x < -delta) then -x_der/x/x elseif (x < delta/2 and x > -delta/2) then x_der/(delta*delta) else
              IBPSA.Utilities.Math.Functions.BaseClasses.der_smoothTransition(
                 x=x,
                 x_der=x_der,
                 delta=delta,
                 deltaInv=deltaInv,
                 a=a, b=b, c=c, d=d, e=e, f=f);
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://IBPSA.Utilities.Math.Functions.inverseXRegularized\">
IBPSA.Utilities.Math.Functions.inverseXRegularized</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
June 22, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_inverseXRegularized;

          function der_regNonZeroPower
            "Power function, regularized near zero, but nonzero value for x=0"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real n "Exponent";
           input Real delta = 0.01 "Abscissa value where transition occurs";
           input Real der_x;
           output Real der_y "Function value";
        protected
            Real a1;
            Real a3;
            Real delta2;
            Real x2;
            Real y_d "=y(delta)";
            Real yP_d "=dy(delta)/dx";
            Real yPP_d "=d^2y(delta)/dx^2";
          algorithm
            if abs(x) > delta then
             der_y := sign(x)*n*abs(x)^(n-1)*der_x;
            else
             delta2 :=delta*delta;
             x2 :=x*x;
             y_d :=delta^n;
             yP_d :=n*delta^(n - 1);
             yPP_d :=n*(n - 1)*delta^(n - 2);
             a1 := -(yP_d/delta - yPP_d)/delta2/8;
             a3 := (yPP_d - 12 * a1 * delta2)/2;
             der_y := x * ( 4 * a1 * x * x + 2 * a3) * der_x;
            end if;
           annotation(derivative(order=2, zeroDerivative=n, zeroDerivative=delta)=der_2_regNonZeroPower,
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://IBPSA.Utilities.Math.Functions.regNonZeroPower\">
IBPSA.Utilities.Math.Functions.regNonZeroPower</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
August 17, 2015 by Michael Wetter:<br/>
Corrected wrong derivative implementation which omitted the <code>der_x</code> term.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/303\">issue 303</a>.
</li>
<li>
March 30, 2011, by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
April 9, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_regNonZeroPower;

          function der_smoothTransition
            "First order derivative of smoothTransition with respect to x"
            extends Modelica.Icons.Function;
            input Real x "Abscissa value";
            input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";

            input Real deltaInv "Inverse value of delta";
            input Real a "Polynomial coefficient";
            input Real b "Polynomial coefficient";
            input Real c "Polynomial coefficient";
            input Real d "Polynomial coefficient";
            input Real e "Polynomial coefficient";
            input Real f "Polynomial coefficient";

            input Real x_der "Derivative of x";
            output Real y_der "Derivative of function value";

        protected
            Real aX "Absolute value of x";
          algorithm
           aX:= abs(x);
           y_der := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der;
           annotation(smoothOrder=1,
                    derivative(order=2,
                    zeroDerivative=delta,
                    zeroDerivative=deltaInv,
                    zeroDerivative=a,
                    zeroDerivative=b,
                    zeroDerivative=c,
                    zeroDerivative=d,
                    zeroDerivative=e,
                    zeroDerivative=f)=IBPSA.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition,
          Documentation(info="<html>
<p>
This function is the 1st order derivative of
<a href=\"modelica://IBPSA.Utilities.Math.Functions.BaseClasses.smoothTransition\">
IBPSA.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
its derivative is provided in
<a href=\"modelica://IBPSA.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
IBPSA.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_smoothTransition;

          function der_spliceFunction "Derivative of splice function"
            extends Modelica.Icons.Function;
              input Real pos;
              input Real neg;
              input Real x;
              input Real deltax=1;
              input Real dpos;
              input Real dneg;
              input Real dx;
              input Real ddeltax=0;
              output Real out;
        protected
              Real scaledX;
              Real scaledX1;
              Real dscaledX1;
              Real y;
              constant Real asin1 = Modelica.Math.asin(1);
          algorithm
              scaledX1 := x/deltax;
              if scaledX1 <= -0.99999999999 then
                out := dneg;
              elseif scaledX1 >= 0.9999999999 then
                out := dpos;
              else
                scaledX := scaledX1*asin1;
                dscaledX1 := (dx - scaledX1*ddeltax)/deltax;
                y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
                out := dpos*y + (1 - y)*dneg;
                out := out + (pos - neg)*dscaledX1*asin1/2/(
                  Modelica.Math.cosh(Modelica.Math.tan(scaledX))*Modelica.Math.cos(
                  scaledX))^2;
              end if;

          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://IBPSA.Utilities.Math.Functions.spliceFunction\">
IBPSA.Utilities.Math.Functions.spliceFunction</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 7, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_spliceFunction;

          function smoothTransition
            "Twice continuously differentiable transition between the regions"
            extends Modelica.Icons.Function;

            // The function that transitions between the regions is implemented
            // using its own function. This allows Dymola 2016 to inline the function
            // inverseXRegularized.

          input Real x "Abscissa value";
          input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
          input Real deltaInv = 1/delta "Inverse value of delta";

          input Real a = -15*deltaInv "Polynomial coefficient";
          input Real b = 119*deltaInv^2 "Polynomial coefficient";
          input Real c = -361*deltaInv^3 "Polynomial coefficient";
          input Real d = 534*deltaInv^4 "Polynomial coefficient";
          input Real e = -380*deltaInv^5 "Polynomial coefficient";
          input Real f = 104*deltaInv^6 "Polynomial coefficient";
          output Real y "Function value";
        protected
            Real aX "Absolute value of x";

          algorithm
           aX:= abs(x);
           y := (if x >= 0 then 1 else -1) * (a + aX*(b + aX*(c + aX*(d + aX*(e + aX*f)))));
          annotation(smoothOrder=2,
            derivative(order=1,
                    zeroDerivative=delta,
                    zeroDerivative=deltaInv,
                    zeroDerivative=a,
                    zeroDerivative=b,
                    zeroDerivative=c,
                    zeroDerivative=d,
                    zeroDerivative=e,
                    zeroDerivative=f)=IBPSA.Utilities.Math.Functions.BaseClasses.der_smoothTransition,
              Documentation(info="<html>
<p>
This function is used by
<a href=\"modelica://IBPSA.Utilities.Math.Functions.inverseXRegularized\">
IBPSA.Utilities.Math.Functions.inverseXRegularized</a>
to provide a twice continuously differentiable transition between
the different regions.
The code has been implemented in a function as this allows
to implement the function
<a href=\"modelica://IBPSA.Utilities.Math.Functions.inverseXRegularized\">
IBPSA.Utilities.Math.Functions.inverseXRegularized</a>
in such a way that Dymola inlines it.
However, this function will not be inlined as its body is too large.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
derivatives are provided in
<a href=\"modelica://IBPSA.Utilities.Math.Functions.BaseClasses.der_smoothTransition\">
IBPSA.Utilities.Math.Functions.BaseClasses.der_smoothTransition</a>
and in
<a href=\"modelica://IBPSA.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
IBPSA.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 12, 2018, by David Blum:<br/>
Change if-statement to if-expression.  
For issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1019\">#1019</a>.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end smoothTransition;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IBPSA.Utilities.Math.Functions\">IBPSA.Utilities.Math.Functions</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for commonly used
mathematical operations. The functions are used in
the blocks
<a href=\"modelica://IBPSA.Utilities.Math\">
IBPSA.Utilities.Math</a>.
</p>
</html>"));
      end Functions;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for commonly used
mathematical operations.
The classes in this package augment the classes
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</p>
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
              {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
                {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
                -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
                -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
                {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
                0,0,0}, smooth=Smooth.Bezier)}));
    end Math;
  annotation (
  preferredView="info", Documentation(info="<html>
<p>
This package contains utility models such as for thermal comfort calculation, input/output, co-simulation, psychrometric calculations and various functions that are used throughout the library.
</p>
</html>"),
  Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
  end Utilities;
annotation (
version="3.0.0",
versionDate="2018-09-28",
dateModified = "2018-09-28",
uses(Modelica(version="3.2.3")),
conversion(from(version="3.0.0",
                script="modelica://IBPSA/Resources/Scripts/Dymola/ConvertIBPSA_from_3.0_to_4.0.mos")),
preferredView="info",
Documentation(info="<html>
<p>
<img
align=\"right\"
alt=\"Logo of IBPSA\"
src=\"modelica://IBPSA/Resources/Images/IBPSA-logo-text.png\" border=\"1\"/>
The <code>IBPSA</code> library is a free library
that provides more than 300 classes (models, functions, etc.) for the development of
Modelica libraries for building and community energy and control systems.
The library is compatible with models from the Modelica Standard Library,
in particular with models from
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a>
and
<a href=\"modelica://Modelica.Media\">Modelica.Media</a>.
</p>
<p>
The development of the IBPSA library is organized through the
<a href=\"https://ibpsa.github.io/project1\">IBPSA Project 1</a>
of the International Building Performance Simulation Association (IBPSA).
From 2012 to 2017, the development was organized through the
<a href=\"http://www.iea-annex60.org\">Annex 60 project</a>
of the Energy in Buildings and Communities Programme of the International Energy Agency (IEA EBC).
</p>
<p>
The intent of the library is that it will be extended by
implementations of Modelica libraries that are targeted to end-users.
Major goals are
</p>
<ul>
<li>to codify best practice and to provide a solid foundation onto which
other libraries for building and community energy systems can be built, and
</li>
<li>
to avoid a fragmentation of libraries that serve similar purpose but
that cannot share models among each others, thereby duplicating efforts
for model development and validation.
</li>
</ul>
<p>
Hence, this library is typically not used directly by end-users,
but rather by developers of libraries that will be distributed to end-users.
Libraries that are using the <code>IBPSA</code> library as their core, or
that are working on using the <code>IBPSA</code> as their core, include, in
alphabetic order:
</p>
<ul>
<li>
The <code>AixLib</code> library from RWTH Aachen, Germany, available at
<a href=\"https://github.com/RWTH-EBC/AixLib\">https://github.com/RWTH-EBC/AixLib</a>
</li>
<li>
The <code>Buildings</code> library from Lawrence Berkeley National Laboratory, Berkeley, CA, available at
<a href=\"http://simulationresearch.lbl.gov/modelica\">http://simulationresearch.lbl.gov/modelica/</a>.
</li>
<li>
The <code>BuildingSystems</code> library from
Universit&auml;t der K&uuml;nste Berlin, Germany,
available at
<a href=\"http://www.modelica-buildingsystems.de/\">http://www.modelica-buildingsystems.de/</a>.
</li>
<li>
The <code>IDEAS</code> library from KU Leuven, Belgium, available at
<a href=\"https://github.com/open-ideas/IDEAS\">https://github.com/open-ideas/IDEAS</a>.
</li>
</ul>
<p>
The library also contains more than 300 example and validation models. For Dymola,
each of these example and validation models contains a script that simulates it and
plots certain variables of interest.
</p>
<p>
The web page for this library is
<a href=\"https://github.com/ibpsa/modelica\">https://github.com/ibpsa/modelica</a>.
Contributions to further advance the library are welcomed.
Contributions may not only be in the form of model development, but also
through model use, model testing and validation,
requirements definition or providing feedback regarding the model applicability
to solve specific problems.
</p>
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
        graphics={Bitmap(extent={{-90,-90},{90,90}},
        fileName="modelica://IBPSA/Resources/Images/IBPSA-logo.png")}));
end IBPSA;

package ModelicaServices
  "ModelicaServices (Default implementation) - Models and functions used in the Modelica Standard Library requiring a tool specific implementation"
extends Modelica.Icons.Package;

package ExternalReferences

  function loadResource
    "Return the absolute path name of a URI or local file name (in this default implementation URIs are not supported, but only local file names)"
    input String uri;
    output String fileReference;
  external "builtin" fileReference=Dymola_ResolveURI(uri);
  annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
fileReference = <b>loadResource</b>(uri);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<b>loadResource</b>(uri)</code>\" returns the
<b>absolute path name</b> of the file that is either defined by an URI or by a local
(e.g. relative) path name. With the returned file name it is possible to
access the file with function calls of the C standard library.
If the data or file is stored in a data-base,
this might require copying the resource to a temporary folder and referencing that.
</p>

<p>
The implementation of this function is tool specific, and this implementation is for Dymola.
However, at least Modelica URIs
(see \"chapter 13.2.3 External Resources\" of the Modelica Specification),
as well as absolute and relative local file path names are supported.
</p>

<h4>Example</h4>
<blockquote><pre>
  file1 = loadResource(\"modelica://Modelica/Resources/Data/Utilities/Examples_readRealParameters.txt\")
          // file1 is the absolute path name of the file
  file2 = loadResource(\"C:\\data\\readParameters.txt\")
          file2 = \"C:/data/readParameters.txt\"
</pre></blockquote>
</html>"));
  end loadResource;
end ExternalReferences;

package Machine

  final constant Real eps=1.e-15 "Biggest number such that 1.0 + eps = 1.0";

  final constant Real small=1.e-60
    "Smallest number such that small and -small are representable on the machine";

  final constant Real inf=1.e+60
    "Biggest Real number such that inf and -inf are representable on the machine";
  annotation (Documentation(info="<html>
<p>
Package in which processor specific constants are defined that are needed
by numerical algorithms. Typically these constants are not directly used,
but indirectly via the alias definition in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.
</p>
</html>"));
end Machine;
annotation (
  Protection(access=Access.hide),
  preferredView="info",
  version="3.2.3",
  versionBuild=0,
  versionDate="2016-01-15",
  dateModified = "2016-01-15 08:44:41Z",
  revisionId="$Id:: package.mo 9141 2016-03-03 19:26:06Z #$",
  uses(Modelica(version="3.2.3")),
  conversion(
    noneFromVersion="1.0",
    noneFromVersion="1.1",
    noneFromVersion="1.2",
    noneFromVersion="3.2.1"),
  Documentation(info="<html>
<p>
This package contains a set of functions and models to be used in the
Modelica Standard Library that requires a tool specific implementation.
These are:
</p>

<ul>
<li> <a href=\"modelica://ModelicaServices.Animation.Shape\">Shape</a>
     provides a 3-dim. visualization of elementary
     mechanical objects. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Animation.Surface\">Surface</a>
     provides a 3-dim. visualization of
     moveable parameterized surface. It is used in
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.ExternalReferences.loadResource\">loadResource</a>
     provides a function to return the absolute path name of an URI or a local file name. It is used in
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">Modelica.Utilities.Files.loadResource</a>
     via inheritance.</li>

<li> <a href=\"modelica://ModelicaServices.Machine\">ModelicaServices.Machine</a>
     provides a package of machine constants. It is used in
<a href=\"modelica://Modelica.Constants\">Modelica.Constants</a>.</li>

<li> <a href=\"modelica://ModelicaServices.Types.SolverMethod\">Types.SolverMethod</a>
     provides a string defining the integration method to solve differential equations in
     a clocked discretized continuous-time partition (see Modelica 3.3 language specification).
     It is not yet used in the Modelica Standard Library, but in the Modelica_Synchronous library
     that provides convenience blocks for the clock operators of Modelica version &ge; 3.3.</li>
</ul>

<p>
This implementation is targeted for Dymola.
</p>

<p>
<b>Licensed by DLR and Dassault Syst&egrave;mes AB under the Modelica License 2</b><br>
Copyright &copy; 2009-2016, DLR and Dassault Syst&egrave;mes AB.
</p>

<p>
<i>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the Modelica License 2. For license conditions (including the disclaimer of warranty) see <a href=\"modelica://Modelica.UsersGuide.ModelicaLicense2\">Modelica.UsersGuide.ModelicaLicense2</a> or visit <a href=\"https://www.modelica.org/licenses/ModelicaLicense2\"> https://www.modelica.org/licenses/ModelicaLicense2</a>.</i>
</p>

</html>"));
end ModelicaServices;

package Modelica "Modelica Standard Library - Version 3.2.3"
extends Modelica.Icons.Package;

  package Blocks
  "Library of basic input/output control blocks (continuous, discrete, logical, table blocks)"
  import SI = Modelica.SIunits;
  extends Modelica.Icons.Package;

    package Continuous
    "Library of continuous control blocks with internal states"
      import Modelica.Blocks.Interfaces;
      import Modelica.SIunits;
      extends Modelica.Icons.Package;

      block Integrator "Output the integral of the input signal with optional reset"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Integrator gain";
        parameter Boolean use_reset = false "=true, if reset port enabled"
          annotation(Evaluate=true, HideResult=true, choices(checkBox=true));
        parameter Boolean use_set = false "=true, if set port enabled and used as reinitialization value when reset"
          annotation(Dialog(enable=use_reset), Evaluate=true, HideResult=true, choices(checkBox=true));

        /* InitialState is the default, because it was the default in Modelica 2.2
     and therefore this setting is backward compatible
  */
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.InitialState
          "Type of initialization (1: no init, 2: steady state, 3,4: initial output)" annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        extends Interfaces.SISO(y(start=y_start));
        Modelica.Blocks.Interfaces.BooleanInput reset if use_reset "Optional connector of reset signal" annotation(Placement(
          transformation(
            extent={{-20,-20},{20,20}},
            rotation=90,
            origin={60,-120})));
        Modelica.Blocks.Interfaces.RealInput set if use_reset and use_set "Optional connector of set signal" annotation(Placement(
          transformation(
            extent={{-20,-20},{20,20}},
            rotation=270,
            origin={60,120})));
    protected
        Modelica.Blocks.Interfaces.BooleanOutput local_reset annotation(HideResult=true);
        Modelica.Blocks.Interfaces.RealOutput local_set annotation(HideResult=true);

      initial equation
        if initType == Init.SteadyState then
           der(y) = 0;
        elseif initType == Init.InitialState or
               initType == Init.InitialOutput then
          y = y_start;
        end if;
      equation
        if use_reset then
          connect(reset, local_reset);
          if use_set then
            connect(set, local_set);
          else
            local_set = y_start;
          end if;
          when local_reset then
            reinit(y, local_set);
          end when;
        else
          local_reset = false;
          local_set = 0;
        end if;
        der(y) = k*u;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as
<em>integral</em> of the input <strong>u</strong> multiplied with
the gain <em>k</em>:
</p>
<pre>
         k
     y = - u
         s
</pre>

<p>
It might be difficult to initialize the integrator in steady state.
This is discussed in the description of package
<a href=\"modelica://Modelica.Blocks.Continuous#info\">Continuous</a>.
</p>

<p>
If the <em>reset</em> port is enabled, then the output <strong>y</strong> is reset to <em>set</em>
or to <em>y_start</em> (if the <em>set</em> port is not enabled), whenever the <em>reset</em>
port has a rising edge.
</p>
</html>"),     Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Line(
                  points={{-80.0,78.0},{-80.0,-90.0}},
                  color={192,192,192}),
                Polygon(
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
                Line(
                  points={{-90.0,-80.0},{82.0,-80.0}},
                  color={192,192,192}),
                Polygon(
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid,
                  points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
                Text(
                  lineColor={192,192,192},
                  extent={{0.0,-70.0},{60.0,-10.0}},
                  textString="I"),
                Text(
                  extent={{-150.0,-150.0},{150.0,-110.0}},
                  textString="k=%k"),
                Line(
                  points=DynamicSelect({{-80.0,-80.0},{80.0,80.0}}, if use_reset then {{-80.0,-80.0},{60.0,60.0},{60.0,-80.0},{80.0,-60.0}} else {{-80.0,-80.0},{80.0,80.0}}),
                  color={0,0,127}),
                Line(
                  visible=use_reset,
                  points={{60,-100},{60,-80}},
                  color={255,0,255},
                  pattern=LinePattern.Dot),
                Text(
                  visible=use_reset,
                  extent={{-28,-62},{94,-86}},
                  textString="reset")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(extent={{-60,60},{60,-60}}, lineColor={0,0,255}),
              Line(points={{-100,0},{-60,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{-36,60},{32,2}},
                textString="k"),
              Text(
                extent={{-32,0},{36,-58}},
                textString="s"),
              Line(points={{-46,0},{46,0}})}));
      end Integrator;

      block Derivative "Approximated derivative block"
        import Modelica.Blocks.Types.Init;
        parameter Real k(unit="1")=1 "Gains";
        parameter SIunits.Time T(min=Modelica.Constants.small) = 0.01
          "Time constants (T>0 required; T=0 is ideal derivative block)";
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
                                                                                          annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real x_start=0 "Initial or guess value of state"
          annotation (Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial value of output (= state)"
          annotation(Dialog(enable=initType == Init.InitialOutput, group=
                "Initialization"));
        extends Interfaces.SISO;

        output Real x(start=x_start) "State of block";

    protected
        parameter Boolean zeroGain = abs(k) < Modelica.Constants.eps;
      initial equation
        if initType == Init.SteadyState then
          der(x) = 0;
        elseif initType == Init.InitialState then
          x = x_start;
        elseif initType == Init.InitialOutput then
          if zeroGain then
             x = u;
          else
             y = y_start;
          end if;
        end if;
      equation
        der(x) = if zeroGain then 0 else (u - x)/T;
        y = if zeroGain then 0 else (k/T)*(u - x);
        annotation (
          Documentation(info="<html>
<p>
This blocks defines the transfer function between the
input u and the output y
as <em>approximated derivative</em>:
</p>
<pre>
             k * s
     y = ------------ * u
            T * s + 1
</pre>
<p>
If you would like to be able to change easily between different
transfer functions (FirstOrder, SecondOrder, ... ) by changing
parameters, use the general block <strong>TransferFunction</strong> instead
and model a derivative block with parameters<br>
b = {k,0}, a = {T, 1}.
</p>

<p>
If k=0, the block reduces to y=0.
</p>
</html>"),     Icon(
          coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Line(points={{-80.0,78.0},{-80.0,-90.0}},
            color={192,192,192}),
        Polygon(lineColor={192,192,192},
          fillColor={192,192,192},
          fillPattern=FillPattern.Solid,
          points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
        Line(points={{-90.0,-80.0},{82.0,-80.0}},
          color={192,192,192}),
        Polygon(lineColor={192,192,192},
          fillColor={192,192,192},
          fillPattern=FillPattern.Solid,
          points={{90.0,-80.0},{68.0,-72.0},{68.0,-88.0},{90.0,-80.0}}),
        Line(origin = {-24.667,-27.333},
          points = {{-55.333,87.333},{-19.333,-40.667},{86.667,-52.667}},
          color = {0,0,127},
          smooth = Smooth.Bezier),
        Text(lineColor={192,192,192},
          extent={{-30.0,14.0},{86.0,60.0}},
          textString="DT1"),
        Text(extent={{-150.0,-150.0},{150.0,-110.0}},
          textString="k=%k")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-54,52},{50,10}},
                textString="k s"),
              Text(
                extent={{-54,-6},{52,-52}},
                textString="T s + 1"),
              Line(points={{-50,0},{50,0}}),
              Rectangle(extent={{-60,60},{60,-60}}, lineColor={0,0,255}),
              Line(points={{-100,0},{-60,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255})}));
      end Derivative;

      block Filter
        "Continuous low pass, high pass, band pass or band stop IIR-filter of type CriticalDamping, Bessel, Butterworth or ChebyshevI"
        import Modelica.Blocks.Continuous.Internal;

        extends Modelica.Blocks.Interfaces.SISO;

        parameter Modelica.Blocks.Types.AnalogFilter analogFilter=Modelica.Blocks.Types.AnalogFilter.CriticalDamping
          "Analog filter characteristics (CriticalDamping/Bessel/Butterworth/ChebyshevI)";
        parameter Modelica.Blocks.Types.FilterType filterType=Modelica.Blocks.Types.FilterType.LowPass
          "Type of filter (LowPass/HighPass/BandPass/BandStop)";
        parameter Integer order(min=1) = 2 "Order of filter";
        parameter Modelica.SIunits.Frequency f_cut "Cut-off frequency";
        parameter Real gain=1.0
          "Gain (= amplitude of frequency response at zero frequency)";
        parameter Real A_ripple(unit="dB") = 0.5
          "Pass band ripple for Chebyshev filter (otherwise not used); > 0 required"
          annotation(Dialog(enable=analogFilter==Modelica.Blocks.Types.AnalogFilter.ChebyshevI));
        parameter Modelica.SIunits.Frequency f_min=0
          "Band of band pass/stop filter is f_min (A=-3db*gain) .. f_cut (A=-3db*gain)"
          annotation(Dialog(enable=filterType == Modelica.Blocks.Types.FilterType.BandPass or
                                   filterType == Modelica.Blocks.Types.FilterType.BandStop));
        parameter Boolean normalized=true
          "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";
        parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.SteadyState
          "Type of initialization (no init/steady state/initial state/initial output)"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        final parameter Integer nx = if filterType == Modelica.Blocks.Types.FilterType.LowPass or
                                        filterType == Modelica.Blocks.Types.FilterType.HighPass then
                                        order else 2*order;
        parameter Real x_start[nx] = zeros(nx) "Initial or guess values of states"
          annotation(Dialog(tab="Advanced"));
        parameter Real y_start = 0 "Initial value of output"
          annotation(Dialog(tab="Advanced"));
        parameter Real u_nominal = 1.0
          "Nominal value of input (used for scaling the states)"
        annotation(Dialog(tab="Advanced"));
        Modelica.Blocks.Interfaces.RealOutput x[nx] "Filter states";

    protected
        parameter Integer ncr = if analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
                                   order else mod(order,2);
        parameter Integer nc0 = if analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
                                   0 else integer(order/2);
        parameter Integer na = if filterType == Modelica.Blocks.Types.FilterType.BandPass or
                                  filterType == Modelica.Blocks.Types.FilterType.BandStop then order else
                               if analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
                                  0 else integer(order/2);
        parameter Integer nr = if filterType == Modelica.Blocks.Types.FilterType.BandPass or
                                  filterType == Modelica.Blocks.Types.FilterType.BandStop then 0 else
                               if analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
                                  order else mod(order,2);

        // Coefficients of prototype base filter (low pass filter with w_cut = 1 rad/s)
        parameter Real cr[ncr](each fixed=false);
        parameter Real c0[nc0](each fixed=false);
        parameter Real c1[nc0](each fixed=false);

        // Coefficients for differential equations.
        parameter Real r[nr](each fixed=false);
        parameter Real a[na](each fixed=false);
        parameter Real b[na](each fixed=false);
        parameter Real ku[na](each fixed=false);
        parameter Real k1[if filterType == Modelica.Blocks.Types.FilterType.LowPass then 0 else na](
                       each fixed = false);
        parameter Real k2[if filterType == Modelica.Blocks.Types.FilterType.LowPass then 0 else na](
                       each fixed = false);

        // Auxiliary variables
        Real uu[na+nr+1];

      initial equation
         if analogFilter == Modelica.Blocks.Types.AnalogFilter.CriticalDamping then
            cr = Internal.Filter.base.CriticalDamping(order, normalized);
         elseif analogFilter == Modelica.Blocks.Types.AnalogFilter.Bessel then
            (cr,c0,c1) = Internal.Filter.base.Bessel(order, normalized);
         elseif analogFilter == Modelica.Blocks.Types.AnalogFilter.Butterworth then
            (cr,c0,c1) = Internal.Filter.base.Butterworth(order, normalized);
         elseif analogFilter == Modelica.Blocks.Types.AnalogFilter.ChebyshevI then
            (cr,c0,c1) = Internal.Filter.base.ChebyshevI(order, A_ripple, normalized);
         end if;

         if filterType == Modelica.Blocks.Types.FilterType.LowPass then
            (r,a,b,ku) = Internal.Filter.roots.lowPass(cr,c0,c1,f_cut);
         elseif filterType == Modelica.Blocks.Types.FilterType.HighPass then
            (r,a,b,ku,k1,k2) = Internal.Filter.roots.highPass(cr,c0,c1,f_cut);
         elseif filterType == Modelica.Blocks.Types.FilterType.BandPass then
            (a,b,ku,k1,k2) = Internal.Filter.roots.bandPass(cr,c0,c1,f_min,f_cut);
         elseif filterType == Modelica.Blocks.Types.FilterType.BandStop then
            (a,b,ku,k1,k2) = Internal.Filter.roots.bandStop(cr,c0,c1,f_min,f_cut);
         end if;

         if init == Modelica.Blocks.Types.Init.InitialState then
            x = x_start;
         elseif init == Modelica.Blocks.Types.Init.SteadyState then
            der(x) = zeros(nx);
         elseif init == Modelica.Blocks.Types.Init.InitialOutput then
            y = y_start;
            if nx > 1 then
               der(x[1:nx-1]) = zeros(nx-1);
            end if;
         end if;

      equation
         assert(u_nominal > 0, "u_nominal > 0 required");
         assert(filterType == Modelica.Blocks.Types.FilterType.LowPass or
                filterType == Modelica.Blocks.Types.FilterType.HighPass or
                f_min > 0, "f_min > 0 required for band pass and band stop filter");
         assert(A_ripple > 0, "A_ripple > 0 required");
         assert(f_cut > 0, "f_cut > 0 required");

         /* All filters have the same basic differential equations:
        Real poles:
           der(x) = r*x - r*u
        Complex conjugate poles:
           der(x1) = a*x1 - b*x2 + ku*u;
           der(x2) = b*x1 + a*x2;
   */
         uu[1] = u/u_nominal;
         for i in 1:nr loop
            der(x[i]) = r[i]*(x[i] - uu[i]);
         end for;
         for i in 1:na loop
            der(x[nr+2*i-1]) = a[i]*x[nr+2*i-1] - b[i]*x[nr+2*i] + ku[i]*uu[nr+i];
            der(x[nr+2*i])   = b[i]*x[nr+2*i-1] + a[i]*x[nr+2*i];
         end for;

         // The output equation is different for the different filter types
         if filterType == Modelica.Blocks.Types.FilterType.LowPass then
            /* Low pass filter
           Real poles             :  y = x
           Complex conjugate poles:  y = x2
      */
            for i in 1:nr loop
               uu[i+1] = x[i];
            end for;
            for i in 1:na loop
               uu[nr+i+1] = x[nr+2*i];
            end for;

         elseif filterType == Modelica.Blocks.Types.FilterType.HighPass then
            /* High pass filter
           Real poles             :  y = -x + u;
           Complex conjugate poles:  y = k1*x1 + k2*x2 + u;
      */
            for i in 1:nr loop
               uu[i+1] = -x[i] + uu[i];
            end for;
            for i in 1:na loop
               uu[nr+i+1] = k1[i]*x[nr+2*i-1] + k2[i]*x[nr+2*i] + uu[nr+i];
            end for;

         elseif filterType == Modelica.Blocks.Types.FilterType.BandPass then
            /* Band pass filter
           Complex conjugate poles:  y = k1*x1 + k2*x2;
      */
            for i in 1:na loop
               uu[nr+i+1] = k1[i]*x[nr+2*i-1] + k2[i]*x[nr+2*i];
            end for;

         elseif filterType == Modelica.Blocks.Types.FilterType.BandStop then
            /* Band pass filter
           Complex conjugate poles:  y = k1*x1 + k2*x2 + u;
      */
            for i in 1:na loop
               uu[nr+i+1] = k1[i]*x[nr+2*i-1] + k2[i]*x[nr+2*i] + uu[nr+i];
            end for;

         else
            assert(false, "filterType (= " + String(filterType) + ") is unknown");
            uu = zeros(na+nr+1);
         end if;

         y = (gain*u_nominal)*uu[nr+na+1];

        annotation (
          Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Line(points={{-80.0,80.0},{-80.0,-88.0}},
              color={192,192,192}),
            Polygon(lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              points={{-80.0,92.0},{-88.0,70.0},{-72.0,70.0},{-80.0,92.0}}),
            Line(points={{-90.0,-78.0},{82.0,-78.0}},
              color={192,192,192}),
            Polygon(lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              points={{90.0,-78.0},{68.0,-70.0},{68.0,-86.0},{90.0,-78.0}}),
            Text(lineColor={192,192,192},
              extent={{-66.0,52.0},{88.0,90.0}},
              textString="%order"),
            Text(
              extent={{-138.0,-140.0},{162.0,-110.0}},
              textString="f_cut=%f_cut"),
            Rectangle(lineColor={160,160,164},
              fillColor={255,255,255},
              fillPattern=FillPattern.Backward,
              extent={{-80.0,-78.0},{22.0,10.0}}),
            Line(origin = {3.333,-6.667}, points = {{-83.333,34.667},{24.667,34.667},{42.667,-71.333}}, color = {0,0,127}, smooth = Smooth.Bezier)}),
          Documentation(info="<html>

<p>
This blocks models various types of filters:
</p>

<blockquote>
<strong>low pass, high pass, band pass, and band stop filters</strong>
</blockquote>

<p>
using various filter characteristics:
</p>

<blockquote>
<strong>CriticalDamping, Bessel, Butterworth, Chebyshev Type I filters</strong>
</blockquote>

<p>
By default, a filter block is initialized in <strong>steady-state</strong>, in order to
avoid unwanted oscillations at the beginning. In special cases, it might be
useful to select one of the other initialization options under tab
\"Advanced\".
</p>

<p>
Typical frequency responses for the 4 supported low pass filter types
are shown in the next figure:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/LowPassOrder4Filters.png\"
     alt=\"LowPassOrder4Filters.png\">
</blockquote>

<p>
The step responses of the same low pass filters are shown in the next figure,
starting from a steady state initial filter with initial input = 0.2:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/LowPassOrder4FiltersStepResponse.png\"
     alt=\"LowPassOrder4FiltersStepResponse.png\">
</blockquote>

<p>
Obviously, the frequency responses give a somewhat wrong impression
of the filter characteristics: Although Butterworth and Chebyshev
filters have a significantly steeper magnitude as the
CriticalDamping and Bessel filters, the step responses of
the latter ones are much better. This means for example, that
a CriticalDamping or a Bessel filter should be selected,
if a filter is mainly used to make a non-linear inverse model
realizable.
</p>

<p>
Typical frequency responses for the 4 supported high pass filter types
are shown in the next figure:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/HighPassOrder4Filters.png\"
     alt=\"HighPassOrder4Filters.png\">
</blockquote>

<p>
The corresponding step responses of these high pass filters are
shown in the next figure:
</p>
<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/HighPassOrder4FiltersStepResponse.png\"
     alt=\"HighPassOrder4FiltersStepResponse.png\">
</blockquote>

<p>
All filters are available in <strong>normalized</strong> (default) and non-normalized form.
In the normalized form, the amplitude of the filter transfer function
at the cut-off frequency f_cut is -3 dB (= 10^(-3/20) = 0.70794..).
Note, when comparing the filters of this function with other software systems,
the setting of \"normalized\" has to be selected appropriately. For example, the signal processing
toolbox of MATLAB provides the filters in non-normalized form and
therefore a comparison makes only sense, if normalized = <strong>false</strong>
is set. A normalized filter is usually better suited for applications,
since filters of different orders are \"comparable\",
whereas non-normalized filters usually require to adapt the
cut-off frequency, when the order of the filter is changed.
See a comparison of \"normalized\" and \"non-normalized\" filters at hand of
CriticalDamping filters of order 1,2,3:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/CriticalDampingNormalized.png\"
     alt=\"CriticalDampingNormalized.png\">
</blockquote>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Blocks/CriticalDampingNonNormalized.png\"
     alt=\"CriticalDampingNonNormalized.png\">
</blockquote>

<h4>Implementation</h4>

<p>
The filters are implemented in the following, reliable way:
</p>

<ol>
<li> A prototype low pass filter with a cut-off angular frequency of 1 rad/s is constructed
     from the desired analogFilter and the desired normalization.</li>

<li> This prototype low pass filter is transformed to the desired filterType and the
     desired cut-off frequency f_cut using a transformation on the Laplace variable \"s\".</li>

<li> The resulting first and second order transfer functions are implemented in
     state space form, using the \"eigen value\" representation of a transfer function:
     <pre>

  // second order block with eigen values: a +/- jb
  <strong>der</strong>(x1) = a*x1 - b*x2 + (a^2 + b^2)/b*u;
  <strong>der</strong>(x2) = b*x1 + a*x2;
       y  = x2;
     </pre>
     The dc-gain from the input to the output of this block is one and the selected
     states are in the order of the input (if \"u\" is in the order of \"one\", then the
     states are also in the order of \"one\"). In the \"Advanced\" tab, a \"nominal\" value for
     the input \"u\" can be given. If appropriately selected, the states are in the order of \"one\" and
     then step-size control is always appropriate.</li>
</ol>

<h4>References</h4>

<dl>
<dt>Tietze U., and Schenk C. (2002):</dt>
<dd> <strong>Halbleiter-Schaltungstechnik</strong>.
     Springer Verlag, 12. Auflage, pp. 815-852.</dd>
</dl>

</html>",     revisions="<html>
<dl>
  <dt><strong>Main Author:</strong></dt>
  <dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>,
      DLR Oberpfaffenhofen.</dd>
</dl>

<h4>Acknowledgement</h4>

<p>
The development of this block was partially funded by BMBF within the
     <a href=\"http://www.eurosyslib.com/\">ITEA2 EUROSYSLIB</a>
      project.
</p>

</html>"));
      end Filter;

      package Internal
      "Internal utility functions and blocks that should not be directly utilized by the user"
          extends Modelica.Icons.InternalPackage;

        package Filter
        "Internal utility functions for filters that should not be directly used"
            extends Modelica.Icons.InternalPackage;

          package base
          "Prototype low pass filters with cut-off frequency of 1 rad/s (other filters are derived by transformation from these base filters)"
              extends Modelica.Icons.InternalPackage;

          function CriticalDamping
              "Return base filter coefficients of CriticalDamping filter (= low pass filter with w_cut = 1 rad/s)"
            extends Modelica.Icons.Function;

            input Integer order(min=1) "Order of filter";
            input Boolean normalized=true
                "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";

            output Real cr[order] "Coefficients of real poles";
          protected
            Real alpha=1.0 "Frequency correction factor";
            Real alpha2 "= alpha*alpha";
            Real den1[order]
                "[p] coefficients of denominator first order polynomials (a*p + 1)";
            Real den2[0,2]
                "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
            Real c0[0] "Coefficients of s^0 term if conjugate complex pole";
            Real c1[0] "Coefficients of s^1 term if conjugate complex pole";
          algorithm
            if normalized then
               // alpha := sqrt(2^(1/order) - 1);
               alpha := sqrt(10^(3/10/order)-1);
            else
               alpha := 1.0;
            end if;

            for i in 1:order loop
               den1[i] := alpha;
            end for;

            // Determine polynomials with highest power of s equal to one
              (cr,c0,c1) :=
                Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(
                den1, den2);
          end CriticalDamping;

          function Bessel
              "Return base filter coefficients of Bessel filter (= low pass filter with w_cut = 1 rad/s)"
            extends Modelica.Icons.Function;

            input Integer order(min=1) "Order of filter";
            input Boolean normalized=true
                "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";

            output Real cr[mod(order, 2)] "Coefficient of real pole";
            output Real c0[integer(order/2)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[integer(order/2)]
                "Coefficients of s^1 term if conjugate complex pole";
          protected
            Real alpha=1.0 "Frequency correction factor";
            Real alpha2 "= alpha*alpha";
            Real den1[size(cr,1)]
                "[p] coefficients of denominator first order polynomials (a*p + 1)";
            Real den2[size(c0, 1),2]
                "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
          algorithm
              (den1,den2,alpha) :=
                Modelica.Blocks.Continuous.Internal.Filter.Utilities.BesselBaseCoefficients(
                order);
            if not normalized then
               alpha2 := alpha*alpha;
               for i in 1:size(c0, 1) loop
                 den2[i, 1] := den2[i, 1]*alpha2;
                 den2[i, 2] := den2[i, 2]*alpha;
               end for;
               if size(cr,1) == 1 then
                 den1[1] := den1[1]*alpha;
               end if;
               end if;

            // Determine polynomials with highest power of s equal to one
              (cr,c0,c1) :=
                Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(
                den1, den2);
          end Bessel;

          function Butterworth
              "Return base filter coefficients of Butterworth filter (= low pass filter with w_cut = 1 rad/s)"
            import Modelica.Constants.pi;
            extends Modelica.Icons.Function;

            input Integer order(min=1) "Order of filter";
            input Boolean normalized=true
                "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";

            output Real cr[mod(order, 2)] "Coefficient of real pole";
            output Real c0[integer(order/2)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[integer(order/2)]
                "Coefficients of s^1 term if conjugate complex pole";
          protected
            Real alpha=1.0 "Frequency correction factor";
            Real alpha2 "= alpha*alpha";
            Real den1[size(cr,1)]
                "[p] coefficients of denominator first order polynomials (a*p + 1)";
            Real den2[size(c0, 1),2]
                "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
          algorithm
            for i in 1:size(c0, 1) loop
              den2[i, 1] := 1.0;
              den2[i, 2] := -2*Modelica.Math.cos(pi*(0.5 + (i - 0.5)/order));
            end for;
            if size(cr,1) == 1 then
              den1[1] := 1.0;
            end if;

            /* Transformation of filter transfer function with "new(p) = alpha*p"
     in order that the filter transfer function has an amplitude of
     -3 db at the cutoff frequency
  */
            /*
    if normalized then
      alpha := Internal.normalizationFactor(den1, den2);
      alpha2 := alpha*alpha;
      for i in 1:size(c0, 1) loop
        den2[i, 1] := den2[i, 1]*alpha2;
        den2[i, 2] := den2[i, 2]*alpha;
      end for;
      if size(cr,1) == 1 then
        den1[1] := den1[1]*alpha;
      end if;
    end if;
  */

            // Determine polynomials with highest power of s equal to one
              (cr,c0,c1) :=
                Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(
                den1, den2);
          end Butterworth;

          function ChebyshevI
              "Return base filter coefficients of Chebyshev I filter (= low pass filter with w_cut = 1 rad/s)"
            import Modelica.Math.asinh;
            import Modelica.Constants.pi;

            extends Modelica.Icons.Function;

            input Integer order(min=1) "Order of filter";
            input Real A_ripple = 0.5 "Pass band ripple in [dB]";
            input Boolean normalized=true
                "= true, if amplitude at f_cut = -3db, otherwise unmodified filter";

            output Real cr[mod(order, 2)] "Coefficient of real pole";
            output Real c0[integer(order/2)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[integer(order/2)]
                "Coefficients of s^1 term if conjugate complex pole";
          protected
            Real epsilon;
            Real fac;
            Real alpha=1.0 "Frequency correction factor";
            Real alpha2 "= alpha*alpha";
            Real den1[size(cr,1)]
                "[p] coefficients of denominator first order polynomials (a*p + 1)";
            Real den2[size(c0, 1),2]
                "[p^2, p] coefficients of denominator second order polynomials (b*p^2 + a*p + 1)";
          algorithm
              epsilon := sqrt(10^(A_ripple/10) - 1);
              fac := asinh(1/epsilon)/order;

              den1 := fill(1/sinh(fac),size(den1,1));
              if size(cr,1) == 0 then
                 for i in 1:size(c0, 1) loop
                    den2[i,1] :=1/(cosh(fac)^2 - cos((2*i - 1)*pi/(2*order))^2);
                    den2[i,2] :=2*den2[i, 1]*sinh(fac)*cos((2*i - 1)*pi/(2*order));
                 end for;
              else
                 for i in 1:size(c0, 1) loop
                    den2[i,1] :=1/(cosh(fac)^2 - cos(i*pi/order)^2);
                    den2[i,2] :=2*den2[i, 1]*sinh(fac)*cos(i*pi/order);
                 end for;
              end if;

              /* Transformation of filter transfer function with "new(p) = alpha*p"
       in order that the filter transfer function has an amplitude of
       -3 db at the cutoff frequency
    */
              if normalized then
                alpha :=
                  Modelica.Blocks.Continuous.Internal.Filter.Utilities.normalizationFactor(
                  den1, den2);
                alpha2 := alpha*alpha;
                for i in 1:size(c0, 1) loop
                  den2[i, 1] := den2[i, 1]*alpha2;
                  den2[i, 2] := den2[i, 2]*alpha;
                end for;
                den1 := den1*alpha;
              end if;

            // Determine polynomials with highest power of s equal to one
              (cr,c0,c1) :=
                Modelica.Blocks.Continuous.Internal.Filter.Utilities.toHighestPowerOne(
                den1, den2);
          end ChebyshevI;
          end base;

          package coefficients "Filter coefficients"
              extends Modelica.Icons.InternalPackage;

          function lowPass
              "Return low pass filter coefficients at given cut-off frequency"
            import Modelica.Constants.pi;
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles";
            input Real c0_in[:]
                "Coefficients of s^0 term if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
            input Modelica.SIunits.Frequency f_cut "Cut-off frequency";

            output Real cr[size(cr_in,1)] "Coefficient of real pole";
            output Real c0[size(c0_in,1)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";

          protected
            Modelica.SIunits.AngularVelocity w_cut=2*pi*f_cut
                "Cut-off angular frequency";
            Real w_cut2=w_cut*w_cut;

          algorithm
            assert(f_cut > 0, "Cut-off frequency f_cut must be positive");

            /* Change filter coefficients according to transformation new(s) = s/w_cut
     s + cr           -> (s/w) + cr              = (s + w*cr)/w
     s^2 + c1*s + c0  -> (s/w)^2 + c1*(s/w) + c0 = (s^2 + (c1*w)*s + (c0*w^2))/w^2
  */
            cr := w_cut*cr_in;
            c1 := w_cut*c1_in;
            c0 := w_cut2*c0_in;

          end lowPass;

          function highPass
              "Return high pass filter coefficients at given cut-off frequency"
            import Modelica.Constants.pi;
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles";
            input Real c0_in[:]
                "Coefficients of s^0 term if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
            input Modelica.SIunits.Frequency f_cut "Cut-off frequency";

            output Real cr[size(cr_in,1)] "Coefficient of real pole";
            output Real c0[size(c0_in,1)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";

          protected
            Modelica.SIunits.AngularVelocity w_cut=2*pi*f_cut
                "Cut-off angular frequency";
            Real w_cut2=w_cut*w_cut;

          algorithm
            assert(f_cut > 0, "Cut-off frequency f_cut must be positive");

            /* Change filter coefficients according to transformation: new(s) = 1/s
        1/(s + cr)          -> 1/(1/s + cr)                = (1/cr)*s / (s + (1/cr))
        1/(s^2 + c1*s + c0) -> 1/((1/s)^2 + c1*(1/s) + c0) = (1/c0)*s^2 / (s^2 + (c1/c0)*s + 1/c0)

     Check whether transformed roots are also conjugate complex:
        c0 - c1^2/4 > 0  -> (1/c0) - (c1/c0)^2 / 4
                            = (c0 - c1^2/4) / c0^2 > 0
        It is therefore guaranteed that the roots remain conjugate complex

     Change filter coefficients according to transformation new(s) = s/w_cut
        s + 1/cr                -> (s/w) + 1/cr                   = (s + w/cr)/w
        s^2 + (c1/c0)*s + 1/c0  -> (s/w)^2 + (c1/c0)*(s/w) + 1/c0 = (s^2 + (w*c1/c0)*s + (w^2/c0))/w^2
  */
            for i in 1:size(cr_in,1) loop
               cr[i] := w_cut/cr_in[i];
            end for;

            for i in 1:size(c0_in,1) loop
               c0[i] := w_cut2/c0_in[i];
               c1[i] := w_cut*c1_in[i]/c0_in[i];
            end for;

          end highPass;

          function bandPass
              "Return band pass filter coefficients at given cut-off frequency"
            import Modelica.Constants.pi;
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles";
            input Real c0_in[:]
                "Coefficients of s^0 term if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
            input Modelica.SIunits.Frequency f_min
                "Band of band pass filter is f_min (A=-3db) .. f_max (A=-3db)";
            input Modelica.SIunits.Frequency f_max "Upper band frequency";

            output Real cr[0] "Coefficient of real pole";
            output Real c0[size(cr_in,1) + 2*size(c0_in,1)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[size(cr_in,1) + 2*size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
            output Real cn "Numerator coefficient of the PT2 terms";
          protected
            Modelica.SIunits.Frequency f0 = sqrt(f_min*f_max);
            Modelica.SIunits.AngularVelocity w_cut=2*pi*f0
                "Cut-off angular frequency";
            Real w_band = (f_max - f_min) / f0;
            Real w_cut2=w_cut*w_cut;
            Real c;
            Real alpha;
            Integer j;
          algorithm
            assert(f_min > 0 and f_min < f_max, "Band frequencies f_min and f_max are wrong");

              /* The band pass filter is derived from the low pass filter by
       the transformation new(s) = (s + 1/s)/w   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       1/(s + cr)         -> 1/((s/w + 1/s/w) + cr)
                             = w*s / (s^2 + cr*w*s + 1)

       1/(s^2 + c1*s + c0) -> 1/( (s+1/s)^2/w^2 + c1*(s + 1/s)/w + c0 )
                              = 1 /( ( s^2 + 1/s^2 + 2)/w^2 + (s + 1/s)*c1/w + c0 )
                              = w^2*s^2 / (s^4 + 2*s^2 + 1 + (s^3 + s)*c1*w + c0*w^2*s^2)
                              = w^2*s^2 / (s^4 + c1*w*s^3 + (2+c0*w^2)*s^2 + c1*w*s + 1)

                              Assume the following description with PT2:
                              = w^2*s^2 /( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                           (s^2 + s*(c*alpha) + alpha^2) )
                              = w^2*s^2 / ( s^4 + c*(alpha + 1/alpha)*s^3
                                                + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                + c*(alpha + 1/alpha)*s + 1 )

                              and therefore:
                                c*(alpha + 1/alpha) = c1*w       -> c = c1*w / (alpha + 1/alpha)
                                                                      = c1*w*alpha/(1+alpha^2)
                                alpha^2 + 1/alpha^2 + c^2 = 2+c0*w^2 -> equation to determine alpha
                                alpha^4 + 1 + c1^2*w^2*alpha^4/(1+alpha^2)^2 = (2+c0*w^2)*alpha^2
                                or z = alpha^2
                                z^2 + c^1^2*w^2*z^2/(1+z)^2 - (2+c0*w^2)*z + 1 = 0

     Check whether roots remain conjugate complex
        c0 - (c1/2)^2 > 0:    1/alpha^2 - (c/alpha)^2/4
                              = 1/alpha^2*(1 - c^2/4)    -> not possible to figure this out

     Afterwards, change filter coefficients according to transformation new(s) = s/w_cut
        w_band*s/(s^2 + c1*s + c0)  -> w_band*(s/w)/((s/w)^2 + c1*(s/w) + c0 =
                                       (w_band/w)*s/(s^2 + (c1*w)*s + (c0*w^2))/w^2) =
                                       (w_band*w)*s/(s^2 + (c1*w)*s + (c0*w^2))
    */
              for i in 1:size(cr_in,1) loop
                 c1[i] := w_cut*cr_in[i]*w_band;
                 c0[i] := w_cut2;
              end for;

              for i in 1:size(c1_in,1) loop
                alpha :=
                  Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha(
                        c1_in[i],
                        c0_in[i],
                        w_band);
                 c       := c1_in[i]*w_band / (alpha + 1/alpha);
                 j       := size(cr_in,1) + 2*i - 1;
                 c1[j]   := w_cut*c/alpha;
                 c1[j+1] := w_cut*c*alpha;
                 c0[j]   := w_cut2/alpha^2;
                 c0[j+1] := w_cut2*alpha^2;
              end for;

              cn :=w_band*w_cut;

          end bandPass;

          function bandStop
              "Return band stop filter coefficients at given cut-off frequency"
            import Modelica.Constants.pi;
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles";
            input Real c0_in[:]
                "Coefficients of s^0 term if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
            input Modelica.SIunits.Frequency f_min
                "Band of band stop filter is f_min (A=-3db) .. f_max (A=-3db)";
            input Modelica.SIunits.Frequency f_max "Upper band frequency";

            output Real cr[0] "Coefficient of real pole";
            output Real c0[size(cr_in,1) + 2*size(c0_in,1)]
                "Coefficients of s^0 term if conjugate complex pole";
            output Real c1[size(cr_in,1) + 2*size(c0_in,1)]
                "Coefficients of s^1 term if conjugate complex pole";
          protected
            Modelica.SIunits.Frequency f0 = sqrt(f_min*f_max);
            Modelica.SIunits.AngularVelocity w_cut=2*pi*f0
                "Cut-off angular frequency";
            Real w_band = (f_max - f_min) / f0;
            Real w_cut2=w_cut*w_cut;
            Real c;
            Real ww;
            Real alpha;
            Integer j;
          algorithm
            assert(f_min > 0 and f_min < f_max, "Band frequencies f_min and f_max are wrong");

              /* The band pass filter is derived from the low pass filter by
       the transformation new(s) = (s + 1/s)/w   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       1/(s + cr)         -> 1/((s/w + 1/s/w) + cr)
                             = w*s / (s^2 + cr*w*s + 1)

       1/(s^2 + c1*s + c0) -> 1/( (s+1/s)^2/w^2 + c1*(s + 1/s)/w + c0 )
                              = 1 /( ( s^2 + 1/s^2 + 2)/w^2 + (s + 1/s)*c1/w + c0 )
                              = w^2*s^2 / (s^4 + 2*s^2 + 1 + (s^3 + s)*c1*w + c0*w^2*s^2)
                              = w^2*s^2 / (s^4 + c1*w*s^3 + (2+c0*w^2)*s^2 + c1*w*s + 1)

                              Assume the following description with PT2:
                              = w^2*s^2 /( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                           (s^2 + s*(c*alpha) + alpha^2) )
                              = w^2*s^2 / ( s^4 + c*(alpha + 1/alpha)*s^3
                                                + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                + c*(alpha + 1/alpha)*s + 1 )

                              and therefore:
                                c*(alpha + 1/alpha) = c1*w       -> c = c1*w / (alpha + 1/alpha)
                                                                      = c1*w*alpha/(1+alpha^2)
                                alpha^2 + 1/alpha^2 + c^2 = 2+c0*w^2 -> equation to determine alpha
                                alpha^4 + 1 + c1^2*w^2*alpha^4/(1+alpha^2)^2 = (2+c0*w^2)*alpha^2
                                or z = alpha^2
                                z^2 + c^1^2*w^2*z^2/(1+z)^2 - (2+c0*w^2)*z + 1 = 0

       The band stop filter is derived from the low pass filter by
       the transformation new(s) = w/( (s + 1/s) )   (w = w_band = (f_max - f_min)/sqrt(f_max*f_min) )

       cr/(s + cr)         -> 1/(( w/(s + 1/s) ) + cr)
                              = (s^2 + 1) / (s^2 + (w/cr)*s + 1)

       c0/(s^2 + c1*s + c0) -> c0/( w^2/(s + 1/s)^2 + c1*w/(s + 1/s) + c0 )
                               = c0*(s^2 + 1)^2 / (s^4 + c1*w*s^3/c0 + (2+w^2/b)*s^2 + c1*w*s/c0 + 1)

                               Assume the following description with PT2:
                               = c0*(s^2 + 1)^2 / ( (s^2 + s*(c/alpha) + 1/alpha^2)*
                                                    (s^2 + s*(c*alpha) + alpha^2) )
                               = c0*(s^2 + 1)^2 / (  s^4 + c*(alpha + 1/alpha)*s^3
                                                         + (alpha^2 + 1/alpha^2 + c^2)*s^2
                                                         + c*(alpha + 1/alpha)*p + 1 )

                            and therefore:
                              c*(alpha + 1/alpha) = c1*w/b         -> c = c1*w/(c0*(alpha + 1/alpha))
                              alpha^2 + 1/alpha^2 + c^2 = 2+w^2/c0 -> equation to determine alpha
                              alpha^4 + 1 + (c1*w/c0*alpha^2)^2/(1+alpha^2)^2 = (2+w^2/c0)*alpha^2
                              or z = alpha^2
                              z^2 + (c1*w/c0*z)^2/(1+z)^2 - (2+w^2/c0)*z + 1 = 0

                            same as:  ww = w/c0
                              z^2 + (c1*ww*z)^2/(1+z)^2 - (2+c0*ww)*z + 1 = 0  -> same equation as for BandPass

     Afterwards, change filter coefficients according to transformation new(s) = s/w_cut
        c0*(s^2+1)(s^2 + c1*s + c0)  -> c0*((s/w)^2 + 1) / ((s/w)^2 + c1*(s/w) + c0 =
                                        c0/w^2*(s^2 + w^2) / (s^2 + (c1*w)*s + (c0*w^2))/w^2) =
                                        (s^2 + c0*w^2) / (s^2 + (c1*w)*s + (c0*w^2))
    */
              for i in 1:size(cr_in,1) loop
                 c1[i] := w_cut*w_band/cr_in[i];
                 c0[i] := w_cut2;
              end for;

              for i in 1:size(c1_in,1) loop
                 ww      := w_band/c0_in[i];
                alpha :=
                  Modelica.Blocks.Continuous.Internal.Filter.Utilities.bandPassAlpha(
                        c1_in[i],
                        c0_in[i],
                        ww);
                 c       := c1_in[i]*ww / (alpha + 1/alpha);
                 j       := size(cr_in,1) + 2*i - 1;
                 c1[j]   := w_cut*c/alpha;
                 c1[j+1] := w_cut*c*alpha;
                 c0[j]   := w_cut2/alpha^2;
                 c0[j+1] := w_cut2*alpha^2;
              end for;

          end bandStop;
          end coefficients;

          package roots
          "Filter roots and gain as needed for block implementations"
              extends Modelica.Icons.InternalPackage;

          function lowPass
              "Return low pass filter roots as needed for block for given cut-off frequency"
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles of base filter";
            input Real c0_in[:]
                "Coefficients of s^0 term of base filter if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term of base filter if conjugate complex pole";
            input Modelica.SIunits.Frequency f_cut "Cut-off frequency";

            output Real r[size(cr_in,1)] "Real eigenvalues";
            output Real a[size(c0_in,1)]
                "Real parts of complex conjugate eigenvalues";
            output Real b[size(c0_in,1)]
                "Imaginary parts of complex conjugate eigenvalues";
            output Real ku[size(c0_in,1)] "Input gain";
          protected
            Real c0[size(c0_in,1)];
            Real c1[size(c0_in,1)];
            Real cr[size(cr_in,1)];
          algorithm
            // Get coefficients of low pass filter at f_cut
            (cr, c0, c1) :=coefficients.lowPass(cr_in, c0_in, c1_in, f_cut);

            // Transform coefficients in to root
            for i in 1:size(cr_in,1) loop
              r[i] :=-cr[i];
            end for;

            for i in 1:size(c0_in,1) loop
              a [i] :=-c1[i]/2;
              b [i] :=sqrt(c0[i] - a[i]*a[i]);
              ku[i] :=c0[i]/b[i];
            end for;

            annotation (Documentation(info="<html>

<p>
The goal is to implement the filter in the following form:
</p>

<pre>
  // real pole:
   der(x) = r*x - r*u
       y  = x

  // complex conjugate poles:
  der(x1) = a*x1 - b*x2 + ku*u;
  der(x2) = b*x1 + a*x2;
       y  = x2;

            ku = (a^2 + b^2)/b
</pre>
<p>
This representation has the following transfer function:
</p>
<pre>
// real pole:
    s*y = r*y - r*u
  or
    (s-r)*y = -r*u
  or
    y = -r/(s-r)*u

  comparing coefficients with
    y = cr/(s + cr)*u  ->  r = -cr      // r is the real eigenvalue

// complex conjugate poles
    s*x2 =  a*x2 + b*x1
    s*x1 = -b*x2 + a*x1 + ku*u
  or
    (s-a)*x2               = b*x1  ->  x2 = b/(s-a)*x1
    (s + b^2/(s-a) - a)*x1 = ku*u  ->  (s(s-a) + b^2 - a*(s-a))*x1  = ku*(s-a)*u
                                   ->  (s^2 - 2*a*s + a^2 + b^2)*x1 = ku*(s-a)*u
  or
    x1 = ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
    x2 = b/(s-a)*ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
       = b*ku/(s^2 - 2*a*s + a^2 + b^2)*u
    y  = x2

  comparing coefficients with
    y = c0/(s^2 + c1*s + c0)*u  ->  a  = -c1/2
                                    b  = sqrt(c0 - a^2)
                                    ku = c0/b
                                       = (a^2 + b^2)/b

  comparing with eigenvalue representation:
    (s - (a+jb))*(s - (a-jb)) = s^2 -2*a*s + a^2 + b^2
  shows that:
    a: real part of eigenvalue
    b: imaginary part of eigenvalue

  time -> infinity:
    y(s=0) = x2(s=0) = 1
             x1(s=0) = -ku*a/(a^2 + b^2)*u
                     = -(a/b)*u
</pre>

</html>"));
          end lowPass;

          function highPass
              "Return high pass filter roots as needed for block for given cut-off frequency"
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles of base filter";
            input Real c0_in[:]
                "Coefficients of s^0 term of base filter if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term of base filter if conjugate complex pole";
            input Modelica.SIunits.Frequency f_cut "Cut-off frequency";

            output Real r[size(cr_in,1)] "Real eigenvalues";
            output Real a[size(c0_in,1)]
                "Real parts of complex conjugate eigenvalues";
            output Real b[size(c0_in,1)]
                "Imaginary parts of complex conjugate eigenvalues";
            output Real ku[size(c0_in,1)] "Gains of input terms";
            output Real k1[size(c0_in,1)] "Gains of y = k1*x1 + k2*x + u";
            output Real k2[size(c0_in,1)] "Gains of y = k1*x1 + k2*x + u";
          protected
            Real c0[size(c0_in,1)];
            Real c1[size(c0_in,1)];
            Real cr[size(cr_in,1)];
            Real ba2;
          algorithm
            // Get coefficients of high pass filter at f_cut
            (cr, c0, c1) :=coefficients.highPass(cr_in, c0_in, c1_in, f_cut);

            // Transform coefficients in to roots
            for i in 1:size(cr_in,1) loop
              r[i] :=-cr[i];
            end for;

            for i in 1:size(c0_in,1) loop
              a[i]  := -c1[i]/2;
              b[i]  := sqrt(c0[i] - a[i]*a[i]);
              ku[i] := c0[i]/b[i];
              k1[i] := 2*a[i]/ku[i];
              ba2   := (b[i]/a[i])^2;
              k2[i] := (1-ba2)/(1+ba2);
            end for;

            annotation (Documentation(info="<html>

<p>
The goal is to implement the filter in the following form:
</p>

<pre>
  // real pole:
   der(x) = r*x - r*u
       y  = -x + u

  // complex conjugate poles:
  der(x1) = a*x1 - b*x2 + ku*u;
  der(x2) = b*x1 + a*x2;
       y  = k1*x1 + k2*x2 + u;

            ku = (a^2 + b^2)/b
            k1 = 2*a/ku
            k2 = (a^2 - b^2) / (b*ku)
               = (a^2 - b^2) / (a^2 + b^2)
               = (1 - (b/a)^2) / (1 + (b/a)^2)

</pre>
<p>
This representation has the following transfer function:
</p>
<pre>
// real pole:
    s*x = r*x - r*u
  or
    (s-r)*x = -r*u   -> x = -r/(s-r)*u
  or
    y = r/(s-r)*u + (s-r)/(s-r)*u
      = (r+s-r)/(s-r)*u
      = s/(s-r)*u

  comparing coefficients with
    y = s/(s + cr)*u  ->  r = -cr      // r is the real eigenvalue

// complex conjugate poles
    s*x2 =  a*x2 + b*x1
    s*x1 = -b*x2 + a*x1 + ku*u
  or
    (s-a)*x2               = b*x1  ->  x2 = b/(s-a)*x1
    (s + b^2/(s-a) - a)*x1 = ku*u  ->  (s(s-a) + b^2 - a*(s-a))*x1  = ku*(s-a)*u
                                   ->  (s^2 - 2*a*s + a^2 + b^2)*x1 = ku*(s-a)*u
  or
    x1 = ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
    x2 = b/(s-a)*ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
       = b*ku/(s^2 - 2*a*s + a^2 + b^2)*u
    y  = k1*x1 + k2*x2 + u
       = (k1*ku*(s-a) + k2*b*ku +  s^2 - 2*a*s + a^2 + b^2) /
         (s^2 - 2*a*s + a^2 + b^2)*u
       = (s^2 + (k1*ku - 2*a)*s + k2*b*ku - k1*ku*a + a^2 + b^2) /
         (s^2 - 2*a*s + a^2 + b^2)*u
       = (s^2 + (2*a-2*a)*s + a^2 - b^2 - 2*a^2 + a^2 + b^2) /
         (s^2 - 2*a*s + a^2 + b^2)*u
       = s^2 / (s^2 - 2*a*s + a^2 + b^2)*u

  comparing coefficients with
    y = s^2/(s^2 + c1*s + c0)*u  ->  a = -c1/2
                                     b = sqrt(c0 - a^2)

  comparing with eigenvalue representation:
    (s - (a+jb))*(s - (a-jb)) = s^2 -2*a*s + a^2 + b^2
  shows that:
    a: real part of eigenvalue
    b: imaginary part of eigenvalue
</pre>

</html>"));
          end highPass;

          function bandPass
              "Return band pass filter roots as needed for block for given cut-off frequency"
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles of base filter";
            input Real c0_in[:]
                "Coefficients of s^0 term of base filter if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term of base filter if conjugate complex pole";
            input Modelica.SIunits.Frequency f_min
                "Band of band pass filter is f_min (A=-3db) .. f_max (A=-3db)";
            input Modelica.SIunits.Frequency f_max "Upper band frequency";

            output Real a[size(cr_in,1) + 2*size(c0_in,1)]
                "Real parts of complex conjugate eigenvalues";
            output Real b[size(cr_in,1) + 2*size(c0_in,1)]
                "Imaginary parts of complex conjugate eigenvalues";
            output Real ku[size(cr_in,1) + 2*size(c0_in,1)] "Gains of input terms";
            output Real k1[size(cr_in,1) + 2*size(c0_in,1)]
                "Gains of y = k1*x1 + k2*x";
            output Real k2[size(cr_in,1) + 2*size(c0_in,1)]
                "Gains of y = k1*x1 + k2*x";
          protected
            Real cr[0];
            Real c0[size(a,1)];
            Real c1[size(a,1)];
            Real cn;
            Real bb;
          algorithm
            // Get coefficients of band pass filter at f_cut
            (cr, c0, c1, cn) :=coefficients.bandPass(cr_in, c0_in, c1_in, f_min, f_max);

            // Transform coefficients in to roots
            for i in 1:size(a,1) loop
              a[i]  := -c1[i]/2;
              bb    := c0[i] - a[i]*a[i];
              assert(bb >= 0, "\nNot possible to use band pass filter, since transformation results in\n"+
                              "system that does not have conjugate complex poles.\n" +
                              "Try to use another analog filter for the band pass.\n");
              b[i]  := sqrt(bb);
              ku[i] := c0[i]/b[i];
              k1[i] := cn/ku[i];
              k2[i] := cn*a[i]/(b[i]*ku[i]);
            end for;

            annotation (Documentation(info="<html>

<p>
The goal is to implement the filter in the following form:
</p>

<pre>
  // complex conjugate poles:
  der(x1) = a*x1 - b*x2 + ku*u;
  der(x2) = b*x1 + a*x2;
       y  = k1*x1 + k2*x2;

            ku = (a^2 + b^2)/b
            k1 = cn/ku
            k2 = cn*a/(b*ku)
</pre>
<p>
This representation has the following transfer function:
</p>
<pre>
// complex conjugate poles
    s*x2 =  a*x2 + b*x1
    s*x1 = -b*x2 + a*x1 + ku*u
  or
    (s-a)*x2               = b*x1  ->  x2 = b/(s-a)*x1
    (s + b^2/(s-a) - a)*x1 = ku*u  ->  (s(s-a) + b^2 - a*(s-a))*x1  = ku*(s-a)*u
                                   ->  (s^2 - 2*a*s + a^2 + b^2)*x1 = ku*(s-a)*u
  or
    x1 = ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
    x2 = b/(s-a)*ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
       = b*ku/(s^2 - 2*a*s + a^2 + b^2)*u
    y  = k1*x1 + k2*x2
       = (k1*ku*(s-a) + k2*b*ku) / (s^2 - 2*a*s + a^2 + b^2)*u
       = (k1*ku*s + k2*b*ku - k1*ku*a) / (s^2 - 2*a*s + a^2 + b^2)*u
       = (cn*s + cn*a - cn*a) / (s^2 - 2*a*s + a^2 + b^2)*u
       = cn*s / (s^2 - 2*a*s + a^2 + b^2)*u

  comparing coefficients with
    y = cn*s / (s^2 + c1*s + c0)*u  ->  a = -c1/2
                                        b = sqrt(c0 - a^2)

  comparing with eigenvalue representation:
    (s - (a+jb))*(s - (a-jb)) = s^2 -2*a*s + a^2 + b^2
  shows that:
    a: real part of eigenvalue
    b: imaginary part of eigenvalue
</pre>

</html>"));
          end bandPass;

          function bandStop
              "Return band stop filter roots as needed for block for given cut-off frequency"
            extends Modelica.Icons.Function;

            input Real cr_in[:] "Coefficients of real poles of base filter";
            input Real c0_in[:]
                "Coefficients of s^0 term of base filter if conjugate complex pole";
            input Real c1_in[size(c0_in,1)]
                "Coefficients of s^1 term of base filter if conjugate complex pole";
            input Modelica.SIunits.Frequency f_min
                "Band of band stop filter is f_min (A=-3db) .. f_max (A=-3db)";
            input Modelica.SIunits.Frequency f_max "Upper band frequency";

            output Real a[size(cr_in,1) + 2*size(c0_in,1)]
                "Real parts of complex conjugate eigenvalues";
            output Real b[size(cr_in,1) + 2*size(c0_in,1)]
                "Imaginary parts of complex conjugate eigenvalues";
            output Real ku[size(cr_in,1) + 2*size(c0_in,1)] "Gains of input terms";
            output Real k1[size(cr_in,1) + 2*size(c0_in,1)]
                "Gains of y = k1*x1 + k2*x";
            output Real k2[size(cr_in,1) + 2*size(c0_in,1)]
                "Gains of y = k1*x1 + k2*x";
          protected
            Real cr[0];
            Real c0[size(a,1)];
            Real c1[size(a,1)];
            Real cn;
            Real bb;
          algorithm
            // Get coefficients of band stop filter at f_cut
            (cr, c0, c1) :=coefficients.bandStop(cr_in, c0_in, c1_in, f_min, f_max);

            // Transform coefficients in to roots
            for i in 1:size(a,1) loop
              a[i]  := -c1[i]/2;
              bb    := c0[i] - a[i]*a[i];
              assert(bb >= 0, "\nNot possible to use band stop filter, since transformation results in\n"+
                              "system that does not have conjugate complex poles.\n" +
                              "Try to use another analog filter for the band stop filter.\n");
              b[i]  := sqrt(bb);
              ku[i] := c0[i]/b[i];
              k1[i] := 2*a[i]/ku[i];
              k2[i] := (c0[i] + a[i]^2 - b[i]^2)/(b[i]*ku[i]);
            end for;

            annotation (Documentation(info="<html>

<p>
The goal is to implement the filter in the following form:
</p>

<pre>
  // complex conjugate poles:
  der(x1) = a*x1 - b*x2 + ku*u;
  der(x2) = b*x1 + a*x2;
       y  = k1*x1 + k2*x2 + u;

            ku = (a^2 + b^2)/b
            k1 = 2*a/ku
            k2 = (c0 + a^2 - b^2)/(b*ku)
</pre>
<p>
This representation has the following transfer function:
</p>
<pre>
// complex conjugate poles
    s*x2 =  a*x2 + b*x1
    s*x1 = -b*x2 + a*x1 + ku*u
  or
    (s-a)*x2               = b*x1  ->  x2 = b/(s-a)*x1
    (s + b^2/(s-a) - a)*x1 = ku*u  ->  (s(s-a) + b^2 - a*(s-a))*x1  = ku*(s-a)*u
                                   ->  (s^2 - 2*a*s + a^2 + b^2)*x1 = ku*(s-a)*u
  or
    x1 = ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
    x2 = b/(s-a)*ku*(s-a)/(s^2 - 2*a*s + a^2 + b^2)*u
       = b*ku/(s^2 - 2*a*s + a^2 + b^2)*u
    y  = k1*x1 + k2*x2 + u
       = (k1*ku*(s-a) + k2*b*ku + s^2 - 2*a*s + a^2 + b^2) / (s^2 - 2*a*s + a^2 + b^2)*u
       = (s^2 + (k1*ku-2*a)*s + k2*b*ku - k1*ku*a + a^2 + b^2) / (s^2 - 2*a*s + a^2 + b^2)*u
       = (s^2 + c0 + a^2 - b^2 - 2*a^2 + a^2 + b^2) / (s^2 - 2*a*s + a^2 + b^2)*u
       = (s^2 + c0) / (s^2 - 2*a*s + a^2 + b^2)*u

  comparing coefficients with
    y = (s^2 + c0) / (s^2 + c1*s + c0)*u  ->  a = -c1/2
                                              b = sqrt(c0 - a^2)

  comparing with eigenvalue representation:
    (s - (a+jb))*(s - (a-jb)) = s^2 -2*a*s + a^2 + b^2
  shows that:
    a: real part of eigenvalue
    b: imaginary part of eigenvalue
</pre>

</html>"));
          end bandStop;
          end roots;

          package Utilities "Utility functions for filter computations"
              extends Modelica.Icons.InternalPackage;

            function BesselBaseCoefficients
              "Return coefficients of normalized low pass Bessel filter (= gain at cut-off frequency 1 rad/s is decreased 3dB)"
              extends Modelica.Icons.Function;

              import Modelica.Utilities.Streams;
              input Integer order "Order of filter in the range 1..41";
              output Real c1[mod(order, 2)]
                "[p] coefficients of Bessel denominator polynomials (a*p + 1)";
              output Real c2[integer(order/2),2]
                "[p^2, p] coefficients of Bessel denominator polynomials (b2*p^2 + b1*p + 1)";
              output Real alpha "Normalization factor";
            algorithm
              if order == 1 then
                alpha := 1.002377293007601;
                c1[1] := 0.9976283451109835;
              elseif order == 2 then
                alpha := 0.7356641785819585;
                c2[1, 1] := 0.6159132201783791;
                c2[1, 2] := 1.359315879600889;
              elseif order == 3 then
                alpha := 0.5704770156982642;
                c1[1] := 0.7548574865985343;
                c2[1, 1] := 0.4756958028827457;
                c2[1, 2] := 0.9980615136104388;
              elseif order == 4 then
                alpha := 0.4737978580281427;
                c2[1, 1] := 0.4873729247240677;
                c2[1, 2] := 1.337564170455762;
                c2[2, 1] := 0.3877724315741958;
                c2[2, 2] := 0.7730405590839861;
              elseif order == 5 then
                alpha := 0.4126226974763408;
                c1[1] := 0.6645723262620757;
                c2[1, 1] := 0.4115231900614016;
                c2[1, 2] := 1.138349926728708;
                c2[2, 1] := 0.3234938702877912;
                c2[2, 2] := 0.6205992985771313;
              elseif order == 6 then
                alpha := 0.3705098000736233;
                c2[1, 1] := 0.3874508649098960;
                c2[1, 2] := 1.219740879520741;
                c2[2, 1] := 0.3493298843155746;
                c2[2, 2] := 0.9670265529381365;
                c2[3, 1] := 0.2747419229514599;
                c2[3, 2] := 0.5122165075105700;
              elseif order == 7 then
                alpha := 0.3393452623586350;
                c1[1] := 0.5927147125821412;
                c2[1, 1] := 0.3383379423919174;
                c2[1, 2] := 1.092630816438030;
                c2[2, 1] := 0.3001025788696046;
                c2[2, 2] := 0.8289928256598656;
                c2[3, 1] := 0.2372867471539579;
                c2[3, 2] := 0.4325128641920154;
              elseif order == 8 then
                alpha := 0.3150267393795002;
                c2[1, 1] := 0.3151115975207653;
                c2[1, 2] := 1.109403015460190;
                c2[2, 1] := 0.2969344839572762;
                c2[2, 2] := 0.9737455812222699;
                c2[3, 1] := 0.2612545921889538;
                c2[3, 2] := 0.7190394712068573;
                c2[4, 1] := 0.2080523342974281;
                c2[4, 2] := 0.3721456473047434;
              elseif order == 9 then
                alpha := 0.2953310177184124;
                c1[1] := 0.5377196679501422;
                c2[1, 1] := 0.2824689124281034;
                c2[1, 2] := 1.022646191567475;
                c2[2, 1] := 0.2626824161383468;
                c2[2, 2] := 0.8695626454762596;
                c2[3, 1] := 0.2302781917677917;
                c2[3, 2] := 0.6309047553448520;
                c2[4, 1] := 0.1847991729757028;
                c2[4, 2] := 0.3251978031287202;
              elseif order == 10 then
                alpha := 0.2789426890619463;
                c2[1, 1] := 0.2640769908255582;
                c2[1, 2] := 1.019788132875305;
                c2[2, 1] := 0.2540802639216947;
                c2[2, 2] := 0.9377020417760623;
                c2[3, 1] := 0.2343577229427963;
                c2[3, 2] := 0.7802229808216112;
                c2[4, 1] := 0.2052193139338624;
                c2[4, 2] := 0.5594176813008133;
                c2[5, 1] := 0.1659546953748916;
                c2[5, 2] := 0.2878349616233292;
              elseif order == 11 then
                alpha := 0.2650227766037203;
                c1[1] := 0.4950265498954191;
                c2[1, 1] := 0.2411858478546218;
                c2[1, 2] := 0.9567800996387417;
                c2[2, 1] := 0.2296849355380925;
                c2[2, 2] := 0.8592523717113126;
                c2[3, 1] := 0.2107851705677406;
                c2[3, 2] := 0.7040216048898129;
                c2[4, 1] := 0.1846461385164021;
                c2[4, 2] := 0.5006729207276717;
                c2[5, 1] := 0.1504217970817433;
                c2[5, 2] := 0.2575070491320295;
              elseif order == 12 then
                alpha := 0.2530051198547209;
                c2[1, 1] := 0.2268294941204543;
                c2[1, 2] := 0.9473116570034053;
                c2[2, 1] := 0.2207657387793729;
                c2[2, 2] := 0.8933728946287606;
                c2[3, 1] := 0.2087600700376653;
                c2[3, 2] := 0.7886236252756229;
                c2[4, 1] := 0.1909959101492760;
                c2[4, 2] := 0.6389263649257017;
                c2[5, 1] := 0.1675208146048472;
                c2[5, 2] := 0.4517847275162215;
                c2[6, 1] := 0.1374257286372761;
                c2[6, 2] := 0.2324699157474680;
              elseif order == 13 then
                alpha := 0.2424910397561007;
                c1[1] := 0.4608848369928040;
                c2[1, 1] := 0.2099813050274780;
                c2[1, 2] := 0.8992478823790660;
                c2[2, 1] := 0.2027250423101359;
                c2[2, 2] := 0.8328117484224146;
                c2[3, 1] := 0.1907635894058731;
                c2[3, 2] := 0.7257379204691213;
                c2[4, 1] := 0.1742280397887686;
                c2[4, 2] := 0.5830640944868014;
                c2[5, 1] := 0.1530858190490478;
                c2[5, 2] := 0.4106192089751885;
                c2[6, 1] := 0.1264090712880446;
                c2[6, 2] := 0.2114980230156001;
              elseif order == 14 then
                alpha := 0.2331902368695848;
                c2[1, 1] := 0.1986162311411235;
                c2[1, 2] := 0.8876961808055535;
                c2[2, 1] := 0.1946683341271615;
                c2[2, 2] := 0.8500754229171967;
                c2[3, 1] := 0.1868331332895056;
                c2[3, 2] := 0.7764629313723603;
                c2[4, 1] := 0.1752118757862992;
                c2[4, 2] := 0.6699720402924552;
                c2[5, 1] := 0.1598906457908402;
                c2[5, 2] := 0.5348446712848934;
                c2[6, 1] := 0.1407810153019944;
                c2[6, 2] := 0.3755841316563539;
                c2[7, 1] := 0.1169627966707339;
                c2[7, 2] := 0.1937088226304455;
              elseif order == 15 then
                alpha := 0.2248854870552422;
                c1[1] := 0.4328492272335646;
                c2[1, 1] := 0.1857292591004588;
                c2[1, 2] := 0.8496337061962563;
                c2[2, 1] := 0.1808644178280136;
                c2[2, 2] := 0.8020517898136011;
                c2[3, 1] := 0.1728264404199081;
                c2[3, 2] := 0.7247449729331105;
                c2[4, 1] := 0.1616970125901954;
                c2[4, 2] := 0.6205369315943097;
                c2[5, 1] := 0.1475257264578426;
                c2[5, 2] := 0.4929612162355906;
                c2[6, 1] := 0.1301861023357119;
                c2[6, 2] := 0.3454770708040735;
                c2[7, 1] := 0.1087810777120188;
                c2[7, 2] := 0.1784526655428406;
              elseif order == 16 then
                alpha := 0.2174105053474761;
                c2[1, 1] := 0.1765637967473151;
                c2[1, 2] := 0.8377453068635511;
                c2[2, 1] := 0.1738525357503125;
                c2[2, 2] := 0.8102988957433199;
                c2[3, 1] := 0.1684627004613343;
                c2[3, 2] := 0.7563265923413258;
                c2[4, 1] := 0.1604519074815815;
                c2[4, 2] := 0.6776082294687619;
                c2[5, 1] := 0.1498828607802206;
                c2[5, 2] := 0.5766417034027680;
                c2[6, 1] := 0.1367764717792823;
                c2[6, 2] := 0.4563528264410489;
                c2[7, 1] := 0.1209810465419295;
                c2[7, 2] := 0.3193782657322374;
                c2[8, 1] := 0.1016312648007554;
                c2[8, 2] := 0.1652419227369036;
              elseif order == 17 then
                alpha := 0.2106355148193306;
                c1[1] := 0.4093223608497299;
                c2[1, 1] := 0.1664014345826274;
                c2[1, 2] := 0.8067173752345952;
                c2[2, 1] := 0.1629839591538256;
                c2[2, 2] := 0.7712924931447541;
                c2[3, 1] := 0.1573277802512491;
                c2[3, 2] := 0.7134213666303411;
                c2[4, 1] := 0.1494828185148637;
                c2[4, 2] := 0.6347841731714884;
                c2[5, 1] := 0.1394948812681826;
                c2[5, 2] := 0.5375594414619047;
                c2[6, 1] := 0.1273627583380806;
                c2[6, 2] := 0.4241608926375478;
                c2[7, 1] := 0.1129187258461290;
                c2[7, 2] := 0.2965752009703245;
                c2[8, 1] := 0.9533357359908857e-1;
                c2[8, 2] := 0.1537041700889585;
              elseif order == 18 then
                alpha := 0.2044575288651841;
                c2[1, 1] := 0.1588768571976356;
                c2[1, 2] := 0.7951914263212913;
                c2[2, 1] := 0.1569357024981854;
                c2[2, 2] := 0.7744529690772538;
                c2[3, 1] := 0.1530722206358810;
                c2[3, 2] := 0.7335304425992080;
                c2[4, 1] := 0.1473206710524167;
                c2[4, 2] := 0.6735038935387268;
                c2[5, 1] := 0.1397225420331520;
                c2[5, 2] := 0.5959151542621590;
                c2[6, 1] := 0.1303092459809849;
                c2[6, 2] := 0.5026483447894845;
                c2[7, 1] := 0.1190627367060072;
                c2[7, 2] := 0.3956893824587150;
                c2[8, 1] := 0.1058058030798994;
                c2[8, 2] := 0.2765091830730650;
                c2[9, 1] := 0.8974708108800873e-1;
                c2[9, 2] := 0.1435505288284833;
              elseif order == 19 then
                alpha := 0.1987936248083529;
                c1[1] := 0.3892259966869526;
                c2[1, 1] := 0.1506640012172225;
                c2[1, 2] := 0.7693121733774260;
                c2[2, 1] := 0.1481728062796673;
                c2[2, 2] := 0.7421133586741549;
                c2[3, 1] := 0.1440444668388838;
                c2[3, 2] := 0.6975075386214800;
                c2[4, 1] := 0.1383101628540374;
                c2[4, 2] := 0.6365464378910025;
                c2[5, 1] := 0.1310032283190998;
                c2[5, 2] := 0.5606211948462122;
                c2[6, 1] := 0.1221431166405330;
                c2[6, 2] := 0.4713530424221445;
                c2[7, 1] := 0.1116991161103884;
                c2[7, 2] := 0.3703717538617073;
                c2[8, 1] := 0.9948917351196349e-1;
                c2[8, 2] := 0.2587371155559744;
                c2[9, 1] := 0.8475989238107367e-1;
                c2[9, 2] := 0.1345537894555993;
              elseif order == 20 then
                alpha := 0.1935761760416219;
                c2[1, 1] := 0.1443871348337404;
                c2[1, 2] := 0.7584165598446141;
                c2[2, 1] := 0.1429501891353184;
                c2[2, 2] := 0.7423000962318863;
                c2[3, 1] := 0.1400877384920004;
                c2[3, 2] := 0.7104185332215555;
                c2[4, 1] := 0.1358210369491446;
                c2[4, 2] := 0.6634599783272630;
                c2[5, 1] := 0.1301773703034290;
                c2[5, 2] := 0.6024175491895959;
                c2[6, 1] := 0.1231826501439148;
                c2[6, 2] := 0.5285332736326852;
                c2[7, 1] := 0.1148465498575254;
                c2[7, 2] := 0.4431977385498628;
                c2[8, 1] := 0.1051289462376788;
                c2[8, 2] := 0.3477444062821162;
                c2[9, 1] := 0.9384622797485121e-1;
                c2[9, 2] := 0.2429038300327729;
                c2[10, 1] := 0.8028211612831444e-1;
                c2[10, 2] := 0.1265329974009533;
              elseif order == 21 then
                alpha := 0.1887494014766075;
                c1[1] := 0.3718070668941645;
                c2[1, 1] := 0.1376151928386445;
                c2[1, 2] := 0.7364290859445481;
                c2[2, 1] := 0.1357438914390695;
                c2[2, 2] := 0.7150167318935022;
                c2[3, 1] := 0.1326398453462415;
                c2[3, 2] := 0.6798001808470175;
                c2[4, 1] := 0.1283231214897678;
                c2[4, 2] := 0.6314663440439816;
                c2[5, 1] := 0.1228169159777534;
                c2[5, 2] := 0.5709353626166905;
                c2[6, 1] := 0.1161406100773184;
                c2[6, 2] := 0.4993087153571335;
                c2[7, 1] := 0.1082959649233524;
                c2[7, 2] := 0.4177766148584385;
                c2[8, 1] := 0.9923596957485723e-1;
                c2[8, 2] := 0.3274257287232124;
                c2[9, 1] := 0.8877776108724853e-1;
                c2[9, 2] := 0.2287218166767916;
                c2[10, 1] := 0.7624076527736326e-1;
                c2[10, 2] := 0.1193423971506988;
              elseif order == 22 then
                alpha := 0.1842668221199706;
                c2[1, 1] := 0.1323053462701543;
                c2[1, 2] := 0.7262446126765204;
                c2[2, 1] := 0.1312121721769772;
                c2[2, 2] := 0.7134286088450949;
                c2[3, 1] := 0.1290330911166814;
                c2[3, 2] := 0.6880287870435514;
                c2[4, 1] := 0.1257817990372067;
                c2[4, 2] := 0.6505015800059301;
                c2[5, 1] := 0.1214765261983008;
                c2[5, 2] := 0.6015107185211451;
                c2[6, 1] := 0.1161365140967959;
                c2[6, 2] := 0.5418983553698413;
                c2[7, 1] := 0.1097755171533100;
                c2[7, 2] := 0.4726370779831614;
                c2[8, 1] := 0.1023889478519956;
                c2[8, 2] := 0.3947439506537486;
                c2[9, 1] := 0.9392485861253800e-1;
                c2[9, 2] := 0.3090996703083202;
                c2[10, 1] := 0.8420273775456455e-1;
                c2[10, 2] := 0.2159561978556017;
                c2[11, 1] := 0.7257600023938262e-1;
                c2[11, 2] := 0.1128633732721116;
              elseif order == 23 then
                alpha := 0.1800893554453722;
                c1[1] := 0.3565232673929280;
                c2[1, 1] := 0.1266275171652706;
                c2[1, 2] := 0.7072778066734162;
                c2[2, 1] := 0.1251865227648538;
                c2[2, 2] := 0.6900676345785905;
                c2[3, 1] := 0.1227944815236645;
                c2[3, 2] := 0.6617011100576023;
                c2[4, 1] := 0.1194647013077667;
                c2[4, 2] := 0.6226432315773119;
                c2[5, 1] := 0.1152132989252356;
                c2[5, 2] := 0.5735222810625359;
                c2[6, 1] := 0.1100558598478487;
                c2[6, 2] := 0.5151027978024605;
                c2[7, 1] := 0.1040013558214886;
                c2[7, 2] := 0.4482410942032739;
                c2[8, 1] := 0.9704014176512626e-1;
                c2[8, 2] := 0.3738049984631116;
                c2[9, 1] := 0.8911683905758054e-1;
                c2[9, 2] := 0.2925028692588410;
                c2[10, 1] := 0.8005438265072295e-1;
                c2[10, 2] := 0.2044134600278901;
                c2[11, 1] := 0.6923832296800832e-1;
                c2[11, 2] := 0.1069984887283394;
              elseif order == 24 then
                alpha := 0.1761838665838427;
                c2[1, 1] := 0.1220804912720132;
                c2[1, 2] := 0.6978026874156063;
                c2[2, 1] := 0.1212296762358897;
                c2[2, 2] := 0.6874139794926736;
                c2[3, 1] := 0.1195328372961027;
                c2[3, 2] := 0.6667954259551859;
                c2[4, 1] := 0.1169990987333593;
                c2[4, 2] := 0.6362602049901176;
                c2[5, 1] := 0.1136409040480130;
                c2[5, 2] := 0.5962662188435553;
                c2[6, 1] := 0.1094722001757955;
                c2[6, 2] := 0.5474001634109253;
                c2[7, 1] := 0.1045052832229087;
                c2[7, 2] := 0.4903523180249535;
                c2[8, 1] := 0.9874509806025907e-1;
                c2[8, 2] := 0.4258751523524645;
                c2[9, 1] := 0.9217799943472177e-1;
                c2[9, 2] := 0.3547079765396403;
                c2[10, 1] := 0.8474633796250476e-1;
                c2[10, 2] := 0.2774145482392767;
                c2[11, 1] := 0.7627722381240495e-1;
                c2[11, 2] := 0.1939329108084139;
                c2[12, 1] := 0.6618645465422745e-1;
                c2[12, 2] := 0.1016670147947242;
              elseif order == 25 then
                alpha := 0.1725220521949266;
                c1[1] := 0.3429735385896000;
                c2[1, 1] := 0.1172525033170618;
                c2[1, 2] := 0.6812327932576614;
                c2[2, 1] := 0.1161194585333535;
                c2[2, 2] := 0.6671566071153211;
                c2[3, 1] := 0.1142375145794466;
                c2[3, 2] := 0.6439167855053158;
                c2[4, 1] := 0.1116157454252308;
                c2[4, 2] := 0.6118378416180135;
                c2[5, 1] := 0.1082654809459177;
                c2[5, 2] := 0.5713609763370088;
                c2[6, 1] := 0.1041985674230918;
                c2[6, 2] := 0.5230289949762722;
                c2[7, 1] := 0.9942439308123559e-1;
                c2[7, 2] := 0.4674627926041906;
                c2[8, 1] := 0.9394453593830893e-1;
                c2[8, 2] := 0.4053226688298811;
                c2[9, 1] := 0.8774221237222533e-1;
                c2[9, 2] := 0.3372372276379071;
                c2[10, 1] := 0.8075839512216483e-1;
                c2[10, 2] := 0.2636485508005428;
                c2[11, 1] := 0.7282483286646764e-1;
                c2[11, 2] := 0.1843801345273085;
                c2[12, 1] := 0.6338571166846652e-1;
                c2[12, 2] := 0.9680153764737715e-1;
              elseif order == 26 then
                alpha := 0.1690795702796737;
                c2[1, 1] := 0.1133168695796030;
                c2[1, 2] := 0.6724297955493932;
                c2[2, 1] := 0.1126417845769961;
                c2[2, 2] := 0.6638709519790540;
                c2[3, 1] := 0.1112948749545606;
                c2[3, 2] := 0.6468652038763624;
                c2[4, 1] := 0.1092823986944244;
                c2[4, 2] := 0.6216337070799265;
                c2[5, 1] := 0.1066130386697976;
                c2[5, 2] := 0.5885011413992190;
                c2[6, 1] := 0.1032969057045413;
                c2[6, 2] := 0.5478864278297548;
                c2[7, 1] := 0.9934388184210715e-1;
                c2[7, 2] := 0.5002885306054287;
                c2[8, 1] := 0.9476081523436283e-1;
                c2[8, 2] := 0.4462644847551711;
                c2[9, 1] := 0.8954648464575577e-1;
                c2[9, 2] := 0.3863930785049522;
                c2[10, 1] := 0.8368166847159917e-1;
                c2[10, 2] := 0.3212074592527143;
                c2[11, 1] := 0.7710664731701103e-1;
                c2[11, 2] := 0.2510470347119383;
                c2[12, 1] := 0.6965807988411425e-1;
                c2[12, 2] := 0.1756419294111342;
                c2[13, 1] := 0.6080674930548766e-1;
                c2[13, 2] := 0.9234535279274277e-1;
              elseif order == 27 then
                alpha := 0.1658353543067995;
                c1[1] := 0.3308543720638957;
                c2[1, 1] := 0.1091618578712746;
                c2[1, 2] := 0.6577977071169651;
                c2[2, 1] := 0.1082549561495043;
                c2[2, 2] := 0.6461121666520275;
                c2[3, 1] := 0.1067479247890451;
                c2[3, 2] := 0.6267937760991321;
                c2[4, 1] := 0.1046471079537577;
                c2[4, 2] := 0.6000750116745808;
                c2[5, 1] := 0.1019605976654259;
                c2[5, 2] := 0.5662734183049320;
                c2[6, 1] := 0.9869726954433709e-1;
                c2[6, 2] := 0.5257827234948534;
                c2[7, 1] := 0.9486520934132483e-1;
                c2[7, 2] := 0.4790595019077763;
                c2[8, 1] := 0.9046906518775348e-1;
                c2[8, 2] := 0.4266025862147336;
                c2[9, 1] := 0.8550529998276152e-1;
                c2[9, 2] := 0.3689188223512328;
                c2[10, 1] := 0.7995282239306020e-1;
                c2[10, 2] := 0.3064589322702932;
                c2[11, 1] := 0.7375174596252882e-1;
                c2[11, 2] := 0.2394754504667310;
                c2[12, 1] := 0.6674377263329041e-1;
                c2[12, 2] := 0.1676223546666024;
                c2[13, 1] := 0.5842458027529246e-1;
                c2[13, 2] := 0.8825044329219431e-1;
              elseif order == 28 then
                alpha := 0.1627710671942929;
                c2[1, 1] := 0.1057232656113488;
                c2[1, 2] := 0.6496161226860832;
                c2[2, 1] := 0.1051786825724864;
                c2[2, 2] := 0.6424661279909941;
                c2[3, 1] := 0.1040917964935006;
                c2[3, 2] := 0.6282470268918791;
                c2[4, 1] := 0.1024670101953951;
                c2[4, 2] := 0.6071189030701136;
                c2[5, 1] := 0.1003105109519892;
                c2[5, 2] := 0.5793175191747016;
                c2[6, 1] := 0.9762969425430802e-1;
                c2[6, 2] := 0.5451486608855443;
                c2[7, 1] := 0.9443223803058400e-1;
                c2[7, 2] := 0.5049796971628137;
                c2[8, 1] := 0.9072460982036488e-1;
                c2[8, 2] := 0.4592270546572523;
                c2[9, 1] := 0.8650956423253280e-1;
                c2[9, 2] := 0.4083368605952977;
                c2[10, 1] := 0.8178165740374893e-1;
                c2[10, 2] := 0.3527525188880655;
                c2[11, 1] := 0.7651838885868020e-1;
                c2[11, 2] := 0.2928534570013572;
                c2[12, 1] := 0.7066010532447490e-1;
                c2[12, 2] := 0.2288185204390681;
                c2[13, 1] := 0.6405358596145789e-1;
                c2[13, 2] := 0.1602396172588190;
                c2[14, 1] := 0.5621780070227172e-1;
                c2[14, 2] := 0.8447589564915071e-1;
              elseif order == 29 then
                alpha := 0.1598706626277596;
                c1[1] := 0.3199314513011623;
                c2[1, 1] := 0.1021101032532951;
                c2[1, 2] := 0.6365758882240111;
                c2[2, 1] := 0.1013729819392774;
                c2[2, 2] := 0.6267495975736321;
                c2[3, 1] := 0.1001476175660628;
                c2[3, 2] := 0.6104876178266819;
                c2[4, 1] := 0.9843854640428316e-1;
                c2[4, 2] := 0.5879603139195113;
                c2[5, 1] := 0.9625164534591696e-1;
                c2[5, 2] := 0.5594012291050210;
                c2[6, 1] := 0.9359356960417668e-1;
                c2[6, 2] := 0.5251016150410664;
                c2[7, 1] := 0.9047086748649986e-1;
                c2[7, 2] := 0.4854024475590397;
                c2[8, 1] := 0.8688856407189167e-1;
                c2[8, 2] := 0.4406826457109709;
                c2[9, 1] := 0.8284779224069856e-1;
                c2[9, 2] := 0.3913408089298914;
                c2[10, 1] := 0.7834154620997181e-1;
                c2[10, 2] := 0.3377643999400627;
                c2[11, 1] := 0.7334628941928766e-1;
                c2[11, 2] := 0.2802710651919946;
                c2[12, 1] := 0.6780290487362146e-1;
                c2[12, 2] := 0.2189770008083379;
                c2[13, 1] := 0.6156321231528423e-1;
                c2[13, 2] := 0.1534235999306070;
                c2[14, 1] := 0.5416797446761512e-1;
                c2[14, 2] := 0.8098664736760292e-1;
              elseif order == 30 then
                alpha := 0.1571200296252450;
                c2[1, 1] := 0.9908074847842124e-1;
                c2[1, 2] := 0.6289618807831557;
                c2[2, 1] := 0.9863509708328196e-1;
                c2[2, 2] := 0.6229164525571278;
                c2[3, 1] := 0.9774542692037148e-1;
                c2[3, 2] := 0.6108853364240036;
                c2[4, 1] := 0.9641490581986484e-1;
                c2[4, 2] := 0.5929869253412513;
                c2[5, 1] := 0.9464802912225441e-1;
                c2[5, 2] := 0.5693960175547550;
                c2[6, 1] := 0.9245027206218041e-1;
                c2[6, 2] := 0.5403402396359503;
                c2[7, 1] := 0.8982754584112941e-1;
                c2[7, 2] := 0.5060948065875106;
                c2[8, 1] := 0.8678535291732599e-1;
                c2[8, 2] := 0.4669749797983789;
                c2[9, 1] := 0.8332744242052199e-1;
                c2[9, 2] := 0.4233249626334694;
                c2[10, 1] := 0.7945356393775309e-1;
                c2[10, 2] := 0.3755006094498054;
                c2[11, 1] := 0.7515543969833788e-1;
                c2[11, 2] := 0.3238400339292700;
                c2[12, 1] := 0.7040879901685638e-1;
                c2[12, 2] := 0.2686072427439079;
                c2[13, 1] := 0.6515528854010540e-1;
                c2[13, 2] := 0.2098650589782619;
                c2[14, 1] := 0.5925168237177876e-1;
                c2[14, 2] := 0.1471138832654873;
                c2[15, 1] := 0.5225913954211672e-1;
                c2[15, 2] := 0.7775248839507864e-1;
              elseif order == 31 then
                alpha := 0.1545067022920929;
                c1[1] := 0.3100206996451866;
                c2[1, 1] := 0.9591020358831668e-1;
                c2[1, 2] := 0.6172474793293396;
                c2[2, 1] := 0.9530301275601203e-1;
                c2[2, 2] := 0.6088916323460413;
                c2[3, 1] := 0.9429332655402368e-1;
                c2[3, 2] := 0.5950511595503025;
                c2[4, 1] := 0.9288445429894548e-1;
                c2[4, 2] := 0.5758534119053522;
                c2[5, 1] := 0.9108073420087422e-1;
                c2[5, 2] := 0.5514734636081183;
                c2[6, 1] := 0.8888719137536870e-1;
                c2[6, 2] := 0.5221306199481831;
                c2[7, 1] := 0.8630901440239650e-1;
                c2[7, 2] := 0.4880834248148061;
                c2[8, 1] := 0.8335074993373294e-1;
                c2[8, 2] := 0.4496225358496770;
                c2[9, 1] := 0.8001502494376102e-1;
                c2[9, 2] := 0.4070602306679052;
                c2[10, 1] := 0.7630041338037624e-1;
                c2[10, 2] := 0.3607139804818122;
                c2[11, 1] := 0.7219760885744920e-1;
                c2[11, 2] := 0.3108783301229550;
                c2[12, 1] := 0.6768185077153345e-1;
                c2[12, 2] := 0.2577706252514497;
                c2[13, 1] := 0.6269571766328638e-1;
                c2[13, 2] := 0.2014081375889921;
                c2[14, 1] := 0.5710081766945065e-1;
                c2[14, 2] := 0.1412581515841926;
                c2[15, 1] := 0.5047740914807019e-1;
                c2[15, 2] := 0.7474725873250158e-1;
              elseif order == 32 then
                alpha := 0.1520196210848210;
                c2[1, 1] := 0.9322163554339406e-1;
                c2[1, 2] := 0.6101488690506050;
                c2[2, 1] := 0.9285233997694042e-1;
                c2[2, 2] := 0.6049832320721264;
                c2[3, 1] := 0.9211494244473163e-1;
                c2[3, 2] := 0.5946969295569034;
                c2[4, 1] := 0.9101176786042449e-1;
                c2[4, 2] := 0.5793791854364477;
                c2[5, 1] := 0.8954614071360517e-1;
                c2[5, 2] := 0.5591619969234026;
                c2[6, 1] := 0.8772216763680164e-1;
                c2[6, 2] := 0.5342177994699602;
                c2[7, 1] := 0.8554440426912734e-1;
                c2[7, 2] := 0.5047560942986598;
                c2[8, 1] := 0.8301735302045588e-1;
                c2[8, 2] := 0.4710187048140929;
                c2[9, 1] := 0.8014469519188161e-1;
                c2[9, 2] := 0.4332730387207936;
                c2[10, 1] := 0.7692807528893225e-1;
                c2[10, 2] := 0.3918021436411035;
                c2[11, 1] := 0.7336507157284898e-1;
                c2[11, 2] := 0.3468890521471250;
                c2[12, 1] := 0.6944555312763458e-1;
                c2[12, 2] := 0.2987898029050460;
                c2[13, 1] := 0.6514446669420571e-1;
                c2[13, 2] := 0.2476810747407199;
                c2[14, 1] := 0.6040544477732702e-1;
                c2[14, 2] := 0.1935412053397663;
                c2[15, 1] := 0.5509478650672775e-1;
                c2[15, 2] := 0.1358108994174911;
                c2[16, 1] := 0.4881064725720192e-1;
                c2[16, 2] := 0.7194819894416505e-1;
              elseif order == 33 then
                alpha := 0.1496489351138032;
                c1[1] := 0.3009752799176432;
                c2[1, 1] := 0.9041725460994505e-1;
                c2[1, 2] := 0.5995521047364046;
                c2[2, 1] := 0.8991117804113002e-1;
                c2[2, 2] := 0.5923764112099496;
                c2[3, 1] := 0.8906941547422532e-1;
                c2[3, 2] := 0.5804822013853129;
                c2[4, 1] := 0.8789442491445575e-1;
                c2[4, 2] := 0.5639663528946501;
                c2[5, 1] := 0.8638945831033775e-1;
                c2[5, 2] := 0.5429623519607796;
                c2[6, 1] := 0.8455834602616358e-1;
                c2[6, 2] := 0.5176379938389326;
                c2[7, 1] := 0.8240517431382334e-1;
                c2[7, 2] := 0.4881921474066189;
                c2[8, 1] := 0.7993380417355076e-1;
                c2[8, 2] := 0.4548502528082586;
                c2[9, 1] := 0.7714713890732801e-1;
                c2[9, 2] := 0.4178579388038483;
                c2[10, 1] := 0.7404596598181127e-1;
                c2[10, 2] := 0.3774715722484659;
                c2[11, 1] := 0.7062702339160462e-1;
                c2[11, 2] := 0.3339432938810453;
                c2[12, 1] := 0.6687952672391507e-1;
                c2[12, 2] := 0.2874950693388235;
                c2[13, 1] := 0.6277828912909767e-1;
                c2[13, 2] := 0.2382680702894708;
                c2[14, 1] := 0.5826808305383988e-1;
                c2[14, 2] := 0.1862073169968455;
                c2[15, 1] := 0.5321974125363517e-1;
                c2[15, 2] := 0.1307323751236313;
                c2[16, 1] := 0.4724820282032780e-1;
                c2[16, 2] := 0.6933542082177094e-1;
              elseif order == 34 then
                alpha := 0.1473858373968463;
                c2[1, 1] := 0.8801537152275983e-1;
                c2[1, 2] := 0.5929204288972172;
                c2[2, 1] := 0.8770594341007476e-1;
                c2[2, 2] := 0.5884653382247518;
                c2[3, 1] := 0.8708797598072095e-1;
                c2[3, 2] := 0.5795895850253119;
                c2[4, 1] := 0.8616320590689187e-1;
                c2[4, 2] := 0.5663615383647170;
                c2[5, 1] := 0.8493413175570858e-1;
                c2[5, 2] := 0.5488825092350877;
                c2[6, 1] := 0.8340387368687513e-1;
                c2[6, 2] := 0.5272851839324592;
                c2[7, 1] := 0.8157596213131521e-1;
                c2[7, 2] := 0.5017313864372913;
                c2[8, 1] := 0.7945402670834270e-1;
                c2[8, 2] := 0.4724089864574216;
                c2[9, 1] := 0.7704133559556429e-1;
                c2[9, 2] := 0.4395276256463053;
                c2[10, 1] := 0.7434009635219704e-1;
                c2[10, 2] := 0.4033126590648964;
                c2[11, 1] := 0.7135035113853376e-1;
                c2[11, 2] := 0.3639961488919042;
                c2[12, 1] := 0.6806813160738834e-1;
                c2[12, 2] := 0.3218025212900124;
                c2[13, 1] := 0.6448214312000864e-1;
                c2[13, 2] := 0.2769235521088158;
                c2[14, 1] := 0.6056719318430530e-1;
                c2[14, 2] := 0.2294693573271038;
                c2[15, 1] := 0.5626925196925040e-1;
                c2[15, 2] := 0.1793564218840015;
                c2[16, 1] := 0.5146352031547277e-1;
                c2[16, 2] := 0.1259877129326412;
                c2[17, 1] := 0.4578069074410591e-1;
                c2[17, 2] := 0.6689147319568768e-1;
              elseif order == 35 then
                alpha := 0.1452224267615486;
                c1[1] := 0.2926764667564367;
                c2[1, 1] := 0.8551731299267280e-1;
                c2[1, 2] := 0.5832758214629523;
                c2[2, 1] := 0.8509109732853060e-1;
                c2[2, 2] := 0.5770596582643844;
                c2[3, 1] := 0.8438201446671953e-1;
                c2[3, 2] := 0.5667497616665494;
                c2[4, 1] := 0.8339191981579831e-1;
                c2[4, 2] := 0.5524209816238369;
                c2[5, 1] := 0.8212328610083385e-1;
                c2[5, 2] := 0.5341766459916322;
                c2[6, 1] := 0.8057906332198853e-1;
                c2[6, 2] := 0.5121470053512750;
                c2[7, 1] := 0.7876247299954955e-1;
                c2[7, 2] := 0.4864870722254752;
                c2[8, 1] := 0.7667670879950268e-1;
                c2[8, 2] := 0.4573736721705665;
                c2[9, 1] := 0.7432449556218945e-1;
                c2[9, 2] := 0.4250013835198991;
                c2[10, 1] := 0.7170742126011575e-1;
                c2[10, 2] := 0.3895767735915445;
                c2[11, 1] := 0.6882488171701314e-1;
                c2[11, 2] := 0.3513097926737368;
                c2[12, 1] := 0.6567231746957568e-1;
                c2[12, 2] := 0.3103999917596611;
                c2[13, 1] := 0.6223804362223595e-1;
                c2[13, 2] := 0.2670123611280899;
                c2[14, 1] := 0.5849696460782910e-1;
                c2[14, 2] := 0.2212298104867592;
                c2[15, 1] := 0.5439628409499822e-1;
                c2[15, 2] := 0.1729443731341637;
                c2[16, 1] := 0.4981540179136920e-1;
                c2[16, 2] := 0.1215462157134930;
                c2[17, 1] := 0.4439981033536435e-1;
                c2[17, 2] := 0.6460098363520967e-1;
              elseif order == 36 then
                alpha := 0.1431515914458580;
                c2[1, 1] := 0.8335881847130301e-1;
                c2[1, 2] := 0.5770670512160201;
                c2[2, 1] := 0.8309698922852212e-1;
                c2[2, 2] := 0.5731929100172432;
                c2[3, 1] := 0.8257400347039723e-1;
                c2[3, 2] := 0.5654713811993058;
                c2[4, 1] := 0.8179117911600136e-1;
                c2[4, 2] := 0.5539556343603020;
                c2[5, 1] := 0.8075042173126963e-1;
                c2[5, 2] := 0.5387245649546684;
                c2[6, 1] := 0.7945413151258206e-1;
                c2[6, 2] := 0.5198817177723069;
                c2[7, 1] := 0.7790506514288866e-1;
                c2[7, 2] := 0.4975537629595409;
                c2[8, 1] := 0.7610613635339480e-1;
                c2[8, 2] := 0.4718884193866789;
                c2[9, 1] := 0.7406012816626425e-1;
                c2[9, 2] := 0.4430516443136726;
                c2[10, 1] := 0.7176927060205631e-1;
                c2[10, 2] := 0.4112237708115829;
                c2[11, 1] := 0.6923460172504251e-1;
                c2[11, 2] := 0.3765940116389730;
                c2[12, 1] := 0.6645495833489556e-1;
                c2[12, 2] := 0.3393522147815403;
                c2[13, 1] := 0.6342528888937094e-1;
                c2[13, 2] := 0.2996755899575573;
                c2[14, 1] := 0.6013361864949449e-1;
                c2[14, 2] := 0.2577053294053830;
                c2[15, 1] := 0.5655503081322404e-1;
                c2[15, 2] := 0.2135004731531631;
                c2[16, 1] := 0.5263798119559069e-1;
                c2[16, 2] := 0.1669320999865636;
                c2[17, 1] := 0.4826589873626196e-1;
                c2[17, 2] := 0.1173807590715484;
                c2[18, 1] := 0.4309819397289806e-1;
                c2[18, 2] := 0.6245036108880222e-1;
              elseif order == 37 then
                alpha := 0.1411669104782917;
                c1[1] := 0.2850271036215707;
                c2[1, 1] := 0.8111958235023328e-1;
                c2[1, 2] := 0.5682412610563970;
                c2[2, 1] := 0.8075727567979578e-1;
                c2[2, 2] := 0.5628142923227016;
                c2[3, 1] := 0.8015440554413301e-1;
                c2[3, 2] := 0.5538087696879930;
                c2[4, 1] := 0.7931239302677386e-1;
                c2[4, 2] := 0.5412833323304460;
                c2[5, 1] := 0.7823314328639347e-1;
                c2[5, 2] := 0.5253190555393968;
                c2[6, 1] := 0.7691895211595101e-1;
                c2[6, 2] := 0.5060183741977191;
                c2[7, 1] := 0.7537237072011853e-1;
                c2[7, 2] := 0.4835036020049034;
                c2[8, 1] := 0.7359601294804538e-1;
                c2[8, 2] := 0.4579149413954837;
                c2[9, 1] := 0.7159227884849299e-1;
                c2[9, 2] := 0.4294078049978829;
                c2[10, 1] := 0.6936295002846032e-1;
                c2[10, 2] := 0.3981491350382047;
                c2[11, 1] := 0.6690857785828917e-1;
                c2[11, 2] := 0.3643121502867948;
                c2[12, 1] := 0.6422751692085542e-1;
                c2[12, 2] := 0.3280684291406284;
                c2[13, 1] := 0.6131430866206096e-1;
                c2[13, 2] := 0.2895750997170303;
                c2[14, 1] := 0.5815677249570920e-1;
                c2[14, 2] := 0.2489521814805720;
                c2[15, 1] := 0.5473023527947980e-1;
                c2[15, 2] := 0.2062377435955363;
                c2[16, 1] := 0.5098441033167034e-1;
                c2[16, 2] := 0.1612849131645336;
                c2[17, 1] := 0.4680658811093562e-1;
                c2[17, 2] := 0.1134672937045305;
                c2[18, 1] := 0.4186928031694695e-1;
                c2[18, 2] := 0.6042754777339966e-1;
              elseif order == 38 then
                alpha := 0.1392625697140030;
                c2[1, 1] := 0.7916943373658329e-1;
                c2[1, 2] := 0.5624158631591745;
                c2[2, 1] := 0.7894592250257840e-1;
                c2[2, 2] := 0.5590219398777304;
                c2[3, 1] := 0.7849941672384930e-1;
                c2[3, 2] := 0.5522551628416841;
                c2[4, 1] := 0.7783093084875645e-1;
                c2[4, 2] := 0.5421574325808380;
                c2[5, 1] := 0.7694193770482690e-1;
                c2[5, 2] := 0.5287909941093643;
                c2[6, 1] := 0.7583430534712885e-1;
                c2[6, 2] := 0.5122376814029880;
                c2[7, 1] := 0.7451020436122948e-1;
                c2[7, 2] := 0.4925978555548549;
                c2[8, 1] := 0.7297197617673508e-1;
                c2[8, 2] := 0.4699889739625235;
                c2[9, 1] := 0.7122194706992953e-1;
                c2[9, 2] := 0.4445436860615774;
                c2[10, 1] := 0.6926216260386816e-1;
                c2[10, 2] := 0.4164072786327193;
                c2[11, 1] := 0.6709399961255503e-1;
                c2[11, 2] := 0.3857341621868851;
                c2[12, 1] := 0.6471757977022456e-1;
                c2[12, 2] := 0.3526828388476838;
                c2[13, 1] := 0.6213084287116965e-1;
                c2[13, 2] := 0.3174082831364342;
                c2[14, 1] := 0.5932799638550641e-1;
                c2[14, 2] := 0.2800495563550299;
                c2[15, 1] := 0.5629672408524944e-1;
                c2[15, 2] := 0.2407078154782509;
                c2[16, 1] := 0.5301264751544952e-1;
                c2[16, 2] := 0.1994026830553859;
                c2[17, 1] := 0.4942673259817896e-1;
                c2[17, 2] := 0.1559719194038917;
                c2[18, 1] := 0.4542996716979947e-1;
                c2[18, 2] := 0.1097844277878470;
                c2[19, 1] := 0.4070720755433961e-1;
                c2[19, 2] := 0.5852181110523043e-1;
              elseif order == 39 then
                alpha := 0.1374332900196804;
                c1[1] := 0.2779468246419593;
                c2[1, 1] := 0.7715084161825772e-1;
                c2[1, 2] := 0.5543001331300056;
                c2[2, 1] := 0.7684028301163326e-1;
                c2[2, 2] := 0.5495289890712267;
                c2[3, 1] := 0.7632343924866024e-1;
                c2[3, 2] := 0.5416083298429741;
                c2[4, 1] := 0.7560141319808483e-1;
                c2[4, 2] := 0.5305846713929198;
                c2[5, 1] := 0.7467569064745969e-1;
                c2[5, 2] := 0.5165224112570647;
                c2[6, 1] := 0.7354807648551346e-1;
                c2[6, 2] := 0.4995030679271456;
                c2[7, 1] := 0.7222060351121389e-1;
                c2[7, 2] := 0.4796242430956156;
                c2[8, 1] := 0.7069540462458585e-1;
                c2[8, 2] := 0.4569982440368368;
                c2[9, 1] := 0.6897453353492381e-1;
                c2[9, 2] := 0.4317502624832354;
                c2[10, 1] := 0.6705970959388781e-1;
                c2[10, 2] := 0.4040159353969854;
                c2[11, 1] := 0.6495194541066725e-1;
                c2[11, 2] := 0.3739379843169939;
                c2[12, 1] := 0.6265098412417610e-1;
                c2[12, 2] := 0.3416613843816217;
                c2[13, 1] := 0.6015440984955930e-1;
                c2[13, 2] := 0.3073260166338746;
                c2[14, 1] := 0.5745615876877304e-1;
                c2[14, 2] := 0.2710546723961181;
                c2[15, 1] := 0.5454383762391338e-1;
                c2[15, 2] := 0.2329316824061170;
                c2[16, 1] := 0.5139340231935751e-1;
                c2[16, 2] := 0.1929604256043231;
                c2[17, 1] := 0.4795705862458131e-1;
                c2[17, 2] := 0.1509655259246037;
                c2[18, 1] := 0.4412933231935506e-1;
                c2[18, 2] := 0.1063130748962878;
                c2[19, 1] := 0.3960672309405603e-1;
                c2[19, 2] := 0.5672356837211527e-1;
              elseif order == 40 then
                alpha := 0.1356742655825434;
                c2[1, 1] := 0.7538038374294594e-1;
                c2[1, 2] := 0.5488228264329617;
                c2[2, 1] := 0.7518806529402738e-1;
                c2[2, 2] := 0.5458297722483311;
                c2[3, 1] := 0.7480383050347119e-1;
                c2[3, 2] := 0.5398604576730540;
                c2[4, 1] := 0.7422847031965465e-1;
                c2[4, 2] := 0.5309482987446206;
                c2[5, 1] := 0.7346313704205006e-1;
                c2[5, 2] := 0.5191429845322307;
                c2[6, 1] := 0.7250930053201402e-1;
                c2[6, 2] := 0.5045099368431007;
                c2[7, 1] := 0.7136868456879621e-1;
                c2[7, 2] := 0.4871295553902607;
                c2[8, 1] := 0.7004317764946634e-1;
                c2[8, 2] := 0.4670962098860498;
                c2[9, 1] := 0.6853470921527828e-1;
                c2[9, 2] := 0.4445169164956202;
                c2[10, 1] := 0.6684507689945471e-1;
                c2[10, 2] := 0.4195095960479698;
                c2[11, 1] := 0.6497570123412630e-1;
                c2[11, 2] := 0.3922007419030645;
                c2[12, 1] := 0.6292726794917847e-1;
                c2[12, 2] := 0.3627221993494397;
                c2[13, 1] := 0.6069918741663154e-1;
                c2[13, 2] := 0.3312065181294388;
                c2[14, 1] := 0.5828873983769410e-1;
                c2[14, 2] := 0.2977798532686911;
                c2[15, 1] := 0.5568964389813015e-1;
                c2[15, 2] := 0.2625503293999835;
                c2[16, 1] := 0.5288947816690705e-1;
                c2[16, 2] := 0.2255872486520188;
                c2[17, 1] := 0.4986456327645859e-1;
                c2[17, 2] := 0.1868796731919594;
                c2[18, 1] := 0.4656832613054458e-1;
                c2[18, 2] := 0.1462410193532463;
                c2[19, 1] := 0.4289867647614935e-1;
                c2[19, 2] := 0.1030361558710747;
                c2[20, 1] := 0.3856310684054106e-1;
                c2[20, 2] := 0.5502423832293889e-1;
              elseif order == 41 then
                alpha := 0.1339811106984253;
                c1[1] := 0.2713685065531391;
                c2[1, 1] := 0.7355140275160984e-1;
                c2[1, 2] := 0.5413274778282860;
                c2[2, 1] := 0.7328319082267173e-1;
                c2[2, 2] := 0.5371064088294270;
                c2[3, 1] := 0.7283676160772547e-1;
                c2[3, 2] := 0.5300963437270770;
                c2[4, 1] := 0.7221298133014343e-1;
                c2[4, 2] := 0.5203345998371490;
                c2[5, 1] := 0.7141302173623395e-1;
                c2[5, 2] := 0.5078728971879841;
                c2[6, 1] := 0.7043831559982149e-1;
                c2[6, 2] := 0.4927768111819803;
                c2[7, 1] := 0.6929049381827268e-1;
                c2[7, 2] := 0.4751250308594139;
                c2[8, 1] := 0.6797129849758392e-1;
                c2[8, 2] := 0.4550083840638406;
                c2[9, 1] := 0.6648246325101609e-1;
                c2[9, 2] := 0.4325285673076087;
                c2[10, 1] := 0.6482554675958526e-1;
                c2[10, 2] := 0.4077964789091151;
                c2[11, 1] := 0.6300169683004558e-1;
                c2[11, 2] := 0.3809299858742483;
                c2[12, 1] := 0.6101130648543355e-1;
                c2[12, 2] := 0.3520508315700898;
                c2[13, 1] := 0.5885349417435808e-1;
                c2[13, 2] := 0.3212801560701271;
                c2[14, 1] := 0.5652528148656809e-1;
                c2[14, 2] := 0.2887316252774887;
                c2[15, 1] := 0.5402021575818373e-1;
                c2[15, 2] := 0.2545001287790888;
                c2[16, 1] := 0.5132588802608274e-1;
                c2[16, 2] := 0.2186415296842951;
                c2[17, 1] := 0.4841900639702602e-1;
                c2[17, 2] := 0.1811322622296060;
                c2[18, 1] := 0.4525419574485134e-1;
                c2[18, 2] := 0.1417762065404688;
                c2[19, 1] := 0.4173260173087802e-1;
                c2[19, 2] := 0.9993834530966510e-1;
                c2[20, 1] := 0.3757210572966463e-1;
                c2[20, 2] := 0.5341611499960143e-1;
              else
                Streams.error("Input argument order (= " + String(order) +
                  ") of Bessel filter is not in the range 1..41");
              end if;

              annotation (Documentation(info="<html><p>The transfer function H(p) of a <em>n</em> 'th order Bessel filter is given by</p>
<blockquote><pre>
        Bn(0)
H(p) = -------
        Bn(p)
 </pre>
</blockquote>
<p>with the denominator polynomial</p>
<blockquote><pre>
         n             n  (2n - k)!       p^k
Bn(p) = sum c_k*p^k = sum ----------- * -------   (1)
        k=0           k=0 (n - k)!k!    2^(n-k)
</pre></blockquote>
<p>and the numerator</p>
<blockquote><pre>
               (2n)!     1
Bn(0) = c_0 = ------- * ---- .                    (2)
                n!      2^n
 </pre></blockquote>
<p>Although the coefficients c_k are integer numbers, it is not advisable to use the
polynomials in an unfactorized form because the coefficients are fast growing with order
n (c_0 is approximately 0.3e24 and 0.8e59 for order n=20 and order n=40
respectively).</p>

<p>Therefore, the polynomial Bn(p) is factorized to first and second order polynomials with
real coefficients corresponding to zeros and poles representation that is used in this library.</p>

<p>The function returns the coefficients which resulted from factorization of the normalized transfer function</p>
<blockquote><pre>
H'(p') = H(p),  p' = p/w0
</pre></blockquote>
<p>as well as</p>
<blockquote><pre>
alpha = 1/w0
</pre></blockquote>
<p>the reciprocal of the cut of frequency w0 where the gain of the transfer function is
decreased 3dB.</p>

<p>Both, coefficients and cut off frequency were calculated symbolically and were eventually evaluated
with high precision calculation. The results were stored in this function as real
numbers.</p>

<h4>Calculation of normalized Bessel filter coefficients</h4>
<p>Equation</p>
<blockquote><pre>
abs(H(j*w0)) = abs(Bn(0)/Bn(j*w0)) = 10^(-3/20)
</pre></blockquote>
<p>which must be fulfilled for cut off frequency w = w0 leads to</p>
<blockquote><pre>
[Re(Bn(j*w0))]^2 + [Im(Bn(j*w0))]^2 - (Bn(0)^2)*10^(3/10) = 0
</pre></blockquote>
<p>which has exactly one real solution w0 for each order n. This solutions of w0 are
calculated symbolically first and evaluated by using high precise values of the
coefficients c_k calculated by following (1) and (2).</p>

<p>With w0, the coefficients of the factorized polynomial can be computed by calculating the
zeros of the denominator polynomial</p>
<blockquote><pre>
        n
Bn(p) = sum w0^k*c_k*(p/w0)^k
        k=0
</pre></blockquote>
<p>of the normalized transfer function H'(p'). There exist n/2 of conjugate complex
pairs of zeros (beta +-j*gamma) if n is even and one additional real zero (alpha) if n is
odd. Finally, the coefficients a, b1_k, b2_k of the polynomials</p>
<blockquote><pre> a*p + 1,  n is odd </pre></blockquote>
<p>and</p>
<blockquote><pre>
b2_k*p^2 + b1_k*p + 1,   k = 1,... div(n,2)
</pre></blockquote>
<p>results from</p>
<blockquote><pre>
a = -1/alpha
</pre></blockquote>
<p>and</p>
<blockquote><pre>
b2_k = 1/(beta_k^2 + gamma_k^2) b1_k = -2*beta_k/(beta_k^2 + gamma_k^2)
</pre></blockquote>
</html>"));
            end BesselBaseCoefficients;

            function toHighestPowerOne
              "Transform filter to form with highest power of s equal 1"
              extends Modelica.Icons.Function;

              input Real den1[:] "[s] coefficients of polynomials (den1[i]*s + 1)";
              input Real den2[:,2]
                "[s^2, s] coefficients of polynomials (den2[i,1]*s^2 + den2[i,2]*s + 1)";
              output Real cr[size(den1, 1)]
                "[s^0] coefficients of polynomials cr[i]*(s+1/cr[i])";
              output Real c0[size(den2, 1)]
                "[s^0] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
              output Real c1[size(den2, 1)]
                "[s^1] coefficients of polynomials (s^2 + (den2[i,2]/den2[i,1])*s + (1/den2[i,1]))";
            algorithm
              for i in 1:size(den1, 1) loop
                cr[i] := 1/den1[i];
              end for;

              for i in 1:size(den2, 1) loop
                c1[i] := den2[i, 2]/den2[i, 1];
                c0[i] := 1/den2[i, 1];
              end for;
            end toHighestPowerOne;

            function normalizationFactor
              "Compute correction factor of low pass filter such that amplitude at cut-off frequency is -3db (=10^(-3/20) = 0.70794...)"
              extends Modelica.Icons.Function;

              import Modelica.Utilities.Streams;

              input Real c1[:]
                "[p] coefficients of denominator polynomials (c1[i}*p + 1)";
              input Real c2[:,2]
                "[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)";
              output Real alpha "Correction factor (replace p by alpha*p)";
          protected
              Real alpha_min;
              Real alpha_max;

              function normalizationResidue
                "Residue of correction factor computation"
                extends Modelica.Icons.Function;
                input Real c1[:]
                  "[p] coefficients of denominator polynomials (c1[i]*p + 1)";
                input Real c2[:,2]
                  "[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)";
                input Real alpha;
                output Real residue;
            protected
                constant Real beta= 10^(-3/20)
                  "Amplitude of -3db required, i.e., -3db = 20*log(beta)";
                Real cc1;
                Real cc2;
                Real p;
                Real alpha2=alpha*alpha;
                Real alpha4=alpha2*alpha2;
                Real A2=1.0;
              algorithm
                assert(size(c1,1) <= 1, "Internal error 2 (should not occur)");
                if size(c1, 1) == 1 then
                  cc1 := c1[1]*c1[1];
                  p := 1 + cc1*alpha2;
                  A2 := A2*p;
                end if;
                for i in 1:size(c2, 1) loop
                  cc1 := c2[i, 2]*c2[i, 2] - 2*c2[i, 1];
                  cc2 := c2[i, 1]*c2[i, 1];
                  p := 1 + cc1*alpha2 + cc2*alpha4;
                  A2 := A2*p;
                end for;
                residue := 1/sqrt(A2) - beta;
              end normalizationResidue;

              function findInterval "Find interval for the root"
                extends Modelica.Icons.Function;
                input Real c1[:]
                  "[p] coefficients of denominator polynomials (a*p + 1)";
                input Real c2[:,2]
                  "[p^2, p] coefficients of denominator polynomials (b*p^2 + a*p + 1)";
                output Real alpha_min;
                output Real alpha_max;
            protected
                Real alpha = 1.0;
                Real residue;
              algorithm
                alpha_min :=0;
                residue := normalizationResidue(c1, c2, alpha);
                if residue < 0 then
                   alpha_max :=alpha;
                else
                   while residue >= 0 loop
                      alpha := 1.1*alpha;
                      residue := normalizationResidue(c1, c2, alpha);
                   end while;
                   alpha_max :=alpha;
                end if;
              end findInterval;

            function solveOneNonlinearEquation
                "Solve f(u) = 0; f(u_min) and f(u_max) must have different signs"
                extends Modelica.Icons.Function;
                import Modelica.Utilities.Streams.error;

              input Real c1[:]
                  "[p] coefficients of denominator polynomials (c1[i]*p + 1)";
              input Real c2[:,2]
                  "[p^2, p] coefficients of denominator polynomials (c2[i,1]*p^2 + c2[i,2]*p + 1)";
              input Real u_min "Lower bound of search interval";
              input Real u_max "Upper bound of search interval";
              input Real tolerance=100*Modelica.Constants.eps
                  "Relative tolerance of solution u";
              output Real u "Value of independent variable so that f(u) = 0";

            protected
              constant Real eps=Modelica.Constants.eps "machine epsilon";
              Real a=u_min "Current best minimum interval value";
              Real b=u_max "Current best maximum interval value";
              Real c "Intermediate point a <= c <= b";
              Real d;
              Real e "b - a";
              Real m;
              Real s;
              Real p;
              Real q;
              Real r;
              Real tol;
              Real fa "= f(a)";
              Real fb "= f(b)";
              Real fc;
              Boolean found=false;
            algorithm
              // Check that f(u_min) and f(u_max) have different sign
              fa := normalizationResidue(c1,c2,u_min);
              fb := normalizationResidue(c1,c2,u_max);
              fc := fb;
              if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
                error(
                  "The arguments u_min and u_max to solveOneNonlinearEquation(..)\n" +
                  "do not bracket the root of the single non-linear equation:\n" +
                  "  u_min  = " + String(u_min) + "\n" + "  u_max  = " + String(u_max)
                   + "\n" + "  fa = f(u_min) = " + String(fa) + "\n" +
                  "  fb = f(u_max) = " + String(fb) + "\n" +
                  "fa and fb must have opposite sign which is not the case");
              end if;

              // Initialize variables
              c := a;
              fc := fa;
              e := b - a;
              d := e;

              // Search loop
              while not found loop
                if abs(fc) < abs(fb) then
                  a := b;
                  b := c;
                  c := a;
                  fa := fb;
                  fb := fc;
                  fc := fa;
                end if;

                tol := 2*eps*abs(b) + tolerance;
                m := (c - b)/2;

                if abs(m) <= tol or fb == 0.0 then
                  // root found (interval is small enough)
                  found := true;
                  u := b;
                else
                  // Determine if a bisection is needed
                  if abs(e) < tol or abs(fa) <= abs(fb) then
                    e := m;
                    d := e;
                  else
                    s := fb/fa;
                    if a == c then
                      // linear interpolation
                      p := 2*m*s;
                      q := 1 - s;
                    else
                      // inverse quadratic interpolation
                      q := fa/fc;
                      r := fb/fc;
                      p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
                      q := (q - 1)*(r - 1)*(s - 1);
                    end if;

                    if p > 0 then
                      q := -q;
                    else
                      p := -p;
                    end if;

                    s := e;
                    e := d;
                    if 2*p < 3*m*q - abs(tol*q) and p < abs(0.5*s*q) then
                      // interpolation successful
                      d := p/q;
                    else
                      // use bi-section
                      e := m;
                      d := e;
                    end if;
                  end if;

                  // Best guess value is defined as "a"
                  a := b;
                  fa := fb;
                  b := b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
                  fb := normalizationResidue(c1,c2,b);

                  if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
                    // initialize variables
                    c := a;
                    fc := fa;
                    e := b - a;
                    d := e;
                  end if;
                end if;
              end while;

              annotation (Documentation(info="<html>

<p>
This function determines the solution of <strong>one non-linear algebraic equation</strong> \"y=f(u)\"
in <strong>one unknown</strong> \"u\" in a reliable way. It is one of the best numerical
algorithms for this purpose. As input, the nonlinear function f(u)
has to be given, as well as an interval u_min, u_max that
contains the solution, i.e., \"f(u_min)\" and \"f(u_max)\" must
have a different sign. If possible, a smaller interval is computed by
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<dl>
<dt> Brent R.P.:</dt>
<dd> <strong>Algorithms for Minimization without derivatives</strong>.
     Prentice Hall, 1973, pp. 58-59.</dd>
</dl>

</html>"));
            end solveOneNonlinearEquation;

            algorithm
               // Find interval for alpha
               (alpha_min, alpha_max) :=findInterval(c1, c2);

               // Compute alpha, so that abs(G(p)) = -3db
               alpha :=solveOneNonlinearEquation(
                c1,
                c2,
                alpha_min,
                alpha_max);
            end normalizationFactor;

            encapsulated function bandPassAlpha "Return alpha for band pass"
              extends Modelica.Icons.Function;

              import Modelica;
               input Real a "Coefficient of s^1";
               input Real b "Coefficient of s^0";
               input Modelica.SIunits.AngularVelocity w
                "Bandwidth angular frequency";
               output Real alpha "Alpha factor to build up band pass";

          protected
              Real alpha_min;
              Real alpha_max;
              Real z_min;
              Real z_max;
              Real z;

              function residue "Residue of non-linear equation"
                extends Modelica.Icons.Function;
                input Real a;
                input Real b;
                input Real w;
                input Real z;
                output Real res;
              algorithm
                res := z^2 + (a*w*z/(1+z))^2 - (2+b*w^2)*z + 1;
              end residue;

            function solveOneNonlinearEquation
                "Solve f(u) = 0; f(u_min) and f(u_max) must have different signs"
                extends Modelica.Icons.Function;
                import Modelica.Utilities.Streams.error;

              input Real aa;
              input Real bb;
              input Real ww;
              input Real u_min "Lower bound of search interval";
              input Real u_max "Upper bound of search interval";
              input Real tolerance=100*Modelica.Constants.eps
                  "Relative tolerance of solution u";
              output Real u "Value of independent variable so that f(u) = 0";

            protected
              constant Real eps=Modelica.Constants.eps "machine epsilon";
              Real a=u_min "Current best minimum interval value";
              Real b=u_max "Current best maximum interval value";
              Real c "Intermediate point a <= c <= b";
              Real d;
              Real e "b - a";
              Real m;
              Real s;
              Real p;
              Real q;
              Real r;
              Real tol;
              Real fa "= f(a)";
              Real fb "= f(b)";
              Real fc;
              Boolean found=false;
            algorithm
              // Check that f(u_min) and f(u_max) have different sign
              fa := residue(aa,bb,ww,u_min);
              fb := residue(aa,bb,ww,u_max);
              fc := fb;
              if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
                error(
                  "The arguments u_min and u_max to solveOneNonlinearEquation(..)\n" +
                  "do not bracket the root of the single non-linear equation:\n" +
                  "  u_min  = " + String(u_min) + "\n" + "  u_max  = " + String(u_max)
                   + "\n" + "  fa = f(u_min) = " + String(fa) + "\n" +
                  "  fb = f(u_max) = " + String(fb) + "\n" +
                  "fa and fb must have opposite sign which is not the case");
              end if;

              // Initialize variables
              c := a;
              fc := fa;
              e := b - a;
              d := e;

              // Search loop
              while not found loop
                if abs(fc) < abs(fb) then
                  a := b;
                  b := c;
                  c := a;
                  fa := fb;
                  fb := fc;
                  fc := fa;
                end if;

                tol := 2*eps*abs(b) + tolerance;
                m := (c - b)/2;

                if abs(m) <= tol or fb == 0.0 then
                  // root found (interval is small enough)
                  found := true;
                  u := b;
                else
                  // Determine if a bisection is needed
                  if abs(e) < tol or abs(fa) <= abs(fb) then
                    e := m;
                    d := e;
                  else
                    s := fb/fa;
                    if a == c then
                      // linear interpolation
                      p := 2*m*s;
                      q := 1 - s;
                    else
                      // inverse quadratic interpolation
                      q := fa/fc;
                      r := fb/fc;
                      p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
                      q := (q - 1)*(r - 1)*(s - 1);
                    end if;

                    if p > 0 then
                      q := -q;
                    else
                      p := -p;
                    end if;

                    s := e;
                    e := d;
                    if 2*p < 3*m*q - abs(tol*q) and p < abs(0.5*s*q) then
                      // interpolation successful
                      d := p/q;
                    else
                      // use bi-section
                      e := m;
                      d := e;
                    end if;
                  end if;

                  // Best guess value is defined as "a"
                  a := b;
                  fa := fb;
                  b := b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
                  fb := residue(aa,bb,ww,b);

                  if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
                    // initialize variables
                    c := a;
                    fc := fa;
                    e := b - a;
                    d := e;
                  end if;
                end if;
              end while;

              annotation (Documentation(info="<html>

<p>
This function determines the solution of <strong>one non-linear algebraic equation</strong> \"y=f(u)\"
in <strong>one unknown</strong> \"u\" in a reliable way. It is one of the best numerical
algorithms for this purpose. As input, the nonlinear function f(u)
has to be given, as well as an interval u_min, u_max that
contains the solution, i.e., \"f(u_min)\" and \"f(u_max)\" must
have a different sign. If possible, a smaller interval is computed by
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<dl>
<dt> Brent R.P.:</dt>
<dd> <strong>Algorithms for Minimization without derivatives</strong>.
     Prentice Hall, 1973, pp. 58-59.</dd>
</dl>

</html>"));
            end solveOneNonlinearEquation;

            algorithm
              assert( a^2/4 - b <= 0,  "Band pass transformation cannot be computed");
              z :=solveOneNonlinearEquation(a, b, w, 0, 1);
              alpha := sqrt(z);

              annotation (Documentation(info="<html>
<p>
A band pass with bandwidth \"w\" is determined from a low pass
</p>

<pre>
  1/(p^2 + a*p + b)
</pre>

<p>
with the transformation
</p>

<pre>
  new(p) = (p + 1/p)/w
</pre>

<p>
This results in the following derivation:
</p>

<pre>
  1/(p^2 + a*p + b) -> 1/( (p+1/p)^2/w^2 + a*(p + 1/p)/w + b )
                     = 1 /( ( p^2 + 1/p^2 + 2)/w^2 + (p + 1/p)*a/w + b )
                     = w^2*p^2 / (p^4 + 2*p^2 + 1 + (p^3 + p)a*w + b*w^2*p^2)
                     = w^2*p^2 / (p^4 + a*w*p^3 + (2+b*w^2)*p^2 + a*w*p + 1)
</pre>

<p>
This 4th order transfer function shall be split in to two transfer functions of order 2 each
for numerical reasons. With the following formulation, the fourth order
polynomial can be represented (with the unknowns \"c\" and \"alpha\"):
</p>

<pre>
  g(p) = w^2*p^2 / ( (p*alpha)^2 + c*(p*alpha) + 1) * ( (p/alpha)^2 + c*(p/alpha) + 1)
       = w^2*p^2 / ( p^4 + c*(alpha + 1/alpha)*p^3 + (alpha^2 + 1/alpha^2 + c^2)*p^2
                                                   + c*(alpha + 1/alpha)*p + 1 )
</pre>

<p>
Comparison of coefficients:
</p>

<pre>
  c*(alpha + 1/alpha) = a*w           -> c = a*w / (alpha + 1/alpha)
  alpha^2 + 1/alpha^2 + c^2 = 2+b*w^2 -> equation to determine alpha

  alpha^4 + 1 + a^2*w^2*alpha^4/(1+alpha^2)^2 = (2+b*w^2)*alpha^2
    or z = alpha^2
  z^2 + a^2*w^2*z^2/(1+z)^2 - (2+b*w^2)*z + 1 = 0
</pre>

<p>
Therefore the last equation has to be solved for \"z\" (basically, this means to compute
a real zero of a fourth order polynomial):
</p>

<pre>
   solve: 0 = f(z)  = z^2 + a^2*w^2*z^2/(1+z)^2 - (2+b*w^2)*z + 1  for \"z\"
              f(0)  = 1  &gt; 0
              f(1)  = 1 + a^2*w^2/4 - (2+b*w^2) + 1
                    = (a^2/4 - b)*w^2  &lt; 0
                    // since b - a^2/4 > 0 requirement for complex conjugate poles
   -> 0 &lt; z &lt; 1
</pre>

<p>
This function computes the solution of this equation and returns \"alpha = sqrt(z)\";
</p>

</html>"));
            end bandPassAlpha;
          end Utilities;
        end Filter;
      end Internal;
      annotation (
        Documentation(info="<html>
<p>
This package contains basic <strong>continuous</strong> input/output blocks
described by differential equations.
</p>

<p>
All blocks of this package can be initialized in different
ways controlled by parameter <strong>initType</strong>. The possible
values of initType are defined in
<a href=\"modelica://Modelica.Blocks.Types.Init\">Modelica.Blocks.Types.Init</a>:
</p>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Name</strong></td>
      <td><strong>Description</strong></td></tr>

  <tr><td><strong>Init.NoInit</strong></td>
      <td>no initialization (start values are used as guess values with fixed=false)</td></tr>

  <tr><td><strong>Init.SteadyState</strong></td>
      <td>steady state initialization (derivatives of states are zero)</td></tr>

  <tr><td><strong>Init.InitialState</strong></td>
      <td>Initialization with initial states</td></tr>

  <tr><td><strong>Init.InitialOutput</strong></td>
      <td>Initialization with initial outputs (and steady state of the states if possible)</td></tr>
</table>

<p>
For backward compatibility reasons the default of all blocks is
<strong>Init.NoInit</strong>, with the exception of Integrator and LimIntegrator
where the default is <strong>Init.InitialState</strong> (this was the initialization
defined in version 2.2 of the Modelica standard library).
</p>

<p>
In many cases, the most useful initial condition is
<strong>Init.SteadyState</strong> because initial transients are then no longer
present. The drawback is that in combination with a non-linear
plant, non-linear algebraic equations occur that might be
difficult to solve if appropriate guess values for the
iteration variables are not provided (i.e., start values with fixed=false).
However, it is often already useful to just initialize
the linear blocks from the Continuous blocks library in SteadyState.
This is uncritical, because only linear algebraic equations occur.
If Init.NoInit is set, then the start values for the states are
interpreted as <strong>guess</strong> values and are propagated to the
states with fixed=<strong>false</strong>.
</p>

<p>
Note, initialization with Init.SteadyState is usually difficult
for a block that contains an integrator
(Integrator, LimIntegrator, PI, PID, LimPID).
This is due to the basic equation of an integrator:
</p>

<pre>
  <strong>initial equation</strong>
     <strong>der</strong>(y) = 0;   // Init.SteadyState
  <strong>equation</strong>
     <strong>der</strong>(y) = k*u;
</pre>

<p>
The steady state equation leads to the condition that the input to the
integrator is zero. If the input u is already (directly or indirectly) defined
by another initial condition, then the initialization problem is <strong>singular</strong>
(has none or infinitely many solutions). This situation occurs often
for mechanical systems, where, e.g., u = desiredSpeed - measuredSpeed and
since speed is both a state and a derivative, it is always defined by
Init.InitialState or Init.SteadyState initialization.
</p>

<p>
In such a case, <strong>Init.NoInit</strong> has to be selected for the integrator
and an additional initial equation has to be added to the system
to which the integrator is connected. E.g., useful initial conditions
for a 1-dim. rotational inertia controlled by a PI controller are that
<strong>angle</strong>, <strong>speed</strong>, and <strong>acceleration</strong> of the inertia are zero.
</p>

</html>"),     Icon(graphics={Line(
              origin={0.061,4.184},
              points={{81.939,36.056},{65.362,36.056},{14.39,-26.199},{-29.966,
                  113.485},{-65.374,-61.217},{-78.061,-78.184}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Continuous;

    package Interfaces
    "Library of connectors and partial models for input/output blocks"
      import Modelica.SIunits;
      extends Modelica.Icons.InterfacesPackage;

      connector RealInput = input Real "'input Real' as connector" annotation (
        defaultComponentName="u",
        Icon(graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            points={{-100.0,100.0},{100.0,0.0},{-100.0,-100.0}})},
          coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(
          coordinateSystem(preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={0,0,127},
            fillPattern=FillPattern.Solid,
            points={{0.0,50.0},{100.0,0.0},{0.0,-50.0},{0.0,50.0}}),
          Text(
            lineColor={0,0,127},
            extent={{-10.0,60.0},{-10.0,85.0}},
            textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Real.
</p>
</html>"));

      connector RealOutput = output Real "'output Real' as connector" annotation (
        defaultComponentName="y",
        Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-100.0,100.0},{100.0,0.0},{-100.0,-100.0}})}),
        Diagram(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(
            lineColor={0,0,127},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid,
            points={{-100.0,50.0},{0.0,0.0},{-100.0,-50.0}}),
          Text(
            lineColor={0,0,127},
            extent={{30.0,60.0},{30.0,110.0}},
            textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Real.
</p>
</html>"));

      connector BooleanInput = input Boolean "'input Boolean' as connector"
        annotation (
        defaultComponentName="u",
        Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Boolean.
</p>
</html>"));

      connector BooleanOutput = output Boolean "'output Boolean' as connector"
        annotation (
        defaultComponentName="y",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,0,255},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              lineColor={255,0,255},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Boolean.
</p>
</html>"));

      connector IntegerInput = input Integer "'input Integer' as connector"
        annotation (
        defaultComponentName="u",
        Icon(graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,127,0},
              fillColor={255,127,0},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=true,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{0,50},{100,0},{0,-50},{0,50}},
              lineColor={255,127,0},
              fillColor={255,127,0},
              fillPattern=FillPattern.Solid), Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,127,0},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one input signal of type Integer.
</p>
</html>"));

      connector IntegerOutput = output Integer "'output Integer' as connector"
        annotation (
        defaultComponentName="y",
        Icon(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,100},{100,0},{-100,-100},{-100,100}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
        Diagram(coordinateSystem(
            preserveAspectRatio=true,
            extent={{-100,-100},{100,100}}), graphics={Polygon(
              points={{-100,50},{0,0},{-100,-50},{-100,50}},
              lineColor={255,127,0},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid), Text(
              extent={{30,110},{30,60}},
              lineColor={255,127,0},
              textString="%name")}),
        Documentation(info="<html>
<p>
Connector with one output signal of type Integer.
</p>
</html>"));

      connector BooleanVectorInput = input Boolean
        "Boolean input connector used for vector of connectors" annotation (
        defaultComponentName="u",
        Icon(graphics={Ellipse(
              extent={{-100,-100},{100,100}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}, coordinateSystem(
            extent={{-100,-100},{100,100}},
            preserveAspectRatio=false,
            initialScale=0.2)),
        Diagram(coordinateSystem(
            preserveAspectRatio=false,
            initialScale=0.2,
            extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-10,85},{-10,60}},
              lineColor={255,0,255},
              textString="%name"), Ellipse(
              extent={{-50,50},{50,-50}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Boolean input connector that is used for a vector of connectors,
for example <a href=\"modelica://Modelica.Blocks.Interfaces.PartialBooleanMISO\">PartialBooleanMISO</a>,
and has therefore a different icon as BooleanInput connector.
</p>
</html>"));

      partial block SO "Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real output signal.
</p>
</html>"));

      end SO;

      partial block MO "Multiple Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        parameter Integer nout(min=1) = 1 "Number of outputs";
        RealOutput y[nout] "Connector of Real output signals" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real output signal vector.
</p>
</html>"));

      end MO;

      partial block SISO "Single Input Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealInput u "Connector of Real input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Real input and one continuous Real output signal.
</p>
</html>"));
      end SISO;

      partial block SI2SO
        "2 Single Input / 1 Single Output continuous control block"
        extends Modelica.Blocks.Icons.Block;

        RealInput u1 "Connector of Real input signal 1" annotation (Placement(
              transformation(extent={{-140,40},{-100,80}})));
        RealInput u2 "Connector of Real input signal 2" annotation (Placement(
              transformation(extent={{-140,-80},{-100,-40}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Documentation(info="<html>
<p>
Block has two continuous Real input signals u1 and u2 and one
continuous Real output signal y.
</p>
</html>"));

      end SI2SO;

      partial block SIMO "Single Input Multiple Output continuous control block"
        extends Modelica.Blocks.Icons.Block;
        parameter Integer nout=1 "Number of outputs";
        RealInput u "Connector of Real input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y[nout] "Connector of Real output signals" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Documentation(info="<html>
<p> Block has one continuous Real input signal and a
    vector of continuous Real output signals.</p>

</html>"));
      end SIMO;

      partial block MISO "Multiple Input Single Output continuous control block"

        extends Modelica.Blocks.Icons.Block;
        parameter Integer nin=1 "Number of inputs";
        RealInput u[nin] "Connector of Real input signals" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y "Connector of Real output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has a vector of continuous Real input signals and
one continuous Real output signal.
</p>
</html>"));
      end MISO;

      partial block MIMOs
        "Multiple Input Multiple Output continuous control block with same number of inputs and outputs"

        extends Modelica.Blocks.Icons.Block;
        parameter Integer n=1 "Number of inputs (= number of outputs)";
        RealInput u[n] "Connector of Real input signals" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y[n] "Connector of Real output signals" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has a continuous Real input and a continuous Real output signal vector
where the signal sizes of the input and output vector are identical.
</p>
</html>"));
      end MIMOs;

      partial block SVcontrol "Single-Variable continuous controller"
        extends Modelica.Blocks.Icons.Block;

        RealInput u_s "Connector of setpoint input signal" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        RealInput u_m "Connector of measurement input signal" annotation (Placement(
              transformation(
              origin={0,-120},
              extent={{20,-20},{-20,20}},
              rotation=270)));
        RealOutput y "Connector of actuator output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={Text(
                  extent={{-102,34},{-142,24}},
                  textString="(setpoint)",
                  lineColor={0,0,255}),Text(
                  extent={{100,24},{140,14}},
                  textString="(actuator)",
                  lineColor={0,0,255}),Text(
                  extent={{-83,-112},{-33,-102}},
                  textString=" (measurement)",
                  lineColor={0,0,255})}), Documentation(info="<html>
<p>
Block has two continuous Real input signals and one
continuous Real output signal. The block is designed
to be used as base class for a corresponding controller.
</p>
</html>"));
      end SVcontrol;

      partial block IntegerSO "Single Integer Output continuous control block"
        extends Modelica.Blocks.Icons.IntegerBlock;

        IntegerOutput y "Connector of Integer output signal" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));
        annotation (Documentation(info="<html>
<p>
Block has one continuous Integer output signal.
</p>
</html>"));
      end IntegerSO;

      partial block partialBooleanSISO
        "Partial block with 1 input and 1 output Boolean signal"
        extends Modelica.Blocks.Icons.PartialBooleanBlock;
        Blocks.Interfaces.BooleanInput u "Connector of Boolean input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Ellipse(
                extent={{-71,7},{-85,-7}},
                lineColor=DynamicSelect({235,235,235}, if u > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if u > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid), Ellipse(
                extent={{71,7},{85,-7}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
Block has one continuous Boolean input and one continuous Boolean output signal
with a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanSISO;

      partial block partialBooleanSI2SO
        "Partial block with 2 input and 1 output Boolean signal"
        extends Modelica.Blocks.Icons.PartialBooleanBlock;
        Blocks.Interfaces.BooleanInput u1 "Connector of first Boolean input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Blocks.Interfaces.BooleanInput u2
          "Connector of second Boolean input signal" annotation (Placement(
              transformation(extent={{-140,-100},{-100,-60}})));
        Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Ellipse(
                extent={{-71,7},{-85,-7}},
                lineColor=DynamicSelect({235,235,235}, if u1 > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if u1 > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-71,-74},{-85,-88}},
                lineColor=DynamicSelect({235,235,235}, if u2 > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if u2 > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{71,7},{85,-7}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
Block has two continuous Boolean input and one continuous Boolean output signal
with a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanSI2SO;

      partial block partialBooleanSI "Partial block with 1 input Boolean signal"
        extends Modelica.Blocks.Icons.PartialBooleanBlock;

        Blocks.Interfaces.BooleanInput u "Connector of Boolean input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Ellipse(
                extent={{-71,7},{-85,-7}},
                lineColor=DynamicSelect({235,235,235}, if u > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if u > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
Block has one continuous Boolean input signal
with a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanSI;

      partial block partialBooleanSO "Partial block with 1 output Boolean signal"

        Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        extends Modelica.Blocks.Icons.PartialBooleanBlock;

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Ellipse(
                extent={{71,7},{85,-7}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
Block has one continuous Boolean output signal
with a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanSO;

      partial block partialBooleanThresholdComparison
        "Partial block to compare the Real input u with a threshold and provide the result as 1 Boolean output signal"

        parameter Real threshold=0 "Comparison with respect to threshold";

        Blocks.Interfaces.RealInput u "Connector of Real input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Blocks.Interfaces.BooleanOutput y "Connector of Boolean output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-150,-140},{150,-110}},
                textString="%threshold"),
              Ellipse(
                extent={{71,7},{85,-7}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid),      Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),           Documentation(info="<html>
<p>
Block has one continuous Real input and one continuous Boolean output signal
as well as a 3D icon (e.g., used in Blocks.Logical library).
</p>
</html>"));

      end partialBooleanThresholdComparison;

      partial block PartialBooleanSISO_small
        "Partial block with a BooleanInput and a BooleanOutput signal and a small block icon"

        Modelica.Blocks.Interfaces.BooleanInput u "Boolean input signal"
          annotation (Placement(transformation(extent={{-180,-40},{-100,40}})));
        Modelica.Blocks.Interfaces.BooleanOutput y "Boolean output signal"
          annotation (Placement(transformation(extent={{100,-20},{140,20}})));
        annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.04), graphics={
              Text(
                extent={{-300,200},{300,120}},
                textString="%name",
                lineColor={0,0,255}),
              Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Ellipse(
                extent={{60,10},{80,-10}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid)}));
      end PartialBooleanSISO_small;

      partial block PartialBooleanMISO
        "Partial block with a BooleanVectorInput and a BooleanOutput signal"

        parameter Integer nu(min=0) = 0 "Number of input connections"
          annotation (Dialog(connectorSizing=true), HideResult=true);
        Modelica.Blocks.Interfaces.BooleanVectorInput u[nu]
          "Vector of Boolean input signals"
          annotation (Placement(transformation(extent={{-120,70},{-80,-70}})));
        Modelica.Blocks.Interfaces.BooleanOutput y "Boolean output signal"
          annotation (Placement(transformation(extent={{100,-15},{130,15}})));
        annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              initialScale=0.06), graphics={
              Text(
                extent={{-250,170},{250,110}},
                textString="%name",
                lineColor={0,0,255}),
              Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Ellipse(
                extent={{60,10},{80,-10}},
                lineColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillColor=DynamicSelect({235,235,235}, if y > 0.5 then {0,255,0}
                     else {235,235,235}),
                fillPattern=FillPattern.Solid)}));
      end PartialBooleanMISO;

      partial block PartialConversionBlock
        "Partial block defining the interface for conversion blocks"

        RealInput u "Connector of Real input signal to be converted" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        RealOutput y
          "Connector of Real output signal containing input signal u in another unit"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        annotation (
          Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
            Rectangle(
              lineColor={0,0,127},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-100.0,-100.0},{100.0,100.0}}),
            Line(
              points={{-90.0,0.0},{30.0,0.0}},
              color={191,0,0}),
            Polygon(
              lineColor={191,0,0},
              fillColor={191,0,0},
              fillPattern=FillPattern.Solid,
              points={{90.0,0.0},{30.0,20.0},{30.0,-20.0},{90.0,0.0}}),
            Text(
              lineColor={0,0,255},
              extent={{-150,110},{150,150}},
              textString="%name")}), Documentation(info="<html>
<p>
This block defines the interface of a conversion block that
converts from one unit into another one.
</p>

</html>"));

      end PartialConversionBlock;

      partial block BlockIcon
        "This icon will be removed in future Modelica versions, use Modelica.Blocks.Icons.Block instead."
        extends Modelica.Icons.ObsoleteModel;

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
This icon will be removed in future versions of the Modelica Standard Library.
Instead the icon <a href=\"modelica://Modelica.Blocks.Icons.Block\">Modelica.Blocks.Icons.Block</a> shall be used.
</p>
</html>"),
        obsolete = "Obsolete block - use Modelica.Blocks.Icons.Block instead");
      end BlockIcon;
      annotation (Documentation(info="<html>
<p>
This package contains interface definitions for
<strong>continuous</strong> input/output blocks with Real,
Integer and Boolean signals. Furthermore, it contains
partial models for continuous and discrete blocks.
</p>

</html>",     revisions="<html>
<ul>
<li><em>Oct. 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Added several new interfaces.</li>
<li><em>Oct. 24, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       RealInputSignal renamed to RealInput. RealOutputSignal renamed to
       output RealOutput. GraphBlock renamed to BlockIcon. SISOreal renamed to
       SISO. SOreal renamed to SO. I2SOreal renamed to M2SO.
       SignalGenerator renamed to SignalSource. Introduced the following
       new models: MIMO, MIMOs, SVcontrol, MVcontrol, DiscreteBlockIcon,
       DiscreteBlock, DiscreteSISO, DiscreteMIMO, DiscreteMIMOs,
       BooleanBlockIcon, BooleanSISO, BooleanSignalSource, MI2BooleanMOs.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Interfaces;

    package Logical
    "Library of components with Boolean input and output signals"
      extends Modelica.Icons.Package;

      block And "Logical 'and': y = u1 and u2"
        extends Blocks.Interfaces.partialBooleanSI2SO;
      equation
        y = u1 and u2;
        annotation (
          defaultComponentName="and1",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-90,40},{90,-40}},
                textString="and")}),
          Documentation(info="<html>
<p>
The output is <strong>true</strong> if all inputs are <strong>true</strong>, otherwise
the output is <strong>false</strong>.
</p>
</html>"));
      end And;

      block Or "Logical 'or': y = u1 or u2"
        extends Blocks.Interfaces.partialBooleanSI2SO;
      equation
        y = u1 or u2;
        annotation (
          defaultComponentName="or1",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-90,40},{90,-40}},
                textString="or")}),
          Documentation(info="<html>
<p>
The output is <strong>true</strong> if at least one input is <strong>true</strong>, otherwise
the output is <strong>false</strong>.
</p>
</html>"));
      end Or;

      block Not "Logical 'not': y = not u"
        extends Blocks.Interfaces.partialBooleanSISO;

      equation
        y = not u;
        annotation (
          defaultComponentName="not1",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-90,40},{90,-40}},
                textString="not")}),
          Documentation(info="<html>
<p>
The output is <strong>true</strong> if the input is <strong>false</strong>, otherwise
the output is <strong>false</strong>.
</p>
</html>"));
      end Not;

      block GreaterThreshold
        "Output y is true, if input u is greater than threshold"
        extends Blocks.Interfaces.partialBooleanThresholdComparison;
      equation
        y = u > threshold;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(
                points={{-54,20},{-8,0},{-54,-20}},
                thickness=0.5)}), Documentation(info="<html>
<p>
The output is <strong>true</strong> if the Real input is greater than
parameter <strong>threshold</strong>, otherwise
the output is <strong>false</strong>.
</p>
</html>"));
      end GreaterThreshold;

      block GreaterEqualThreshold
        "Output y is true, if input u is greater or equal than threshold"

        extends Blocks.Interfaces.partialBooleanThresholdComparison;
      equation
        y = u >= threshold;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(
                points={{-54,20},{-8,0},{-54,-20}},
                thickness=0.5),
              Line(points={{-54,-30},{-8,-30}}, thickness=0.5)}),
          Documentation(info="<html>
<p>
The output is <strong>true</strong> if the Real input is greater than or equal to
parameter <strong>threshold</strong>, otherwise
the output is <strong>false</strong>.
</p>
</html>"));
      end GreaterEqualThreshold;

      block LessThreshold "Output y is true, if input u is less than threshold"

        extends Blocks.Interfaces.partialBooleanThresholdComparison;
      equation
        y = u < threshold;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(points={{-8,20},{-54,0},{-8,-20}}, thickness=0.5)}), Documentation(info="<html>
<p>
The output is <strong>true</strong> if the Real input is less than
parameter <strong>threshold</strong>, otherwise
the output is <strong>false</strong>.
</p>
</html>"));
      end LessThreshold;

      block LessEqualThreshold
        "Output y is true, if input u is less or equal than threshold"
        extends Blocks.Interfaces.partialBooleanThresholdComparison;
      equation
        y = u <= threshold;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Line(points={{-8,20},{-54,0},{-8,-20}}, thickness=0.5),
              Line(points={{-54,-30},{-8,-30}}, thickness=0.5)}),
          Documentation(info="<html>
<p>
The output is <strong>true</strong> if the Real input is less than or equal to
parameter <strong>threshold</strong>, otherwise
the output is <strong>false</strong>.
</p>
</html>"));
      end LessEqualThreshold;

      block Switch "Switch between two Real signals"
        extends Modelica.Blocks.Icons.PartialBooleanBlock;
        Blocks.Interfaces.RealInput u1 "Connector of first Real input signal"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Blocks.Interfaces.BooleanInput u2 "Connector of Boolean input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Blocks.Interfaces.RealInput u3 "Connector of second Real input signal"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
        Blocks.Interfaces.RealOutput y "Connector of Real output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = if u2 then u1 else u3;
        annotation (
          defaultComponentName="switch1",
          Documentation(info="<html>
<p>The Logical.Switch switches, depending on the
logical connector u2 (the middle connector)
between the two possible input signals
u1 (upper connector) and u3 (lower connector).</p>
<p>If u2 is <strong>true</strong>, the output signal y is set equal to
u1, else it is set equal to u3.</p>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{12,0},{100,0}},
                color={0,0,127}),
              Line(points={{-100,0},{-40,0}},
                color={255,0,255}),
              Line(points={{-100,-80},{-40,-80},{-40,-80}},
                color={0,0,127}),
              Line(points={{-40,12},{-40,-12}},
                color={255,0,255}),
              Line(points={{-100,80},{-38,80}},
                color={0,0,127}),
              Line(points=DynamicSelect({{-38,80},{6,2}}, if u2 then {{-38,80},{6,2}} else {{-38,-80},{6,2}}),
                color={0,0,127},
                thickness=1),
              Ellipse(lineColor={0,0,255},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{2,-8},{18,8}})}));
      end Switch;

      block Hysteresis "Transform Real to Boolean signal with Hysteresis"

        extends Modelica.Blocks.Icons.PartialBooleanBlock;
        parameter Real uLow(start=0) "if y=true and u<=uLow, switch to y=false";
        parameter Real uHigh(start=1) "if y=false and u>=uHigh, switch to y=true";
        parameter Boolean pre_y_start=false "Value of pre(y) at initial time";

        Blocks.Interfaces.RealInput u annotation (Placement(transformation(extent={
                  {-140,-20},{-100,20}})));
        Blocks.Interfaces.BooleanOutput y annotation (Placement(transformation(
                extent={{100,-10},{120,10}})));

      initial equation
        pre(y) = pre_y_start;
      equation
        assert(uHigh > uLow,"Hysteresis limits wrong (uHigh <= uLow)");
        y = not pre(y) and u > uHigh or pre(y) and u >= uLow;
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Polygon(
                  points={{-65,89},{-73,67},{-57,67},{-65,89}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),Line(points={{-65,67},{-65,-81}},
                color={192,192,192}),Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
                Polygon(
                  points={{90,-70},{68,-62},{68,-78},{90,-70}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{70,-80},{94,-100}},
                  lineColor={160,160,164},
                  textString="u"),Text(
                  extent={{-65,93},{-12,75}},
                  lineColor={160,160,164},
                  textString="y"),Line(
                  points={{-80,-70},{30,-70}},
                  thickness=0.5),Line(
                  points={{-50,10},{80,10}},
                  thickness=0.5),Line(
                  points={{-50,10},{-50,-70}},
                  thickness=0.5),Line(
                  points={{30,10},{30,-70}},
                  thickness=0.5),Line(
                  points={{-10,-65},{0,-70},{-10,-75}},
                  thickness=0.5),Line(
                  points={{-10,15},{-20,10},{-10,5}},
                  thickness=0.5),Line(
                  points={{-55,-20},{-50,-30},{-44,-20}},
                  thickness=0.5),Line(
                  points={{25,-30},{30,-19},{35,-30}},
                  thickness=0.5),Text(
                  extent={{-99,2},{-70,18}},
                  lineColor={160,160,164},
                  textString="true"),Text(
                  extent={{-98,-87},{-66,-73}},
                  lineColor={160,160,164},
                  textString="false"),Text(
                  extent={{19,-87},{44,-70}},
                  textString="uHigh"),Text(
                  extent={{-63,-88},{-38,-71}},
                  textString="uLow"),Line(points={{-69,10},{-60,10}}, color={160,
                160,164})}),
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-29}}, color={192,192,192}),
              Polygon(
                points={{92,-29},{70,-21},{70,-37},{92,-29}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-79,-29},{84,-29}}, color={192,192,192}),
              Line(points={{-79,-29},{41,-29}}),
              Line(points={{-15,-21},{1,-29},{-15,-36}}),
              Line(points={{41,51},{41,-29}}),
              Line(points={{33,3},{41,22},{50,3}}),
              Line(points={{-49,51},{81,51}}),
              Line(points={{-4,59},{-19,51},{-4,43}}),
              Line(points={{-59,29},{-49,11},{-39,29}}),
              Line(points={{-49,51},{-49,-29}}),
              Text(
                extent={{-92,-49},{-9,-92}},
                lineColor={192,192,192},
                textString="%uLow"),
              Text(
                extent={{2,-49},{91,-92}},
                lineColor={192,192,192},
                textString="%uHigh"),
              Rectangle(extent={{-91,-49},{-8,-92}}, lineColor={192,192,192}),
              Line(points={{-49,-29},{-49,-49}}, color={192,192,192}),
              Rectangle(extent={{2,-49},{91,-92}}, lineColor={192,192,192}),
              Line(points={{41,-29},{41,-49}}, color={192,192,192})}),
          Documentation(info="<html>
<p>
This block transforms a <strong>Real</strong> input signal into a <strong>Boolean</strong>
output signal:
</p>
<ul>
<li> When the output was <strong>false</strong> and the input becomes
     <strong>greater</strong> than parameter <strong>uHigh</strong>, the output
     switches to <strong>true</strong>.</li>
<li> When the output was <strong>true</strong> and the input becomes
     <strong>less</strong> than parameter <strong>uLow</strong>, the output
     switches to <strong>false</strong>.</li>
</ul>
<p>
The start value of the output is defined via parameter
<strong>pre_y_start</strong> (= value of pre(y) at initial time).
The default value of this parameter is <strong>false</strong>.
</p>
</html>"));
      end Hysteresis;

      block Timer
        "Timer measuring the time from the time instant where the Boolean input became true"

        extends Modelica.Blocks.Icons.PartialBooleanBlock;
        Blocks.Interfaces.BooleanInput u "Connector of Boolean input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Blocks.Interfaces.RealOutput y "Connector of Real output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

    protected
        discrete Modelica.SIunits.Time entryTime "Time instant when u became true";
      initial equation
        pre(entryTime) = 0;
      equation
        when u then
          entryTime = time;
        end when;
        y = if u then time - entryTime else 0.0;
        annotation (
          Icon(
            coordinateSystem(preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}),
              graphics={
            Line(points={{-90,-70},{82,-70}},
              color={192,192,192}),
            Line(points={{-80,68},{-80,-80}},
              color={192,192,192}),
            Polygon(lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              points={{90,-70},{68,-62},{68,-78},{90,-70}}),
            Polygon(lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid,
              points={{-80,90},{-88,68},{-72,68},{-80,90}}),
            Line(points={{-80,-70},{-60,-70},{-60,-26},{38,-26},{38,-70},{66,-70}},
              color={255,0,255}),
            Line(points={{-80,0},{-62,0},{40,90},{40,0},{68,0}},
              color={0,0,127})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Line(points={{-90,-70},{82,-70}}),
                Line(points={{-80,68},{-80,-80}}),Polygon(
                  points={{90,-70},{68,-62},{68,-78},{90,-70}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Polygon(
                  points={{-80,90},{-88,68},{-72,68},{-80,90}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Line(points={{-80,-68},{-60,-68},{
                -60,-40},{20,-40},{20,-68},{60,-68}}, color={255,0,255}),Line(
                points={{-80,-20},{-60,-20},{20,60},{20,-20},{60,-20},{60,-20}},
                color={0,0,255}),Text(
                  extent={{-88,6},{-54,-4}},
                  textString="y"),Text(
                  extent={{48,-80},{84,-88}},
                  textString="time"),Text(
                  extent={{-88,-36},{-54,-46}},
                  textString="u")}),
          Documentation(info="<html>
<p>When the Boolean input \"u\" becomes <strong>true</strong>, the timer starts
and the output \"y\" is the time that has elapsed since \"u\" became <strong>true</strong>.
When the input becomes <strong>false</strong>, the timer stops and the output is reset to zero.
</p>
</html>"));
      end Timer;
      annotation (Documentation(info="<html>
<p>
This package provides blocks with Boolean input and output signals
to describe logical networks. A typical example for a logical
network built with package Logical is shown in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/LogicalNetwork1.png\"
     alt=\"LogicalNetwork1.png\">
</p>

<p>
The actual value of Boolean input and/or output signals is displayed
in the respective block icon as \"circle\", where \"white\" color means
value <strong>false</strong> and \"green\" color means value <strong>true</strong>. These
values are visualized in a diagram animation.
</p>
</html>"),     Icon(graphics={Line(
              points={{-86,-22},{-50,-22},{-50,22},{48,22},{48,-22},{88,-24}},
              color={255,0,255})}));
    end Logical;

    package Math
    "Library of Real mathematical functions as input/output blocks"
      import Modelica.SIunits;
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

      encapsulated package UnitConversions
      "Conversion blocks to convert between SI and non-SI unit signals"
        import Modelica;
        import SI = Modelica.SIunits;
        import NonSI = Modelica.SIunits.Conversions.NonSIunits;
        extends Modelica.Icons.Package;

        block From_degC "Convert from degCelsius to Kelvin"
          extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit="degC"),
              y(unit="K"));
        equation
          y = SI.Conversions.from_degC(u);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                      extent={{-20,100},{-100,20}},
                      textString="degC"),Text(
                      extent={{100,-20},{20,-100}},
                      textString="K")}), Documentation(info="<html>
<p>
This block converts the input signal from degCelsius to Kelvin and returns
the result as output signal.
</p>
</html>"));
        end From_degC;

        block From_deg "Convert from degree to radian"
          extends Modelica.Blocks.Interfaces.PartialConversionBlock(u(unit="deg"),
              y(unit="rad"));
        equation
          y = SI.Conversions.from_deg(u);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                      extent={{-20,100},{-100,20}},
                      textString="deg"),Text(
                      extent={{100,-20},{20,-100}},
                      textString="rad")}), Documentation(info="<html>
<p>
This block converts the input signal from degree to radian and returns
the result as output signal.
</p>
</html>"));
        end From_deg;
        annotation (Documentation(info="<html>
<p>
This package consists of blocks that convert an input signal
with a specific unit to an output signal in another unit
(e.g., conversion of an angle signal from \"deg\" to \"rad\").
</p>

</html>"));
      end UnitConversions;

      block Gain "Output the product of a gain value with the input signal"

        parameter Real k(start=1, unit="1")
          "Gain value multiplied with input signal";
    public
        Interfaces.RealInput u "Input signal connector" annotation (Placement(
              transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealOutput y "Output signal connector" annotation (Placement(
              transformation(extent={{100,-10},{120,10}})));

      equation
        y = k*u;
        annotation (
          Documentation(info="<html>
<p>
This block computes output <em>y</em> as
<em>product</em> of gain <em>k</em> with the
input <em>u</em>:
</p>
<pre>
    y = k * u;
</pre>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-150,-140},{150,-100}},
                textString="k=%k"),
              Text(
                extent={{-150,140},{150,100}},
                textString="%name",
                lineColor={0,0,255})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Polygon(
                  points={{-100,-100},{-100,100},{100,0},{-100,-100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{-76,38},{0,-34}},
                  textString="k",
                  lineColor={0,0,255})}));
      end Gain;

      block Sum "Output the sum of the elements of the input vector"
        extends Interfaces.MISO;
        parameter Real k[nin]=ones(nin) "Optional: sum coefficients";
      equation
        y = k*u;
        annotation (
          defaultComponentName="sum1",
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as
<em>sum</em> of the elements of the input signal vector
<strong>u</strong>:
</p>
<pre>
    <strong>y</strong> = <strong>u</strong>[1] + <strong>u</strong>[2] + ...;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   nin = 3;

  results in the following equations:

     y = u[1] + u[2] + u[3];
</pre>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Line(
                points={{26,42},{-34,42},{6,2},{-34,-38},{26,-38}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Line(
                  points={{26,42},{-34,42},{6,2},{-34,-38},{26,-38}})}));
      end Sum;

      block Feedback "Output difference between commanded and feedback input"

        Interfaces.RealInput u1 annotation (Placement(transformation(extent={{-100,
                  -20},{-60,20}})));
        Interfaces.RealInput u2 annotation (Placement(transformation(
              origin={0,-80},
              extent={{-20,-20},{20,20}},
              rotation=90)));
        Interfaces.RealOutput y annotation (Placement(transformation(extent={{80,-10},
                  {100,10}})));

      equation
        y = u1 - u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>difference</em> of the
commanded input <strong>u1</strong> and the feedback
input <strong>u2</strong>:
</p>
<pre>
    <strong>y</strong> = <strong>u1</strong> - <strong>u2</strong>;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   n = 2

  results in the following equations:

     y = u1 - u2
</pre>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Ellipse(
                lineColor={0,0,127},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                extent={{-20,-20},{20,20}}),
              Line(points={{-60,0},{-20,0}}, color={0,0,127}),
              Line(points={{20,0},{80,0}}, color={0,0,127}),
              Line(points={{0,-20},{0,-60}}, color={0,0,127}),
              Text(extent={{-14,-94},{82,0}}, textString="-"),
              Text(
                lineColor={0,0,255},
                extent={{-150,44},{150,94}},
                textString="%name")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Ellipse(
                  extent={{-20,20},{20,-20}},
                  fillColor={235,235,235},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,255}),Line(points={{-60,0},{-20,0}}, color={0,0,255}),
                Line(points={{20,0},{80,0}}, color={0,0,255}),Line(points={{0,
                -20},{0,-60}}, color={0,0,255}),Text(
                  extent={{-12,10},{84,-84}},
                  textString="-")}));
      end Feedback;

      block Add "Output the sum of the two inputs"
        extends Interfaces.SI2SO;

        parameter Real k1=+1 "Gain of input signal 1";
        parameter Real k2=+1 "Gain of input signal 2";

      equation
        y = k1*u1 + k2*u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>sum</em> of the
two input signals <strong>u1</strong> and <strong>u2</strong>:
</p>
<pre>
    <strong>y</strong> = k1*<strong>u1</strong> + k2*<strong>u2</strong>;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   k1= +2, k2= -3

  results in the following equations:

     y = 2 * u1 - 3 * u2
</pre>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,60},{-74,24},{-44,24}}, color={0,0,127}),
              Line(points={{-100,-60},{-74,-28},{-42,-28}}, color={0,0,127}),
              Ellipse(lineColor={0,0,127}, extent={{-50,-50},{50,50}}),
              Line(points={{50,0},{100,0}}, color={0,0,127}),
              Text(extent={{-38,-34},{38,34}}, textString="+"),
              Text(extent={{-100,52},{5,92}}, textString="%k1"),
              Text(extent={{-100,-92},{5,-52}}, textString="%k2")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,127},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Line(points={{50,0},{100,0}},
                color={0,0,255}),Line(points={{-100,60},{-74,24},{-44,24}}, color={
                0,0,127}),Line(points={{-100,-60},{-74,-28},{-42,-28}}, color={0,0,127}),
                Ellipse(extent={{-50,50},{50,-50}}, lineColor={0,0,127}),Line(
                points={{50,0},{100,0}}, color={0,0,127}),Text(
                  extent={{-36,38},{40,-30}},
                  textString="+"),Text(
                  extent={{-100,52},{5,92}},
                  textString="k1"),Text(
                  extent={{-100,-52},{5,-92}},
                  textString="k2")}));
      end Add;

      block Add3 "Output the sum of the three inputs"
        extends Modelica.Blocks.Icons.Block;

        parameter Real k1=+1 "Gain of input signal 1";
        parameter Real k2=+1 "Gain of input signal 2";
        parameter Real k3=+1 "Gain of input signal 3";
        Interfaces.RealInput u1 "Connector of Real input signal 1" annotation (
            Placement(transformation(extent={{-140,60},{-100,100}})));
        Interfaces.RealInput u2 "Connector of Real input signal 2" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealInput u3 "Connector of Real input signal 3" annotation (
            Placement(transformation(extent={{-140,-100},{-100,-60}})));
        Interfaces.RealOutput y "Connector of Real output signal" annotation (
            Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = k1*u1 + k2*u2 + k3*u3;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes output <strong>y</strong> as <em>sum</em> of the
three input signals <strong>u1</strong>, <strong>u2</strong> and <strong>u3</strong>:
</p>
<pre>
    <strong>y</strong> = k1*<strong>u1</strong> + k2*<strong>u2</strong> + k3*<strong>u3</strong>;
</pre>
<p>
Example:
</p>
<pre>
     parameter:   k1= +2, k2= -3, k3=1;

  results in the following equations:

     y = 2 * u1 - 3 * u2 + u3;
</pre>

</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-100,50},{5,90}},
                textString="%k1"),
              Text(
                extent={{-100,-20},{5,20}},
                textString="%k2"),
              Text(
                extent={{-100,-50},{5,-90}},
                textString="%k3"),
              Text(
                extent={{2,36},{100,-44}},
                textString="+")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{-100,50},{5,90}},
                  textString="k1"),Text(
                  extent={{-100,-20},{5,20}},
                  textString="k2"),Text(
                  extent={{-100,-50},{5,-90}},
                  textString="k3"),Text(
                  extent={{2,46},{100,-34}},
                  textString="+")}));
      end Add3;

      block Product "Output product of the two inputs"
        extends Interfaces.SI2SO;

      equation
        y = u1*u2;
        annotation (
          Documentation(info="<html>
<p>
This blocks computes the output <strong>y</strong>
as <em>product</em> of the two inputs <strong>u1</strong> and <strong>u2</strong>:
</p>
<pre>
    y = u1 * u2;
</pre>

</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,60},{-40,60},{-30,40}}, color={0,0,127}),
              Line(points={{-100,-60},{-40,-60},{-30,-40}}, color={0,0,127}),
              Line(points={{50,0},{100,0}}, color={0,0,127}),
              Line(points={{-30,0},{30,0}}),
              Line(points={{-15,25.99},{15,-25.99}}),
              Line(points={{-15,-25.99},{15,25.99}}),
              Ellipse(lineColor={0,0,127}, extent={{-50,-50},{50,50}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                  extent={{-100,-100},{100,100}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),Line(points={{-100,60},{-40,60},{-30,
                40}}, color={0,0,255}),Line(points={{-100,-60},{-40,-60},{-30,-40}},
                color={0,0,255}),Line(points={{50,0},{100,0}}, color={0,0,255}),
                Line(points={{-30,0},{30,0}}),Line(points={{-15,
                25.99},{15,-25.99}}),Line(points={{-15,-25.99},{15,
                25.99}}),Ellipse(extent={{-50,50},{50,-50}},
                lineColor={0,0,255})}));
      end Product;

      block Abs "Output the absolute value of the input"
        extends Interfaces.SISO;
        parameter Boolean generateEvent=false
          "Choose whether events shall be generated" annotation (Evaluate=true);
      equation
        //y = abs(u);
        y = if generateEvent then (if u >= 0 then u else -u) else (if noEvent(u >=
          0) then u else -u);
        annotation (
          defaultComponentName="abs1",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Polygon(
                points={{92,0},{70,8},{70,-8},{92,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,80},{0,0},{80,80}}),
              Line(points={{0,-14},{0,68}}, color={192,192,192}),
              Polygon(
                points={{0,90},{-8,68},{8,68},{0,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-34,-28},{38,-76}},
                lineColor={192,192,192},
                textString="abs"),
              Line(points={{-88,0},{76,0}}, color={192,192,192})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Line(points={{-100,0},{76,0}}, color={192,192,192}),
                Polygon(
                  points={{92,0},{76,6},{76,-6},{92,0}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),Line(points={{-80,80},{0,0},{80,80}}),Line(points={{0,-80},{0,68}}, color={192,192,192}),
                Polygon(
                  points={{0,90},{-8,68},{8,68},{0,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),Line(points={{0,-80},{0,68}},
                color={192,192,192}),Polygon(
                  points={{0,90},{-8,68},{8,68},{0,90}},
                  lineColor={192,192,192},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{7,98},{34,78}},
                  lineColor={160,160,164},
                  textString="u"),Text(
                  extent={{74,-8},{96,-28}},
                  lineColor={160,160,164},
                  textString="y"),Text(
                  extent={{52,-3},{72,-23}},
                  textString="1",
                  lineColor={0,0,255}),Text(
                  extent={{-86,-1},{-66,-21}},
                  textString="-1",
                  lineColor={0,0,255}),Text(
                  extent={{-28,79},{-8,59}},
                  textString="1",
                  lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
This blocks computes the output <strong>y</strong>
as <em>absolute value</em> of the input <strong>u</strong>:
</p>
<pre>
    y = <strong>abs</strong>( u );
</pre>
<p>
The Boolean parameter generateEvent decides whether Events are generated at zero crossing (Modelica specification before 3) or not.
</p>
</html>"));
      end Abs;

      block IntegerToReal "Convert Integer to Real signals"
        extends Modelica.Blocks.Icons.Block;
        Interfaces.IntegerInput u "Connector of Integer input signal" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        Interfaces.RealOutput y "Connector of Real output signal" annotation (
            Placement(transformation(extent={{100,-10},{120,10}})));
      equation
        y = u;
        annotation (Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
              Text(
                lineColor={255,127,0},
                extent={{-120.0,-40.0},{-20.0,40.0}},
                textString="I"),
              Text(
                lineColor={0,0,127},
                extent={{0.0,-40.0},{100.0,40.0}},
                textString="R"),
              Polygon(
                lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                points={{10.0,0.0},{-10.0,20.0},{-10.0,10.0},{-40.0,10.0},{-40.0,-10.0},
                    {-10.0,-10.0},{-10.0,-20.0},{10.0,0.0}})}), Documentation(info="<html>
<p>
This block computes the output <strong>y</strong>
as <em>Real equivalent</em> of the Integer input <strong>u</strong>:
</p>
<pre>    y = u;
</pre>
<p>where <strong>u</strong> is of Integer and <strong>y</strong> of Real type.</p>
</html>"));
      end IntegerToReal;

      block BooleanToReal "Convert Boolean to Real signal"
        extends Interfaces.partialBooleanSI;
        parameter Real realTrue=1.0 "Output signal for true Boolean input";
        parameter Real realFalse=0.0 "Output signal for false Boolean input";

        Blocks.Interfaces.RealOutput y "Connector of Real output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = if u then realTrue else realFalse;
        annotation (Documentation(info="<html>
<p>
This block computes the output <strong>y</strong>
as <em>Real equivalent</em> of the Boolean input <strong>u</strong>:
</p>
<pre>    y = <strong>if</strong> u <strong>then</strong> realTrue <strong>else</strong> realFalse;
</pre>
<p>where <strong>u</strong> is of Boolean and <strong>y</strong> of Real type,
and <strong>realTrue</strong> and <strong>realFalse</strong> are parameters.
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Text(
                extent={{-86,92},{-6,10}},
                lineColor={255,0,255},
                textString="B"),
              Polygon(
                points={{-12,-46},{-32,-26},{-32,-36},{-64,-36},{-64,-56},{-32,-56},
                    {-32,-66},{-12,-46}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,127}),
              Text(
                extent={{8,-4},{92,-94}},
                textString="R",
                lineColor={0,0,127})}));
      end BooleanToReal;

      block BooleanToInteger "Convert Boolean to Integer signal"
        extends Interfaces.partialBooleanSI;
        parameter Integer integerTrue=1 "Output signal for true Boolean input";
        parameter Integer integerFalse=0 "Output signal for false Boolean input";

        Blocks.Interfaces.IntegerOutput y "Connector of Integer output signal"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      equation
        y = if u then integerTrue else integerFalse;
        annotation (Documentation(info="<html>
<p>
This block computes the output <strong>y</strong>
as <em>Integer equivalent</em> of the Boolean input <strong>u</strong>:
</p>
<pre>    y = <strong>if</strong> u <strong>then</strong> integerTrue <strong>else</strong> integerFalse;
</pre>
<p>where <strong>u</strong> is of Boolean and <strong>y</strong> of Integer type,
and <strong>integerTrue</strong> and <strong>integerFalse</strong> are parameters.
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Text(
                extent={{-86,92},{-6,10}},
                lineColor={255,0,255},
                textString="B"),
              Polygon(
                points={{-12,-46},{-32,-26},{-32,-36},{-64,-36},{-64,-56},{-32,-56},
                    {-32,-66},{-12,-46}},
                lineColor={255,170,85},
                fillColor={255,170,85},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{8,-4},{92,-94}},
                lineColor={255,170,85},
                textString="I")}));
      end BooleanToInteger;

      block RealToBoolean "Convert Real to Boolean signal"

        Blocks.Interfaces.RealInput u "Connector of Real input signal" annotation (
            Placement(transformation(extent={{-140,-20},{-100,20}})));
        extends Interfaces.partialBooleanSO;
        parameter Real threshold=0.5
          "Output signal y is true, if input u >= threshold";

      equation
        y = u >= threshold;
        annotation (Documentation(info="<html>
<p>
This block computes the Boolean output <strong>y</strong>
from the Real input <strong>u</strong> by the equation:
</p>

<pre>    y = u &ge; threshold;
</pre>

<p>
where <strong>threshold</strong> is a parameter.
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Text(
                extent={{-86,92},{-6,10}},
                lineColor={0,0,127},
                textString="R"),
              Polygon(
                points={{-12,-46},{-32,-26},{-32,-36},{-64,-36},{-64,-56},{-32,-56},
                    {-32,-66},{-12,-46}},
                lineColor={255,0,255},
                fillColor={255,0,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{8,-4},{92,-94}},
                lineColor={255,0,255},
                textString="B")}));
      end RealToBoolean;

      block IntegerToBoolean "Convert Integer to Boolean signal"

        Blocks.Interfaces.IntegerInput u "Connector of Integer input signal"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        extends Interfaces.partialBooleanSO;
        parameter Integer threshold=1
          "Output signal y is true, if input u >= threshold";

      equation
        y = u >= threshold;
        annotation (Documentation(info="<html>
<p>
This block computes the Boolean output <strong>y</strong>
from the Integer input <strong>u</strong> by the equation:
</p>

<pre>    y = u &ge; threshold;
</pre>

<p>
where <strong>threshold</strong> is a parameter.
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Text(
                extent={{-86,92},{-6,10}},
                lineColor={255,128,0},
                textString="I"),
              Polygon(
                points={{-12,-46},{-32,-26},{-32,-36},{-64,-36},{-64,-56},{-32,-56},
                    {-32,-66},{-12,-46}},
                lineColor={255,0,255},
                fillColor={255,0,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{8,-4},{92,-94}},
                lineColor={255,0,255},
                textString="B")}));
      end IntegerToBoolean;

      block Max "Pass through the largest signal"
        extends Interfaces.SI2SO;
      equation
        y = max(u1, u2);
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={Text(
                extent={{-90,36},{90,-36}},
                lineColor={160,160,164},
                textString="max()")}), Documentation(info="<html>
<p>
This block computes the output <strong>y</strong> as <em>maximum</em>
of the two Real inputs <strong>u1</strong> and <strong>u2</strong>:
</p>
<pre>    y = <strong>max</strong> ( u1 , u2 );
</pre>
</html>"));
      end Max;
      annotation (Documentation(info="<html>
<p>
This package contains basic <strong>mathematical operations</strong>,
such as summation and multiplication, and basic <strong>mathematical
functions</strong>, such as <strong>sqrt</strong> and <strong>sin</strong>, as
input/output blocks. All blocks of this library can be either
connected with continuous blocks or with sampled-data blocks.
</p>
</html>",     revisions="<html>
<ul>
<li><em>August 24, 2016</em>
       by Christian Kral: added WrapAngle</li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       New blocks added: RealToInteger, IntegerToReal, Max, Min, Edge, BooleanChange, IntegerChange.</li>
<li><em>August 7, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized (partly based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist).
</li>
</ul>
</html>"),     Icon(graphics={Line(
              points={{-80,-2},{-68.7,32.2},{-61.5,51.1},{-55.1,64.4},{-49.4,72.6},
                  {-43.8,77.1},{-38.2,77.8},{-32.6,74.6},{-26.9,67.7},{-21.3,57.4},
                  {-14.9,42.1},{-6.83,19.2},{10.1,-32.8},{17.3,-52.2},{23.7,-66.2},
                  {29.3,-75.1},{35,-80.4},{40.6,-82},{46.2,-79.6},{51.9,-73.5},{
                  57.5,-63.9},{63.9,-49.2},{72,-26.8},{80,-2}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Math;

    package MathBoolean
    "Library of Boolean mathematical functions as input/output blocks"
      extends Modelica.Icons.Package;

      block And "Logical 'and': y = u[1] and u[2] and ... and u[nu]"
        extends Modelica.Blocks.Interfaces.PartialBooleanMISO;

      equation
        y = Modelica.Math.BooleanVectors.allTrue(
                                  u);
        annotation (defaultComponentName="and1", Icon(graphics={Text(
                  extent={{-76,40},{60,-40}},
                  textString="and")}),
          Documentation(info="<html>
<p>
The output is <strong>true</strong> if all inputs are <strong>true</strong>, otherwise
the output is <strong>false</strong>.
</p>

<p>
The input connector is a vector of Boolean input signals.
When a connection line is drawn, the dimension of the input
vector is enlarged by one and the connection is automatically
connected to this new free index (thanks to the
connectorSizing annotation).
</p>

<p>
The usage is demonstrated, e.g., in example
<a href=\"modelica://Modelica.Blocks.Examples.BooleanNetwork1\">Modelica.Blocks.Examples.BooleanNetwork1</a>.
</p>

<p>
If no connection to the input connector \"u\" is present,
the output is set to <strong>false</strong>: y=false.
</p>
</html>"));
      end And;

      block Or "Logical 'or': y = u[1] or u[2] or ... or u[nu]"
        extends Modelica.Blocks.Interfaces.PartialBooleanMISO;

      equation
        y = Modelica.Math.BooleanVectors.anyTrue(
                                  u);
        annotation (defaultComponentName="or1", Icon(graphics={Text(
                  extent={{-80,40},{60,-40}},
                  textString="or")}),
          Documentation(info="<html>
<p>
The output is <strong>true</strong> if at least one input is <strong>true</strong>, otherwise
the output is <strong>false</strong>.
</p>

<p>
The input connector is a vector of Boolean input signals.
When a connection line is drawn, the dimension of the input
vector is enlarged by one and the connection is automatically
connected to this new free index (thanks to the
connectorSizing annotation).
</p>

<p>
The usage is demonstrated, e.g., in example
<a href=\"modelica://Modelica.Blocks.Examples.BooleanNetwork1\">Modelica.Blocks.Examples.BooleanNetwork1</a>.
</p>

<p>
If no connection to the input connector \"u\" is present,
the output is set to <strong>false</strong>: y=false.
</p>

</html>"));
      end Or;

      block Not "Logical 'not': y = not u"
        extends Modelica.Blocks.Interfaces.PartialBooleanSISO_small;

      equation
        y = not u;
        annotation (defaultComponentName="not1", Icon(graphics={Text(
                  extent={{-98,40},{42,-40}},
                  textString="not")}),
          Documentation(info="<html>
<p>
The output is <strong>false</strong> if at least one input is <strong>true</strong>, otherwise
the output is <strong>true</strong>.
</p>

<p>
The input connector is a vector of Boolean input signals.
When a connection line is drawn, the dimension of the input
vector is enlarged by one and the connection is automatically
connected to this new free index (thanks to the
connectorSizing annotation).
</p>

<p>
The usage is demonstrated, e.g., in example
<a href=\"modelica://Modelica.Blocks.Examples.BooleanNetwork1\">Modelica.Blocks.Examples.BooleanNetwork1</a>.
</p>
</html>"));
      end Not;
      annotation (Documentation(info="<html>
<p>
This package contains basic <strong>mathematical operations</strong>
on <strong>Boolean</strong> signals.
</p>

<p>
The new features are:
</p>

<ul>
<li> If useful, blocks may have an arbitrary number of inputs (e.g., \"And\" block with 2,3,4,...
     Boolean inputs). This is based on the \"connectorSizing\" annotation which
     allows a tool to conveniently handle vectors of connectors.</li>

<li> The blocks are smaller in size, so that the diagram area is better
     utilized for trivial blocks such as \"And\" or \"Or\".</li>

</ul>

</html>"),     Icon(graphics={Line(points={{-80,-16},{-4,-16},{-4,28},{38,28},{38,
                  -16},{66,-16}}, color={255,0,255})}));
    end MathBoolean;

    package Nonlinear
    "Library of discontinuous or non-differentiable algebraic control blocks"
      import Modelica.Blocks.Interfaces;
      extends Modelica.Icons.Package;

          block Limiter "Limit the range of a signal"
            parameter Real uMax(start=1) "Upper limits of input signals";
            parameter Real uMin= -uMax "Lower limits of input signals";
            parameter Boolean strict=false "= true, if strict limits with noEvent(..)"
              annotation (Evaluate=true, choices(checkBox=true), Dialog(tab="Advanced"));
            parameter Types.LimiterHomotopy homotopyType = Modelica.Blocks.Types.LimiterHomotopy.Linear "Simplified model for homotopy-based initialization"
              annotation (Evaluate=true, Dialog(group="Initialization"));
            parameter Boolean limitsAtInit=true
              "Has no longer an effect and is only kept for backwards compatibility (the implementation uses now the homotopy operator)"
              annotation (Dialog(tab="Dummy"),Evaluate=true, choices(checkBox=true));
            extends Interfaces.SISO;
    protected
            Real simplifiedExpr "Simplified expression for homotopy-based initialization";

          equation
            assert(uMax >= uMin, "Limiter: Limits must be consistent. However, uMax (=" + String(uMax) +
                                 ") < uMin (=" + String(uMin) + ")");
            simplifiedExpr = (if homotopyType == Types.LimiterHomotopy.Linear then u
                              else if homotopyType == Types.LimiterHomotopy.UpperLimit then uMax
                              else if homotopyType == Types.LimiterHomotopy.LowerLimit then uMin
                              else 0);
            if strict then
              if homotopyType == Types.LimiterHomotopy.NoHomotopy then
                y = smooth(0, noEvent(if u > uMax then uMax else if u < uMin then uMin else u));
              else
                y = homotopy(actual = smooth(0, noEvent(if u > uMax then uMax else if u < uMin then uMin else u)),
                             simplified=simplifiedExpr);
              end if;
            else
              if homotopyType == Types.LimiterHomotopy.NoHomotopy then
                y = smooth(0,if u > uMax then uMax else if u < uMin then uMin else u);
              else
                y = homotopy(actual = smooth(0,if u > uMax then uMax else if u < uMin then uMin else u),
                             simplified=simplifiedExpr);
              end if;
            end if;
            annotation (
              Documentation(info="<html>
<p>
The Limiter block passes its input signal as output signal
as long as the input is within the specified upper and lower
limits. If this is not the case, the corresponding limits are passed
as output.
</p>
<p>
The parameter <code>homotopyType</code> in the Advanced tab specifies the
simplified behaviour if homotopy-based initialization is used:
</p>
<ul>
<li><code>NoHomotopy</code>: the actual expression with limits is used</li>
<li><code>Linear</code>: a linear behaviour y = u is assumed (default option)</li>
<li><code>UpperLimit</code>: it is assumed that the output is stuck at the upper limit u = uMax</li>
<li><code>LowerLimit</code>: it is assumed that the output is stuck at the lower limit u = uMin</li>
</ul>
<p>
If it is known a priori in which region the input signal will be located, this option can help
a lot by removing one strong nonlinearity from the initialization problem.
</p>
</html>"),     Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{0,-90},{0,68}}, color={192,192,192}),
              Polygon(
                points={{0,90},{-8,68},{8,68},{0,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{68,0}}, color={192,192,192}),
              Polygon(
                points={{90,0},{68,-8},{68,8},{90,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,-70},{-50,-70},{50,70},{80,70}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="uMax=%uMax"),
              Line(
                visible=strict,
                points={{50,70},{80,70}},
                color={255,0,0}),
              Line(
                visible=strict,
                points={{-80,-70},{-50,-70}},
                color={255,0,0})}),
              Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{0,-60},{0,50}}, color={192,192,192}),
              Polygon(
                points={{0,60},{-5,50},{5,50},{0,60}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-60,0},{50,0}}, color={192,192,192}),
              Polygon(
                points={{60,0},{50,-5},{50,5},{60,0}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-50,-40},{-30,-40},{30,40},{50,40}}),
              Text(
                extent={{46,-6},{68,-18}},
                lineColor={128,128,128},
                textString="u"),
              Text(
                extent={{-30,70},{-5,50}},
                lineColor={128,128,128},
                textString="y"),
              Text(
                extent={{-58,-54},{-28,-42}},
                lineColor={128,128,128},
                textString="uMin"),
              Text(
                extent={{26,40},{66,56}},
                lineColor={128,128,128},
                textString="uMax")}));
          end Limiter;
          annotation (
            Documentation(info="<html>
<p>
This package contains <strong>discontinuous</strong> and
<strong>non-differentiable, algebraic</strong> input/output blocks.
</p>
</html>",     revisions="<html>
<ul>
<li><em>October 21, 2002</em>
       by Christian Schweiger:<br>
       New block VariableLimiter added.</li>
<li><em>August 22, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.
</li>
</ul>
</html>"),     Icon(graphics={Line(points={{-80,-66},{-26,-66},{28,52},{88,52}},
                color={95,95,95})}));
    end Nonlinear;

    package Routing "Library of blocks to combine and extract signals"
      extends Modelica.Icons.Package;

      block Replicator "Signal replicator"
        extends Modelica.Blocks.Interfaces.SIMO;
      equation
        y = fill(u, nout);
        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-100,0},{-6,0}}, color={0,0,127}),
              Line(points={{100,0},{10,0}}, color={0,0,127}),
              Line(points={{0,0},{100,10}}, color={0,0,127}),
              Line(points={{0,0},{100,-10}}, color={0,0,127}),
              Ellipse(
                extent={{-15,15},{15,-15}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
This block replicates the input signal to an array of <code>nout</code> identical output signals.
</p>
</html>"));
      end Replicator;

      model RealPassThrough "Pass a Real signal through without modification"
        extends Modelica.Blocks.Interfaces.SISO;
      equation
        y = u;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Line(points={{-100,0},{100,0}},
                  color={0,0,127})}),
                          Documentation(info="<html>
<p>
Passes a Real signal through without modification.  Enables signals to be read out of one bus, have their name changed and be sent back to a bus.
</p>
</html>"));
      end RealPassThrough;
      annotation (Documentation(info="<html>
<p>
This package contains blocks to combine and extract signals.
</p>
</html>"),     Icon(graphics={
            Line(points={{-90,0},{4,0}}, color={95,95,95}),
            Line(points={{88,65},{48,65},{-8,0}}, color={95,95,95}),
            Line(points={{-8,0},{93,0}}, color={95,95,95}),
            Line(points={{87,-65},{48,-65},{-8,0}}, color={95,95,95})}));
    end Routing;

    package Sources
    "Library of signal source blocks generating Real, Integer and Boolean signals"
      import Modelica.Blocks.Interfaces;
      import Modelica.SIunits;
      extends Modelica.Icons.SourcesPackage;

      block RealExpression "Set output signal to a time varying Real expression"

        Modelica.Blocks.Interfaces.RealOutput y=0.0 "Value of Real output"
          annotation (Dialog(group="Time varying output signal"), Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                textString="%y"),
              Text(
                extent={{-150,90},{150,50}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
The (time varying) Real output signal of this block can be defined in its
parameter menu via variable <strong>y</strong>. The purpose is to support the
easy definition of Real expressions in a block diagram. For example,
in the y-menu the definition \"if time &lt; 1 then 0 else 1\" can be given in order
to define that the output signal is one, if time &ge; 1 and otherwise
it is zero. Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
variable <strong>y</strong> is both a variable and a connector.
</p>
</html>"));

      end RealExpression;

      block IntegerExpression
        "Set output signal to a time varying Integer expression"

        Modelica.Blocks.Interfaces.IntegerOutput y=0 "Value of Integer output"
          annotation (Dialog(group="Time varying output signal"), Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                textString="%y"),
              Text(
                extent={{-150,90},{150,50}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
The (time varying) Integer output signal of this block can be defined in its
parameter menu via variable <strong>y</strong>. The purpose is to support the
easy definition of Integer expressions in a block diagram. For example,
in the y-menu the definition \"if time &lt; 1 then 0 else 1\" can be given in order
to define that the output signal is one, if time &ge; 1 and otherwise
it is zero. Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
variable <strong>y</strong> is both a variable and a connector.
</p>
</html>"));

      end IntegerExpression;

      block BooleanExpression
        "Set output signal to a time varying Boolean expression"

        Modelica.Blocks.Interfaces.BooleanOutput y=false "Value of Boolean output"
          annotation (Dialog(group="Time varying output signal"), Placement(
              transformation(extent={{100,-10},{120,10}})));

        annotation (Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-40}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised),
              Text(
                extent={{-96,15},{96,-15}},
                textString="%y"),
              Text(
                extent={{-150,90},{150,50}},
                textString="%name",
                lineColor={0,0,255}),
              Polygon(
                points={{100,10},{120,0},{100,-10},{100,10}},
                lineColor=DynamicSelect({255,0,255}, if y > 0.5 then {0,255,0}
                     else {255,0,255}),
                fillColor=DynamicSelect({255,255,255}, if y > 0.5 then {0,255,0}
                     else {255,255,255}),
                fillPattern=FillPattern.Solid)}), Documentation(info="<html>
<p>
The (time varying) Boolean output signal of this block can be defined in its
parameter menu via variable <strong>y</strong>. The purpose is to support the
easy definition of Boolean expressions in a block diagram. For example,
in the y-menu the definition \"time &gt;= 1 and time &lt;= 2\" can be given in order
to define that the output signal is <strong>true</strong> in the time interval
1 &le; time &le; 2 and otherwise it is <strong>false</strong>.
Note, that \"time\" is a built-in variable that is always
accessible and represents the \"model time\" and that
variable <strong>y</strong> is both a variable and a connector.
</p>
</html>"));

      end BooleanExpression;

      block Constant "Generate constant signal of type Real"
        parameter Real k(start=1) "Constant output value"
        annotation(Dialog(groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png"));
        extends Interfaces.SO;

      equation
        y = k;
        annotation (
          defaultComponentName="const",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,0},{80,0}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="k=%k")}),
          Diagram(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Polygon(
                points={{-80,90},{-86,68},{-74,68},{-80,90}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-80}}, color={95,95,95}),
              Line(
                points={{-80,0},{80,0}},
                color={0,0,255},
                thickness=0.5),
              Line(points={{-90,-70},{82,-70}}, color={95,95,95}),
              Polygon(
                points={{90,-70},{68,-64},{68,-76},{90,-70}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-83,92},{-30,74}},
                textString="y"),
              Text(
                extent={{70,-80},{94,-100}},
                textString="time"),
              Text(
                extent={{-101,8},{-81,-12}},
                textString="k")}),
          Documentation(info="<html>
<p>
The Real output y is a constant signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png\"
     alt=\"Constant.png\">
</p>
</html>"));
      end Constant;

      block CombiTimeTable
        "Table look-up with respect to time and linear/periodic extrapolation methods (data from matrix/file)"
        import Modelica.Blocks.Tables.Internal;
        extends Modelica.Blocks.Interfaces.MO(final nout=max([size(columns, 1); size(offset, 1)]));
        parameter Boolean tableOnFile=false
          "= true, if table is defined on file or in function usertab"
          annotation (Dialog(group="Table data definition"));
        parameter Real table[:, :] = fill(0.0, 0, 2)
          "Table matrix (time = first column; e.g., table=[0, 0; 1, 1; 2, 4])"
          annotation (Dialog(group="Table data definition",enable=not tableOnFile));
        parameter String tableName="NoName"
          "Table name on file or in function usertab (see docu)"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter String fileName="NoName" "File where matrix is stored"
          annotation (Dialog(
            group="Table data definition",
            enable=tableOnFile,
            loadSelector(filter="Text files (*.txt);;MATLAB MAT-files (*.mat)",
                caption="Open file in which table is present")));
        parameter Boolean verboseRead=true
          "= true, if info message that file is loading is to be printed"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter Integer columns[:]=2:size(table, 2)
          "Columns of table to be interpolated"
          annotation (Dialog(group="Table data interpretation",
          groupImage="modelica://Modelica/Resources/Images/Blocks/Sources/CombiTimeTable.png"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
          "Smoothness of table interpolation"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
          "Extrapolation of data outside the definition range"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.SIunits.Time timeScale(
          min=Modelica.Constants.eps)=1 "Time scale of first table column"
          annotation (Dialog(group="Table data interpretation"), Evaluate=true);
        parameter Real offset[:]={0} "Offsets of output signals"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.SIunits.Time startTime=0
          "Output = offset for time < startTime"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.SIunits.Time shiftTime=startTime
          "Shift time of first table column"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.TimeEvents timeEvents=Modelica.Blocks.Types.TimeEvents.Always
          "Time event handling of table interpolation"
          annotation (Dialog(group="Table data interpretation", enable=smoothness == Modelica.Blocks.Types.Smoothness.LinearSegments));
        parameter Boolean verboseExtrapolation=false
          "= true, if warning messages are to be printed if time is outside the table definition range"
          annotation (Dialog(group="Table data interpretation", enable=extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint));
        final parameter Modelica.SIunits.Time t_min=t_minScaled*timeScale
          "Minimum abscissa value defined in table";
        final parameter Modelica.SIunits.Time t_max=t_maxScaled*timeScale
          "Maximum abscissa value defined in table";
        final parameter Real t_minScaled=Internal.getTimeTableTmin(tableID)
          "Minimum (scaled) abscissa value defined in table";
        final parameter Real t_maxScaled=Internal.getTimeTableTmax(tableID)
          "Maximum (scaled) abscissa value defined in table";
    protected
        final parameter Real p_offset[nout]=(if size(offset, 1) == 1 then ones(nout)*offset[1] else offset)
          "Offsets of output signals";
        parameter Modelica.Blocks.Types.ExternalCombiTimeTable tableID=
            Modelica.Blocks.Types.ExternalCombiTimeTable(
              if tableOnFile then tableName else "NoName",
              if tableOnFile and fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(fileName) then fileName else "NoName",
              table,
              startTime/timeScale,
              columns,
              smoothness,
              extrapolation,
              shiftTime/timeScale,
              if smoothness == Modelica.Blocks.Types.Smoothness.LinearSegments then timeEvents elseif smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then Modelica.Blocks.Types.TimeEvents.Always else Modelica.Blocks.Types.TimeEvents.NoTimeEvents,
              if tableOnFile then verboseRead else false) "External table object";
        discrete Modelica.SIunits.Time nextTimeEvent(start=0, fixed=true)
          "Next time event instant";
        discrete Real nextTimeEventScaled(start=0, fixed=true)
          "Next scaled time event instant";
        Real timeScaled "Scaled time";
        function readTableData =
          Modelica.Blocks.Tables.Internal.readTimeTableData "Read table data from text or MATLAB MAT-file";
                                 // No longer used, but kept for backward compatibility
      equation
        if tableOnFile then
          assert(tableName <> "NoName",
            "tableOnFile = true and no table name given");
        else
          assert(size(table, 1) > 0 and size(table, 2) > 0,
            "tableOnFile = false and parameter table is an empty matrix");
        end if;

        if verboseExtrapolation and (
          extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or
          extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint) then
          assert(noEvent(time >= t_min), "
Extrapolation warning: Time (="     + String(time) + ") must be greater or equal
than the minimum abscissa value t_min (="     + String(t_min) + ") defined in the table.
",     level=AssertionLevel.warning);
          assert(noEvent(time <= t_max), "
Extrapolation warning: Time (="     + String(time) + ") must be less or equal
than the maximum abscissa value t_max (="     + String(t_max) + ") defined in the table.
",     level=AssertionLevel.warning);
        end if;

        timeScaled = time/timeScale;
        when {time >= pre(nextTimeEvent), initial()} then
          nextTimeEventScaled = Internal.getNextTimeEvent(tableID, timeScaled);
          nextTimeEvent = if nextTimeEventScaled < Modelica.Constants.inf then nextTimeEventScaled*timeScale else Modelica.Constants.inf;
        end when;
        if smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then
          for i in 1:nout loop
            y[i] = p_offset[i] + Internal.getTimeTableValueNoDer(tableID, i, timeScaled, nextTimeEventScaled, pre(nextTimeEventScaled));
          end for;
        else
          for i in 1:nout loop
            y[i] = p_offset[i] + Internal.getTimeTableValue(tableID, i, timeScaled, nextTimeEventScaled, pre(nextTimeEventScaled));
          end for;
        end if;
        annotation (
          Documentation(info="<html>
<p>
This block generates an output signal y[:] by <strong>constant</strong>,
<strong>linear</strong> or <strong>cubic Hermite spline interpolation</strong>
in a table. The time points and function values are stored in a matrix
<strong>table[i,j]</strong>, where the first column table[:,1] contains the
time points and the other columns contain the data to be interpolated.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/CombiTimeTable.png\"
     alt=\"CombiTimeTable.png\">
</p>

<p>
Via parameter <strong>columns</strong> it can be defined which columns of the
table are interpolated. If, e.g., columns={2,4}, it is assumed that
2 output signals are present and that the first output is computed
by interpolation of column 2 and the second output is computed
by interpolation of column 4 of the table matrix.
The table interpolation has the following properties:
</p>
<ul>
<li>The interpolation interval is found by a binary search where the interval used in the
    last call is used as start interval.</li>
<li>The time points need to be <strong>strictly increasing</strong> for cubic Hermite
    spline interpolation, otherwise <strong>monotonically increasing</strong>.</li>
<li><strong>Discontinuities</strong> are allowed for (constant or) linear interpolation,
    by providing the same time point twice in the table.</li>
<li>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:
<pre>
  smoothness = 1: Linear interpolation
             = 2: Akima interpolation: Smooth interpolation by cubic Hermite
                  splines such that der(y) is continuous, also if extrapolated.
             = 3: Constant segments
             = 4: Fritsch-Butland interpolation: Smooth interpolation by cubic
                  Hermite splines such that y preserves the monotonicity and
                  der(y) is continuous, also if extrapolated.
             = 5: Steffen interpolation: Smooth interpolation by cubic Hermite
                  splines such that y preserves the monotonicity and der(y)
                  is continuous, also if extrapolated.
</pre></li>
<li>Values <strong>outside</strong> of the table range, are computed by
    extrapolation according to the setting of parameter <strong>extrapolation</strong>:
<pre>
  extrapolation = 1: Hold the first or last value of the table,
                     if outside of the table scope.
                = 2: Extrapolate by using the derivative at the first/last table
                     points if outside of the table scope.
                     (If smoothness is LinearSegments or ConstantSegments
                     this means to extrapolate linearly through the first/last
                     two table points.).
                = 3: Periodically repeat the table data (periodical function).
                = 4: No extrapolation, i.e. extrapolation triggers an error
</pre></li>
<li>If the table has only <strong>one row</strong>, no interpolation is performed and
    the table values of this row are just returned.</li>
<li>Via parameters <strong>shiftTime</strong> and <strong>offset</strong> the curve defined
    by the table can be shifted both in time and in the ordinate value.
    The time instants stored in the table are therefore <strong>relative</strong>
    to <strong>shiftTime</strong>.</li>
<li>If time &lt; startTime, no interpolation is performed and the offset
    is used as ordinate value for all outputs.</li>
<li>The table is implemented in a numerically sound way by
    generating <strong>time events</strong> at interval boundaries, in case of
    interpolation by linear segments.
    This generates continuously differentiable values for the integrator.
    Via parameter <strong>timeEvents</strong> it is defined how the time events are generated:
<pre>
  timeEvents = 1: Always generate time events at interval boundaries
             = 2: Generate time events at discontinuities (defined by duplicated sample points)
             = 3: No time events at interval boundaries
</pre>
    For interpolation by constant segments time events are always generated at interval boundaries.
    For smooth interpolation by cubic Hermite splines no time events are generated at interval boundaries.</li>
<li>Via parameter <strong>timeScale</strong> the first column of the table array can
    be scaled, e.g., if the table array is given in hours (instead of seconds)
    <strong>timeScale</strong> shall be set to 3600.</li>
<li>For special applications it is sometimes needed to know the minimum
    and maximum time instant defined in the table as a parameter. For this
    reason parameters <strong>t_min</strong>/<strong>t_minScaled</strong> and
    <strong>t_max</strong>/<strong>t_maxScaled</strong> are provided and can be
    accessed from the outside of the table object. Whereas <strong>t_min</strong> and
    <strong>t_max</strong> define the scaled abscissa values (using parameter
    <strong>timeScale</strong>) in SIunits.Time, <strong>t_minScaled</strong> and
    <strong>t_maxScaled</strong> define the unitless original abscissa values of
    the table.</li>
</ul>
<p>
Example:
</p>
<pre>
   table = [0, 0;
            1, 0;
            1, 1;
            2, 4;
            3, 9;
            4, 16];
   extrapolation = 2 (default), timeEvents = 2
If, e.g., time = 1.0, the output y =  0.0 (before event), 1.0 (after event)
    e.g., time = 1.5, the output y =  2.5,
    e.g., time = 2.0, the output y =  4.0,
    e.g., time = 5.0, the output y = 23.0 (i.e., extrapolation via last 2 points).
</pre>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li>Explicitly supplied as <strong>parameter matrix</strong> \"table\",
    and the other parameters have the following values:
<pre>
   tableName is \"NoName\" or has only blanks,
   fileName  is \"NoName\" or has only blanks.
</pre></li>
<li><strong>Read</strong> from a <strong>file</strong> \"fileName\" where the matrix is stored as
    \"tableName\". Both text and MATLAB MAT-file format is possible.
    (The text format is described below).
    The MAT-file format comes in four different versions: v4, v6, v7 and v7.3.
    The library supports at least v4, v6 and v7 whereas v7.3 is optional.
    It is most convenient to generate the MAT-file from FreeMat or MATLAB&reg;
    by command
<pre>
   save tables.mat tab1 tab2 tab3
</pre>
    or Scilab by command
<pre>
   savematfile tables.mat tab1 tab2 tab3
</pre>
    when the three tables tab1, tab2, tab3 should be used from the model.<br>
    Note, a fileName can be defined as URI by using the helper function
    <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>.</li>
<li>Statically stored in function \"usertab\" in file \"usertab.c\".
    The matrix is identified by \"tableName\". Parameter
    fileName = \"NoName\" or has only blanks. Row-wise storage is always to be
    preferred as otherwise the table is reallocated and transposed.</li>
</ol>
<p>
When the constant \"NO_FILE_SYSTEM\" is defined, all file I/O related parts of the
source code are removed by the C-preprocessor, such that no access to files takes place.
</p>
<p>
If tables are read from a text file, the file needs to have the
following structure (\"-----\" is not part of the file content):
</p>
<pre>
-----------------------------------------------------
#1
double tab1(6,2)   # comment line
  0   0
  1   0
  1   1
  2   4
  3   9
  4  16
double tab2(6,2)   # another comment line
  0   0
  2   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre>
<p>
Note, that the first two characters in the file need to be
\"#1\" (a line comment defining the version number of the file format).
Afterwards, the corresponding matrix has to be declared
with type (= \"double\" or \"float\"), name and actual dimensions.
Finally, in successive rows of the file, the elements of the matrix
have to be given. The elements have to be provided as a sequence of
numbers in row-wise order (therefore a matrix row can span several
lines in the file and need not start at the beginning of a line).
Numbers have to be given according to C syntax (such as 2.3, -2, +2.e4).
Number separators are spaces, tab (\\t), comma (,), or semicolon (;).
Several matrices may be defined one after another. Line comments start
with the hash symbol (#) and can appear everywhere.
Text files should either be ASCII or UTF-8 encoded, where UTF-8 encoded strings are only allowed in line comments and an optional UTF-8 BOM at the start of the text file is ignored.
Other characters, like trailing non comments, are not allowed in the file.
</p>
<p>
MATLAB is a registered trademark of The MathWorks, Inc.
</p>
</html>",     revisions="<html>
<p><strong>Release Notes:</strong></p>
<ul>
<li><em>April 09, 2013</em>
       by Thomas Beutlich:<br>
       Implemented as external object.</li>
<li><em>March 31, 2001</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Used CombiTableTime as a basis and added the
       arguments <strong>extrapolation, columns, startTime</strong>.
       This allows periodic function definitions.</li>
</ul>
</html>"),Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Polygon(lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid,
            points={{-80.0,90.0},{-88.0,68.0},{-72.0,68.0},{-80.0,90.0}}),
          Line(points={{-80.0,68.0},{-80.0,-80.0}},
            color={192,192,192}),
          Line(points={{-90.0,-70.0},{82.0,-70.0}},
            color={192,192,192}),
          Polygon(lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid,
            points={{90.0,-70.0},{68.0,-62.0},{68.0,-78.0},{90.0,-70.0}}),
          Rectangle(lineColor={255,255,255},
            fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-48.0,-50.0},{2.0,70.0}}),
          Line(points={{-48.0,-50.0},{-48.0,70.0},{52.0,70.0},{52.0,-50.0},{-48.0,-50.0},{-48.0,-20.0},{52.0,-20.0},{52.0,10.0},{-48.0,10.0},{-48.0,40.0},{52.0,40.0},{52.0,70.0},{2.0,70.0},{2.0,-51.0}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,68},{-80,-80}}, color={95,95,95}),
              Line(points={{-90,-70},{82,-70}}, color={95,95,95}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-20,90},{20,-30}},
                lineColor={255,255,255},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-20,-30},{-20,90},{80,90},{80,-30},{-20,-30},{-20,0},{
                    80,0},{80,30},{-20,30},{-20,60},{80,60},{80,90},{20,90},{20,-30}}),
              Text(
                extent={{-71,-42},{-32,-54}},
                textString="offset"),
              Polygon(
                points={{-31,-30},{-33,-40},{-28,-40},{-31,-30}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-31,-70},{-34,-60},{-29,-60},{-31,-70},{-31,-70}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Line(points={{-31,-31},{-31,-70}}, color={95,95,95}),
              Line(points={{-20,-30},{-20,-70}}, color={95,95,95}),
              Text(
                extent={{-42,-74},{6,-84}},
                textString="startTime"),
              Line(points={{-20,-30},{-80,-30}}, color={95,95,95}),
              Text(
                extent={{-73,93},{-44,74}},
                textString="y"),
              Text(
                extent={{66,-81},{92,-92}},
                textString="time"),
              Text(
                extent={{-19,83},{20,68}},
                textString="time"),
              Text(
                extent={{21,82},{50,68}},
                textString="y[1]"),
              Line(points={{50,90},{50,-30}}),
              Line(points={{80,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{34,-30},{71,-42}},
                textString="columns",
                lineColor={0,0,255}),
              Text(
                extent={{51,82},{80,68}},
                textString="y[2]")}));
      end CombiTimeTable;

      block IntegerConstant "Generate constant signal of type Integer"
        parameter Integer k(start=1) "Constant output value";
        extends Interfaces.IntegerSO;

      equation
        y = k;
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Line(points={{-80,68},{-80,-80}}, color={192,192,192}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,-70},{82,-70}}, color={192,192,192}),
              Polygon(
                points={{90,-70},{68,-62},{68,-78},{90,-70}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,0},{80,0}}),
              Text(
                extent={{-150,-150},{150,-110}},
                textString="k=%k")}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Polygon(
                  points={{-80,90},{-86,68},{-74,68},{-80,90}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),Line(points={{-80,68},{-80,-80}},
                color={95,95,95}),Line(
                  points={{-80,0},{80,0}},
                  color={0,0,255},
                  thickness=0.5),Line(points={{-90,-70},{82,-70}}, color={95,95,95}),
                Polygon(
                  points={{90,-70},{68,-62},{68,-78},{90,-70}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),Text(
                  extent={{-81,92},{-38,74}},
                  textString="y"),Text(
                  extent={{66,-82},{94,-94}},
                  textString="time"),Text(
                  extent={{-101,8},{-81,-12}},
                  textString="k")}),
          Documentation(info="<html>
<p>
The Integer output y is a constant signal:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Blocks/Sources/IntegerConstant.png\"
     alt=\"IntegerConstant.png\">
</p>
</html>"));
      end IntegerConstant;
      annotation (Documentation(info="<html>
<p>
This package contains <strong>source</strong> components, i.e., blocks which
have only output signals. These blocks are used as signal generators
for Real, Integer and Boolean signals.
</p>

<p>
All Real source signals (with the exception of the Constant source)
have at least the following two parameters:
</p>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>offset</strong></td>
      <td>Value which is added to the signal</td>
  </tr>
  <tr><td><strong>startTime</strong></td>
      <td>Start time of signal. For time &lt; startTime,
                the output y is set to offset.</td>
  </tr>
</table>

<p>
The <strong>offset</strong> parameter is especially useful in order to shift
the corresponding source, such that at initial time the system
is stationary. To determine the corresponding value of offset,
usually requires a trimming calculation.
</p>
</html>",     revisions="<html>
<ul>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Integer sources added. Step, TimeTable and BooleanStep slightly changed.</li>
<li><em>Nov. 8, 1999</em>
       by <a href=\"mailto:christoph@clauss-it.com\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       New sources: Exponentials, TimeTable. Trapezoid slightly enhanced
       (nperiod=-1 is an infinite number of periods).</li>
<li><em>Oct. 31, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       <a href=\"mailto:christoph@clauss-it.com\">Christoph Clau&szlig;</a>,
       <a href=\"mailto:Andre.Schneider@eas.iis.fraunhofer.de\">Andre.Schneider@eas.iis.fraunhofer.de</a>,
       All sources vectorized. New sources: ExpSine, Trapezoid,
       BooleanConstant, BooleanStep, BooleanPulse, SampleTrigger.
       Improved documentation, especially detailed description of
       signals in diagram layer.</li>
<li><em>June 29, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
    end Sources;

    package Tables
    "Library of blocks to interpolate in one and two-dimensional tables"
      extends Modelica.Icons.Package;

      block CombiTable1D
        "Table look-up in one dimension (matrix/file) with n inputs and n outputs"
        extends Modelica.Blocks.Interfaces.MIMOs(final n=size(columns, 1));
        parameter Boolean tableOnFile=false
          "= true, if table is defined on file or in function usertab"
          annotation (Dialog(group="Table data definition"));
        parameter Real table[:, :] = fill(0.0, 0, 2)
          "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])"
          annotation (Dialog(group="Table data definition",enable=not tableOnFile));
        parameter String tableName="NoName"
          "Table name on file or in function usertab (see docu)"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter String fileName="NoName" "File where matrix is stored"
          annotation (Dialog(
            group="Table data definition",
            enable=tableOnFile,
            loadSelector(filter="Text files (*.txt);;MATLAB MAT-files (*.mat)",
                caption="Open file in which table is present")));
        parameter Boolean verboseRead=true
          "= true, if info message that file is loading is to be printed"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter Integer columns[:]=2:size(table, 2)
          "Columns of table to be interpolated"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
          "Smoothness of table interpolation"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
          "Extrapolation of data outside the definition range"
          annotation (Dialog(group="Table data interpretation"));
        parameter Boolean verboseExtrapolation=false
          "= true, if warning messages are to be printed if table input is outside the definition range"
          annotation (Dialog(group="Table data interpretation", enable=extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint));
        final parameter Real u_min=Internal.getTable1DAbscissaUmin(tableID)
          "Minimum abscissa value defined in table";
        final parameter Real u_max=Internal.getTable1DAbscissaUmax(tableID)
          "Maximum abscissa value defined in table";
    protected
        parameter Modelica.Blocks.Types.ExternalCombiTable1D tableID=
            Modelica.Blocks.Types.ExternalCombiTable1D(
              if tableOnFile then tableName else "NoName",
              if tableOnFile and fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(fileName) then fileName else "NoName",
              table,
              columns,
              smoothness,
              extrapolation,
              if tableOnFile then verboseRead else false) "External table object";
        function readTableData =
          Modelica.Blocks.Tables.Internal.readTable1DData "Read table data from text or MATLAB MAT-file";
                                 // No longer used, but kept for backward compatibility
      equation
        if tableOnFile then
          assert(tableName <> "NoName",
            "tableOnFile = true and no table name given");
        else
          assert(size(table, 1) > 0 and size(table, 2) > 0,
            "tableOnFile = false and parameter table is an empty matrix");
        end if;

        if verboseExtrapolation and (
          extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or
          extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint) then
          for i in 1:n loop
            assert(noEvent(u[i] >= u_min), "
Extrapolation warning: The value u["     + String(i) +"] (=" + String(u[i]) + ") must be greater or equal
than the minimum abscissa value u_min (="     + String(u_min) + ") defined in the table.
",     level=AssertionLevel.warning);
            assert(noEvent(u[i] <= u_max), "
Extrapolation warning: The value u["     + String(i) +"] (=" + String(u[i]) + ") must be less or equal
than the maximum abscissa value u_max (="     + String(u_max) + ") defined in the table.
",     level=AssertionLevel.warning);
          end for;
        end if;

        if smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then
          for i in 1:n loop
            y[i] = Internal.getTable1DValueNoDer(tableID, i, u[i]);
          end for;
        else
          for i in 1:n loop
            y[i] = Internal.getTable1DValue(tableID, i, u[i]);
          end for;
        end if;
        annotation (
          Documentation(info="<html>
<p>
<strong>Univariate constant</strong>, <strong>linear</strong> or <strong>cubic Hermite
spline interpolation</strong> in <strong>one</strong> dimension of a
<strong>table</strong>.
Via parameter <strong>columns</strong> it can be defined how many columns of the
table are interpolated. If, e.g., columns={2,4}, it is assumed that 2 input
and 2 output signals are present and that the first output interpolates
the first input via column 2 and the second output interpolates the
second input via column 4 of the table matrix.
</p>
<p>
The grid points and function values are stored in a matrix \"table[i,j]\",
where the first column \"table[:,1]\" contains the grid points and the
other columns contain the data to be interpolated. Example:
</p>
<pre>
   table = [0,  0;
            1,  1;
            2,  4;
            4, 16]
   If, e.g., the input u = 1.0, the output y =  1.0,
       e.g., the input u = 1.5, the output y =  2.5,
       e.g., the input u = 2.0, the output y =  4.0,
       e.g., the input u =-1.0, the output y = -1.0 (i.e., extrapolation).
</pre>
<ul>
<li>The interpolation interval is found by a binary search where the interval used in the
    last call is used as start interval.</li>
<li>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:
<pre>
  smoothness = 1: Linear interpolation
             = 2: Akima interpolation: Smooth interpolation by cubic Hermite
                  splines such that der(y) is continuous, also if extrapolated.
             = 3: Constant segments
             = 4: Fritsch-Butland interpolation: Smooth interpolation by cubic
                  Hermite splines such that y preserves the monotonicity and
                  der(y) is continuous, also if extrapolated.
             = 5: Steffen interpolation: Smooth interpolation by cubic Hermite
                  splines such that y preserves the monotonicity and der(y)
                  is continuous, also if extrapolated.
</pre></li>
<li>Values <strong>outside</strong> of the table range, are computed by
    extrapolation according to the setting of parameter <strong>extrapolation</strong>:
<pre>
  extrapolation = 1: Hold the first or last value of the table,
                     if outside of the table scope.
                = 2: Extrapolate by using the derivative at the first/last table
                     points if outside of the table scope.
                     (If smoothness is LinearSegments or ConstantSegments
                     this means to extrapolate linearly through the first/last
                     two table points.).
                = 3: Periodically repeat the table data (periodical function).
                = 4: No extrapolation, i.e. extrapolation triggers an error
</pre></li>
<li>If the table has only <strong>one row</strong>, the table value is returned,
    independent of the value of the input signal.</li>
<li>The grid values (first column) have to be strictly increasing.</li>
</ul>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li>Explicitly supplied as <strong>parameter matrix</strong> \"table\",
    and the other parameters have the following values:
<pre>
   tableName is \"NoName\" or has only blanks,
   fileName  is \"NoName\" or has only blanks.
</pre></li>
<li><strong>Read</strong> from a <strong>file</strong> \"fileName\" where the matrix is stored as
    \"tableName\". Both text and MATLAB MAT-file format is possible.
    (The text format is described below).
    The MAT-file format comes in four different versions: v4, v6, v7 and v7.3.
    The library supports at least v4, v6 and v7 whereas v7.3 is optional.
    It is most convenient to generate the MAT-file from FreeMat or MATLAB&reg;
    by command
<pre>
   save tables.mat tab1 tab2 tab3
</pre>
    or Scilab by command
<pre>
   savematfile tables.mat tab1 tab2 tab3
</pre>
    when the three tables tab1, tab2, tab3 should be used from the model.<br>
    Note, a fileName can be defined as URI by using the helper function
    <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>.</li>
<li>Statically stored in function \"usertab\" in file \"usertab.c\".
    The matrix is identified by \"tableName\". Parameter
    fileName = \"NoName\" or has only blanks. Row-wise storage is always to be
    preferred as otherwise the table is reallocated and transposed.
    See the <a href=\"modelica://Modelica.Blocks.Tables\">Tables</a> package
    documentation for more details.</li>
</ol>
<p>
When the constant \"NO_FILE_SYSTEM\" is defined, all file I/O related parts of the
source code are removed by the C-preprocessor, such that no access to files takes place.
</p>
<p>
If tables are read from a text file, the file needs to have the
following structure (\"-----\" is not part of the file content):
</p>
<pre>
-----------------------------------------------------
#1
double tab1(5,2)   # comment line
  0   0
  1   1
  2   4
  3   9
  4  16
double tab2(5,2)   # another comment line
  0   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre>
<p>
Note, that the first two characters in the file need to be
\"#1\" (a line comment defining the version number of the file format).
Afterwards, the corresponding matrix has to be declared
with type (= \"double\" or \"float\"), name and actual dimensions.
Finally, in successive rows of the file, the elements of the matrix
have to be given. The elements have to be provided as a sequence of
numbers in row-wise order (therefore a matrix row can span several
lines in the file and need not start at the beginning of a line).
Numbers have to be given according to C syntax (such as 2.3, -2, +2.e4).
Number separators are spaces, tab (\\t), comma (,), or semicolon (;).
Several matrices may be defined one after another. Line comments start
with the hash symbol (#) and can appear everywhere.
Text files should either be ASCII or UTF-8 encoded, where UTF-8 encoded strings are only allowed in line comments and an optional UTF-8 BOM at the start of the text file is ignored.
Other characters, like trailing non comments, are not allowed in the file.
</p>
<p>
MATLAB is a registered trademark of The MathWorks, Inc.
</p>
</html>"),Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Line(points={{-60.0,40.0},{-60.0,-40.0},{60.0,-40.0},{60.0,40.0},{30.0,40.0},{30.0,-40.0},{-30.0,-40.0},{-30.0,40.0},{-60.0,40.0},{-60.0,20.0},{60.0,20.0},{60.0,0.0},{-60.0,0.0},{-60.0,-20.0},{60.0,-20.0},{60.0,-40.0},{-60.0,-40.0},{-60.0,40.0},{60.0,40.0},{60.0,-40.0}}),
          Line(points={{0.0,40.0},{0.0,-40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,20.0},{-30.0,40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,0.0},{-30.0,20.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-20.0},{-30.0,0.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-40.0},{-30.0,-20.0}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-60,60},{60,-60}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(points={{-100,0},{-58,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{-100,100},{100,64}},
                textString="Univariate constant, linear or cubic Hermite spline table interpolation",
                lineColor={0,0,255}),
              Line(points={{-54,40},{-54,-40},{54,-40},{54,40},{28,40},{28,-40},{-28,
                    -40},{-28,40},{-54,40},{-54,20},{54,20},{54,0},{-54,0},{-54,-20},
                    {54,-20},{54,-40},{-54,-40},{-54,40},{54,40},{54,-40}}, color={
                    0,0,0}),
              Line(points={{0,40},{0,-40}}),
              Rectangle(
                extent={{-54,40},{-28,20}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,20},{-28,0}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,0},{-28,-20}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,-20},{-28,-40}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-50,54},{-32,42}},
                textString="u[1]/[2]",
                lineColor={0,0,255}),
              Text(
                extent={{-24,54},{0,42}},
                textString="y[1]",
                lineColor={0,0,255}),
              Text(
                extent={{-2,-40},{30,-54}},
                textString="columns",
                lineColor={0,0,255}),
              Text(
                extent={{2,54},{26,42}},
                textString="y[2]",
                lineColor={0,0,255})}));
      end CombiTable1D;

      block CombiTable1Ds
        "Table look-up in one dimension (matrix/file) with one input and n outputs"
        extends Modelica.Blocks.Interfaces.SIMO(final nout=size(columns, 1));
        parameter Boolean tableOnFile=false
          "= true, if table is defined on file or in function usertab"
          annotation (Dialog(group="Table data definition"));
        parameter Real table[:, :] = fill(0.0, 0, 2)
          "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])"
          annotation (Dialog(group="Table data definition",enable=not tableOnFile));
        parameter String tableName="NoName"
          "Table name on file or in function usertab (see docu)"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter String fileName="NoName" "File where matrix is stored"
          annotation (Dialog(
            group="Table data definition",
            enable=tableOnFile,
            loadSelector(filter="Text files (*.txt);;MATLAB MAT-files (*.mat)",
                caption="Open file in which table is present")));
        parameter Boolean verboseRead=true
          "= true, if info message that file is loading is to be printed"
          annotation (Dialog(group="Table data definition",enable=tableOnFile));
        parameter Integer columns[:]=2:size(table, 2)
          "Columns of table to be interpolated"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Smoothness smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
          "Smoothness of table interpolation"
          annotation (Dialog(group="Table data interpretation"));
        parameter Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints
          "Extrapolation of data outside the definition range"
          annotation (Dialog(group="Table data interpretation"));
        parameter Boolean verboseExtrapolation=false
          "= true, if warning messages are to be printed if table input is outside the definition range"
          annotation (Dialog(group="Table data interpretation", enable=extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint));
        final parameter Real u_min=Internal.getTable1DAbscissaUmin(tableID)
          "Minimum abscissa value defined in table";
        final parameter Real u_max=Internal.getTable1DAbscissaUmax(tableID)
          "Maximum abscissa value defined in table";
    protected
        parameter Modelica.Blocks.Types.ExternalCombiTable1D tableID=
            Modelica.Blocks.Types.ExternalCombiTable1D(
              if tableOnFile then tableName else "NoName",
              if tableOnFile and fileName <> "NoName" and not Modelica.Utilities.Strings.isEmpty(fileName) then fileName else "NoName",
              table,
              columns,
              smoothness,
              extrapolation,
              if tableOnFile then verboseRead else false) "External table object";
        function readTableData =
          Modelica.Blocks.Tables.Internal.readTable1DData "Read table data from text or MATLAB MAT-file";
                                 // No longer used, but kept for backward compatibility
      equation
        if tableOnFile then
          assert(tableName <> "NoName",
            "tableOnFile = true and no table name given");
        else
          assert(size(table, 1) > 0 and size(table, 2) > 0,
            "tableOnFile = false and parameter table is an empty matrix");
        end if;

        if verboseExtrapolation and (
          extrapolation == Modelica.Blocks.Types.Extrapolation.LastTwoPoints or
          extrapolation == Modelica.Blocks.Types.Extrapolation.HoldLastPoint) then
          assert(noEvent(u >= u_min), "
Extrapolation warning: The value u (="     + String(u) + ") must be greater or equal
than the minimum abscissa value u_min (="     + String(u_min) + ") defined in the table.
",     level=AssertionLevel.warning);
          assert(noEvent(u <= u_max), "
Extrapolation warning: The value u (="     + String(u) + ") must be less or equal
than the maximum abscissa value u_max (="     + String(u_max) + ") defined in the table.
",     level=AssertionLevel.warning);
        end if;

        if smoothness == Modelica.Blocks.Types.Smoothness.ConstantSegments then
          for i in 1:nout loop
            y[i] = Internal.getTable1DValueNoDer(tableID, i, u);
          end for;
        else
          for i in 1:nout loop
            y[i] = Internal.getTable1DValue(tableID, i, u);
          end for;
        end if;
        annotation (
          Documentation(info="<html>
<p>
<strong>Univariate constant</strong>, <strong>linear</strong> or <strong>cubic Hermite
spline interpolation</strong> in <strong>one</strong> dimension of a
<strong>table</strong>.
Via parameter <strong>columns</strong> it can be defined how many columns of the
table are interpolated. If, e.g., columns={2,4}, it is assumed that
2 output signals are present and that the first output interpolates
via column 2 and the second output interpolates via column 4 of the
table matrix.
</p>
<p>
The grid points and function values are stored in a matrix \"table[i,j]\",
where the first column \"table[:,1]\" contains the grid points and the
other columns contain the data to be interpolated. Example:
</p>
<pre>
   table = [0,  0;
            1,  1;
            2,  4;
            4, 16]
   If, e.g., the input u = 1.0, the output y =  1.0,
       e.g., the input u = 1.5, the output y =  2.5,
       e.g., the input u = 2.0, the output y =  4.0,
       e.g., the input u =-1.0, the output y = -1.0 (i.e., extrapolation).
</pre>
<ul>
<li>The interpolation interval is found by a binary search where the interval used in the
    last call is used as start interval.</li>
<li>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:
<pre>
  smoothness = 1: Linear interpolation
             = 2: Akima interpolation: Smooth interpolation by cubic Hermite
                  splines such that der(y) is continuous, also if extrapolated.
             = 3: Constant segments
             = 4: Fritsch-Butland interpolation: Smooth interpolation by cubic
                  Hermite splines such that y preserves the monotonicity and
                  der(y) is continuous, also if extrapolated.
             = 5: Steffen interpolation: Smooth interpolation by cubic Hermite
                  splines such that y preserves the monotonicity and der(y)
                  is continuous, also if extrapolated.
</pre></li>
<li>Values <strong>outside</strong> of the table range, are computed by
    extrapolation according to the setting of parameter <strong>extrapolation</strong>:
<pre>
  extrapolation = 1: Hold the first or last value of the table,
                     if outside of the table scope.
                = 2: Extrapolate by using the derivative at the first/last table
                     points if outside of the table scope.
                     (If smoothness is LinearSegments or ConstantSegments
                     this means to extrapolate linearly through the first/last
                     two table points.).
                = 3: Periodically repeat the table data (periodical function).
                = 4: No extrapolation, i.e. extrapolation triggers an error
</pre></li>
<li>If the table has only <strong>one row</strong>, the table value is returned,
    independent of the value of the input signal.</li>
<li>The grid values (first column) have to be strictly increasing.</li>
</ul>
<p>
The table matrix can be defined in the following ways:
</p>
<ol>
<li>Explicitly supplied as <strong>parameter matrix</strong> \"table\",
    and the other parameters have the following values:
<pre>
   tableName is \"NoName\" or has only blanks,
   fileName  is \"NoName\" or has only blanks.
</pre></li>
<li><strong>Read</strong> from a <strong>file</strong> \"fileName\" where the matrix is stored as
    \"tableName\". Both text and MATLAB MAT-file format is possible.
    (The text format is described below).
    The MAT-file format comes in four different versions: v4, v6, v7 and v7.3.
    The library supports at least v4, v6 and v7 whereas v7.3 is optional.
    It is most convenient to generate the MAT-file from FreeMat or MATLAB&reg;
    by command
<pre>
   save tables.mat tab1 tab2 tab3
</pre>
    or Scilab by command
<pre>
   savematfile tables.mat tab1 tab2 tab3
</pre>
    when the three tables tab1, tab2, tab3 should be used from the model.<br>
    Note, a fileName can be defined as URI by using the helper function
    <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>.</li>
<li>Statically stored in function \"usertab\" in file \"usertab.c\".
    The matrix is identified by \"tableName\". Parameter
    fileName = \"NoName\" or has only blanks. Row-wise storage is always to be
    preferred as otherwise the table is reallocated and transposed.
    See the <a href=\"modelica://Modelica.Blocks.Tables\">Tables</a> package
    documentation for more details.</li>
</ol>
<p>
When the constant \"NO_FILE_SYSTEM\" is defined, all file I/O related parts of the
source code are removed by the C-preprocessor, such that no access to files takes place.
</p>
<p>
If tables are read from a text file, the file needs to have the
following structure (\"-----\" is not part of the file content):
</p>
<pre>
-----------------------------------------------------
#1
double tab1(5,2)   # comment line
  0   0
  1   1
  2   4
  3   9
  4  16
double tab2(5,2)   # another comment line
  0   0
  2   2
  4   8
  6  18
  8  32
-----------------------------------------------------
</pre>
<p>
Note, that the first two characters in the file need to be
\"#1\" (a line comment defining the version number of the file format).
Afterwards, the corresponding matrix has to be declared
with type (= \"double\" or \"float\"), name and actual dimensions.
Finally, in successive rows of the file, the elements of the matrix
have to be given. The elements have to be provided as a sequence of
numbers in row-wise order (therefore a matrix row can span several
lines in the file and need not start at the beginning of a line).
Numbers have to be given according to C syntax (such as 2.3, -2, +2.e4).
Number separators are spaces, tab (\\t), comma (,), or semicolon (;).
Several matrices may be defined one after another. Line comments start
with the hash symbol (#) and can appear everywhere.
Text files should either be ASCII or UTF-8 encoded, where UTF-8 encoded strings are only allowed in line comments and an optional UTF-8 BOM at the start of the text file is ignored.
Other characters, like trailing non comments, are not allowed in the file.
</p>
<p>
MATLAB is a registered trademark of The MathWorks, Inc.
</p>
</html>"),Icon(
          coordinateSystem(preserveAspectRatio=true,
            extent={{-100.0,-100.0},{100.0,100.0}}),
            graphics={
          Line(points={{-60.0,40.0},{-60.0,-40.0},{60.0,-40.0},{60.0,40.0},{30.0,40.0},{30.0,-40.0},{-30.0,-40.0},{-30.0,40.0},{-60.0,40.0},{-60.0,20.0},{60.0,20.0},{60.0,0.0},{-60.0,0.0},{-60.0,-20.0},{60.0,-20.0},{60.0,-40.0},{-60.0,-40.0},{-60.0,40.0},{60.0,40.0},{60.0,-40.0}}),
          Line(points={{0.0,40.0},{0.0,-40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,20.0},{-30.0,40.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,0.0},{-30.0,20.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-20.0},{-30.0,0.0}}),
          Rectangle(fillColor={255,215,136},
            fillPattern=FillPattern.Solid,
            extent={{-60.0,-40.0},{-30.0,-20.0}})}),
          Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={
              Rectangle(
                extent={{-60,60},{60,-60}},
                fillColor={235,235,235},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}),
              Line(points={{-100,0},{-58,0}}, color={0,0,255}),
              Line(points={{60,0},{100,0}}, color={0,0,255}),
              Text(
                extent={{-100,100},{100,64}},
                textString="Univariate constant, linear or cubic Hermite spline table interpolation",
                lineColor={0,0,255}),
              Line(points={{-54,40},{-54,-40},{54,-40},{54,40},{28,40},{28,-40},{-28,
                    -40},{-28,40},{-54,40},{-54,20},{54,20},{54,0},{-54,0},{-54,-20},
                    {54,-20},{54,-40},{-54,-40},{-54,40},{54,40},{54,-40}}, color={
                    0,0,0}),
              Line(points={{0,40},{0,-40}}),
              Rectangle(
                extent={{-54,40},{-28,20}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,20},{-28,0}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,0},{-28,-20}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-54,-20},{-28,-40}},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-52,56},{-34,44}},
                textString="u",
                lineColor={0,0,255}),
              Text(
                extent={{-22,54},{2,42}},
                textString="y[1]",
                lineColor={0,0,255}),
              Text(
                extent={{4,54},{28,42}},
                textString="y[2]",
                lineColor={0,0,255}),
              Text(
                extent={{0,-40},{32,-54}},
                textString="columns",
                lineColor={0,0,255})}));
      end CombiTable1Ds;

      package Internal
      "Internal external object definitions for table functions that should not be directly utilized by the user"
        extends Modelica.Icons.InternalPackage;

        function readTimeTableData "Read table data from text or MATLAB MAT-file"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          input Boolean forceRead = false
            "= true: Force reading of table data; = false: Only read, if not yet read.";
          output Real readSuccess "Table read success";
          input Boolean verboseRead = true
            "= true: Print info message; = false: No info message";
          external"C" readSuccess = ModelicaStandardTables_CombiTimeTable_read(tableID, forceRead, verboseRead)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation(__ModelicaAssociation_Impure=true);
        end readTimeTableData;

        function getTimeTableValue
          "Interpolate 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          input Integer icol;
          input Real timeIn;
          discrete input Real nextTimeEvent;
          discrete input Real pre_nextTimeEvent;
          output Real y;
          external"C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation (derivative(
              noDerivative=nextTimeEvent,
              noDerivative=pre_nextTimeEvent) = getDerTimeTableValue);
        end getTimeTableValue;

        function getTimeTableValueNoDer
          "Interpolate 1-dim. table where first column is time (but do not provide a derivative function)"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          input Integer icol;
          input Real timeIn;
          discrete input Real nextTimeEvent;
          discrete input Real pre_nextTimeEvent;
          output Real y;
          external"C" y = ModelicaStandardTables_CombiTimeTable_getValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTimeTableValueNoDer;

        function getDerTimeTableValue
          "Derivative of interpolated 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          input Integer icol;
          input Real timeIn;
          discrete input Real nextTimeEvent;
          discrete input Real pre_nextTimeEvent;
          input Real der_timeIn;
          output Real der_y;
          external"C" der_y = ModelicaStandardTables_CombiTimeTable_getDerValue(tableID, icol, timeIn, nextTimeEvent, pre_nextTimeEvent, der_timeIn)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getDerTimeTableValue;

        function getTimeTableTmin
          "Return minimum abscissa value of 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          output Real timeMin "Minimum abscissa value in table";
          external"C" timeMin = ModelicaStandardTables_CombiTimeTable_minimumTime(tableID)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTimeTableTmin;

        function getTimeTableTmax
          "Return maximum abscissa value of 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          output Real timeMax "Maximum abscissa value in table";
          external"C" timeMax = ModelicaStandardTables_CombiTimeTable_maximumTime(tableID)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTimeTableTmax;

        function readTable1DData "Read table data from text or MATLAB MAT-file"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Boolean forceRead = false
            "= true: Force reading of table data; = false: Only read, if not yet read.";
          input Boolean verboseRead = true
            "= true: Print info message; = false: No info message";
          output Real readSuccess "Table read success";
          external"C" readSuccess = ModelicaStandardTables_CombiTable1D_read(tableID, forceRead, verboseRead)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation(__ModelicaAssociation_Impure=true);
        end readTable1DData;

        function getNextTimeEvent
          "Return next time event value of 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTimeTable tableID;
          input Real timeIn;
          output Real nextTimeEvent "Next time event in table";
          external"C" nextTimeEvent = ModelicaStandardTables_CombiTimeTable_nextTimeEvent(tableID, timeIn)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getNextTimeEvent;

        function getTable1DValue "Interpolate 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Integer icol;
          input Real u;
          output Real y;
          external"C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
          annotation (derivative = getDerTable1DValue);
        end getTable1DValue;

        function getTable1DValueNoDer
          "Interpolate 1-dim. table defined by matrix (but do not provide a derivative function)"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Integer icol;
          input Real u;
          output Real y;
          external"C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DValueNoDer;

        function getDerTable1DValue
          "Derivative of interpolated 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          input Integer icol;
          input Real u;
          input Real der_u;
          output Real der_y;
          external"C" der_y = ModelicaStandardTables_CombiTable1D_getDerValue(tableID, icol, u, der_u)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getDerTable1DValue;

        function getTable1DAbscissaUmin
          "Return minimum abscissa value of 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          output Real uMin "Minimum abscissa value in table";
          external"C" uMin = ModelicaStandardTables_CombiTable1D_minimumAbscissa(tableID)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DAbscissaUmin;

        function getTable1DAbscissaUmax
          "Return maximum abscissa value of 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
          output Real uMax "Maximum abscissa value in table";
          external"C" uMax = ModelicaStandardTables_CombiTable1D_maximumAbscissa(tableID)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end getTable1DAbscissaUmax;
      end Internal;
      annotation (Documentation(info="<html>
<p>This package contains blocks for one- and two-dimensional interpolation in tables.</p>
<h4>Special interest topic: Statically stored tables for real-time simulation targets</h4>
<p>Especially for use on real-time platform targets (e.g., HIL-simulators) with <strong>no file system</strong>, it is possible to statically
store tables using a function &quot;usertab&quot; in a file conventionally named &quot;usertab.c&quot;. This can be more efficient than providing the tables as Modelica parameter arrays.</p>
<p>This is achieved by providing the tables in a specific structure as C-code and compiling that C-code together with the rest of the simulation model into a binary
that can be executed on the target platform. The &quot;Resources/Data/Tables/&quot; subdirectory of the MSL installation directory contains the files
<a href=\"modelica://Modelica/Resources/Data/Tables/usertab.c\">&quot;usertab.c&quot;</a> and <a href=\"modelica://Modelica/Resources/Data/Tables/usertab.h\">&quot;usertab.h&quot;</a>
that can be used as a template for own developments. While &quot;usertab.c&quot; would be typically used unmodified, the
&quot;usertab.h&quot; needs to adapted for the own needs.</p>
<p>In order to work it is necessary that the compiler pulls in the &quot;usertab.c&quot; file. Different Modelica tools might provide different mechanisms to do so.
Please consult the respective documentation/support for your Modelica tool.</p>
<p>A possible (though a bit &quot;hackish&quot;) Modelica standard conformant approach is to pull in the required files by utilizing a &quot;dummy&quot;-function that uses the Modelica external function
interface to pull in the required &quot;usertab.c&quot;. An example how this can be done is given below.</p>
<pre>
model Test25_usertab \"Test utilizing the usertab.c interface\"
  extends Modelica.Icons.Example;
public
  Modelica.Blocks.Sources.RealExpression realExpression(y=getUsertab(t_new.y))
    annotation (Placement(transformation(extent={{-40,-34},{-10,-14}})));
  Modelica.Blocks.Tables.CombiTable1D t_new(tableOnFile=true, tableName=\"TestTable_1D_a\")
    annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
  Modelica.Blocks.Sources.Clock clock
    annotation (Placement(transformation(extent={{-80,0},{-60,20}})));
protected
  encapsulated function getUsertab
    input Real dummy_u[:];
    output Real dummy_y;
    external \"C\" dummy_y=  mydummyfunc(dummy_u);
    annotation(IncludeDirectory=\"modelica://Modelica/Resources/Data/Tables\",
           Include = \"#include \"usertab.c\"
double mydummyfunc(double* dummy_in) {
   return 0;
}
\");
  end getUsertab;
equation
  connect(clock.y,t_new. u[1]) annotation (Line(
      points={{-59,10},{-42,10}}, color={0,0,127}));
  annotation (experiment(StartTime=0, StopTime=5), uses(Modelica(version=\"3.2.2\")));
end Test25_usertab;
</pre>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                {100,100}}), graphics={
            Rectangle(
              extent={{-76,-26},{80,-76}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-76,24},{80,-26}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Rectangle(
              extent={{-76,74},{80,24}},
              lineColor={95,95,95},
              fillColor={235,235,235},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-28,74},{-28,-76}},
              color={95,95,95}),
            Line(
              points={{24,74},{24,-76}},
              color={95,95,95})}));
    end Tables;

    package Types
    "Library of constants, external objects and types with choices, especially to build menus"
      extends Modelica.Icons.TypesPackage;

      type Smoothness = enumeration(
        LinearSegments   "Table points are linearly interpolated",
        ContinuousDerivative
            "Table points are interpolated (by Akima splines) such that the first derivative is continuous",
        ConstantSegments
            "Table points are not interpolated, but the value from the previous abscissa point is returned",
        MonotoneContinuousDerivative1
            "Table points are interpolated (by Fritsch-Butland splines) such that the monotonicity is preserved and the first derivative is continuous",
        MonotoneContinuousDerivative2
            "Table points are interpolated (by Steffen splines) such that the monotonicity is preserved and the first derivative is continuous")
        "Enumeration defining the smoothness of table interpolation";

        type Extrapolation = enumeration(
        HoldLastPoint
            "Hold the first/last table point outside of the table scope",
        LastTwoPoints
            "Extrapolate by using the derivative at the first/last table points outside of the table scope",
        Periodic   "Repeat the table scope periodically",
        NoExtrapolation   "Extrapolation triggers an error")
        "Enumeration defining the extrapolation of table interpolation";

        type TimeEvents = enumeration(
        Always   "Always generate time events at interval boundaries",
        AtDiscontinuities   "Generate time events at discontinuities (defined by duplicated sample points)",
        NoTimeEvents   "No time events at interval boundaries")
        "Enumeration defining the time event handling of time table interpolation";

        type Init = enumeration(
        NoInit
            "No initialization (start values are used as guess values with fixed=false)",
        SteadyState
            "Steady state initialization (derivatives of states are zero)",
        InitialState   "Initialization with initial states",
        InitialOutput
            "Initialization with initial outputs (and steady state of the states if possible)")
        "Enumeration defining initialization of a block" annotation (Evaluate=true,
        Documentation(info="<html>
  <p>The following initialization alternatives are available:</p>
  <dl>
    <dt><code><strong>NoInit</strong></code></dt>
      <dd>No initialization (start values are used as guess values with <code>fixed=false</code>)</dd>
    <dt><code><strong>SteadyState</strong></code></dt>
      <dd>Steady state initialization (derivatives of states are zero)</dd>
    <dt><code><strong>InitialState</strong></code></dt>
      <dd>Initialization with initial states</dd>
    <dt><code><strong>InitialOutput</strong></code></dt>
      <dd>Initialization with initial outputs (and steady state of the states if possible)</dd>
  </dl>
</html>"));

        type InitPID = enumeration(
        NoInit
            "No initialization (start values are used as guess values with fixed=false)",
        SteadyState
            "Steady state initialization (derivatives of states are zero)",
        InitialState   "Initialization with initial states",
        InitialOutput
            "Initialization with initial outputs (and steady state of the states if possible)",
        DoNotUse_InitialIntegratorState
            "Do not use, only for backward compatibility (initialize only integrator state)")
        "Enumeration defining initialization of PID and LimPID blocks" annotation (
          Evaluate=true, Documentation(info="<html>
<p>
This initialization type is identical to <a href=\"modelica://Modelica.Blocks.Types.Init\">Types.Init</a> and has just one
additional option <strong><code>DoNotUse_InitialIntegratorState</code></strong>. This option
is introduced in order that the default initialization for the
<code>Continuous.PID</code> and <code>Continuous.LimPID</code> blocks are backward
compatible. In Modelica 2.2, the integrators have been initialized
with their given states where as the D-part has not been initialized.
The option <strong><code>DoNotUse_InitialIntegratorState</code></strong> leads to this
initialization definition.
</p>

 <p>The following initialization alternatives are available:</p>
  <dl>
    <dt><code><strong>NoInit</strong></code></dt>
      <dd>No initialization (start values are used as guess values with <code>fixed=false</code>)</dd>
    <dt><code><strong>SteadyState</strong></code></dt>
      <dd>Steady state initialization (derivatives of states are zero)</dd>
    <dt><code><strong>InitialState</strong></code></dt>
      <dd>Initialization with initial states</dd>
    <dt><code><strong>InitialOutput</strong></code></dt>
      <dd>Initialization with initial outputs (and steady state of the states if possible)</dd>
    <dt><code><strong>DoNotUse_InitialIntegratorState</strong></code></dt>
      <dd>Do not use, only for backward compatibility (initialize only integrator state)</dd>
  </dl>
</html>"));

       type SimpleController = enumeration(
        P   "P controller",
        PI   "PI controller",
        PD   "PD controller",
        PID   "PID controller")
        "Enumeration defining P, PI, PD, or PID simple controller type" annotation (
         Evaluate=true);

      type AnalogFilter = enumeration(
        CriticalDamping   "Filter with critical damping",
        Bessel   "Bessel filter",
        Butterworth   "Butterworth filter",
        ChebyshevI   "Chebyshev I filter")
        "Enumeration defining the method of filtering" annotation (Evaluate=true);

      type FilterType = enumeration(
        LowPass   "Low pass filter",
        HighPass   "High pass filter",
        BandPass   "Band pass filter",
        BandStop   "Band stop / notch filter")
        "Enumeration of analog filter types (low, high, band pass or band stop filter)"
        annotation (Evaluate=true);

      type LimiterHomotopy = enumeration(
        NoHomotopy   "Homotopy is not used",
        Linear   "Simplified model without limits",
        UpperLimit   "Simplified model fixed at upper limit",
        LowerLimit   "Simplified model fixed at lower limit")
        "Enumeration defining use of homotopy in limiter components" annotation (Evaluate=true);

      class ExternalCombiTimeTable
        "External object of 1-dim. table where first column is time"
        extends ExternalObject;

        function constructor "Initialize 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input String tableName "Table name";
          input String fileName "File name";
          input Real table[:, :];
          input Modelica.SIunits.Time startTime;
          input Integer columns[:];
          input Modelica.Blocks.Types.Smoothness smoothness;
          input Modelica.Blocks.Types.Extrapolation extrapolation;
          input Modelica.SIunits.Time shiftTime=0.0;
          input Modelica.Blocks.Types.TimeEvents timeEvents=Modelica.Blocks.Types.TimeEvents.Always;
          input Boolean verboseRead=true "= true: Print info message; = false: No info message";
          output ExternalCombiTimeTable externalCombiTimeTable;
        external"C" externalCombiTimeTable = ModelicaStandardTables_CombiTimeTable_init2(
                fileName,
                tableName,
                table,
                size(table, 1),
                size(table, 2),
                startTime,
                columns,
                size(columns, 1),
                smoothness,
                extrapolation,
                shiftTime,
                timeEvents,
                verboseRead) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end constructor;

        function destructor "Terminate 1-dim. table where first column is time"
          extends Modelica.Icons.Function;
          input ExternalCombiTimeTable externalCombiTimeTable;
        external"C" ModelicaStandardTables_CombiTimeTable_close(
            externalCombiTimeTable) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end destructor;

      end ExternalCombiTimeTable;

      class ExternalCombiTable1D
        "External object of 1-dim. table defined by matrix"
        extends ExternalObject;

        function constructor "Initialize 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input String tableName "Table name";
          input String fileName "File name";
          input Real table[:, :];
          input Integer columns[:];
          input Modelica.Blocks.Types.Smoothness smoothness;
          input Modelica.Blocks.Types.Extrapolation extrapolation=Modelica.Blocks.Types.Extrapolation.LastTwoPoints;
          input Boolean verboseRead=true "= true: Print info message; = false: No info message";
          output ExternalCombiTable1D externalCombiTable1D;
        external"C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init2(
                fileName,
                tableName,
                table,
                size(table, 1),
                size(table, 2),
                columns,
                size(columns, 1),
                smoothness,
                extrapolation,
                verboseRead) annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end constructor;

        function destructor "Terminate 1-dim. table defined by matrix"
          extends Modelica.Icons.Function;
          input ExternalCombiTable1D externalCombiTable1D;
        external"C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D)
            annotation (Library={"ModelicaStandardTables", "ModelicaIO", "ModelicaMatIO", "zlib"});
        end destructor;

      end ExternalCombiTable1D;
      annotation (Documentation(info="<html>
<p>
In this package <strong>types</strong>, <strong>constants</strong> and <strong>external objects</strong> are defined that are used
in library Modelica.Blocks. The types have additional annotation choices
definitions that define the menus to be built up in the graphical
user interface when the type is used as parameter in a declaration.
</p>
</html>"));
    end Types;

    package Icons "Icons for Blocks"
        extends Modelica.Icons.IconsPackage;

        partial block Block "Basic graphical layout of input/output block"

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                  100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
          Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output
block (no declarations, no equations). Most blocks
of package Modelica.Blocks inherit directly or indirectly
from this block.
</p>
</html>"));

        end Block;

        partial block DiscreteBlock
        "Graphical layout of discrete block component icon"

          annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={223,211,169},
                borderPattern=BorderPattern.Raised,
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
                               Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
discrete block (no declarations, no equations), e.g.,
from Blocks.Discrete.
</p>
</html>"));
        end DiscreteBlock;

    partial block IntegerBlock "Basic graphical layout of Integer block"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={255,127,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
Integer block (no declarations, no equations).
</p>
</html>"));
    end IntegerBlock;

      partial block PartialBooleanBlock "Basic graphical layout of logical block"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={210,210,210},
                fillPattern=FillPattern.Solid,
                borderPattern=BorderPattern.Raised), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
Block that has only the basic icon for an input/output,
Boolean block (no declarations, no equations) used especially
in the Blocks.Logical library.
</p>
</html>"));
      end PartialBooleanBlock;
    end Icons;
  annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={0.0,35.1488},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Rectangle(
          origin={0.0,-34.8512},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Line(
          origin={-51.25,0.0},
          points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
        Polygon(
          origin={-40.0,35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
        Line(
          origin={51.25,0.0},
          points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
        Polygon(
          origin={40.0,-35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}), Documentation(info="<html>
<p>
This library contains input/output blocks to build up block diagrams.
</p>

<dl>
<dt><strong>Main Author:</strong></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 Wessling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a><br></dd>
</dl>
<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>June 23, 2004</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Introduced new block connectors and adapted all blocks to the new connectors.
       Included subpackages Continuous, Discrete, Logical, Nonlinear from
       package ModelicaAdditions.Blocks.
       Included subpackage ModelicaAdditions.Table in Modelica.Blocks.Sources
       and in the new package Modelica.Blocks.Tables.
       Added new blocks to Blocks.Sources and Blocks.Logical.
       </li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       New subpackage Examples, additional components.
       </li>
<li><em>June 20, 2000</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and
       Michael Tiller:<br>
       Introduced a replaceable signal type into
       Blocks.Interfaces.RealInput/RealOutput:
<pre>
   replaceable type SignalType = Real
</pre>
       in order that the type of the signal of an input/output block
       can be changed to a physical type, for example:
<pre>
   Sine sin1(outPort(redeclare type SignalType=Modelica.SIunits.Torque))
</pre>
      </li>
<li><em>Sept. 18, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Renamed to Blocks. New subpackages Math, Nonlinear.
       Additional components in subpackages Interfaces, Continuous
       and Sources.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized a first version, based on an existing Dymola library
       of Dieter Moormann and Hilding Elmqvist.</li>
</ul>
</html>"));
  end Blocks;

  package Electrical
  "Library of electrical models (analog, digital, machines, multi-phase)"
  extends Modelica.Icons.Package;

    package QuasiStationary
    "Library for quasi-stationary electrical singlephase and multiphase AC simulation"
    extends Modelica.Icons.Package;

      package SinglePhase "Single phase AC components"
        extends Modelica.Icons.Package;

        package Interfaces "Interfaces for AC singlephase models"
          extends Modelica.Icons.InterfacesPackage;

          connector Pin "Quasi-static single-phase pin"
            Modelica.SIunits.ComplexElectricPotential v "Complex potential at the quasi-static single-phase pin";
            flow Modelica.SIunits.ComplexCurrent i "Complex current flowing into the quasi-static single-phase pin";
            annotation (Documentation(info="<html>
<p>
The potential of this connector is the complex voltage and the flow variable is the complex current.
The <a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.PositivePin\">positive</a> and
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.NegativePin\">negative pin</a> are
derived from this base connector.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.PositivePin\">PositivePin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.NegativePin\">NegativePin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.Plug\">Plug</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.PositivePlug\">PositivePlug</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.NegativePlug\">NegativePlug</a>
</p>

</html>"));
          end Pin;
          annotation (Documentation(info="<html>
<p>This package contains connector specifications and partial models for more complex components.</p>
</html>"));
        end Interfaces;
        annotation (Icon(graphics={Rectangle(lineColor={0,0,255}, extent={{-50,-50},{
                    50,50}}), Rectangle(
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                extent={{-20,-20},{20,20}})}, coordinateSystem(extent={{-100,-100},{
                  100,100}}, preserveAspectRatio=true)), Documentation(info="<html>
<p>This package hosts models for quasi stationary single phase circuits.
Quasi stationary theory for single phase circuits can be found in the
<a href=\"modelica://Modelica.Electrical.QuasiStationary.UsersGuide.References\">references</a>.
</p>
<h4>See also</h4>

<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase\">MultiPhase</a>

</html>"));
      end SinglePhase;

      package MultiPhase "Multiphase AC components"
        extends Modelica.Icons.Package;

        package Interfaces "Interfaces for AC multiphase models"
          extends Modelica.Icons.InterfacesPackage;

          connector Plug "Quasi-static polyphase plug"
            parameter Integer m=3 "Number of phases";
            QuasiStationary.SinglePhase.Interfaces.Pin pin[m] "Pins of plug";
            annotation (Documentation(info="<html>

<p>
This multiphase plug contains a vector of <em>m</em> <a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.Pin\">single phase pins</a>.
The <a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.PositivePlug\">positive</a> and
<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.NegativePlug\">negative plug</a> are
derived from this base connector.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.Pin\">Pin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.PositivePin\">PositivePin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.NegativePin\">NegativePin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.PositivePlug\">PositivePlug</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.NegativePlug\">NegativePlug</a>
</p>
</html>"));
          end Plug;

          connector PositivePlug "Positive quasi-static polyphase plug"
            extends Plug;
            QuasiStationary.Types.Reference reference "Reference";
            annotation (
              Icon(graphics={Ellipse(
                    extent={{-100,100},{100,-100}},
                    lineColor={85,170,255},
                    fillColor={85,170,255},
                    fillPattern=FillPattern.Solid)}),
              Diagram(graphics={Ellipse(
                    extent={{-40,40},{40,-40}},
                    lineColor={85,170,255},
                    fillColor={85,170,255},
                    fillPattern=FillPattern.Solid), Text(
                    extent={{-100,100},{100,60}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(info="<html>

<p>
The positive plug is based on <a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.Plug\">Plug</a>.
Additionally the reference angle is specified in the connector. The time derivative of the reference angle is the actual angular velocity of each quasi stationary voltage and current. The symbol is also designed such way to look different than the <a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.NegativePlug\">negative plug</a>.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.Pin\">Pin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.PositivePin\">PositivePin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.NegativePin\">NegativePin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.Plug\">Plug</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.NegativePlug\">NegativePlug</a>
</p>
</html>"));
          end PositivePlug;

          connector NegativePlug "Negative quasi-static polyphase plug"
            extends Plug;
            QuasiStationary.Types.Reference reference;
            annotation (
              Icon(graphics={Ellipse(
                    extent={{-100,100},{100,-100}},
                    lineColor={85,170,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid)}),
              Diagram(graphics={Ellipse(
                    extent={{-40,40},{40,-40}},
                    lineColor={85,170,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid), Text(
                    extent={{-100,100},{100,60}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(info="<html>

<p>
The negative plug is based on <a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.Plug\">Plug</a>.
Additionally the reference angle is specified in the connector. The time derivative of the reference angle is the actual angular velocity of each quasi stationary voltage and current. The symbol is also designed such way to look different than the <a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.PositivePlug\">positive plug</a>.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.Pin\">Pin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.PositivePin\">PositivePin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase.Interfaces.NegativePin\">NegativePin</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.Plug\">Plug</a>,
<a href=\"modelica://Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.PositivePlug\">PositivePlug</a>,
</p>
</html>"));
          end NegativePlug;
        end Interfaces;
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                  {100,100}}), graphics={
              Ellipse(
                origin={14,56},
                lineColor={0,0,255},
                extent={{-84,-126},{56,14}}),
              Ellipse(
                origin={-0,40},
                lineColor={0,0,255},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                extent={{-40,-34},{-20,-14}}),
              Ellipse(
                origin={20,40},
                lineColor={0,0,255},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                extent={{0,-34},{20,-14}}),
              Ellipse(
                origin={10,34},
                lineColor={0,0,255},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                extent={{-20,-74},{0,-54}})}), Documentation(info="<html>
<p>This package hosts models for quasi stationary multi phase circuits.
Quasi stationary theory can be found in
[<a href=\"modelica://Modelica.Electrical.QuasiStationary.UsersGuide.References\">Vaske1973</a>]
and other
<a href=\"modelica://Modelica.Electrical.QuasiStationary.UsersGuide.References\">references</a>.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Electrical.QuasiStationary.SinglePhase\">SinglePhase</a>

</html>"));
      end MultiPhase;

      package Types "Definition of types for quasistationary AC models"
        extends Modelica.Icons.TypesPackage;

        record Reference "Reference angle"
          Modelica.SIunits.Angle gamma;
          function equalityConstraint "Equality constraint for reference angle"
            input Reference reference1;
            input Reference reference2;
            output Real residue[0];
          algorithm
            assert(abs(reference1.gamma - reference2.gamma) < 1E-6*2*Modelica.Constants.pi,
              "Reference angles should be equal!");
            annotation (Documentation(info="<html>
Equality constraint for the reference angle, according to the Modelica Specification (Overdetermined connection sets).
</html>"));
          end equalityConstraint;
          annotation (Documentation(info="<html>
Reference angle, used in the quasi static AC connectors.
</html>"));
        end Reference;
        annotation (Documentation(info="<html>
Type definitions needed for quasistationary AC models.
</html>"));
      end Types;
    annotation (
      preferredView="info",
      Documentation(info="<html>
<dl>
  <dt><strong>Main Authors:</strong></dt>
  <dd>
<p>
  Anton Haumer<br>
  <a href=\"https://www.haumer.at/\">Technical Consulting &amp; Electrical Engineering</a><br>
  D-93049 Regensburg, Germany<br>
  email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
</p>
<p>
  Dr. Christian Kral<br>
  <a href=\"https://christiankral.net/\">Electric Machines, Drives and Systems</a><br>
  A-1060 Vienna, Austria<br>
  email: <a href=\"mailto:dr.christian.kral@gmail.com\">dr.christian.kral@gmail.com</a> or <a href=\"mailto:mail@christiankral.net\">mail@christiankral.net</a>
</p>
</dd>
</dl>
<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",     revisions="<html>
<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">
    <tr>
      <th>Version</th>
      <th>Revision</th>
      <th>Date</th>
      <th>Author</th>
      <th>Comment</th>
    </tr>
    <tr>
      <td>1.0.0</td>
      <td> </td>
      <td>2010-01-30</td>
      <td>A. Haumer<br>C. Kral</td>
      <td></td>
    </tr>
</table>
</html>"),
      Icon(coordinateSystem(extent={{-100,-100},{100,100}}, preserveAspectRatio=
              true), graphics={Line(
            origin={10,20},
            points={{-90,-20},{-78.7,14.2},{-71.5,33.1},{-65.1,46.4},{-59.4,54.6},{
                -53.8,59.1},{-48.2,59.8},{-42.6,56.6},{-36.9,49.7},{-31.3,39.4},{-24.9,
                24.1},{-16.83,1.2},{0.1,-50.8},{7.3,-70.2},{13.7,-84.2},{19.3,-93.1},
                {25,-98.4},{30.6,-100},{36.2,-97.6},{41.9,-91.5},{47.5,-81.9},{53.9,
                -67.2},{62,-44.8},{70,-20}},
            smooth=Smooth.Bezier)}));
    end QuasiStationary;
  annotation (
    Documentation(info="<html>
<p>
This library contains electrical components to build up analog and digital circuits,
as well as machines to model electrical motors and generators,
especially three phase induction machines such as an asynchronous motor.
</p>

</html>"),
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Rectangle(
        origin={20.3125,82.8571},
        extent={{-45.3125,-57.8571},{4.6875,-27.8571}}),
      Line(
        origin={8.0,48.0},
        points={{32.0,-58.0},{72.0,-58.0}}),
      Line(
        origin={9.0,54.0},
        points={{31.0,-49.0},{71.0,-49.0}}),
      Line(
        origin={-2.0,55.0},
        points={{-83.0,-50.0},{-33.0,-50.0}}),
      Line(
        origin={-3.0,45.0},
        points={{-72.0,-55.0},{-42.0,-55.0}}),
      Line(
        origin={1.0,50.0},
        points={{-61.0,-45.0},{-61.0,-10.0},{-26.0,-10.0}}),
      Line(
        origin={7.0,50.0},
        points={{18.0,-10.0},{53.0,-10.0},{53.0,-45.0}}),
      Line(
        origin={6.2593,48.0},
        points={{53.7407,-58.0},{53.7407,-93.0},{-66.2593,-93.0},{-66.2593,-58.0}})}));
  end Electrical;

  package Mechanics
  "Library of 1-dim. and 3-dim. mechanical components (multi-body, rotational, translational)"
  extends Modelica.Icons.Package;

    package MultiBody "Library to model 3-dimensional mechanical systems"
      extends Modelica.Icons.Package;
    import SI = Modelica.SIunits;
    import Cv = Modelica.SIunits.Conversions;
    import C = Modelica.Constants;

      package Frames "Functions to transform rotational frame quantities"
        extends Modelica.Icons.Package;

        record Orientation
          "Orientation object defining rotation from a frame 1 into a frame 2"

          extends Modelica.Icons.Record;
          Real T[3, 3] "Transformation matrix from world frame to local frame";
          SI.AngularVelocity w[3]
            "Absolute angular velocity of local frame, resolved in local frame";

          encapsulated function equalityConstraint
            "Return the constraint residues to express that two frames have the same orientation"

            import Modelica;
            import Modelica.Mechanics.MultiBody.Frames;
            extends Modelica.Icons.Function;
            input Frames.Orientation R1
              "Orientation object to rotate frame 0 into frame 1";
            input Frames.Orientation R2
              "Orientation object to rotate frame 0 into frame 2";
            output Real residue[3]
              "The rotation angles around x-, y-, and z-axis of frame 1 to rotate frame 1 into frame 2 for a small rotation (should be zero)";
          algorithm
            residue := {
               Modelica.Math.atan2(cross(R1.T[1, :], R1.T[2, :])*R2.T[2, :],R1.T[1,:]*R2.T[1,:]),
               Modelica.Math.atan2(-cross(R1.T[1, :],R1.T[2, :])*R2.T[1, :],R1.T[2,:]*R2.T[2,:]),
               Modelica.Math.atan2(R1.T[2, :]*R2.T[1, :],R1.T[3,:]*R2.T[3,:])};
            annotation(Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
residue = Orientation.<strong>equalityConstraint</strong>(R1, R2);
</pre></blockquote>

<h4>Description</h4>
<p>
The function call <code>Orientation.<strong>equalityConstrain</strong>(R1,R2)</code> returns the Real residue vector
with 3 elements. This vector has zero elements if orientation objects R1 and R2 are identical
(= describe the same orientation). The residue vector is determined by computing the relative
orientation object between R1 and R2 and using the outer-diagonal elements of this matrix to
formulate the residue in such a way that only identical orientation objects lead to a zero residue vector.
</p>
</html>"));
          end equalityConstraint;

          annotation (Documentation(info="<html>
<p>
This object describes the <strong>rotation</strong> from a <strong>frame&nbsp;1</strong> into a <strong>frame&nbsp;2</strong>.
An instance of this type should never be directly accessed but
only with the access functions provided
in package Modelica.Mechanics.MultiBody.Frames. As a consequence, it is not necessary to know
the internal representation of this object as described in the next paragraphs.
</p>
<p>
\"Orientation\" is defined to be a record consisting of two
elements: \"Real T[3,3]\", the transformation matrix to rotate frame&nbsp;1
into frame&nbsp;2 and \"Real w[3]\", the angular velocity of frame&nbsp;2 with
respect to frame&nbsp;1, resolved in frame&nbsp;2. Element \"T\"
has the following interpretation:
</p>

<blockquote><pre>
Orientation R;
<strong>R.T</strong> = [<strong>e</strong><sub>x</sub>, <strong>e</strong><sub>y</sub>, <strong>e</strong><sub>z</sub>];
    e.g., <strong>R.T</strong> = [1,0,0; 0,1,0; 0,0,1]
</pre></blockquote>

<p>
where <strong>e</strong><sub>x</sub>,<strong>e</strong><sub>y</sub>,<strong>e</strong><sub>z</sub>
are unit vectors in the direction of the x-axis, y-axis, and z-axis
of frame&nbsp;1, resolved in frame&nbsp;2, respectively. Therefore, if <strong>v</strong><sub>1</sub>
is vector <strong>v</strong> resolved in frame&nbsp;1 and <strong>v</strong><sub>2</sub> is
vector <strong>v</strong> resolved in frame&nbsp;2, the following relationship holds:
</p>

<blockquote><pre>
<strong>v</strong><sub>2</sub> = <strong>R.T</strong> * <strong>v</strong><sub>1</sub>
</pre></blockquote>

<p>
The <strong>inverse</strong> orientation
<strong>R_inv.T</strong> = <strong>R.T</strong><sup>T</sup> describes the rotation
from frame&nbsp;2 into frame&nbsp;1.
</p>
<p>
Since the orientation is described by 9 variables, there are
6 constraints between these variables. These constraints
are defined in function <strong>Frames.orientationConstraint</strong>.
</p>
<p>
R.w is the angular velocity of frame&nbsp;2 with respect to frame&nbsp;1, resolved
in frame&nbsp;2. Formally, R.w is defined as:<br>
<strong>skew</strong>(R.w) = R.T*<strong>der</strong>(transpose(R.T))
with
</p>
<blockquote><pre>
          |   0   -w[3]  w[2] |
<strong>skew</strong>(w) = |  w[3]   0   -w[1] |
          | -w[2]  w[1]     0 |
</pre></blockquote>
</html>"));
        end Orientation;

        function nullRotation
          "Return orientation object that does not rotate a frame"
          extends Modelica.Icons.Function;
          output Orientation R
            "Orientation object such that frame 1 and frame 2 are identical";
        algorithm
          R := Orientation(T=identity(3),w= zeros(3));
          annotation(Inline=true, Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
R = Frames.<strong>nullRotation</strong>();
</pre></blockquote>

<h4>Description</h4>
<p>
The function call <code>Frames.<strong>nullRotation</strong>()</code> returns an orientation matrix&nbsp;R
describing the orientation object to rotate frame&nbsp;1 into frame&nbsp;2, if frame&nbsp;1 and frame&nbsp;2 are identical.
(= transformation matrix is identity matrix and angular velocity is zero).
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.TransformationMatrices.nullRotation\">TransformationMatrices.nullRotation</a>,
<a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.Quaternions.nullRotation\">Quaternions.nullRotation</a>.
</p>
</html>"));
        end nullRotation;
        annotation (Documentation(info="<html>
<p>
Package <strong>Frames</strong> contains type definitions and
functions to transform rotational frame quantities. The basic idea is to
hide the actual definition of an <strong>orientation</strong> in this package
by providing essentially type <strong>Orientation</strong> together with
<strong>functions</strong> operating on instances of this type.
</p>
<h4>Content</h4>
<p>In the table below an example is given for every function definition.
The used variables have the following declaration:
</p>
<pre>
   Frames.Orientation R, R1, R2, R_rel, R_inv;
   Real[3,3]   T, T_inv;
   Real[3]     v1, v2, w1, w2, n_x, n_y, n_z, e, e_x, res_ori, phi;
   Real[6]     res_equal;
   Real        L, angle;
</pre>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><strong>Orientation R;</strong></td>
      <td>New type defining an orientation object that describes<br>
          the rotation of frame 1 into frame 2.
      </td>
  </tr>
  <tr><td>res_ori = <strong>orientationConstraint</strong>(R);</td>
      <td>Return the constraints between the variables of an orientation object<br>
      (shall be zero).</td>
  </tr>
  <tr><td>w1 = <strong>angularVelocity1</strong>(R);</td>
      <td>Return angular velocity resolved in frame 1 from
          orientation object R.
     </td>
  </tr>
  <tr><td>w2 = <strong>angularVelocity2</strong>(R);</td>
      <td>Return angular velocity resolved in frame 2 from
          orientation object R.
     </td>
  </tr>
  <tr><td>v1 = <strong>resolve1</strong>(R,v2);</td>
      <td>Transform vector v2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td>v2 = <strong>resolve2</strong>(R,v1);</td>
      <td>Transform vector v1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td>v2 = <strong>resolveRelative</strong>(v1,R1,R2);</td>
      <td>Transform vector v1 from frame 1 to frame 2
          using absolute orientation objects R1 of frame 1 and R2 of frame 2.
      </td>
  </tr>
  <tr><td>D1 = <strong>resolveDyade1</strong>(R,D2);</td>
      <td>Transform second order tensor D2 from frame 2 to frame 1.
      </td>
  </tr>
  <tr><td>D2 = <strong>resolveDyade2</strong>(R,D1);</td>
      <td>Transform second order tensor D1 from frame 1 to frame 2.
     </td>
  </tr>
  <tr><td>R = <strong>nullRotation</strong>()</td>
      <td>Return orientation object R that does not rotate a frame.
     </td>
  </tr>
  <tr><td>R_inv = <strong>inverseRotation</strong>(R);</td>
      <td>Return inverse orientation object.
      </td>
  </tr>
  <tr><td>R_rel = <strong>relativeRotation</strong>(R1,R2);</td>
      <td>Return relative orientation object from two absolute
          orientation objects.
      </td>
  </tr>
  <tr><td>R2 = <strong>absoluteRotation</strong>(R1,R_rel);</td>
      <td>Return absolute orientation object from another
          absolute<br> and a relative orientation object.
      </td>
  </tr>
  <tr><td>R = <strong>planarRotation</strong>(e, angle, der_angle);</td>
      <td>Return orientation object of a planar rotation.
      </td>
  </tr>
  <tr><td>angle = <strong>planarRotationAngle</strong>(e, v1, v2);</td>
      <td>Return angle of a planar rotation, given the rotation axis<br>
        and the representations of a vector in frame 1 and frame 2.
      </td>
  </tr>
  <tr><td>R = <strong>axisRotation</strong>(axis, angle, der_angle);</td>
      <td>Return orientation object R to rotate around angle along axis of frame 1.
      </td>
  </tr>
  <tr><td>R = <strong>axesRotations</strong>(sequence, angles, der_angles);</td>
      <td>Return rotation object to rotate in sequence around 3 axes. Example:<br>
          R = axesRotations({1,2,3},{pi/2,pi/4,-pi}, zeros(3));
      </td>
  </tr>
  <tr><td>angles = <strong>axesRotationsAngles</strong>(R, sequence);</td>
      <td>Return the 3 angles to rotate in sequence around 3 axes to<br>
          construct the given orientation object.
      </td>
  </tr>
  <tr><td>phi = <strong>smallRotation</strong>(R);</td>
      <td>Return rotation angles phi valid for a small rotation R.
      </td>
  </tr>
  <tr><td>R = <strong>from_nxy</strong>(n_x, n_y);</td>
      <td>Return orientation object from n_x and n_y vectors.
      </td>
  </tr>
  <tr><td>R = <strong>from_nxz</strong>(n_x, n_z);</td>
      <td>Return orientation object from n_x and n_z vectors.
      </td>
  </tr>
  <tr><td>R = <strong>from_T</strong>(T,w);</td>
      <td>Return orientation object R from transformation matrix T and
          its angular velocity w.
      </td>
  </tr>
  <tr><td>R = <strong>from_T2</strong>(T,der(T));</td>
      <td>Return orientation object R from transformation matrix T and
          its derivative der(T).
      </td>
  </tr>
  <tr><td>R = <strong>from_T_inv</strong>(T_inv,w);</td>
      <td>Return orientation object R from inverse transformation matrix T_inv and
          its angular velocity w.
      </td>
  </tr>
  <tr><td>R = <strong>from_Q</strong>(Q,w);</td>
      <td>Return orientation object R from quaternion orientation object Q
          and its angular velocity w.
      </td>
  </tr>
  <tr><td>T = <strong>to_T</strong>(R);</td>
      <td>Return transformation matrix T from orientation object R.
      </td>
  </tr>
  <tr><td>T_inv = <strong>to_T_inv</strong>(R);</td>
      <td>Return inverse transformation matrix T_inv from orientation object R.
      </td>
  </tr>
  <tr><td>Q = <strong>to_Q</strong>(R);</td>
      <td>Return quaternion orientation object Q from orientation object R.
      </td>
  </tr>
  <tr><td>exy = <strong>to_exy</strong>(R);</td>
      <td>Return [e_x, e_y] matrix of an orientation object R,<br>
          with e_x and e_y vectors of frame 2, resolved in frame 1.
      </td>
  </tr>
  <tr><td>L = <strong>length</strong>(n_x);</td>
      <td>Return length L of a vector n_x.
      </td>
  </tr>
  <tr><td>e_x = <strong>normalize</strong>(n_x);</td>
      <td>Return normalized vector e_x of n_x such that length of e_x is one.
      </td>
  </tr>
  <tr><td>e = <strong>axis</strong>(i);</td>
      <td>Return unit vector e directed along axis i
      </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.Quaternions\">Quaternions</a></td>
      <td><strong>Package</strong> with functions to transform rotational frame quantities based
          on quaternions (also called Euler parameters).
      </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Mechanics.MultiBody.Frames.TransformationMatrices\">TransformationMatrices</a></td>
      <td><strong>Package</strong> with functions to transform rotational frame quantities based
          on transformation matrices.
      </td>
  </tr>
</table>
</html>"),       Icon(graphics={
              Line(points={{-2,-18},{80,-60}}, color={95,95,95}),
              Line(points={{-2,-18},{-2,80}}, color={95,95,95}),
              Line(points={{-78,-56},{-2,-18}}, color={95,95,95})}));
      end Frames;

      package Interfaces
      "Connectors and partial models for 3-dim. mechanical components"
        extends Modelica.Icons.InterfacesPackage;

        partial function partialSurfaceCharacteristic "Interface for a function returning surface characteristics"
          extends Modelica.Icons.Function;
           input Integer nu "Number of points in u-Dimension";
           input Integer nv "Number of points in v-Dimension";
           input Boolean multiColoredSurface=false
            "= true: Color is defined for each surface point";
           output Modelica.SIunits.Position X[nu,nv]
            "[nu,nv] positions of points in x-Direction resolved in surface frame";
           output Modelica.SIunits.Position Y[nu,nv]
            "[nu,nv] positions of points in y-Direction resolved in surface frame";
           output Modelica.SIunits.Position Z[nu,nv]
            "[nu,nv] positions of points in z-Direction resolved in surface frame";
           output Real C[if multiColoredSurface then nu else 0,
                         if multiColoredSurface then nv else 0,3]
            "[nu,nv,3] Color array, defining the color for each surface point";
          annotation (Documentation(info="<html>
<p>This partial function defines the interface of a function that returns
surface characteristics for an object visualization, see e.g.
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.SurfaceCharacteristics.torus\">Visualizers.Advanced.SurfaceCharacteristics.torus</a>.
</p>
</html>"));
        end partialSurfaceCharacteristic;
        annotation (Documentation(info="<html>
<p>
This package contains connectors and partial models (i.e., models
that are only used to build other models) of the MultiBody library.
</p>
</html>"));
      end Interfaces;

      package Types
      "Constants and types with choices, especially to build menus"
        extends Modelica.Icons.TypesPackage;

        type SpecularCoefficient = Modelica.Icons.TypeReal(min=0)
          "Reflection of ambient light (= 0: light is completely absorbed)"
             annotation (choices(
               choice=0 "0.0 \"dull\"",
               choice=0.7 "0.7 \"medium\"",
               choice=1 "1.0 \"glossy\""),
          Documentation(info="<html>
<p>
Type <strong>SpecularCoefficient</strong> defines the reflection of
ambient light on shape surfaces. If value = 0, the light
is completely absorbed. Often, 0.7 is a reasonable value.
It might be that from some viewing directions, a body is no
longer visible, if the SpecularCoefficient value is too high.
In the following image, the different values of SpecularCoefficient
are shown for a cylinder:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Visualizers/SpecularCoefficient.png\"/>
</p>
</html>"));

        type ShapeType = Modelica.Icons.TypeString
          "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring, <external shape>)"
           annotation ( choices(
            choice="box" "\"box\"",
            choice="sphere" "\"sphere\"",
            choice="cylinder" "\"cylinder\"",
            choice="pipecylinder" "\"pipecylinder\"",
            choice="cone" "\"cone\"",
            choice="pipe" "\"pipe\"",
            choice="beam" "\"beam\"",
            choice="gearwheel" "\"gearwheel\"",
            choice="spring" "\"spring\"",
            choice="modelica://PackageName/PathName.dxf"),
          Documentation(info="<html>
<p>
Type <strong>ShapeType</strong> is used to define the shape of the
visual object as parameter String. Usually, \"shapeType\" is used
as instance name. The following
values for shapeType are possible, e.g., shapeType=\"box\":
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/Shape.png\" alt=\"model Visualizers.FixedShape\">
</p>

<p>
The dark blue arrows in the figure above are directed along
variable <strong>lengthDirection</strong>. The light blue arrows are directed
along variable <strong>widthDirection</strong>. The <strong>coordinate systems</strong>
in the figure represent frame_a of the Shape component.
</p>

<p>
Additionally, external shapes can be specified as (not all options might be supported by all tools):
</p>

<ul>
<li> <strong>\"1\", \"2\", ...</strong><br>
     define external shapes specified in DXF format in files \"1.dxf\", \"2.dxf\", ...
     The DXF-files must be found either in the current directory or in the directory where
     the Shape instance is stored that references the DXF file.
     This (very limited) option should not be used for new models. Example:<br>
    shapeType=\"1\".<br></li>

<li> \"<strong>modelica:</strong>//&lt;Modelica-name&gt;/&lt;relative-path-file-name&gt;\"<br>
     characterizes the file that is stored under the location of the
     &lt;Modelica-name&gt; library path with the given relative file name.
     Example:<br> shapeType = \"modelica://Modelica/Resources/Data/Shapes/Engine/piston.dxf\".<br></li>

<li> \"<strong>file:</strong>//&lt;absolute-file-name&gt;\"<br>
     characterizes an absolute file name in the file system. Example:<br>
     shapeType=\"file://C:/users/myname/shapes/piston.dxf\".</li>
</ul>

<p>
The supported file formats are tool dependent. Most tools support
at least DXF-files (a tool might support 3-dim. Face of the DXF format only),
but may support other format as well (such as stl, obj, 3ds).
Since visualization files contain color and other data, the corresponding
information in the model is usually ignored.
</p>
</html>"));

        type ShapeExtra = Modelica.Icons.TypeReal
          "Type of the additional data that can be defined for an elementary ShapeType"
             annotation (
          Documentation(info="<html>
<p>
This type is used in shapes of visual objects to define
extra data depending on the shape type. Usually, input
variable <strong>extra</strong> is used as instance name:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><strong>shapeType</strong></th><th>Meaning of parameter <strong>extra</strong></th></tr>
<tr>
  <td>\"cylinder\"</td>
  <td>if extra&nbsp;&gt;&nbsp;0, a black line is included in the
      cylinder to show the rotation of it.</td>
</tr>
<tr>
  <td>\"cone\"</td>
  <td>extra = diameter-left-side / diameter-right-side, i.e.,<br>
      extra = 1: cylinder<br>
      extra = 0: \"real\" cone.</td>
</tr>
<tr>
  <td>\"pipe\"</td>
  <td>extra = outer-diameter / inner-diameter, i.e,<br>
      extra = 1: cylinder that is completely hollow<br>
      extra = 0: cylinder without a hole.</td>
</tr>
<tr>
  <td>\"gearwheel\"</td>
  <td>extra is the number of teeth of the (external) gear.
If extra&nbsp;&lt;&nbsp;0, an internal gear is visualized with |extra| teeth.
The axis of the gearwheel is along \"lengthDirection\", and usually:
width = height = 2*radiusOfGearWheel.</td>
</tr>
<tr>
  <td>\"spring\"</td>
  <td>extra is the number of windings of the spring.
      Additionally, \"height\" is <strong>not</strong> the \"height\" but
      2*coil-width.</td>
</tr>
<tr>
  <td>external shape</td>
  <td>extra = 0: Visualization from file is not scaled.<br>
                     extra = 1: Visualization from file is scaled with \"length\", \"width\" and \"height\"
                                of the shape</td>
</tr>
</table>
</html>"));
        annotation (Documentation(info="<html>
<p>
In this package <strong>types</strong> and <strong>constants</strong> are defined that are used in the
MultiBody library. The types have additional annotation choices
definitions that define the menus to be built up in the graphical
user interface when the type is used as parameter in a declaration.
</p>
</html>"));
      end Types;
    annotation (
      Documentation(info="<html>
<p>
Library <strong>MultiBody</strong> is a <strong>free</strong> Modelica package providing
3-dimensional mechanical components to model in a convenient way
<strong>mechanical systems</strong>, such as robots, mechanisms, vehicles.
Typical animations generated with this library are shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Mechanics/MultiBody/MultiBody.png\">
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.UsersGuide\">MultiBody.UsersGuide</a>
     discusses the most important aspects how to use this library.</li>
<li> <a href=\"modelica://Modelica.Mechanics.MultiBody.Examples\">MultiBody.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>"),     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                {100,100}}), graphics={
            Polygon(
              points={{-58,76},{6,76},{-26,50},{-58,76}},
              lineColor={95,95,95},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(
              points={{-26,50},{28,-50}}),
            Ellipse(
              extent={{-4,-14},{60,-78}},
              lineColor={135,135,135},
              fillPattern=FillPattern.Sphere,
              fillColor={255,255,255})}));
    end MultiBody;
  annotation (
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={8.6,63.3333},
          lineColor={64,64,64},
          fillColor={192,192,192},
          fillPattern=FillPattern.HorizontalCylinder,
          extent={{-4.6,-93.3333},{41.4,-53.3333}}),
        Ellipse(
          origin={9.0,46.0},
          extent={{-90.0,-60.0},{-80.0,-50.0}}),
        Line(
          origin={9.0,46.0},
          points={{-85.0,-55.0},{-60.0,-21.0}},
          thickness=0.5),
        Ellipse(
          origin={9.0,46.0},
          extent={{-65.0,-26.0},{-55.0,-16.0}}),
        Line(
          origin={9.0,46.0},
          points={{-60.0,-21.0},{9.0,-55.0}},
          thickness=0.5),
        Ellipse(
          origin={9.0,46.0},
          fillPattern=FillPattern.Solid,
          extent={{4.0,-60.0},{14.0,-50.0}}),
        Line(
          origin={9.0,46.0},
          points={{-10.0,-26.0},{72.0,-26.0},{72.0,-86.0},{-10.0,-86.0}})}),
    Documentation(info="<html>
<p>
This package contains components to model the movement
of 1-dim. rotational, 1-dim. translational, and
3-dim. <strong>mechanical systems</strong>.
</p>

<p>
Note, all <strong>dissipative</strong> components of the Modelica.Mechanics library have
an optional <strong>heatPort</strong> connector to which the
dissipated energy is transported in form of heat. This connector is enabled
via parameter \"useHeatPort\". If the heatPort connector is enabled,
it must be connected, and if it is not enabled, it must not be connected.
Independently, whether the heatPort is enabled or not,
the dissipated power is available from variable \"<strong>lossPower</strong>\" (which is
positive if heat is flowing out of the heatPort).
</p>
</html>"));
  end Mechanics;

  package Fluid
  "Library of 1-dim. thermo-fluid flow models using the Modelica.Media media description"
    extends Modelica.Icons.Package;
  import SI = Modelica.SIunits;
  import Cv = Modelica.SIunits.Conversions;

    package Vessels "Devices for storing fluid"
        extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Base classes used in the Vessels package (only of interest to build new component models)"
        extends Modelica.Icons.BasesPackage;

        connector VesselFluidPorts_b
          "Fluid connector with outlined, large icon to be used for horizontally aligned vectors of FluidPorts (vector dimensions must be added after dragging)"
          extends Interfaces.FluidPort;
          annotation (defaultComponentName="ports_b",
                      Diagram(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-50,-200},{50,200}},
                initialScale=0.2), graphics={
                Text(extent={{-75,130},{75,100}}, textString="%name"),
                Rectangle(
                  extent={{-25,100},{25,-100}}),
                Ellipse(
                  extent={{-22,100},{-10,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-20,-69},{-12,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,100},{6,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{10,100},{22,-100}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-4,-69},{4,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{12,-69},{20,69}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}),
               Icon(coordinateSystem(
                preserveAspectRatio=false,
                extent={{-50,-200},{50,200}},
                initialScale=0.2), graphics={
                Rectangle(
                  extent={{-50,200},{50,-200}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-44,200},{-20,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-12,200},{12,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{20,200},{44,-200}},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-39,-118.5},{-25,113}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-7,-118.5},{7,113}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{25,-117.5},{39,114}},
                  lineColor={0,127,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end VesselFluidPorts_b;
      end BaseClasses;
      annotation (Documentation(info="<html>

</html>"));
    end Vessels;

    package Pipes "Devices for conveying fluid"
        extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Base classes used in the Pipes package (only of interest to build new component models)"
        extends Modelica.Icons.BasesPackage;

        package WallFriction
        "Different variants for pressure drops due to pipe wall friction"
          extends Modelica.Icons.Package;

          partial package PartialWallFriction
            "Partial wall friction characteristic (base package of all wall friction characteristics)"
            extends Modelica.Icons.Package;
            import Modelica.Constants.pi;

          // Constants to be set in subpackages
            constant Boolean use_mu = true
              "= true, if mu_a/mu_b are used in function, otherwise value is not used";
            constant Boolean use_roughness = true
              "= true, if roughness is used in function, otherwise value is not used";
            constant Boolean use_dp_small = true
              "= true, if dp_small is used in function, otherwise value is not used";
            constant Boolean use_m_flow_small = true
              "= true, if m_flow_small is used in function, otherwise value is not used";
            constant Boolean dp_is_zero = false
              "= true, if no wall friction is present, i.e., dp = 0 (function massFlowRate_dp() cannot be used)";
            constant Boolean use_Re_turbulent = true
              "= true, if Re_turbulent input is used in function, otherwise value is not used";

          // pressure loss characteristic functions
            replaceable partial function massFlowRate_dp
              "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction"
              extends Modelica.Icons.Function;

              input SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.Area crossArea = pi*diameter^2/4 "Inner cross section area";
              input SI.Length roughness(min=0) = 2.5e-5
                "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
              input SI.AbsolutePressure dp_small = 1
                "Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)";
              input SI.ReynoldsNumber Re_turbulent = 4000
                "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

              output SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
            annotation (Documentation(info="<html>

</html>"));
            end massFlowRate_dp;

            replaceable partial function massFlowRate_dp_staticHead
              "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head"
              extends Modelica.Icons.Function;

              input SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input Real g_times_height_ab
                "Gravity times (Height(port_b) - Height(port_a))";
              input SI.Area crossArea = pi*diameter^2/4 "Inner cross section area";
              input SI.Length roughness(min=0) = 2.5e-5
                "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
              input SI.AbsolutePressure dp_small=1
                "Regularization of zero flow if |dp| < dp_small (dummy if use_dp_small = false)";
              input SI.ReynoldsNumber Re_turbulent = 4000
                "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

              output SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
              annotation (Documentation(info="<html>

</html>"));
            end massFlowRate_dp_staticHead;

            replaceable partial function pressureLoss_m_flow
              "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction"
              extends Modelica.Icons.Function;

              input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.Area crossArea = pi*diameter^2/4 "Inner cross section area";
              input SI.Length roughness(min=0) = 2.5e-5
                "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
              input SI.MassFlowRate m_flow_small = 0.01
                "Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)";
              input SI.ReynoldsNumber Re_turbulent = 4000
                "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

              output SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";

            annotation (Documentation(info="<html>

</html>"));
            end pressureLoss_m_flow;

            replaceable partial function pressureLoss_m_flow_staticHead
              "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction and static head"
                      extends Modelica.Icons.Function;

              input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input Real g_times_height_ab
                "Gravity times (Height(port_b) - Height(port_a))";
              input SI.Area crossArea = pi*diameter^2/4 "Inner cross section area";
              input SI.Length roughness(min=0) = 2.5e-5
                "Absolute roughness of pipe, with a default for a smooth steel pipe (dummy if use_roughness = false)";
              input SI.MassFlowRate m_flow_small = 0.01
                "Regularization of zero flow if |m_flow| < m_flow_small (dummy if use_m_flow_small = false)";
              input SI.ReynoldsNumber Re_turbulent = 4000
                "Turbulent flow if Re >= Re_turbulent (dummy if use_Re_turbulent = false)";

              output SI.Pressure dp "Pressure loss (dp = port_a.p - port_b.p)";

            annotation (Documentation(info="<html>

</html>"));
            end pressureLoss_m_flow_staticHead;
            annotation (Documentation(info="<html>

</html>"));
          end PartialWallFriction;

          package Detailed
          "Pipe wall friction for laminar and turbulent flow (detailed characteristic)"
            extends PartialWallFriction(
                      final use_mu = true,
                      final use_roughness = true,
                      final use_dp_small = true,
                      final use_m_flow_small = true,
                      final use_Re_turbulent = true);
            import ln = Modelica.Math.log "Logarithm, base e";
            import Modelica.Math.log10 "Logarithm, base 10";
            import Modelica.Math.exp "Exponential function";

            redeclare function extends massFlowRate_dp
              "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction"
              import Modelica.Math;
          protected
              Real Delta = roughness/diameter "Relative roughness";
              SI.ReynoldsNumber Re1 = min((745*Math.exp(if Delta <= 0.0065 then 1 else 0.0065/Delta))^0.97, Re_turbulent)
                "Re leaving laminar curve";
              SI.ReynoldsNumber Re2 = Re_turbulent "Re entering turbulent curve";
              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
              SI.ReynoldsNumber Re "Reynolds number";
              Real lambda2 "Modified friction coefficient (= lambda*Re^2)";

              function interpolateInRegion2
                 input Real Re_turbulent;
                 input SI.ReynoldsNumber Re1;
                 input SI.ReynoldsNumber Re2;
                 input Real Delta;
                 input Real lambda2;
                 output SI.ReynoldsNumber Re;
                // point lg(lambda2(Re1)) with derivative at lg(Re1)
            protected
                Real x1=Math.log10(64*Re1);
                Real y1=Math.log10(Re1);
                Real yd1=1;

                // Point lg(lambda2(Re2)) with derivative at lg(Re2)
                Real aux1=(0.5/Math.log(10))*5.74*0.9;
                Real aux2=Delta/3.7 + 5.74/Re2^0.9;
                Real aux3=Math.log10(aux2);
                Real L2=0.25*(Re2/aux3)^2;
                Real aux4=2.51/sqrt(L2) + 0.27*Delta;
                Real aux5=-2*sqrt(L2)*Math.log10(aux4);
                Real x2=Math.log10(L2);
                Real y2=Math.log10(aux5);
                Real yd2=0.5 + (2.51/Math.log(10))/(aux5*aux4);

                // Constants: Cubic polynomial between lg(Re1) and lg(Re2)
                Real diff_x=x2 - x1;
                Real m=(y2 - y1)/diff_x;
                Real c2=(3*m - 2*yd1 - yd2)/diff_x;
                Real c3=(yd1 + yd2 - 2*m)/(diff_x*diff_x);
                Real lambda2_1=64*Re1;
                Real dx;
              algorithm
                 dx := Math.log10(lambda2/lambda2_1);
                 Re := Re1*(lambda2/lambda2_1)^(1 + dx*(c2 + dx*c3));
                 annotation(smoothOrder=1);
              end interpolateInRegion2;

            algorithm
              // Determine upstream density, upstream viscosity, and lambda2
              rho     := if dp >= 0 then rho_a else rho_b;
              mu      := if dp >= 0 then mu_a else mu_b;
              lambda2 := abs(dp)*2*diameter^3*rho/(length*mu*mu);

              // Determine Re under the assumption of laminar flow
              Re := lambda2/64;

              // Modify Re, if turbulent flow
              if Re > Re1 then
                 Re :=-2*sqrt(lambda2)*Math.log10(2.51/sqrt(lambda2) + 0.27*Delta);
                 if Re < Re2 then
                    Re := interpolateInRegion2(Re, Re1, Re2, Delta, lambda2);
                 end if;
              end if;

              // Determine mass flow rate
              m_flow := crossArea/diameter*mu*(if dp >= 0 then Re else -Re);
                      annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
            end massFlowRate_dp;

            redeclare function extends pressureLoss_m_flow
              "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction"
              import Modelica.Math;
              import Modelica.Constants.pi;
          protected
              Real Delta = roughness/diameter "Relative roughness";
              SI.ReynoldsNumber Re1 = min(745*Math.exp(if Delta <= 0.0065 then 1 else 0.0065/Delta), Re_turbulent)
                "Re leaving laminar curve";
              SI.ReynoldsNumber Re2 = Re_turbulent "Re entering turbulent curve";
              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
              SI.ReynoldsNumber Re "Reynolds number";
              Real lambda2 "Modified friction coefficient (= lambda*Re^2)";

              function interpolateInRegion2
                 input SI.ReynoldsNumber Re;
                 input SI.ReynoldsNumber Re1;
                 input SI.ReynoldsNumber Re2;
                 input Real Delta;
                 output Real lambda2;
                // point lg(lambda2(Re1)) with derivative at lg(Re1)
            protected
                Real x1 = Math.log10(Re1);
                Real y1 = Math.log10(64*Re1);
                Real yd1=1;

                // Point lg(lambda2(Re2)) with derivative at lg(Re2)
                Real aux1=(0.5/Math.log(10))*5.74*0.9;
                Real aux2=Delta/3.7 + 5.74/Re2^0.9;
                Real aux3=Math.log10(aux2);
                Real L2=0.25*(Re2/aux3)^2;
                Real aux4=2.51/sqrt(L2) + 0.27*Delta;
                Real aux5=-2*sqrt(L2)*Math.log10(aux4);
                Real x2 =  Math.log10(Re2);
                Real y2 =  Math.log10(L2);
                Real yd2 = 2 + 4*aux1/(aux2*aux3*(Re2)^0.9);

                // Constants: Cubic polynomial between lg(Re1) and lg(Re2)
                Real diff_x=x2 - x1;
                Real m=(y2 - y1)/diff_x;
                Real c2=(3*m - 2*yd1 - yd2)/diff_x;
                Real c3=(yd1 + yd2 - 2*m)/(diff_x*diff_x);
                Real dx;
              algorithm
                 dx := Math.log10(Re/Re1);
                 lambda2 := 64*Re1*(Re/Re1)^(1 + dx*(c2 + dx*c3));
                 annotation(smoothOrder=1);
              end interpolateInRegion2;
            algorithm
              // Determine upstream density and upstream viscosity
              rho     :=if m_flow >= 0 then rho_a else rho_b;
              mu      :=if m_flow >= 0 then mu_a else mu_b;

              // Determine Re, lambda2 and pressure drop
              Re := diameter*abs(m_flow)/(crossArea*mu);
              lambda2 := if Re <= Re1 then 64*Re else
                        (if Re >= Re2 then 0.25*(Re/Math.log10(Delta/3.7 + 5.74/Re^0.9))^2 else
                         interpolateInRegion2(Re, Re1, Re2, Delta));
              dp :=length*mu*mu/(2*rho*diameter*diameter*diameter)*
                   (if m_flow >= 0 then lambda2 else -lambda2);
                      annotation (smoothOrder=1, Documentation(info="<html>

</html>"));
            end pressureLoss_m_flow;

            redeclare function extends massFlowRate_dp_staticHead
              "Return mass flow rate m_flow as function of pressure loss dp, i.e., m_flow = f(dp), due to wall friction and static head"

          protected
              Real Delta = roughness/diameter "Relative roughness";
              SI.ReynoldsNumber Re "Reynolds number";
              SI.ReynoldsNumber Re1 = min((745*exp(if Delta <= 0.0065 then 1 else 0.0065/Delta))^0.97, Re_turbulent)
                "Boundary between laminar regime and transition";
              SI.ReynoldsNumber Re2 = Re_turbulent
                "Boundary between transition and turbulent regime";
              SI.Pressure dp_a
                "Upper end of regularization domain of the m_flow(dp) relation";
              SI.Pressure dp_b
                "Lower end of regularization domain of the m_flow(dp) relation";
              SI.MassFlowRate m_flow_a
                "Value at upper end of regularization domain";
              SI.MassFlowRate m_flow_b
                "Value at lower end of regularization domain";

              SI.MassFlowRate dm_flow_ddp_fric_a
                "Derivative at upper end of regularization domain";
              SI.MassFlowRate dm_flow_ddp_fric_b
                "Derivative at lower end of regularization domain";

              SI.Pressure dp_grav_a = g_times_height_ab*rho_a
                "Static head if mass flows in design direction (a to b)";
              SI.Pressure dp_grav_b = g_times_height_ab*rho_b
                "Static head if mass flows against design direction (b to a)";

              // Properly define zero mass flow conditions
              SI.MassFlowRate m_flow_zero = 0;
              SI.Pressure dp_zero = (dp_grav_a + dp_grav_b)/2;
              Real dm_flow_ddp_fric_zero;

            algorithm
              dp_a := max(dp_grav_a, dp_grav_b)+dp_small;
              dp_b := min(dp_grav_a, dp_grav_b)-dp_small;

              if dp>=dp_a then
                // Positive flow outside regularization
                m_flow := Internal.m_flow_of_dp_fric(dp-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
              elseif dp<=dp_b then
                // Negative flow outside regularization
                m_flow := Internal.m_flow_of_dp_fric(dp-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
              else
                // Regularization parameters
                (m_flow_a, dm_flow_ddp_fric_a) := Internal.m_flow_of_dp_fric(dp_a-dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
                (m_flow_b, dm_flow_ddp_fric_b) := Internal.m_flow_of_dp_fric(dp_b-dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
                // Include a properly defined zero mass flow point
                // Obtain a suitable slope from the linear section slope c (value of m_flow is overwritten later)
                (m_flow, dm_flow_ddp_fric_zero) := Utilities.regFun3(dp_zero, dp_b, dp_a, m_flow_b, m_flow_a, dm_flow_ddp_fric_b, dm_flow_ddp_fric_a);
                // Do regularization
                if dp>dp_zero then
                  m_flow := Utilities.regFun3(dp, dp_zero, dp_a, m_flow_zero, m_flow_a, dm_flow_ddp_fric_zero, dm_flow_ddp_fric_a);
                else
                  m_flow := Utilities.regFun3(dp, dp_b, dp_zero, m_flow_b, m_flow_zero, dm_flow_ddp_fric_b, dm_flow_ddp_fric_zero);
                end if;
              end if;
              annotation (smoothOrder=1);
            end massFlowRate_dp_staticHead;

            redeclare function extends pressureLoss_m_flow_staticHead
              "Return pressure loss dp as function of mass flow rate m_flow, i.e., dp = f(m_flow), due to wall friction and static head"

          protected
              Real Delta = roughness/diameter "Relative roughness";
              SI.ReynoldsNumber Re1 = min(745*exp(if Delta <= 0.0065 then 1 else 0.0065/Delta), Re_turbulent)
                "Boundary between laminar regime and transition";
              SI.ReynoldsNumber Re2 = Re_turbulent
                "Boundary between transition and turbulent regime";

              SI.MassFlowRate m_flow_a
                "Upper end of regularization domain of the dp(m_flow) relation";
              SI.MassFlowRate m_flow_b
                "Lower end of regularization domain of the dp(m_flow) relation";

              SI.Pressure dp_a "Value at upper end of regularization domain";
              SI.Pressure dp_b "Value at lower end of regularization domain";

              SI.Pressure dp_grav_a = g_times_height_ab*rho_a
                "Static head if mass flows in design direction (a to b)";
              SI.Pressure dp_grav_b = g_times_height_ab*rho_b
                "Static head if mass flows against design direction (b to a)";

              Real ddp_dm_flow_a
                "Derivative of pressure drop with mass flow rate at m_flow_a";
              Real ddp_dm_flow_b
                "Derivative of pressure drop with mass flow rate at m_flow_b";

              // Properly define zero mass flow conditions
              SI.MassFlowRate m_flow_zero = 0;
              SI.Pressure dp_zero = (dp_grav_a + dp_grav_b)/2;
              Real ddp_dm_flow_zero;

            algorithm
              m_flow_a := if dp_grav_a<dp_grav_b then
                Internal.m_flow_of_dp_fric(dp_grav_b - dp_grav_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta)+m_flow_small else
                m_flow_small;
              m_flow_b := if dp_grav_a<dp_grav_b then
                Internal.m_flow_of_dp_fric(dp_grav_a - dp_grav_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta)-m_flow_small else
                -m_flow_small;

              if m_flow>=m_flow_a then
                // Positive flow outside regularization
                dp := Internal.dp_fric_of_m_flow(m_flow, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta) + dp_grav_a;
              elseif m_flow<=m_flow_b then
                // Negative flow outside regularization
                dp := Internal.dp_fric_of_m_flow(m_flow, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta) + dp_grav_b;
              else
                // Regularization parameters
                (dp_a, ddp_dm_flow_a) := Internal.dp_fric_of_m_flow(m_flow_a, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
                dp_a := dp_a + dp_grav_a "Adding dp_grav to dp_fric to get dp";
                (dp_b, ddp_dm_flow_b) := Internal.dp_fric_of_m_flow(m_flow_b, rho_a, rho_b, mu_a, mu_b, length, diameter, crossArea, Re1, Re2, Delta);
                dp_b := dp_b + dp_grav_b "Adding dp_grav to dp_fric to get dp";
                // Include a properly defined zero mass flow point
                // Obtain a suitable slope from the linear section slope c (value of dp is overwritten later)
                (dp, ddp_dm_flow_zero) := Utilities.regFun3(m_flow_zero, m_flow_b, m_flow_a, dp_b, dp_a, ddp_dm_flow_b, ddp_dm_flow_a);
                // Do regularization
                if m_flow>m_flow_zero then
                  dp := Utilities.regFun3(m_flow, m_flow_zero, m_flow_a, dp_zero, dp_a, ddp_dm_flow_zero, ddp_dm_flow_a);
                else
                  dp := Utilities.regFun3(m_flow, m_flow_b, m_flow_zero, dp_b, dp_zero, ddp_dm_flow_b, ddp_dm_flow_zero);
                end if;
              end if;
              annotation (smoothOrder=1);
            end pressureLoss_m_flow_staticHead;

          package Internal
            "Functions to calculate mass flow rate from friction pressure drop and vice versa"
            extends Modelica.Icons.InternalPackage;

            function m_flow_of_dp_fric
                "Calculate mass flow rate as function of pressure drop due to friction"
              extends Modelica.Icons.Function;

              input SI.Pressure dp_fric
                  "Pressure loss due to friction (dp = port_a.p - port_b.p)";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                  "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                  "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.Area crossArea "Inner cross section area";
              input SI.ReynoldsNumber Re1
                  "Boundary between laminar regime and transition";
              input SI.ReynoldsNumber Re2
                  "Boundary between transition and turbulent regime";
              input Real Delta "Relative roughness";
              output SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
              output Real dm_flow_ddp_fric
                  "Derivative of mass flow rate with dp_fric";

          protected
              function interpolateInRegion2_withDerivative
                  "Interpolation in log-log space using a cubic Hermite polynomial, where x=log10(lambda2), y=log10(Re)"
                extends Modelica.Icons.Function;

                input Real lambda2 "Known independent variable";
                input SI.ReynoldsNumber Re1
                    "Boundary between laminar regime and transition";
                input SI.ReynoldsNumber Re2
                    "Boundary between transition and turbulent regime";
                input Real Delta "Relative roughness";
                input SI.Pressure dp_fric
                    "Pressure loss due to friction (dp = port_a.p - port_b.p)";
                output SI.ReynoldsNumber Re "Unknown return variable";
                output Real dRe_ddp "Derivative of return value";
                // point lg(lambda2(Re1)) with derivative at lg(Re1)
            protected
                Real x1=log10(64*Re1);
                Real y1=log10(Re1);
                Real y1d=1;

                // Point lg(lambda2(Re2)) with derivative at lg(Re2)
                Real aux2=Delta/3.7 + 5.74/Re2^0.9;
                Real aux3=log10(aux2);
                Real L2=0.25*(Re2/aux3)^2;
                Real aux4=2.51/sqrt(L2) + 0.27*Delta;
                Real aux5=-2*sqrt(L2)*log10(aux4);
                Real x2=log10(L2);
                Real y2=log10(aux5);
                Real y2d=0.5 + (2.51/log(10))/(aux5*aux4);

                // Point of interest in transformed space
                Real x=log10(lambda2);
                Real y;
                Real dy_dx "Derivative in transformed space";
              algorithm
                // Interpolation
                (y, dy_dx) := Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);

                // Return value
                Re := 10^y;

                // Derivative of return value
                dRe_ddp := Re/abs(dp_fric)*dy_dx;
                annotation (smoothOrder=1);
              end interpolateInRegion2_withDerivative;

              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
              Real lambda2 "Modified friction coefficient (= lambda*Re^2)";
              SI.ReynoldsNumber Re "Reynolds number";
              Real dRe_ddp "dRe/ddp";
              Real aux1;
              Real aux2;

            algorithm
              // Determine upstream density and upstream viscosity
              if dp_fric >= 0 then
                rho := rho_a;
                mu  := mu_a;
              else
                rho := rho_b;
                mu  := mu_b;
              end if;

              // Positive mass flow rate
              lambda2 := abs(dp_fric)*2*diameter^3*rho/(length*mu*mu)
                  "Known as lambda2=f(dp)";

              aux1:=(2*diameter^3*rho)/(length*mu^2);

              // Determine Re and dRe/ddp under the assumption of laminar flow
              Re := lambda2/64 "Hagen-Poiseuille";
              dRe_ddp := aux1/64 "Hagen-Poiseuille";

              // Modify Re, if turbulent flow
              if Re > Re1 then
                Re :=-2*sqrt(lambda2)*log10(2.51/sqrt(lambda2) + 0.27*Delta)
                    "Colebrook-White";
                aux2 := sqrt(aux1*abs(dp_fric));
                dRe_ddp := 1/log(10)*(-2*log(2.51/aux2+0.27*Delta)*aux1/(2*aux2)+2*2.51/(2*abs(dp_fric)*(2.51/aux2+0.27*Delta)));
                if Re < Re2 then
                  (Re, dRe_ddp) := interpolateInRegion2_withDerivative(lambda2, Re1, Re2, Delta, dp_fric);
                end if;
              end if;

              // Determine mass flow rate
              m_flow := crossArea/diameter*mu*(if dp_fric >= 0 then Re else -Re);
              // Determine derivative of mass flow rate with dp_fric
              dm_flow_ddp_fric := crossArea/diameter*mu*dRe_ddp;
              annotation(smoothOrder=1);
            end m_flow_of_dp_fric;

            function dp_fric_of_m_flow
                "Calculate pressure drop due to friction as function of mass flow rate"
              extends Modelica.Icons.Function;

              input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
              input SI.Density rho_a "Density at port_a";
              input SI.Density rho_b "Density at port_b";
              input SI.DynamicViscosity mu_a
                  "Dynamic viscosity at port_a (dummy if use_mu = false)";
              input SI.DynamicViscosity mu_b
                  "Dynamic viscosity at port_b (dummy if use_mu = false)";
              input SI.Length length "Length of pipe";
              input SI.Diameter diameter "Inner (hydraulic) diameter of pipe";
              input SI.Area crossArea "Inner cross section area";
              input SI.ReynoldsNumber Re1
                  "Boundary between laminar regime and transition";
              input SI.ReynoldsNumber Re2
                  "Boundary between transition and turbulent regime";
              input Real Delta "Relative roughness";
              output SI.Pressure dp_fric
                  "Pressure loss due to friction (dp_fric = port_a.p - port_b.p - dp_grav)";
              output Real ddp_fric_dm_flow
                  "Derivative of pressure drop with mass flow rate";

          protected
              function interpolateInRegion2
                  "Interpolation in log-log space using a cubic Hermite polynomial, where x=log10(Re), y=log10(lambda2)"
                extends Modelica.Icons.Function;

                input SI.ReynoldsNumber Re "Known independent variable";
                input SI.ReynoldsNumber Re1
                    "Boundary between laminar regime and transition";
                input SI.ReynoldsNumber Re2
                    "Boundary between transition and turbulent regime";
                input Real Delta "Relative roughness";
                input SI.MassFlowRate m_flow "Mass flow rate from port_a to port_b";
                output Real lambda2 "Unknown return value";
                output Real dlambda2_dm_flow "Derivative of return value";
                // point lg(lambda2(Re1)) with derivative at lg(Re1)
            protected
                Real x1 = log10(Re1);
                Real y1 = log10(64*Re1);
                Real y1d = 1;

                // Point lg(lambda2(Re2)) with derivative at lg(Re2)
                Real aux2 = Delta/3.7 + 5.74/Re2^0.9;
                Real aux3 = log10(aux2);
                Real L2 = 0.25*(Re2/aux3)^2;
                Real x2 = log10(Re2);
                Real y2 = log10(L2);
                Real y2d = 2+(2*5.74*0.9)/(log(aux2)*Re2^0.9*aux2);

                // Point of interest in transformed space
                Real x=log10(Re);
                Real y;
                Real dy_dx "Derivative in transformed space";
              algorithm
                // Interpolation
                (y, dy_dx) := Utilities.cubicHermite_withDerivative(x, x1, x2, y1, y2, y1d, y2d);

                // Return value
                lambda2 := 10^y;

                // Derivative of return value
                dlambda2_dm_flow := lambda2/abs(m_flow)*dy_dx;
                annotation(smoothOrder=1);
              end interpolateInRegion2;

              SI.DynamicViscosity mu "Upstream viscosity";
              SI.Density rho "Upstream density";
              SI.ReynoldsNumber Re "Reynolds number";
              Real lambda2 "Modified friction coefficient (= lambda*Re^2)";
              Real dlambda2_dm_flow "dlambda2/dm_flow";
              Real aux1;
              Real aux2;

            algorithm
              // Determine upstream density and upstream viscosity
              if m_flow >= 0 then
                rho := rho_a;
                mu  := mu_a;
              else
                rho := rho_b;
                mu  := mu_b;
              end if;

              // Determine Reynolds number
              Re := abs(m_flow)*diameter/(crossArea*mu);

              aux1 := diameter/(crossArea*mu);

              // Use correlation for lambda2 depending on actual conditions
              if Re <= Re1 then
                lambda2 := 64*Re "Hagen-Poiseuille";
                dlambda2_dm_flow := 64*aux1 "Hagen-Poiseuille";
              elseif Re >= Re2 then
                lambda2 := 0.25*(Re/log10(Delta/3.7 + 5.74/Re^0.9))^2 "Swamee-Jain";
                aux2 := Delta/3.7+5.74/((aux1*abs(m_flow))^0.9);
                dlambda2_dm_flow := 0.5*aux1*Re*log(10)^2*(1/(log(aux2)^2)+(5.74*0.9)/(log(aux2)^3*Re^0.9*aux2))
                    "Swamee-Jain";
              else
                (lambda2, dlambda2_dm_flow) := interpolateInRegion2(Re, Re1, Re2, Delta, m_flow);
              end if;

              // Compute pressure drop from lambda2
              dp_fric :=length*mu*mu/(2*rho*diameter*diameter*diameter)*
                   (if m_flow >= 0 then lambda2 else -lambda2);

              // Compute derivative from dlambda2/dm_flow
              ddp_fric_dm_flow := (length*mu^2)/(2*diameter^3*rho)*dlambda2_dm_flow;
              annotation(smoothOrder=1);
            end dp_fric_of_m_flow;
          end Internal;
            annotation (Documentation(info="<html>
<p>
This component defines the complete regime of wall friction.
The details are described in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a>.
The functional relationship of the friction loss factor &lambda; is
displayed in the next figure. Function massFlowRate_dp() defines the \"red curve\"
(\"Swamee and Jain\"), where as function pressureLoss_m_flow() defines the
\"blue curve\" (\"Colebrook-White\"). The two functions are inverses from
each other and give slightly different results in the transition region
between Re = 1500 .. 4000, in order to get explicit equations without
solving a non-linear equation.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFriction1.png\"
     alt=\"PipeFriction1.png\">
</p>

<p>
Additionally to wall friction, this component properly implements static
head. With respect to the latter, two cases can be distinguished. In the case
shown next, the change of elevation with the path from a to b has the opposite
sign of the change of density.</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFrictionStaticHead_case-a.png\"
     alt=\"PipeFrictionStaticHead_case-a.png\">
</p>

<p>
In the case illustrated second, the change of elevation with the path from a to
b has the same sign of the change of density.</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFrictionStaticHead_case-b.png\"
     alt=\"PipeFrictionStaticHead_case-b.png\">
</p>

</html>"));
          end Detailed;
          annotation (Documentation(info="<html>
<p>
This package provides functions to compute
pressure losses due to <strong>wall friction</strong> in a pipe.
Every correlation is defined by a package that is derived
by inheritance from the package WallFriction.PartialWallFriction.
The details of the underlying pipe wall friction model are described in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.WallFriction\">UsersGuide</a>.
Basically, different variants of the equation
</p>

<pre>
   dp = &lambda;(Re,<font face=\"Symbol\">D</font>)*(L/D)*&rho;*v*|v|/2
</pre>

<p>
are used, where the friction loss factor &lambda; is shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/PipeFriction1.png\"
     alt=\"PipeFriction1.png\">
</p>

</html>"));
        end WallFriction;
      end BaseClasses;
      annotation (Documentation(info="<html>

</html>"));
    end Pipes;

    package Interfaces
    "Interfaces for steady state and unsteady, mixed-phase, multi-substance, incompressible and compressible flow"
      extends Modelica.Icons.InterfacesPackage;

      connector FluidPort
        "Interface for quasi one-dimensional fluid flow in a piping network (incompressible or compressible, one or more phases, one or more substances)"

        replaceable package Medium = Modelica.Media.Interfaces.PartialMedium
          "Medium model" annotation (choicesAllMatching=true);

        flow Medium.MassFlowRate m_flow
          "Mass flow rate from the connection point into the component";
        Medium.AbsolutePressure p "Thermodynamic pressure in the connection point";
        stream Medium.SpecificEnthalpy h_outflow
          "Specific thermodynamic enthalpy close to the connection point if m_flow < 0";
        stream Medium.MassFraction Xi_outflow[Medium.nXi]
          "Independent mixture mass fractions m_i/m close to the connection point if m_flow < 0";
        stream Medium.ExtraProperty C_outflow[Medium.nC]
          "Properties c_i/m close to the connection point if m_flow < 0";
      end FluidPort;

      connector FluidPort_a "Generic fluid connector at design inlet"
        extends FluidPort;
        annotation (defaultComponentName="port_a",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={Ellipse(
                extent={{-40,40},{40,-40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid), Text(extent={{-150,110},{150,50}},
                  textString="%name")}),
             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics={Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid), Ellipse(
                extent={{-100,100},{100,-100}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPort_a;

      connector FluidPort_b "Generic fluid connector at design outlet"
        extends FluidPort;
        annotation (defaultComponentName="port_b",
                    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Ellipse(
                extent={{-40,40},{40,-40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,30},{30,-30}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(extent={{-150,110},{150,50}}, textString="%name")}),
             Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,100}}), graphics={
              Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,127,255},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-100,100},{100,-100}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-80,80},{80,-80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPort_b;

      connector FluidPorts_a
        "Fluid connector with filled, large icon to be used for vectors of FluidPorts (vector dimensions must be added after dragging)"
        extends FluidPort;
        annotation (defaultComponentName="ports_a",
                    Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Text(extent={{-75,130},{75,100}}, textString="%name"),
              Rectangle(
                extent={{25,-100},{-25,100}},
                lineColor={0,127,255}),
              Ellipse(
                extent={{-25,90},{25,40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,25},{25,-25}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,-40},{25,-90}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}),
             Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{50,-200},{-50,200}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,180},{50,80}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,50},{50,-50}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,-80},{50,-180}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPorts_a;

      connector FluidPorts_b
        "Fluid connector with outlined, large icon to be used for vectors of FluidPorts (vector dimensions must be added after dragging)"
        extends FluidPort;
        annotation (defaultComponentName="ports_b",
                    Diagram(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Text(extent={{-75,130},{75,100}}, textString="%name"),
              Rectangle(
                extent={{-25,100},{25,-100}}),
              Ellipse(
                extent={{-25,90},{25,40}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,25},{25,-25}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-25,-40},{25,-90}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,-50},{15,-80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,15},{15,-15}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-15,50},{15,80}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}),
             Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-50,-200},{50,200}},
              initialScale=0.2), graphics={
              Rectangle(
                extent={{-50,200},{50,-200}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,180},{50,80}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,50},{50,-50}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-50,-80},{50,-180}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,30},{30,-30}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,100},{30,160}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{-30,-100},{30,-160}},
                lineColor={0,127,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid)}));
      end FluidPorts_b;
      annotation (Documentation(info="<html>

</html>",     revisions="<html>
<ul>
<li><em>June 9th, 2008</em>
       by Michael Sielemann: Introduced stream keyword after decision at 57th Design Meeting (Lund).</li>
<li><em>May 30, 2007</em>
       by Christoph Richter: moved everything back to its original position in Modelica.Fluid.</li>
<li><em>Apr. 20, 2007</em>
       by Christoph Richter: moved parts of the original package from Modelica.Fluid
       to the development branch of Modelica 2.2.2.</li>
<li><em>Nov. 2, 2005</em>
       by Francesco Casella: restructured after 45th Design Meeting.</li>
<li><em>Nov. 20-21, 2002</em>
       by Hilding Elmqvist, Mike Tiller, Allan Watson, John Batteh, Chuck Newman,
       Jonas Eborn: Improved at the 32nd Modelica Design Meeting.
<li><em>Nov. 11, 2002</em>
       by Hilding Elmqvist, Martin Otter: improved version.</li>
<li><em>Nov. 6, 2002</em>
       by Hilding Elmqvist: first version.</li>
<li><em>Aug. 11, 2002</em>
       by Martin Otter: Improved according to discussion with Hilding
       Elmqvist and Hubertus Tummescheit.<br>
       The PortVicinity model is manually
       expanded in the base models.<br>
       The Volume used for components is renamed
       PartialComponentVolume.<br>
       A new volume model \"Fluid.Components.PortVolume\"
       introduced that has the medium properties of the port to which it is
       connected.<br>
       Fluid.Interfaces.PartialTwoPortTransport is a component
       for elementary two port transport elements, whereas PartialTwoPort
       is a component for a container component.</li>
</ul>
</html>"));
    end Interfaces;

    package Types "Common types for fluid models"
      extends Modelica.Icons.TypesPackage;

      type Dynamics = enumeration(
        DynamicFreeInitial
            "DynamicFreeInitial -- Dynamic balance, Initial guess value",
        FixedInitial   "FixedInitial -- Dynamic balance, Initial value fixed",
        SteadyStateInitial
            "SteadyStateInitial -- Dynamic balance, Steady state initial with guess value",
        SteadyState   "SteadyState -- Steady state balance, Initial guess value")
        "Enumeration to define definition of balance equations"
      annotation (Documentation(info="<html>
<p>
Enumeration to define the formulation of balance equations
(to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><strong>Dynamics.</strong></th><th><strong>Meaning</strong></th></tr>
<tr><td>DynamicFreeInitial</td><td>Dynamic balance, Initial guess value</td></tr>

<tr><td>FixedInitial</td><td>Dynamic balance, Initial value fixed</td></tr>

<tr><td>SteadyStateInitial</td><td>Dynamic balance, Steady state initial with guess value</td></tr>

<tr><td>SteadyState</td><td>Steady state balance, Initial guess value</td></tr>
</table>

<p>
The enumeration \"Dynamics\" is used for the mass, energy and momentum balance equations
respectively. The exact meaning for the three balance equations is stated in the following
tables:
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><strong>Mass balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> <strong>if</strong> Medium.singleState <strong>then</strong><br>
         &nbsp;&nbsp;no initial condition<br>
         <strong>else</strong> p=p_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>if</strong> Medium.singleState <strong>then</strong><br>
         &nbsp;&nbsp;no initial condition<br>
         <strong>else</strong> <strong>der</strong>(p)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(m)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><strong>Energy balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> T=T_start or h=h_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>der</strong>(T)=0 or <strong>der</strong>(h)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(U)=0  </td>
    <td> no initial conditions </td></tr>
</table>

&nbsp;<br>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td colspan=\"3\"><strong>Momentum balance</strong> </td></tr>
<tr><td><strong>Dynamics.</strong></td>
    <td><strong>Balance equation</strong></td>
    <td><strong>Initial condition</strong></td></tr>

<tr><td> DynamicFreeInitial</td>
    <td> no restrictions </td>
    <td> no initial conditions </td></tr>

<tr><td> FixedInitial</td>
    <td> no restrictions </td>
    <td> m_flow = m_flow_start </td></tr>

<tr><td> SteadyStateInitial</td>
    <td> no restrictions </td>
    <td> <strong>der</strong>(m_flow)=0 </td></tr>

<tr><td> SteadyState</td>
    <td> <strong>der</strong>(m_flow)=0 </td>
    <td> no initial conditions </td></tr>
</table>

<p>
In the tables above, the equations are given for one-substance fluids. For multiple-substance
fluids and for trace substances, equivalent equations hold.
</p>

<p>
Medium.singleState is a medium property and defines whether the medium is only
described by one state (+ the mass fractions in case of a multi-substance fluid). In such
a case one initial condition less must be provided. For example, incompressible
media have Medium.singleState = <strong>true</strong>.
</p>

</html>"));

      type PortFlowDirection = enumeration(
        Entering   "Fluid flow is only entering",
        Leaving   "Fluid flow is only leaving",
        Bidirectional   "No restrictions on fluid flow (flow reversal possible)")
        "Enumeration to define whether flow reversal is allowed" annotation (
          Documentation(info="<html>

<p>
Enumeration to define the assumptions on the model for the
direction of fluid flow at a port (to be selected via choices menu):
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><th><strong>PortFlowDirection.</strong></th>
    <th><strong>Meaning</strong></th></tr>

<tr><td>Entering</td>
    <td>Fluid flow is only entering the port from the outside</td></tr>

<tr><td>Leaving</td>
    <td>Fluid flow is only leaving the port to the outside</td></tr>

<tr><td>Bidirectional</td>
    <td>No restrictions on fluid flow (flow reversal possible)</td></tr>
</table>

<p>
The default is \"PortFlowDirection.Bidirectional\". If you are completely sure that
the flow is only in one direction, then the other settings may
make the simulation of your model faster.
</p>

</html>"));
      annotation (preferredView="info",
                  Documentation(info="<html>

</html>"));
    end Types;

    package Utilities
    "Utility models to construct fluid components (should not be used directly)"
      extends Modelica.Icons.UtilitiesPackage;

      function checkBoundary "Check whether boundary definition is correct"
        extends Modelica.Icons.Function;
        input String mediumName;
        input String substanceNames[:] "Names of substances";
        input Boolean singleState;
        input Boolean define_p;
        input Real X_boundary[:];
        input String modelName = "??? boundary ???";
    protected
        Integer nX = size(X_boundary,1);
        String X_str;
      algorithm
        assert(not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""     + modelName + "\":
The selected medium \""     + mediumName + "\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");

        for i in 1:nX loop
          assert(X_boundary[i] >= 0.0, "
Wrong boundary mass fractions in medium \""
      + mediumName + "\" in model \"" + modelName + "\":
The boundary value X_boundary("   + String(i) + ") = " + String(
            X_boundary[i]) + "
is negative. It must be positive.
");     end for;

        if nX > 0 and abs(sum(X_boundary) - 1.0) > 1e-10 then
           X_str :="";
           for i in 1:nX loop
              X_str :=X_str + "   X_boundary[" + String(i) + "] = " + String(X_boundary[
              i]) + " \"" + substanceNames[i] + "\"\n";
           end for;
           Modelica.Utilities.Streams.error(
              "The boundary mass fractions in medium \"" + mediumName + "\" in model \"" + modelName + "\"\n" +
              "do not sum up to 1. Instead, sum(X_boundary) = " + String(sum(X_boundary)) + ":\n"
              + X_str);
        end if;
      end checkBoundary;

      function regPow
        "Anti-symmetric power approximation with non-zero derivative in the origin"
        extends Modelica.Icons.Function;
        input Real x;
        input Real a;
        input Real delta=0.01 "Range of significant deviation from x^a*sgn(x)";
        output Real y;
      algorithm
        y := x*(x*x+delta*delta)^((a-1)/2);

        annotation(Documentation(info="<html>
<p>
This function approximates abs(x)^a*sign(x), such that the derivative is positive, finite and smooth in x=0.
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Function</th><th>Approximation</th><th>Range</th></tr>
<tr><td>y = regPow(x)</td><td>y ~= abs(x)^a*sgn(x)</td><td>abs(x) &gt;&gt;delta</td></tr>
<tr><td>y = regPow(x)</td><td>y ~= x*delta^(a-1)</td><td>abs(x) &lt;&lt; delta</td></tr>
</table>
</html>",   revisions="<html>
<ul>
<li><em>15 Mar 2005</em>
    by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br>
       Created.</li>
</ul>
</html>"));
      end regPow;

      function regStep
        "Approximation of a general step, such that the characteristic is continuous and differentiable"
        extends Modelica.Icons.Function;
        input Real x "Abscissa value";
        input Real y1 "Ordinate value for x > 0";
        input Real y2 "Ordinate value for x < 0";
        input Real x_small(min=0) = 1e-5
          "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
        output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
      algorithm
        y := smooth(1, if x >  x_small then y1 else
                       if x < -x_small then y2 else
                       if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);
        annotation(Documentation(revisions="<html>
<ul>
<li><em>April 29, 2008</em>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><em>August 12, 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",       info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <strong>if</strong> x &gt; 0 <strong>then</strong> y1 <strong>else</strong> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> y1 <strong>else</strong>
                 <strong>if</strong> x &lt; -x_small <strong>then</strong> y2 <strong>else</strong> f(y1, y2));
</pre>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>
</html>"));
      end regStep;

      function regFun3 "Co-monotonic and C1 smooth regularization function"
        extends Modelica.Icons.Function;

        input Real x "Abscissa value";
        input Real x0 "Lower abscissa value";
        input Real x1 "Upper abscissa value";
        input Real y0 "Ordinate value at lower abscissa value";
        input Real y1 "Ordinate value at upper abscissa value";
        input Real y0d "Derivative at lower abscissa value";
        input Real y1d "Derivative at upper abscissa value";

        output Real y "Ordinate value";
        output Real c
          "Slope of linear section between two cubic polynomials or dummy linear section slope if single cubic is used";

    protected
        Real h0 "Width of interval i=0";
        Real Delta0 "Slope of secant on interval i=0";
        Real xstar "Inflection point of cubic polynomial S0";
        Real mu "Distance of inflection point and left limit x0";
        Real eta "Distance of right limit x1 and inflection point";
        Real omega "Slope of cubic polynomial S0 at inflection point";
        Real rho "Weighting factor of eta and eta_tilde, mu and mu_tilde";
        Real theta0 "Slope metric";
        Real mu_tilde "Distance of start of linear section and left limit x0";
        Real eta_tilde "Distance of right limit x1 and end of linear section";
        Real xi1 "Start of linear section";
        Real xi2 "End of linear section";
        Real a1 "Leading coefficient of cubic on the left";
        Real a2 "Leading coefficient of cubic on the right";
        Real const12 "Integration constant of left cubic, linear section";
        Real const3 "Integration constant of right cubic";
        Real aux01;
        Real aux02;
        Boolean useSingleCubicPolynomial=false
          "Indicate to override further logic and use single cubic";
      algorithm
        // Check arguments: Data point position
        assert(x0 < x1, "regFun3(): Data points not sorted appropriately (x0 = " +
          String(x0) + " > x1 = " + String(x1) + "). Please flip arguments.");
        // Check arguments: Data point derivatives
        if y0d*y1d >= 0 then
          // Derivatives at data points allow co-monotone interpolation, nothing to do
        else
          // Strictly speaking, derivatives at data points do not allow co-monotone interpolation, however, they may be numerically zero so assert this
          assert(abs(y0d)<Modelica.Constants.eps or abs(y1d)<Modelica.Constants.eps, "regFun3(): Derivatives at data points do not allow co-monotone interpolation, as both are non-zero, of opposite sign and have an absolute value larger than machine eps (y0d = " +
          String(y0d) + ", y1d = " + String(y1d) + "). Please correct arguments.");
        end if;

        h0 := x1 - x0;
        Delta0 := (y1 - y0)/h0;

        if abs(Delta0) <= 0 then
          // Points (x0,y0) and (x1,y1) on horizontal line
          // Degenerate case as we cannot fulfill the C1 goal an comonotone behaviour at the same time
          y := y0 + Delta0*(x-x0);     // y == y0 == y1 with additional term to assist automatic differentiation
          c := 0;
        elseif abs(y1d + y0d - 2*Delta0) < 100*Modelica.Constants.eps then
          // Inflection point at +/- infinity, thus S0 is co-monotone and can be returned directly
          y := y0 + (x-x0)*(y0d + (x-x0)/h0*( (-2*y0d-y1d+3*Delta0) + (x-x0)*(y0d+y1d-2*Delta0)/h0));
          // Provide a "dummy linear section slope" as the slope of the cubic at x:=(x0+x1)/2
          aux01 := (x0 + x1)/2;
          c := 3*(y0d + y1d - 2*Delta0)*(aux01 - x0)^2/h0^2 + 2*(-2*y0d - y1d + 3*Delta0)*(aux01 - x0)/h0
             + y0d;
        else
          // Points (x0,y0) and (x1,y1) not on horizontal line and inflection point of S0 not at +/- infinity
          // Do actual interpolation
          xstar := 1/3*(-3*x0*y0d - 3*x0*y1d + 6*x0*Delta0 - 2*h0*y0d - h0*y1d + 3*h0*
            Delta0)/(-y0d - y1d + 2*Delta0);
          mu := xstar - x0;
          eta := x1 - xstar;
          omega := 3*(y0d + y1d - 2*Delta0)*(xstar - x0)^2/h0^2 + 2*(-2*y0d - y1d + 3*
            Delta0)*(xstar - x0)/h0 + y0d;

          aux01 := 0.25*sign(Delta0)*min(abs(omega), abs(Delta0))
            "Slope c if not using plain cubic S0";
          if abs(y0d - y1d) <= 100*Modelica.Constants.eps then
            // y0 == y1 (value and sign equal) -> resolve indefinite 0/0
            aux02 := y0d;
            if y1 > y0 + y0d*(x1 - x0) then
              // If y1 is above the linear extension through (x0/y0)
              // with slope y0d (when slopes are identical)
              //  -> then always used single cubic polynomial
              useSingleCubicPolynomial := true;
            end if;
          elseif abs(y1d + y0d - 2*Delta0) < 100*Modelica.Constants.eps then
            // (y1d+y0d-2*Delta0) approximately 0 -> avoid division by 0
            aux02 := (6*Delta0*(y1d + y0d - 3/2*Delta0) - y1d*y0d - y1d^2 - y0d^2)*(
              if (y1d + y0d - 2*Delta0) >= 0 then 1 else -1)*Modelica.Constants.inf;
          else
            // Okay, no guarding necessary
            aux02 := (6*Delta0*(y1d + y0d - 3/2*Delta0) - y1d*y0d - y1d^2 - y0d^2)/(3*
              (y1d + y0d - 2*Delta0));
          end if;

          //aux02 := -1/3*(y0d^2+y0d*y1d-6*y0d*Delta0+y1d^2-6*y1d*Delta0+9*Delta0^2)/(y0d+y1d-2*Delta0);
          //aux02 := -1/3*(6*y1d*y0*x1+y0d*y1d*x1^2-6*y0d*x0*y0+y0d^2*x0^2+y0d^2*x1^2+y1d^2*x1^2+y1d^2*x0^2-2*y0d*x0*y1d*x1-2*x0*y0d^2*x1+y0d*y1d*x0^2+6*y0d*x0*y1-6*y0d*y1*x1+6*y0d*y0*x1-2*x0*y1d^2*x1-6*y1d*y1*x1+6*y1d*x0*y1-6*y1d*x0*y0-18*y1*y0+9*y1^2+9*y0^2)/(y0d*x1^2-2*x0*y0d*x1+y1d*x1^2-2*x0*y1d*x1-2*y1*x1+2*y0*x1+y0d*x0^2+y1d*x0^2+2*x0*y1-2*x0*y0);

          // Test criteria (also used to avoid saddle points that lead to integrator contraction):
          //
          //  1. Cubic is not monotonic (from Gasparo Morandi)
          //       ((mu > 0) and (eta < h0) and (Delta0*omega <= 0))
          //
          //  2. Cubic may be monotonic but the linear section slope c is either too close
          //     to zero or the end point of the linear section is left of the start point
          //     Note however, that the suggested slope has to have the same sign as Delta0.
          //       (abs(aux01)<abs(aux02) and aux02*Delta0>=0)
          //
          //  3. Cubic may be monotonic but the resulting slope in the linear section
          //     is too close to zero (less than 1/10 of Delta0).
          //       (c < Delta0 / 10)
          //
          if (((mu > 0) and (eta < h0) and (Delta0*omega <= 0)) or (abs(aux01) < abs(
              aux02) and aux02*Delta0 >= 0) or (abs(aux01) < abs(0.1*Delta0))) and
              not useSingleCubicPolynomial then
            // NOT monotonic using plain cubic S0, use piecewise function S0 tilde instead
            c := aux01;
            // Avoid saddle points that are co-monotonic but lead to integrator contraction
            if abs(c) < abs(aux02) and aux02*Delta0 >= 0 then
              c := aux02;
            end if;
            if abs(c) < abs(0.1*Delta0) then
              c := 0.1*Delta0;
            end if;
            theta0 := (y0d*mu + y1d*eta)/h0;
            if abs(theta0 - c) < 1e-6 then
              // Slightly reduce c in order to avoid ill-posed problem
              c := (1 - 1e-6)*theta0;
            end if;
            rho := 3*(Delta0 - c)/(theta0 - c);
            mu_tilde := rho*mu;
            eta_tilde := rho*eta;
            xi1 := x0 + mu_tilde;
            xi2 := x1 - eta_tilde;
            a1 := (y0d - c)/max(mu_tilde^2, 100*Modelica.Constants.eps);
            a2 := (y1d - c)/max(eta_tilde^2, 100*Modelica.Constants.eps);
            const12 := y0 - a1/3*(x0 - xi1)^3 - c*x0;
            const3 := y1 - a2/3*(x1 - xi2)^3 - c*x1;
            // Do actual interpolation
            if (x < xi1) then
              y := a1/3*(x - xi1)^3 + c*x + const12;
            elseif (x < xi2) then
              y := c*x + const12;
            else
              y := a2/3*(x - xi2)^3 + c*x + const3;
            end if;
          else
            // Cubic S0 is monotonic, use it as is
            y := y0 + (x-x0)*(y0d + (x-x0)/h0*( (-2*y0d-y1d+3*Delta0) + (x-x0)*(y0d+y1d-2*Delta0)/h0));
            // Provide a "dummy linear section slope" as the slope of the cubic at x:=(x0+x1)/2
            aux01 := (x0 + x1)/2;
            c := 3*(y0d + y1d - 2*Delta0)*(aux01 - x0)^2/h0^2 + 2*(-2*y0d - y1d + 3*Delta0)*(aux01 - x0)/h0
               + y0d;
          end if;
        end if;

        annotation (smoothOrder=1, Documentation(revisions="<html>
<ul>
<li><em>May 2008</em> by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>Designed and implemented.</li>
<li><em>February 2011</em> by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>If the inflection point of the cubic S0 was at +/- infinity, the test criteria of <em>[Gasparo and Morandi, 1991]</em> result in division by zero. This case is handled properly now.</li>
<li><em>March 2013</em> by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>If the arguments prescribed a degenerate case with points <code>(x0,y0)</code> and <code>(x1,y1)</code> on horizontal line, then return value <code>c</code> was undefined. This was corrected. Furthermore, an additional term was included for the computation of <code>y</code> in this case to assist automatic differentiation.</li>
</ul>
</html>",       info="<html>
<p>
Approximates a function in a region between <code>x0</code> and <code>x1</code>
such that
</p>
<ul>
<li> The overall function is continuous with a
     continuous first derivative everywhere.</li>
<li> The function is co-monotone with the given
     data points.</li>
</ul>
<p>
In this region, a continuation is constructed from the given points
<code>(x0, y0)</code>, <code>(x1, y1)</code> and the respective
derivatives. For this purpose, a single polynomial of third order or two
cubic polynomials with a linear section in between are used <em>[Gasparo
and Morandi, 1991]</em>. This algorithm was extended with two additional
conditions to avoid saddle points with zero/infinite derivative that lead to
integrator step size reduction to zero.
</p>
<p>
This function was developed for pressure loss correlations properly
addressing the static head on top of the established requirements
for monotonicity and smoothness. In this case, the present function
allows to implement the exact solution in the limit of
<code>x1-x0 -> 0</code> or <code>y1-y0 -> 0</code>.
</p>
<p>
Typical screenshots for two different configurations
are shown below. The first one illustrates five different settings of <code>xi</code> and <code>yid</code>:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regFun3_a.png\"
      alt=\"regFun3_a.png\">
</p>
<p>
The second graph shows the continuous derivative of this regularization function:
</p>
<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/Components/regFun3_b.png\"
     alt=\"regFun3_a.png\">
</p>

<p>
<strong>Literature</strong>
</p>

<dl>
<dt> Gasparo M. G. and Morandi R. (1991):</dt>
<dd> <strong>Piecewise cubic monotone interpolation with assigned slopes</strong>.
     Computing, Vol. 46, Issue 4, December 1991, pp. 355 - 365.</dd>
</dl>
</html>"));
      end regFun3;

      function cubicHermite "Evaluate a cubic Hermite spline"
        extends Modelica.Icons.Function;

        input Real x "Abscissa value";
        input Real x1 "Lower abscissa value";
        input Real x2 "Upper abscissa value";
        input Real y1 "Lower ordinate value";
        input Real y2 "Upper ordinate value";
        input Real y1d "Lower gradient";
        input Real y2d "Upper gradient";
        output Real y "Interpolated ordinate value";
    protected
        Real h "Distance between x1 and x2";
        Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
        Real h00 "Basis function 00 of cubic Hermite spline";
        Real h10 "Basis function 10 of cubic Hermite spline";
        Real h01 "Basis function 01 of cubic Hermite spline";
        Real h11 "Basis function 11 of cubic Hermite spline";
        Real aux3 "t cube";
        Real aux2 "t square";
      algorithm
        h := x2 - x1;
        if abs(h)>0 then
          // Regular case
          t := (x - x1)/h;

          aux3 :=t^3;
          aux2 :=t^2;

          h00 := 2*aux3 - 3*aux2 + 1;
          h10 := aux3 - 2*aux2 + t;
          h01 := -2*aux3 + 3*aux2;
          h11 := aux3 - aux2;
          y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
        else
          // Degenerate case, x1 and x2 are identical, return step function
          y := (y1 + y2)/2;
        end if;
        annotation(smoothOrder=3, Documentation(revisions="<html>
<ul>
<li><em>May 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
      end cubicHermite;

      function cubicHermite_withDerivative
        "Evaluate a cubic Hermite spline, return value and derivative"
        extends Modelica.Icons.Function;

        input Real x "Abscissa value";
        input Real x1 "Lower abscissa value";
        input Real x2 "Upper abscissa value";
        input Real y1 "Lower ordinate value";
        input Real y2 "Upper ordinate value";
        input Real y1d "Lower gradient";
        input Real y2d "Upper gradient";
        output Real y "Interpolated ordinate value";
        output Real dy_dx "Derivative dy/dx at abscissa value x";
    protected
        Real h "Distance between x1 and x2";
        Real t "abscissa scaled with h, i.e., t=[0..1] within x=[x1..x2]";
        Real h00 "Basis function 00 of cubic Hermite spline";
        Real h10 "Basis function 10 of cubic Hermite spline";
        Real h01 "Basis function 01 of cubic Hermite spline";
        Real h11 "Basis function 11 of cubic Hermite spline";

        Real h00d "d/dt h00";
        Real h10d "d/dt h10";
        Real h01d "d/dt h01";
        Real h11d "d/dt h11";

        Real aux3 "t cube";
        Real aux2 "t square";
      algorithm
        h := x2 - x1;
        if abs(h)>0 then
          // Regular case
          t := (x - x1)/h;

          aux3 :=t^3;
          aux2 :=t^2;

          h00 := 2*aux3 - 3*aux2 + 1;
          h10 := aux3 - 2*aux2 + t;
          h01 := -2*aux3 + 3*aux2;
          h11 := aux3 - aux2;

          h00d := 6*(aux2 - t);
          h10d := 3*aux2 - 4*t + 1;
          h01d := 6*(t - aux2);
          h11d := 3*aux2 - 2*t;

          y := y1*h00 + h*y1d*h10 + y2*h01 + h*y2d*h11;
          dy_dx := y1*h00d/h + y1d*h10d + y2*h01d/h + y2d*h11d;
        else
          // Degenerate case, x1 and x2 are identical, return step function
          y := (y1 + y2)/2;
          dy_dx := sign(y2 - y1)*Modelica.Constants.inf;
        end if;
        annotation(smoothOrder=3, Documentation(revisions="<html>
<ul>
<li><em>May 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Designed and implemented.</li>
</ul>
</html>"));
      end cubicHermite_withDerivative;
      annotation (Documentation(info="<html>

</html>"));
    end Utilities;
  annotation (Icon(graphics={
          Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}}),
          Line(points={{2,42},{2,-10}}),
          Rectangle(
            extent={{-18,50},{22,42}},
            fillPattern=FillPattern.Solid)}), preferredView="info",
    Documentation(info="<html>
<p>
Library <strong>Modelica.Fluid</strong> is a <strong>free</strong> Modelica package providing components for
<strong>1-dimensional thermo-fluid flow</strong> in networks of vessels, pipes, fluid machines, valves and fittings.
A unique feature is that the component equations and the media models
as well as pressure loss and heat transfer correlations are decoupled from each other.
All components are implemented such that they can be used for
media from the Modelica.Media library. This means especially that an
incompressible or compressible medium, a single or a multiple
substance medium with one or more phases might be used.
</p>

<p>
In the next figure, several features of the library are demonstrated with
a simple heating system with a closed flow cycle. By just changing one configuration parameter in the system object the equations are changed between steady-state and dynamic simulation with fixed or steady-state initial conditions.
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Fluid/UsersGuide/HeatingSystem.png\" border=\"1\"
     alt=\"HeatingSystem.png\">
</p>

<p>
With respect to previous versions, the design
of the connectors has been changed in a non-backward compatible way,
using the recently developed concept
of stream connectors that results in much more reliable simulations
(see also <a href=\"modelica://Modelica/Resources/Documentation/Fluid/Stream-Connectors-Overview-Rationale.pdf\">Stream-Connectors-Overview-Rationale.pdf</a>).
This extension was included in Modelica 3.1.
</p>

<p>
The following parts are useful, when newly starting with this library:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Fluid.UsersGuide\">Modelica.Fluid.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica.Fluid.UsersGuide.ReleaseNotes\">Modelica.Fluid.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Fluid.Examples\">Modelica.Fluid.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
Copyright &copy; 2002-2019, Modelica Association and contributors
</p>
</html>"));
  end Fluid;

  package Media "Library of media property models"
  extends Modelica.Icons.Package;
  import SI = Modelica.SIunits;
  import Cv = Modelica.SIunits.Conversions;

  package Interfaces "Interfaces for media models"
    extends Modelica.Icons.InterfacesPackage;

    partial package PartialMedium
      "Partial medium properties (base package of all media packages)"
      extends Modelica.Media.Interfaces.Types;
      extends Modelica.Icons.MaterialPropertiesPackage;

      // Constants to be set in Medium
      constant Modelica.Media.Interfaces.Choices.IndependentVariables
        ThermoStates "Enumeration type for independent variables";
      constant String mediumName="unusablePartialMedium" "Name of the medium";
      constant String substanceNames[:]={mediumName}
        "Names of the mixture substances. Set substanceNames={mediumName} if only one substance.";
      constant String extraPropertiesNames[:]=fill("", 0)
        "Names of the additional (extra) transported properties. Set extraPropertiesNames=fill(\"\",0) if unused";
      constant Boolean singleState
        "= true, if u and d are not a function of pressure";
      constant Boolean reducedX=true
        "= true if medium contains the equation sum(X) = 1.0; set reducedX=true if only one substance (see docu for details)";
      constant Boolean fixedX=false
        "= true if medium contains the equation X = reference_X";
      constant AbsolutePressure reference_p=101325
        "Reference pressure of Medium: default 1 atmosphere";
      constant Temperature reference_T=298.15
        "Reference temperature of Medium: default 25 deg Celsius";
      constant MassFraction reference_X[nX]=fill(1/nX, nX)
        "Default mass fractions of medium";
      constant AbsolutePressure p_default=101325
        "Default value for pressure of medium (for initialization)";
      constant Temperature T_default=Modelica.SIunits.Conversions.from_degC(20)
        "Default value for temperature of medium (for initialization)";
      constant SpecificEnthalpy h_default=specificEnthalpy_pTX(
              p_default,
              T_default,
              X_default)
        "Default value for specific enthalpy of medium (for initialization)";
      constant MassFraction X_default[nX]=reference_X
        "Default value for mass fractions of medium (for initialization)";
      constant ExtraProperty C_default[nC]=fill(0, nC)
        "Default value for trace substances of medium (for initialization)";

      final constant Integer nS=size(substanceNames, 1) "Number of substances";
      constant Integer nX=nS "Number of mass fractions";
      constant Integer nXi=if fixedX then 0 else if reducedX then nS - 1 else nS
        "Number of structurally independent mass fractions (see docu for details)";

      final constant Integer nC=size(extraPropertiesNames, 1)
        "Number of extra (outside of standard mass-balance) transported properties";
      constant Real C_nominal[nC](min=fill(Modelica.Constants.eps, nC)) = 1.0e-6*
        ones(nC) "Default for the nominal values for the extra properties";
      replaceable record FluidConstants =
          Modelica.Media.Interfaces.Types.Basic.FluidConstants
        "Critical, triple, molecular and other standard data of fluid";

      replaceable record ThermodynamicState
        "Minimal variable set that is available as input argument to every medium function"
        extends Modelica.Icons.Record;
      end ThermodynamicState;

      replaceable partial model BaseProperties
        "Base properties (p, d, T, h, u, R, MM and, if applicable, X and Xi) of a medium"
        InputAbsolutePressure p "Absolute pressure of medium";
        InputMassFraction[nXi] Xi(start=reference_X[1:nXi])
          "Structurally independent mass fractions";
        InputSpecificEnthalpy h "Specific enthalpy of medium";
        Density d "Density of medium";
        Temperature T "Temperature of medium";
        MassFraction[nX] X(start=reference_X)
          "Mass fractions (= (component mass)/total mass  m_i/m)";
        SpecificInternalEnergy u "Specific internal energy of medium";
        SpecificHeatCapacity R "Gas constant (of mixture if applicable)";
        MolarMass MM "Molar mass (of mixture or single fluid)";
        ThermodynamicState state
          "Thermodynamic state record for optional functions";
        parameter Boolean preferredMediumStates=false
          "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean standardOrderComponents=true
          "If true, and reducedX = true, the last element of X will be computed from the other ones";
        SI.Conversions.NonSIunits.Temperature_degC T_degC=
            Modelica.SIunits.Conversions.to_degC(T)
          "Temperature of medium in [degC]";
        SI.Conversions.NonSIunits.Pressure_bar p_bar=
            Modelica.SIunits.Conversions.to_bar(p)
          "Absolute pressure of medium in [bar]";

        // Local connector definition, used for equation balancing check
        connector InputAbsolutePressure = input SI.AbsolutePressure
          "Pressure as input signal connector";
        connector InputSpecificEnthalpy = input SI.SpecificEnthalpy
          "Specific enthalpy as input signal connector";
        connector InputMassFraction = input SI.MassFraction
          "Mass fraction as input signal connector";

      equation
        if standardOrderComponents then
          Xi = X[1:nXi];

          if fixedX then
            X = reference_X;
          end if;
          if reducedX and not fixedX then
            X[nX] = 1 - sum(Xi);
          end if;
          for i in 1:nX loop
            assert(X[i] >= -1.e-5 and X[i] <= 1 + 1.e-5, "Mass fraction X[" +
              String(i) + "] = " + String(X[i]) + "of substance " +
              substanceNames[i] + "\nof medium " + mediumName +
              " is not in the range 0..1");
          end for;

        end if;

        assert(p >= 0.0, "Pressure (= " + String(p) + " Pa) of medium \"" +
          mediumName + "\" is negative\n(Temperature = " + String(T) + " K)");
        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,255}), Text(
                extent={{-152,164},{152,102}},
                textString="%name",
                lineColor={0,0,255})}), Documentation(info="<html>
<p>
Model <strong>BaseProperties</strong> is a model within package <strong>PartialMedium</strong>
and contains the <strong>declarations</strong> of the minimum number of
variables that every medium model is supposed to support.
A specific medium inherits from model <strong>BaseProperties</strong> and provides
the equations for the basic properties.</p>
<p>
The BaseProperties model contains the following <strong>7+nXi variables</strong>
(nXi is the number of independent mass fractions defined in package
PartialMedium):
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>absolute pressure</td></tr>
  <tr><td>d</td>
      <td>kg/m3</td>
      <td>density</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>Xi[nXi]</td>
      <td>kg/kg</td>
      <td>independent mass fractions m_i/m</td></tr>
  <tr><td>R</td>
      <td>J/kg.K</td>
      <td>gas constant</td></tr>
  <tr><td>M</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
<p>
In order to implement an actual medium model, one can extend from this
base model and add <strong>5 equations</strong> that provide relations among
these variables. Equations will also have to be added in order to
set all the variables within the ThermodynamicState record state.</p>
<p>
If standardOrderComponents=true, the full composition vector X[nX]
is determined by the equations contained in this base class, depending
on the independent mass fraction vector Xi[nXi].</p>
<p>Additional <strong>2 + nXi</strong> equations will have to be provided
when using the BaseProperties model, in order to fully specify the
thermodynamic conditions. The input connector qualifier applied to
p, h, and nXi indirectly declares the number of missing equations,
permitting advanced equation balance checking by Modelica tools.
Please note that this doesn't mean that the additional equations
should be connection equations, nor that exactly those variables
should be supplied, in order to complete the model.
For further information, see the Modelica.Media User's guide, and
Section 4.7 (Balanced Models) of the Modelica 3.0 specification.</p>
</html>"));
      end BaseProperties;

      replaceable partial function setState_pTX
        "Return thermodynamic state as function of p, T and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_pTX;

      replaceable partial function setState_phX
        "Return thermodynamic state as function of p, h and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_phX;

      replaceable partial function setState_psX
        "Return thermodynamic state as function of p, s and composition X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_psX;

      replaceable partial function setState_dTX
        "Return thermodynamic state as function of d, T and composition X or Xi"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      end setState_dTX;

      replaceable partial function setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
        extends Modelica.Icons.Function;
        input Real x "m_flow or dp";
        input ThermodynamicState state_a "Thermodynamic state if x > 0";
        input ThermodynamicState state_b "Thermodynamic state if x < 0";
        input Real x_small(min=0)
          "Smooth transition in the region -x_small < x < x_small";
        output ThermodynamicState state
          "Smooth thermodynamic state for all x (continuous and differentiable)";
        annotation (Documentation(info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    state = <strong>if</strong> x &gt; 0 <strong>then</strong> state_a <strong>else</strong> state_b;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   state := <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> state_a <strong>else</strong>
                      <strong>if</strong> x &lt; -x_small <strong>then</strong> state_b <strong>else</strong> f(state_a, state_b));
</pre>

<p>
This is performed by applying function <strong>Media.Common.smoothStep</strong>(..)
on every element of the thermodynamic state record.
</p>

<p>
If <strong>mass fractions</strong> X[:] are approximated with this function then this can be performed
for all <strong>nX</strong> mass fractions, instead of applying it for nX-1 mass fractions and computing
the last one by the mass fraction constraint sum(X)=1. The reason is that the approximating function has the
property that sum(state.X) = 1, provided sum(state_a.X) = sum(state_b.X) = 1.
This can be shown by evaluating the approximating function in the abs(x) &lt; x_small
region (otherwise state.X is either state_a.X or state_b.X):
</p>

<pre>
    X[1]  = smoothStep(x, X_a[1] , X_b[1] , x_small);
    X[2]  = smoothStep(x, X_a[2] , X_b[2] , x_small);
       ...
    X[nX] = smoothStep(x, X_a[nX], X_b[nX], x_small);
</pre>

<p>
or
</p>

<pre>
    X[1]  = c*(X_a[1]  - X_b[1])  + (X_a[1]  + X_b[1])/2
    X[2]  = c*(X_a[2]  - X_b[2])  + (X_a[2]  + X_b[2])/2;
       ...
    X[nX] = c*(X_a[nX] - X_b[nX]) + (X_a[nX] + X_b[nX])/2;
    c     = (x/x_small)*((x/x_small)^2 - 3)/4
</pre>

<p>
Summing all mass fractions together results in
</p>

<pre>
    sum(X) = c*(sum(X_a) - sum(X_b)) + (sum(X_a) + sum(X_b))/2
           = c*(1 - 1) + (1 + 1)/2
           = 1
</pre>

</html>"));
      end setSmoothState;

      replaceable partial function dynamicViscosity "Return dynamic viscosity"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DynamicViscosity eta "Dynamic viscosity";
      end dynamicViscosity;

      replaceable partial function thermalConductivity
        "Return thermal conductivity"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output ThermalConductivity lambda "Thermal conductivity";
      end thermalConductivity;

      replaceable function prandtlNumber "Return the Prandtl number"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output PrandtlNumber Pr "Prandtl number";
      algorithm
        Pr := dynamicViscosity(state)*specificHeatCapacityCp(state)/
          thermalConductivity(state);
      end prandtlNumber;

      replaceable partial function pressure "Return pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output AbsolutePressure p "Pressure";
      end pressure;

      replaceable partial function temperature "Return temperature"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Temperature T "Temperature";
      end temperature;

      replaceable partial function density "Return density"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Density d "Density";
      end density;

      replaceable partial function specificEnthalpy "Return specific enthalpy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnthalpy h "Specific enthalpy";
      end specificEnthalpy;

      replaceable partial function specificInternalEnergy
        "Return specific internal energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy u "Specific internal energy";
      end specificInternalEnergy;

      replaceable partial function specificEntropy "Return specific entropy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEntropy s "Specific entropy";
      end specificEntropy;

      replaceable partial function specificGibbsEnergy
        "Return specific Gibbs energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy g "Specific Gibbs energy";
      end specificGibbsEnergy;

      replaceable partial function specificHelmholtzEnergy
        "Return specific Helmholtz energy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificEnergy f "Specific Helmholtz energy";
      end specificHelmholtzEnergy;

      replaceable partial function specificHeatCapacityCp
        "Return specific heat capacity at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificHeatCapacity cp
          "Specific heat capacity at constant pressure";
      end specificHeatCapacityCp;

      function heatCapacity_cp = specificHeatCapacityCp
        "Alias for deprecated name";

      replaceable partial function specificHeatCapacityCv
        "Return specific heat capacity at constant volume"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SpecificHeatCapacity cv
          "Specific heat capacity at constant volume";
      end specificHeatCapacityCv;

      function heatCapacity_cv = specificHeatCapacityCv
        "Alias for deprecated name";

      replaceable partial function isentropicExponent
        "Return isentropic exponent"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output IsentropicExponent gamma "Isentropic exponent";
      end isentropicExponent;

      replaceable partial function isentropicEnthalpy
        "Return isentropic enthalpy"
        extends Modelica.Icons.Function;
        input AbsolutePressure p_downstream "Downstream pressure";
        input ThermodynamicState refState "Reference state for entropy";
        output SpecificEnthalpy h_is "Isentropic enthalpy";
        annotation (Documentation(info="<html>
<p>
This function computes an isentropic state transformation:
</p>
<ol>
<li> A medium is in a particular state, refState.</li>
<li> The enthalpy at another state (h_is) shall be computed
     under the assumption that the state transformation from refState to h_is
     is performed with a change of specific entropy ds = 0 and the pressure of state h_is
     is p_downstream and the composition X upstream and downstream is assumed to be the same.</li>
</ol>

</html>"));
      end isentropicEnthalpy;

      replaceable partial function velocityOfSound "Return velocity of sound"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output VelocityOfSound a "Velocity of sound";
      end velocityOfSound;

      replaceable partial function isobaricExpansionCoefficient
        "Return overall the isobaric expansion coefficient beta"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output IsobaricExpansionCoefficient beta "Isobaric expansion coefficient";
        annotation (Documentation(info="<html>
<pre>
beta is defined as  1/v * der(v,T), with v = 1/d, at constant pressure p.
</pre>
</html>"));
      end isobaricExpansionCoefficient;

      function beta = isobaricExpansionCoefficient
        "Alias for isobaricExpansionCoefficient for user convenience";

      replaceable partial function isothermalCompressibility
        "Return overall the isothermal compressibility factor"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output SI.IsothermalCompressibility kappa "Isothermal compressibility";
        annotation (Documentation(info="<html>
<pre>

kappa is defined as - 1/v * der(v,p), with v = 1/d at constant temperature T.

</pre>
</html>"));
      end isothermalCompressibility;

      function kappa = isothermalCompressibility
        "Alias of isothermalCompressibility for user convenience";

      // explicit derivative functions for finite element models
      replaceable partial function density_derp_h
        "Return density derivative w.r.t. pressure at const specific enthalpy"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByPressure ddph "Density derivative w.r.t. pressure";
      end density_derp_h;

      replaceable partial function density_derh_p
        "Return density derivative w.r.t. specific enthalpy at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByEnthalpy ddhp
          "Density derivative w.r.t. specific enthalpy";
      end density_derh_p;

      replaceable partial function density_derp_T
        "Return density derivative w.r.t. pressure at const temperature"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByPressure ddpT "Density derivative w.r.t. pressure";
      end density_derp_T;

      replaceable partial function density_derT_p
        "Return density derivative w.r.t. temperature at constant pressure"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output DerDensityByTemperature ddTp
          "Density derivative w.r.t. temperature";
      end density_derT_p;

      replaceable partial function density_derX
        "Return density derivative w.r.t. mass fraction"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output Density[nX] dddX "Derivative of density w.r.t. mass fraction";
      end density_derX;

      replaceable partial function molarMass
        "Return the molar mass of the medium"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state record";
        output MolarMass MM "Mixture molar mass";
      end molarMass;

      replaceable function specificEnthalpy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_pTX(
                p,
                T,
                X));
        annotation (inverse(T=temperature_phX(
                      p,
                      h,
                      X)));
      end specificEnthalpy_pTX;

      replaceable function specificEntropy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEntropy s "Specific entropy";
      algorithm
        s := specificEntropy(setState_pTX(
                p,
                T,
                X));

        annotation (inverse(T=temperature_psX(
                      p,
                      s,
                      X)));
      end specificEntropy_pTX;

      replaceable function density_pTX "Return density from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:] "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_pTX(
                p,
                T,
                X));
      end density_pTX;

      replaceable function temperature_phX
        "Return temperature from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := temperature(setState_phX(
                p,
                h,
                X));
      end temperature_phX;

      replaceable function density_phX "Return density from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_phX(
                p,
                h,
                X));
      end density_phX;

      replaceable function temperature_psX
        "Return temperature from p,s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := temperature(setState_psX(
                p,
                s,
                X));
        annotation (inverse(s=specificEntropy_pTX(
                      p,
                      T,
                      X)));
      end temperature_psX;

      replaceable function density_psX "Return density from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_psX(
                p,
                s,
                X));
      end density_psX;

      replaceable function specificEnthalpy_psX
        "Return specific enthalpy from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_psX(
                p,
                s,
                X));
      end specificEnthalpy_psX;

      type MassFlowRate = SI.MassFlowRate (
          quantity="MassFlowRate." + mediumName,
          min=-1.0e5,
          max=1.e5) "Type for mass flow rate with medium specific attributes";

      // Only for backwards compatibility to version 3.2 (
      // (do not use these definitions in new models, but use Modelica.Media.Interfaces.Choices instead)
      package Choices = Modelica.Media.Interfaces.Choices annotation (obsolete=
            "Use Modelica.Media.Interfaces.Choices");

      annotation (Documentation(info="<html>
<p>
<strong>PartialMedium</strong> is a package and contains all <strong>declarations</strong> for
a medium. This means that constants, models, and functions
are defined that every medium is supposed to support
(some of them are optional). A medium package
inherits from <strong>PartialMedium</strong> and provides the
equations for the medium. The details of this package
are described in
<a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media.UsersGuide</a>.
</p>
</html>",   revisions="<html>

</html>"));
    end PartialMedium;

    partial package PartialPureSubstance
      "Base class for pure substances of one chemical substance"
      extends PartialMedium(final reducedX=true, final fixedX=true);

      replaceable function setState_pT "Return thermodynamic state from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_pTX(
                p,
                T,
                fill(0, 0));
      end setState_pT;

      replaceable function setState_ph "Return thermodynamic state from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_phX(
                p,
                h,
                fill(0, 0));
      end setState_ph;

      replaceable function setState_ps "Return thermodynamic state from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_psX(
                p,
                s,
                fill(0, 0));
      end setState_ps;

      replaceable function setState_dT "Return thermodynamic state from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := setState_dTX(
                d,
                T,
                fill(0, 0));
      end setState_dT;

      replaceable function density_ph "Return density from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output Density d "Density";
      algorithm
        d := density_phX(
                p,
                h,
                fill(0, 0));
      end density_ph;

      replaceable function temperature_ph "Return temperature from p and h"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        output Temperature T "Temperature";
      algorithm
        T := temperature_phX(
                p,
                h,
                fill(0, 0));
      end temperature_ph;

      replaceable function pressure_dT "Return pressure from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output AbsolutePressure p "Pressure";
      algorithm
        p := pressure(setState_dTX(
                d,
                T,
                fill(0, 0)));
      end pressure_dT;

      replaceable function specificEnthalpy_dT
        "Return specific enthalpy from d and T"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy(setState_dTX(
                d,
                T,
                fill(0, 0)));
      end specificEnthalpy_dT;

      replaceable function specificEnthalpy_ps
        "Return specific enthalpy from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy_psX(
                p,
                s,
                fill(0, 0));
      end specificEnthalpy_ps;

      replaceable function temperature_ps "Return temperature from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output Temperature T "Temperature";
      algorithm
        T := temperature_psX(
                p,
                s,
                fill(0, 0));
      end temperature_ps;

      replaceable function density_ps "Return density from p and s"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        output Density d "Density";
      algorithm
        d := density_psX(
                p,
                s,
                fill(0, 0));
      end density_ps;

      replaceable function specificEnthalpy_pT
        "Return specific enthalpy from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := specificEnthalpy_pTX(
                p,
                T,
                fill(0, 0));
      end specificEnthalpy_pT;

      replaceable function density_pT "Return density from p and T"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        output Density d "Density";
      algorithm
        d := density(setState_pTX(
                p,
                T,
                fill(0, 0)));
      end density_pT;

      redeclare replaceable partial model extends BaseProperties(final
          standardOrderComponents=true)
      end BaseProperties;
    end PartialPureSubstance;

    partial package PartialMixtureMedium
      "Base class for pure substances of several chemical substances"
      extends PartialMedium(redeclare replaceable record FluidConstants =
            Modelica.Media.Interfaces.Types.IdealGas.FluidConstants);

      redeclare replaceable record extends ThermodynamicState
        "Thermodynamic state variables"
        AbsolutePressure p "Absolute pressure of medium";
        Temperature T "Temperature of medium";
        MassFraction[nX] X(start=reference_X)
          "Mass fractions (= (component mass)/total mass  m_i/m)";
      end ThermodynamicState;

      constant FluidConstants[nS] fluidConstants "Constant data for the fluid";

      replaceable function gasConstant
        "Return the gas constant of the mixture (also for liquids)"
        extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        output SI.SpecificHeatCapacity R "Mixture gas constant";
      end gasConstant;

      function moleToMassFractions "Return mass fractions X from mole fractions"
        extends Modelica.Icons.Function;
        input SI.MoleFraction moleFractions[:] "Mole fractions of mixture";
        input MolarMass[:] MMX "Molar masses of components";
        output SI.MassFraction X[size(moleFractions, 1)]
          "Mass fractions of gas mixture";
    protected
        MolarMass Mmix=moleFractions*MMX "Molar mass of mixture";
      algorithm
        for i in 1:size(moleFractions, 1) loop
          X[i] := moleFractions[i]*MMX[i]/Mmix;
        end for;
        annotation (smoothOrder=5);
      end moleToMassFractions;

      function massToMoleFractions "Return mole fractions from mass fractions X"
        extends Modelica.Icons.Function;
        input SI.MassFraction X[:] "Mass fractions of mixture";
        input SI.MolarMass[:] MMX "Molar masses of components";
        output SI.MoleFraction moleFractions[size(X, 1)]
          "Mole fractions of gas mixture";
    protected
        Real invMMX[size(X, 1)] "Inverses of molar weights";
        SI.MolarMass Mmix "Molar mass of mixture";
      algorithm
        for i in 1:size(X, 1) loop
          invMMX[i] := 1/MMX[i];
        end for;
        Mmix := 1/(X*invMMX);
        for i in 1:size(X, 1) loop
          moleFractions[i] := Mmix*X[i]/MMX[i];
        end for;
        annotation (smoothOrder=5);
      end massToMoleFractions;

    end PartialMixtureMedium;

    partial package PartialCondensingGases
      "Base class for mixtures of condensing and non-condensing gases"
      extends PartialMixtureMedium(ThermoStates=Modelica.Media.Interfaces.Choices.IndependentVariables.pTX);

      replaceable partial function saturationPressure
        "Return saturation pressure of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature Tsat "Saturation temperature";
        output AbsolutePressure psat "Saturation pressure";
      end saturationPressure;

      replaceable partial function enthalpyOfVaporization
        "Return vaporization enthalpy of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy r0 "Vaporization enthalpy";
      end enthalpyOfVaporization;

      replaceable partial function enthalpyOfLiquid
        "Return liquid enthalpy of condensing fluid"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Liquid enthalpy";
      end enthalpyOfLiquid;

      replaceable partial function enthalpyOfGas
        "Return enthalpy of non-condensing gas mixture"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        input MassFraction[:] X "Vector of mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfGas;

      replaceable partial function enthalpyOfCondensingGas
        "Return enthalpy of condensing gas (most often steam)"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfCondensingGas;

      replaceable partial function enthalpyOfNonCondensingGas
        "Return enthalpy of the non-condensing species"
        extends Modelica.Icons.Function;
        input Temperature T "Temperature";
        output SpecificEnthalpy h "Specific enthalpy";
      end enthalpyOfNonCondensingGas;
    end PartialCondensingGases;

    partial package PartialSimpleMedium
      "Medium model with linear dependency of u, h from temperature. All other quantities, especially density, are constant."

      extends Interfaces.PartialPureSubstance(final ThermoStates=Modelica.Media.Interfaces.Choices.IndependentVariables.pT,
          final singleState=true);

      constant SpecificHeatCapacity cp_const
        "Constant specific heat capacity at constant pressure";
      constant SpecificHeatCapacity cv_const
        "Constant specific heat capacity at constant volume";
      constant Density d_const "Constant density";
      constant DynamicViscosity eta_const "Constant dynamic viscosity";
      constant ThermalConductivity lambda_const "Constant thermal conductivity";
      constant VelocityOfSound a_const "Constant velocity of sound";
      constant Temperature T_min "Minimum temperature valid for medium model";
      constant Temperature T_max "Maximum temperature valid for medium model";
      constant Temperature T0=reference_T "Zero enthalpy temperature";
      constant MolarMass MM_const "Molar mass";

      constant FluidConstants[nS] fluidConstants "Fluid constants";

      redeclare record extends ThermodynamicState "Thermodynamic state"
        AbsolutePressure p "Absolute pressure of medium";
        Temperature T "Temperature of medium";
      end ThermodynamicState;

      redeclare replaceable model extends BaseProperties(T(stateSelect=if
              preferredMediumStates then StateSelect.prefer else StateSelect.default),
          p(stateSelect=if preferredMediumStates then StateSelect.prefer else
              StateSelect.default)) "Base properties"
      equation
        assert(T >= T_min and T <= T_max, "
Temperature T (= "   + String(T) + " K) is not
in the allowed range ("   + String(T_min) + " K <= T <= " + String(T_max) + " K)
required from medium model \""   + mediumName + "\".
");

        // h = cp_const*(T-T0);
        h = specificEnthalpy_pTX(
                p,
                T,
                X);
        u = cv_const*(T - T0);
        d = d_const;
        R = 0;
        MM = MM_const;
        state.T = T;
        state.p = p;
        annotation (Documentation(info="<html>
<p>
This is the most simple incompressible medium model, where
specific enthalpy h and specific internal energy u are only
a function of temperature T and all other provided medium
quantities are assumed to be constant.
Note that the (small) influence of the pressure term p/d is neglected.
</p>
</html>"));
      end BaseProperties;

      redeclare function setState_pTX
        "Return thermodynamic state from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=T);
      end setState_pTX;

      redeclare function setState_phX
        "Return thermodynamic state from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=T0 + h/cp_const);
      end setState_phX;

      redeclare replaceable function setState_psX
        "Return thermodynamic state from p, s, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEntropy s "Specific entropy";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        state := ThermodynamicState(p=p, T=Modelica.Math.exp(s/cp_const +
          Modelica.Math.log(reference_T)))
          "Here the incompressible limit is used, with cp as heat capacity";
      end setState_psX;

      redeclare function setState_dTX
        "Return thermodynamic state from d, T, and X or Xi"
        extends Modelica.Icons.Function;
        input Density d "Density";
        input Temperature T "Temperature";
        input MassFraction X[:]=reference_X "Mass fractions";
        output ThermodynamicState state "Thermodynamic state record";
      algorithm
        assert(false,
          "Pressure can not be computed from temperature and density for an incompressible fluid!");
      end setState_dTX;

      redeclare function extends setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
      algorithm
        state := ThermodynamicState(p=Media.Common.smoothStep(
                x,
                state_a.p,
                state_b.p,
                x_small), T=Media.Common.smoothStep(
                x,
                state_a.T,
                state_b.T,
                x_small));
      end setSmoothState;

      redeclare function extends dynamicViscosity "Return dynamic viscosity"

      algorithm
        eta := eta_const;
      end dynamicViscosity;

      redeclare function extends thermalConductivity
        "Return thermal conductivity"

      algorithm
        lambda := lambda_const;
      end thermalConductivity;

      redeclare function extends pressure "Return pressure"

      algorithm
        p := state.p;
      end pressure;

      redeclare function extends temperature "Return temperature"

      algorithm
        T := state.T;
      end temperature;

      redeclare function extends density "Return density"

      algorithm
        d := d_const;
      end density;

      redeclare function extends specificEnthalpy "Return specific enthalpy"

      algorithm
        h := cp_const*(state.T - T0);
      end specificEnthalpy;

      redeclare function extends specificHeatCapacityCp
        "Return specific heat capacity at constant pressure"

      algorithm
        cp := cp_const;
      end specificHeatCapacityCp;

      redeclare function extends specificHeatCapacityCv
        "Return specific heat capacity at constant volume"

      algorithm
        cv := cv_const;
      end specificHeatCapacityCv;

      redeclare function extends isentropicExponent "Return isentropic exponent"

      algorithm
        gamma := cp_const/cv_const;
      end isentropicExponent;

      redeclare function extends velocityOfSound "Return velocity of sound"

      algorithm
        a := a_const;
      end velocityOfSound;

      redeclare function specificEnthalpy_pTX
        "Return specific enthalpy from p, T, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input Temperature T "Temperature";
        input MassFraction X[nX] "Mass fractions";
        output SpecificEnthalpy h "Specific enthalpy";
      algorithm
        h := cp_const*(T - T0);
        annotation (Documentation(info="<html>
<p>
This function computes the specific enthalpy of the fluid, but neglects the (small) influence of the pressure term p/d.
</p>
</html>"));
      end specificEnthalpy_pTX;

      redeclare function temperature_phX
        "Return temperature from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[nX] "Mass fractions";
        output Temperature T "Temperature";
      algorithm
        T := T0 + h/cp_const;
      end temperature_phX;

      redeclare function density_phX "Return density from p, h, and X or Xi"
        extends Modelica.Icons.Function;
        input AbsolutePressure p "Pressure";
        input SpecificEnthalpy h "Specific enthalpy";
        input MassFraction X[nX] "Mass fractions";
        output Density d "Density";
      algorithm
        d := density(setState_phX(
                p,
                h,
                X));
      end density_phX;

      redeclare function extends specificInternalEnergy
        "Return specific internal energy"
        extends Modelica.Icons.Function;
      algorithm
        //  u := cv_const*(state.T - T0) - reference_p/d_const;
        u := cv_const*(state.T - T0);
        annotation (Documentation(info="<html>
<p>
This function computes the specific internal energy of the fluid, but neglects the (small) influence of the pressure term p/d.
</p>
</html>"));
      end specificInternalEnergy;

      redeclare function extends specificEntropy "Return specific entropy"
        extends Modelica.Icons.Function;
      algorithm
        s := cv_const*Modelica.Math.log(state.T/T0);
      end specificEntropy;

      redeclare function extends specificGibbsEnergy
        "Return specific Gibbs energy"
        extends Modelica.Icons.Function;
      algorithm
        g := specificEnthalpy(state) - state.T*specificEntropy(state);
      end specificGibbsEnergy;

      redeclare function extends specificHelmholtzEnergy
        "Return specific Helmholtz energy"
        extends Modelica.Icons.Function;
      algorithm
        f := specificInternalEnergy(state) - state.T*specificEntropy(state);
      end specificHelmholtzEnergy;

      redeclare function extends isentropicEnthalpy "Return isentropic enthalpy"
      algorithm
        h_is := cp_const*(temperature(refState) - T0);
      end isentropicEnthalpy;

      redeclare function extends isobaricExpansionCoefficient
        "Returns overall the isobaric expansion coefficient beta"
      algorithm
        beta := 0.0;
      end isobaricExpansionCoefficient;

      redeclare function extends isothermalCompressibility
        "Returns overall the isothermal compressibility factor"
      algorithm
        kappa := 0;
      end isothermalCompressibility;

      redeclare function extends density_derp_T
        "Returns the partial derivative of density with respect to pressure at constant temperature"
      algorithm
        ddpT := 0;
      end density_derp_T;

      redeclare function extends density_derT_p
        "Returns the partial derivative of density with respect to temperature at constant pressure"
      algorithm
        ddTp := 0;
      end density_derT_p;

      redeclare function extends density_derX
        "Returns the partial derivative of density with respect to mass fractions at constant pressure and temperature"
      algorithm
        dddX := fill(0, nX);
      end density_derX;

      redeclare function extends molarMass "Return the molar mass of the medium"
      algorithm
        MM := MM_const;
      end molarMass;
    end PartialSimpleMedium;

    package Choices "Types, constants to define menu choices"
      extends Modelica.Icons.Package;

      type IndependentVariables = enumeration(
        T   "Temperature",
        pT   "Pressure, Temperature",
        ph   "Pressure, Specific Enthalpy",
        phX   "Pressure, Specific Enthalpy, Mass Fraction",
        pTX   "Pressure, Temperature, Mass Fractions",
        dTX   "Density, Temperature, Mass Fractions")
        "Enumeration defining the independent variables of a medium";

      type ReferenceEnthalpy = enumeration(
        ZeroAt0K
            "The enthalpy is 0 at 0 K (default), if the enthalpy of formation is excluded",
        ZeroAt25C
            "The enthalpy is 0 at 25 degC, if the enthalpy of formation is excluded",
        UserDefined
            "The user-defined reference enthalpy is used at 293.15 K (25 degC)")
        "Enumeration defining the reference enthalpy of a medium" annotation (
          Evaluate=true);
      annotation (Documentation(info="<html>
<p>
Enumerations and data types for all types of fluids
</p>

<p>
Note: Reference enthalpy might have to be extended with enthalpy of formation.
</p>
</html>"));
    end Choices;

    package Types "Types to be used in fluid models"
      extends Modelica.Icons.Package;

      type AbsolutePressure = SI.AbsolutePressure (
          min=0,
          max=1.e8,
          nominal=1.e5,
          start=1.e5)
        "Type for absolute pressure with medium specific attributes";

      type Density = SI.Density (
          min=0,
          max=1.e5,
          nominal=1,
          start=1) "Type for density with medium specific attributes";

      type DynamicViscosity = SI.DynamicViscosity (
          min=0,
          max=1.e8,
          nominal=1.e-3,
          start=1.e-3)
        "Type for dynamic viscosity with medium specific attributes";

      type EnthalpyFlowRate = SI.EnthalpyFlowRate (
          nominal=1000.0,
          min=-1.0e8,
          max=1.e8) "Type for enthalpy flow rate with medium specific attributes";

      type MassFraction = Real (
          quantity="MassFraction",
          final unit="kg/kg",
          min=0,
          max=1,
          nominal=0.1) "Type for mass fraction with medium specific attributes";

      type MoleFraction = Real (
          quantity="MoleFraction",
          final unit="mol/mol",
          min=0,
          max=1,
          nominal=0.1) "Type for mole fraction with medium specific attributes";

      type MolarMass = SI.MolarMass (
          min=0.001,
          max=0.25,
          nominal=0.032) "Type for molar mass with medium specific attributes";

      type MolarVolume = SI.MolarVolume (
          min=1e-6,
          max=1.0e6,
          nominal=1.0) "Type for molar volume with medium specific attributes";

      type IsentropicExponent = SI.RatioOfSpecificHeatCapacities (
          min=1,
          max=500000,
          nominal=1.2,
          start=1.2)
        "Type for isentropic exponent with medium specific attributes";

      type SpecificEnergy = SI.SpecificEnergy (
          min=-1.0e8,
          max=1.e8,
          nominal=1.e6)
        "Type for specific energy with medium specific attributes";

      type SpecificInternalEnergy = SpecificEnergy
        "Type for specific internal energy with medium specific attributes";

      type SpecificEnthalpy = SI.SpecificEnthalpy (
          min=-1.0e10,
          max=1.e10,
          nominal=1.e6)
        "Type for specific enthalpy with medium specific attributes";

      type SpecificEntropy = SI.SpecificEntropy (
          min=-1.e7,
          max=1.e7,
          nominal=1.e3)
        "Type for specific entropy with medium specific attributes";

      type SpecificHeatCapacity = SI.SpecificHeatCapacity (
          min=0,
          max=1.e7,
          nominal=1.e3,
          start=1.e3)
        "Type for specific heat capacity with medium specific attributes";

      type Temperature = SI.Temperature (
          min=1,
          max=1.e4,
          nominal=300,
          start=288.15) "Type for temperature with medium specific attributes";

      type ThermalConductivity = SI.ThermalConductivity (
          min=0,
          max=500,
          nominal=1,
          start=1)
        "Type for thermal conductivity with medium specific attributes";

      type PrandtlNumber = SI.PrandtlNumber (
          min=1e-3,
          max=1e5,
          nominal=1.0) "Type for Prandtl number with medium specific attributes";

      type VelocityOfSound = SI.Velocity (
          min=0,
          max=1.e5,
          nominal=1000,
          start=1000)
        "Type for velocity of sound with medium specific attributes";

      type ExtraProperty = Real (min=0.0, start=1.0)
        "Type for unspecified, mass-specific property transported by flow";

      type ExtraPropertyFlowRate = Real (unit="kg/s")
        "Type for flow rate of unspecified, mass-specific property";

      type IsobaricExpansionCoefficient = Real (
          min=0,
          max=1.0e8,
          unit="1/K")
        "Type for isobaric expansion coefficient with medium specific attributes";

      type DipoleMoment = Real (
          min=0.0,
          max=2.0,
          unit="debye",
          quantity="ElectricDipoleMoment")
        "Type for dipole moment with medium specific attributes";

      type DerDensityByPressure = SI.DerDensityByPressure
        "Type for partial derivative of density with respect to pressure with medium specific attributes";

      type DerDensityByEnthalpy = SI.DerDensityByEnthalpy
        "Type for partial derivative of density with respect to enthalpy with medium specific attributes";

      type DerDensityByTemperature = SI.DerDensityByTemperature
        "Type for partial derivative of density with respect to temperature with medium specific attributes";

      package Basic
      "The most basic version of a record used in several degrees of detail"
        extends Icons.Package;

        record FluidConstants
          "Critical, triple, molecular and other standard data of fluid"
          extends Modelica.Icons.Record;
          String iupacName
            "Complete IUPAC name (or common name, if non-existent)";
          String casRegistryNumber
            "Chemical abstracts sequencing number (if it exists)";
          String chemicalFormula
            "Chemical formula, (brutto, nomenclature according to Hill";
          String structureFormula "Chemical structure formula";
          MolarMass molarMass "Molar mass";
        end FluidConstants;
      end Basic;

      package IdealGas
      "The ideal gas version of a record used in several degrees of detail"
        extends Icons.Package;

        record FluidConstants "Extended fluid constants"
          extends Modelica.Media.Interfaces.Types.Basic.FluidConstants;
          Temperature criticalTemperature "Critical temperature";
          AbsolutePressure criticalPressure "Critical pressure";
          MolarVolume criticalMolarVolume "Critical molar Volume";
          Real acentricFactor "Pitzer acentric factor";
          //   Temperature triplePointTemperature "Triple point temperature";
          //   AbsolutePressure triplePointPressure "Triple point pressure";
          Temperature meltingPoint "Melting point at 101325 Pa";
          Temperature normalBoilingPoint "Normal boiling point (at 101325 Pa)";
          DipoleMoment dipoleMoment
            "Dipole moment of molecule in Debye (1 debye = 3.33564e10-30 C.m)";
          Boolean hasIdealGasHeatCapacity=false
            "True if ideal gas heat capacity is available";
          Boolean hasCriticalData=false "True if critical data are known";
          Boolean hasDipoleMoment=false "True if a dipole moment known";
          Boolean hasFundamentalEquation=false "True if a fundamental equation";
          Boolean hasLiquidHeatCapacity=false
            "True if liquid heat capacity is available";
          Boolean hasSolidHeatCapacity=false
            "True if solid heat capacity is available";
          Boolean hasAccurateViscosityData=false
            "True if accurate data for a viscosity function is available";
          Boolean hasAccurateConductivityData=false
            "True if accurate data for thermal conductivity is available";
          Boolean hasVapourPressureCurve=false
            "True if vapour pressure data, e.g., Antoine coefficients are known";
          Boolean hasAcentricFactor=false
            "True if Pitzer acentric factor is known";
          SpecificEnthalpy HCRIT0=0.0
            "Critical specific enthalpy of the fundamental equation";
          SpecificEntropy SCRIT0=0.0
            "Critical specific entropy of the fundamental equation";
          SpecificEnthalpy deltah=0.0
            "Difference between specific enthalpy model (h_m) and f.eq. (h_f) (h_m - h_f)";
          SpecificEntropy deltas=0.0
            "Difference between specific enthalpy model (s_m) and f.eq. (s_f) (s_m - s_f)";
        end FluidConstants;
      end IdealGas;
    end Types;
    annotation (Documentation(info="<html>
<p>
This package provides basic interfaces definitions of media models for different
kind of media.
</p>
</html>"));
  end Interfaces;

  package Common
    "Data structures and fundamental functions for fluid properties"
    extends Modelica.Icons.Package;

    function smoothStep
      "Approximation of a general step, such that the characteristic is continuous and differentiable"
      extends Modelica.Icons.Function;
      input Real x "Abscissa value";
      input Real y1 "Ordinate value for x > 0";
      input Real y2 "Ordinate value for x < 0";
      input Real x_small(min=0) = 1e-5
        "Approximation of step for -x_small <= x <= x_small; x_small > 0 required";
      output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
    algorithm
      y := smooth(1, if x > x_small then y1 else if x < -x_small then y2 else if
        abs(x_small) > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2 - y1)/4 + (y1
         + y2)/2 else (y1 + y2)/2);

      annotation (
        Inline=true,
        smoothOrder=1,
        Documentation(revisions="<html>
<ul>
<li><em>April 29, 2008</em>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br>
    Designed and implemented.</li>
<li><em>August 12, 2008</em>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",   info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <strong>if</strong> x &gt; 0 <strong>then</strong> y1 <strong>else</strong> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <strong>smooth</strong>(1, <strong>if</strong> x &gt;  x_small <strong>then</strong> y1 <strong>else</strong>
                 <strong>if</strong> x &lt; -x_small <strong>then</strong> y2 <strong>else</strong> f(y1, y2));
</pre>

<p>
In the region -x_small &lt; x &lt; x_small a 2nd order polynomial is used
for a smooth transition from y1 to y2.
</p>

<p>
If <strong>mass fractions</strong> X[:] are approximated with this function then this can be performed
for all <strong>nX</strong> mass fractions, instead of applying it for nX-1 mass fractions and computing
the last one by the mass fraction constraint sum(X)=1. The reason is that the approximating function has the
property that sum(X) = 1, provided sum(X_a) = sum(X_b) = 1
(and y1=X_a[i], y2=X_b[i]).
This can be shown by evaluating the approximating function in the abs(x) &lt; x_small
region (otherwise X is either X_a or X_b):
</p>

<pre>
    X[1]  = smoothStep(x, X_a[1] , X_b[1] , x_small);
    X[2]  = smoothStep(x, X_a[2] , X_b[2] , x_small);
       ...
    X[nX] = smoothStep(x, X_a[nX], X_b[nX], x_small);
</pre>

<p>
or
</p>

<pre>
    X[1]  = c*(X_a[1]  - X_b[1])  + (X_a[1]  + X_b[1])/2
    X[2]  = c*(X_a[2]  - X_b[2])  + (X_a[2]  + X_b[2])/2;
       ...
    X[nX] = c*(X_a[nX] - X_b[nX]) + (X_a[nX] + X_b[nX])/2;
    c     = (x/x_small)*((x/x_small)^2 - 3)/4
</pre>

<p>
Summing all mass fractions together results in
</p>

<pre>
    sum(X) = c*(sum(X_a) - sum(X_b)) + (sum(X_a) + sum(X_b))/2
           = c*(1 - 1) + (1 + 1)/2
           = 1
</pre>
</html>"));
    end smoothStep;

    package OneNonLinearEquation
      "Determine solution of a non-linear algebraic equation in one unknown without derivatives in a reliable and efficient way"
      extends Modelica.Icons.Package;

      replaceable record f_nonlinear_Data
        "Data specific for function f_nonlinear"
        extends Modelica.Icons.Record;
      end f_nonlinear_Data;

      replaceable partial function f_nonlinear
        "Nonlinear algebraic equation in one unknown: y = f_nonlinear(x,p,X)"
        extends Modelica.Icons.Function;
        input Real x "Independent variable of function";
        input Real p=0.0 "Disregarded variables (here always used for pressure)";
        input Real[:] X=fill(0, 0)
          "Disregarded variables (her always used for composition)";
        input f_nonlinear_Data f_nonlinear_data
          "Additional data for the function";
        output Real y "= f_nonlinear(x)";
        // annotation(derivative(zeroDerivative=y)); // this must hold for all replaced functions
      end f_nonlinear;

      replaceable function solve
        "Solve f_nonlinear(x_zero)=y_zero; f_nonlinear(x_min) - y_zero and f_nonlinear(x_max)-y_zero must have different sign"
        import Modelica.Utilities.Streams.error;
        extends Modelica.Icons.Function;
        input Real y_zero
          "Determine x_zero, such that f_nonlinear(x_zero) = y_zero";
        input Real x_min "Minimum value of x";
        input Real x_max "Maximum value of x";
        input Real pressure=0.0
          "Disregarded variables (here always used for pressure)";
        input Real[:] X=fill(0, 0)
          "Disregarded variables (here always used for composition)";
        input f_nonlinear_Data f_nonlinear_data
          "Additional data for function f_nonlinear";
        input Real x_tol=100*Modelica.Constants.eps
          "Relative tolerance of the result";
        output Real x_zero "f_nonlinear(x_zero) = y_zero";
    protected
        constant Real eps=Modelica.Constants.eps "Machine epsilon";
        constant Real x_eps=1e-10
          "Slight modification of x_min, x_max, since x_min, x_max are usually exactly at the borders T_min/h_min and then small numeric noise may make the interval invalid";
        Real x_min2=x_min - x_eps;
        Real x_max2=x_max + x_eps;
        Real a=x_min2 "Current best minimum interval value";
        Real b=x_max2 "Current best maximum interval value";
        Real c "Intermediate point a <= c <= b";
        Real d;
        Real e "b - a";
        Real m;
        Real s;
        Real p;
        Real q;
        Real r;
        Real tol;
        Real fa "= f_nonlinear(a) - y_zero";
        Real fb "= f_nonlinear(b) - y_zero";
        Real fc;
        Boolean found=false;
      algorithm
        // Check that f(x_min) and f(x_max) have different sign
        fa := f_nonlinear(
                x_min2,
                pressure,
                X,
                f_nonlinear_data) - y_zero;
        fb := f_nonlinear(
                x_max2,
                pressure,
                X,
                f_nonlinear_data) - y_zero;
        fc := fb;
        if fa > 0.0 and fb > 0.0 or fa < 0.0 and fb < 0.0 then
          error(
            "The arguments x_min and x_max to OneNonLinearEquation.solve(..)\n"
             + "do not bracket the root of the single non-linear equation:\n" +
            "  x_min  = " + String(x_min2) + "\n" + "  x_max  = " + String(x_max2)
             + "\n" + "  y_zero = " + String(y_zero) + "\n" +
            "  fa = f(x_min) - y_zero = " + String(fa) + "\n" +
            "  fb = f(x_max) - y_zero = " + String(fb) + "\n" +
            "fa and fb must have opposite sign which is not the case");
        end if;

        // Initialize variables
        c := a;
        fc := fa;
        e := b - a;
        d := e;

        // Search loop
        while not found loop
          if abs(fc) < abs(fb) then
            a := b;
            b := c;
            c := a;
            fa := fb;
            fb := fc;
            fc := fa;
          end if;

          tol := 2*eps*abs(b) + x_tol;
          m := (c - b)/2;

          if abs(m) <= tol or fb == 0.0 then
            // root found (interval is small enough)
            found := true;
            x_zero := b;
          else
            // Determine if a bisection is needed
            if abs(e) < tol or abs(fa) <= abs(fb) then
              e := m;
              d := e;
            else
              s := fb/fa;
              if a == c then
                // linear interpolation
                p := 2*m*s;
                q := 1 - s;
              else
                // inverse quadratic interpolation
                q := fa/fc;
                r := fb/fc;
                p := s*(2*m*q*(q - r) - (b - a)*(r - 1));
                q := (q - 1)*(r - 1)*(s - 1);
              end if;

              if p > 0 then
                q := -q;
              else
                p := -p;
              end if;

              s := e;
              e := d;
              if 2*p < 3*m*q - abs(tol*q) and p < abs(0.5*s*q) then
                // interpolation successful
                d := p/q;
              else
                // use bi-section
                e := m;
                d := e;
              end if;
            end if;

            // Best guess value is defined as "a"
            a := b;
            fa := fb;
            b := b + (if abs(d) > tol then d else if m > 0 then tol else -tol);
            fb := f_nonlinear(
                    b,
                    pressure,
                    X,
                    f_nonlinear_data) - y_zero;

            if fb > 0 and fc > 0 or fb < 0 and fc < 0 then
              // initialize variables
              c := a;
              fc := fa;
              e := b - a;
              d := e;
            end if;
          end if;
        end while;
      end solve;

      annotation (Documentation(info="<html>
<p>
This function should currently only be used in Modelica.Media,
since it might be replaced in the future by another strategy,
where the tool is responsible for the solution of the non-linear
equation.
</p>

<p>
This library determines the solution of one non-linear algebraic equation \"y=f(x)\"
in one unknown \"x\" in a reliable way. As input, the desired value y of the
non-linear function has to be given, as well as an interval x_min, x_max that
contains the solution, i.e., \"f(x_min) - y\" and \"f(x_max) - y\" must
have a different sign. If possible, a smaller interval is computed by
inverse quadratic interpolation (interpolating with a quadratic polynomial
through the last 3 points and computing the zero). If this fails,
bisection is used, which always reduces the interval by a factor of 2.
The inverse quadratic interpolation method has superlinear convergence.
This is roughly the same convergence rate as a globally convergent Newton
method, but without the need to compute derivatives of the non-linear
function. The solver function is a direct mapping of the Algol 60 procedure
\"zero\" to Modelica, from:
</p>

<dl>
<dt> Brent R.P.:</dt>
<dd> <strong>Algorithms for Minimization without derivatives</strong>.
     Prentice Hall, 1973, pp. 58-59.</dd>
</dl>

<p>
Due to current limitations of the
Modelica language (not possible to pass a function reference to a function),
the construction to use this solver on a user-defined function is a bit
complicated (this method is from Hans Olsson, Dassault Syst&egrave;mes AB). A user has to
provide a package in the following way:
</p>

<pre>
  <strong>package</strong> MyNonLinearSolver
    <strong>extends</strong> OneNonLinearEquation;

    <strong>redeclare record extends</strong> Data
      // Define data to be passed to user function
      ...
    <strong>end</strong> Data;

    <strong>redeclare function extends</strong> f_nonlinear
    <strong>algorithm</strong>
       // Compute the non-linear equation: y = f(x, Data)
    <strong>end</strong> f_nonlinear;

    // Dummy definition that has to be present for current Dymola
    <strong>redeclare function extends</strong> solve
    <strong>end</strong> solve;
  <strong>end</strong> MyNonLinearSolver;

  x_zero = MyNonLinearSolver.solve(y_zero, x_min, x_max, data=data);
</pre>
</html>"));
    end OneNonLinearEquation;
    annotation (Documentation(info="<html><h4>Package description</h4>
      <p>Package Modelica.Media.Common provides records and functions shared by many of the property sub-packages.
      High accuracy fluid property models share a lot of common structure, even if the actual models are different.
      Common data structures and computations shared by these property models are collected in this library.
   </p>

</html>",   revisions="<html>
      <ul>
      <li>First implemented: <em>July, 2000</em>
      by Hubertus Tummescheit
      for the ThermoFluid Library with help from Jonas Eborn and Falko Jens Wagner
      </li>
      <li>Code reorganization, enhanced documentation, additional functions: <em>December, 2002</em>
      by Hubertus Tummescheit and move to Modelica
                            properties library.</li>
      <li>Inclusion into Modelica.Media: September 2003</li>
      </ul>

      <address>Author: Hubertus Tummescheit,<br>
      Lund University<br>
      Department of Automatic Control<br>
      Box 118, 22100 Lund, Sweden<br>
      email: hubertus@control.lth.se
      </address>
</html>"));
  end Common;

    package Air "Medium models for air"
        extends Modelica.Icons.VariantsPackage;

      package MoistAir "Air: Moist air model (190 ... 647 K)"
        extends Interfaces.PartialCondensingGases(
          mediumName="Moist air",
          substanceNames={"water","air"},
          final reducedX=true,
          final singleState=false,
          reference_X={0.01,0.99},
          fluidConstants={IdealGases.Common.FluidData.H2O,IdealGases.Common.FluidData.N2},
          Temperature(min=190, max=647));
        import Modelica.Media.IdealGases.Common.Functions;

        constant Integer Water=1
          "Index of water (in substanceNames, massFractions X, etc.)";

        constant Integer Air=2
          "Index of air (in substanceNames, massFractions X, etc.)";

        constant Real k_mair=steam.MM/dryair.MM "Ratio of molar weights";

        constant IdealGases.Common.DataRecord dryair=IdealGases.Common.SingleGasesData.Air;

        constant IdealGases.Common.DataRecord steam=IdealGases.Common.SingleGasesData.H2O;

        constant SI.MolarMass[2] MMX={steam.MM,dryair.MM}
          "Molar masses of components";
        import Modelica.Media.Interfaces;
        import Modelica.Math;
        import Modelica.Constants;
        import Modelica.Media.IdealGases.Common.SingleGasNasa;
        import Modelica.Media.Interfaces.Choices.ReferenceEnthalpy;

        redeclare record extends ThermodynamicState
          "ThermodynamicState record for moist air"
        end ThermodynamicState;

        redeclare replaceable model extends BaseProperties(
          T(stateSelect=if preferredMediumStates then StateSelect.prefer else
                StateSelect.default),
          p(stateSelect=if preferredMediumStates then StateSelect.prefer else
                StateSelect.default),
          Xi(each stateSelect=if preferredMediumStates then StateSelect.prefer
                 else StateSelect.default),
          final standardOrderComponents=true) "Moist air base properties record"

          /* p, T, X = X[Water] are used as preferred states, since only then all
     other quantities can be computed in a recursive sequence.
     If other variables are selected as states, static state selection
     is no longer possible and non-linear algebraic equations occur.
      */
          MassFraction x_water "Mass of total water/mass of dry air";
          Real phi "Relative humidity";

      protected
          MassFraction X_liquid "Mass fraction of liquid or solid water";
          MassFraction X_steam "Mass fraction of steam water";
          MassFraction X_air "Mass fraction of air";
          MassFraction X_sat
            "Steam water mass fraction of saturation boundary in kg_water/kg_moistair";
          MassFraction x_sat
            "Steam water mass content of saturation boundary in kg_water/kg_dryair";
          AbsolutePressure p_steam_sat "partial saturation pressure of steam";
        equation
          assert(T >= 190 and T <= 647, "
Temperature T is not in the allowed range
190.0 K <= (T ="     + String(T) + " K) <= 647.0 K
required from medium model \""     + mediumName + "\".");
          MM = 1/(Xi[Water]/MMX[Water] + (1.0 - Xi[Water])/MMX[Air]);

          p_steam_sat = min(saturationPressure(T), 0.999*p);
          X_sat = min(p_steam_sat*k_mair/max(100*Constants.eps, p - p_steam_sat)*(1
             - Xi[Water]), 1.0)
            "Water content at saturation with respect to actual water content";
          X_liquid = max(Xi[Water] - X_sat, 0.0);
          X_steam = Xi[Water] - X_liquid;
          X_air = 1 - Xi[Water];

          h = specificEnthalpy_pTX(
                p,
                T,
                Xi);
          R = dryair.R*(X_air/(1 - X_liquid)) + steam.R*X_steam/(1 - X_liquid);
          //
          u = h - R*T;
          d = p/(R*T);
          /* Note, u and d are computed under the assumption that the volume of the liquid
         water is negligible with respect to the volume of air and of steam
      */
          state.p = p;
          state.T = T;
          state.X = X;

          // these x are per unit mass of DRY air!
          x_sat = k_mair*p_steam_sat/max(100*Constants.eps, p - p_steam_sat);
          x_water = Xi[Water]/max(X_air, 100*Constants.eps);
          phi = p/p_steam_sat*Xi[Water]/(Xi[Water] + k_mair*X_air);
          annotation (Documentation(info="<html>
<p>This model computes thermodynamic properties of moist air from three independent (thermodynamic or/and numerical) state variables. Preferred numerical states are temperature T, pressure p and the reduced composition vector Xi, which contains the water mass fraction only. As an EOS the <strong>ideal gas law</strong> is used and associated restrictions apply. The model can also be used in the <strong>fog region</strong>, when moisture is present in its liquid state. However, it is assumed that the liquid water volume is negligible compared to that of the gas phase. Computation of thermal properties is based on property data of <a href=\"modelica://Modelica.Media.Air.DryAirNasa\"> dry air</a> and water (source: VDI-W&auml;rmeatlas), respectively. Besides the standard thermodynamic variables <strong>absolute and relative humidity</strong>, x_water and phi, respectively, are given by the model. Upper case X denotes absolute humidity with respect to mass of moist air while absolute humidity with respect to mass of dry air only is denoted by a lower case x throughout the model. See <a href=\"modelica://Modelica.Media.Air.MoistAir\">package description</a> for further information.</p>
</html>"));
        end BaseProperties;

        redeclare function setState_pTX
          "Return thermodynamic state as function of pressure p, temperature T and composition X"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input Temperature T "Temperature";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "Thermodynamic state";
        algorithm
          state := if size(X, 1) == nX then ThermodynamicState(
                p=p,
                T=T,
                X=X) else ThermodynamicState(
                p=p,
                T=T,
                X=cat(
                  1,
                  X,
                  {1 - sum(X)}));
          annotation (smoothOrder=2, Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from pressure p, temperature T and composition X.
</html>"));
        end setState_pTX;

        redeclare function setState_phX
          "Return thermodynamic state as function of pressure p, specific enthalpy h and composition X"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "Thermodynamic state";
        algorithm
          state := if size(X, 1) == nX then ThermodynamicState(
                p=p,
                T=T_phX(
                  p,
                  h,
                  X),
                X=X) else ThermodynamicState(
                p=p,
                T=T_phX(
                  p,
                  h,
                  X),
                X=cat(
                  1,
                  X,
                  {1 - sum(X)}));
          annotation (smoothOrder=2, Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from pressure p, specific enthalpy h and composition X.
</html>"));
        end setState_phX;

        redeclare function setState_dTX
          "Return thermodynamic state as function of density d, temperature T and composition X"
          extends Modelica.Icons.Function;
          input Density d "Density";
          input Temperature T "Temperature";
          input MassFraction X[:]=reference_X "Mass fractions";
          output ThermodynamicState state "Thermodynamic state";
        algorithm
          state := if size(X, 1) == nX then ThermodynamicState(
                p=d*({steam.R,dryair.R}*X)*T,
                T=T,
                X=X) else ThermodynamicState(
                p=d*({steam.R,dryair.R}*cat(
                  1,
                  X,
                  {1 - sum(X)}))*T,
                T=T,
                X=cat(
                  1,
                  X,
                  {1 - sum(X)}));
          annotation (smoothOrder=2, Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from density d, temperature T and composition X.
</html>"));
        end setState_dTX;

        redeclare function extends setSmoothState
          "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
        algorithm
          state := ThermodynamicState(
                p=Media.Common.smoothStep(
                  x,
                  state_a.p,
                  state_b.p,
                  x_small),
                T=Media.Common.smoothStep(
                  x,
                  state_a.T,
                  state_b.T,
                  x_small),
                X=Media.Common.smoothStep(
                  x,
                  state_a.X,
                  state_b.X,
                  x_small));
        end setSmoothState;

        redeclare function extends gasConstant
          "Return ideal gas constant as a function from thermodynamic state, only valid for phi<1"

        algorithm
          R := dryair.R*(1 - state.X[Water]) + steam.R*state.X[Water];
          annotation (smoothOrder=2, Documentation(info="<html>
The ideal gas constant for moist air is computed from <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state</a> assuming that all water is in the gas phase.
</html>"));
        end gasConstant;

        function saturationPressureLiquid
          "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 647.096 K"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "Saturation temperature";
          output SI.AbsolutePressure psat "Saturation pressure";
      protected
          SI.Temperature Tcritical=647.096 "Critical temperature";
          SI.AbsolutePressure pcritical=22.064e6 "Critical pressure";
          Real r1=(1 - Tsat/Tcritical) "Common subexpression";
          Real a[:]={-7.85951783,1.84408259,-11.7866497,22.6807411,-15.9618719,
              1.80122502} "Coefficients a[:]";
          Real n[:]={1.0,1.5,3.0,3.5,4.0,7.5} "Coefficients n[:]";
        algorithm
          psat := exp(((a[1]*r1^n[1] + a[2]*r1^n[2] + a[3]*r1^n[3] + a[4]*r1^n[4]
             + a[5]*r1^n[5] + a[6]*r1^n[6])*Tcritical)/Tsat)*pcritical;
          annotation (
            derivative=saturationPressureLiquid_der,
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
<p>Saturation pressure of water above the triple point temperature is computed from temperature.</p>
<p>Source: A Saul, W Wagner: &quot;International equations for the saturation properties of ordinary water substance&quot;, equation 2.1</p>
</html>"));
        end saturationPressureLiquid;

        function saturationPressureLiquid_der
          "Derivative function for 'saturationPressureLiquid'"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "Saturation temperature";
          input Real dTsat(unit="K/s") "Saturation temperature derivative";
          output Real psat_der(unit="Pa/s") "Saturation pressure derivative";
      protected
          SI.Temperature Tcritical=647.096 "Critical temperature";
          SI.AbsolutePressure pcritical=22.064e6 "Critical pressure";
          Real r1=(1 - Tsat/Tcritical) "Common subexpression 1";
          Real r1_der=-1/Tcritical*dTsat "Derivative of common subexpression 1";
          Real a[:]={-7.85951783,1.84408259,-11.7866497,22.6807411,-15.9618719,
              1.80122502} "Coefficients a[:]";
          Real n[:]={1.0,1.5,3.0,3.5,4.0,7.5} "Coefficients n[:]";
          Real r2=(a[1]*r1^n[1] + a[2]*r1^n[2] + a[3]*r1^n[3] + a[4]*r1^n[4] + a[5]
              *r1^n[5] + a[6]*r1^n[6]) "Common subexpression 2";
        algorithm
          // Approach used here is based on Baehr: "Thermodynamik", 12th edition p.204ff, "Method of Wagner"
          //psat := exp(((a[1]*r1^n[1] + a[2]*r1^n[2] + a[3]*r1^n[3] + a[4]*r1^n[4] + a[5]*r1^n[5] + a[6]*r1^n[6])*Tcritical)/Tsat) * pcritical;
          psat_der := exp((r2*Tcritical)/Tsat)*pcritical*((a[1]*(r1^(n[1] - 1)*n[1]
            *r1_der) + a[2]*(r1^(n[2] - 1)*n[2]*r1_der) + a[3]*(r1^(n[3] - 1)*n[3]*
            r1_der) + a[4]*(r1^(n[4] - 1)*n[4]*r1_der) + a[5]*(r1^(n[5] - 1)*n[5]*
            r1_der) + a[6]*(r1^(n[6] - 1)*n[6]*r1_der))*Tcritical/Tsat - r2*
            Tcritical*dTsat/Tsat^2);
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
<p>Saturation pressure of water above the triple point temperature is computed from temperature.</p>
<p>Source: A Saul, W Wagner: &quot;International equations for the saturation properties of ordinary water substance&quot;, equation 2.1</p>
</html>"));
        end saturationPressureLiquid_der;

        function sublimationPressureIce
          "Return sublimation pressure of water as a function of temperature T between 190 and 273.16 K"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "Sublimation temperature";
          output SI.AbsolutePressure psat "Sublimation pressure";
      protected
          SI.Temperature Ttriple=273.16 "Triple point temperature";
          SI.AbsolutePressure ptriple=611.657 "Triple point pressure";
          Real r1=Tsat/Ttriple "Common subexpression";
          Real a[:]={-13.9281690,34.7078238} "Coefficients a[:]";
          Real n[:]={-1.5,-1.25} "Coefficients n[:]";
        algorithm
          psat := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*ptriple;
          annotation (
            Inline=false,
            smoothOrder=5,
            derivative=sublimationPressureIce_der,
            Documentation(info="<html>
<p>Sublimation pressure of water below the triple point temperature is computed from temperature.</p>
<p>Source: W Wagner, A Saul, A Pruss: &quot;International equations for the pressure along the melting and along the sublimation curve of ordinary water substance&quot;, equation 3.5</p>
</html>"));
        end sublimationPressureIce;

        function sublimationPressureIce_der
          "Derivative function for 'sublimationPressureIce'"

          extends Modelica.Icons.Function;
          input SI.Temperature Tsat "Sublimation temperature";
          input Real dTsat(unit="K/s") "Sublimation temperature derivative";
          output Real psat_der(unit="Pa/s") "Sublimation pressure derivative";
      protected
          SI.Temperature Ttriple=273.16 "Triple point temperature";
          SI.AbsolutePressure ptriple=611.657 "Triple point pressure";
          Real r1=Tsat/Ttriple "Common subexpression 1";
          Real r1_der=dTsat/Ttriple "Derivative of common subexpression 1";
          Real a[:]={-13.9281690,34.7078238} "Coefficients a[:]";
          Real n[:]={-1.5,-1.25} "Coefficients n[:]";
        algorithm
          //psat := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2]) * ptriple;
          psat_der := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*ptriple*(-(a[1]
            *(r1^(n[1] - 1)*n[1]*r1_der)) - (a[2]*(r1^(n[2] - 1)*n[2]*r1_der)));
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
<p>Sublimation pressure of water below the triple point temperature is computed from temperature.</p>
<p>Source: W Wagner, A Saul, A Pruss: &quot;International equations for the pressure along the melting and along the sublimation curve of ordinary water substance&quot;, equation 3.5</p>
</html>"));
        end sublimationPressureIce_der;

        redeclare function extends saturationPressure
          "Return saturation pressure of water as a function of temperature T between 190 and 647.096 K"

        algorithm
          psat := Utilities.spliceFunction(
                saturationPressureLiquid(Tsat),
                sublimationPressureIce(Tsat),
                Tsat - 273.16,
                1.0);
          annotation (
            Inline=false,
            smoothOrder=5,
            derivative=saturationPressure_der,
            Documentation(info="<html>
Saturation pressure of water in the liquid and the solid region is computed using correlations. Functions for the
<a href=\"modelica://Modelica.Media.Air.MoistAir.sublimationPressureIce\">solid</a> and the <a href=\"modelica://Modelica.Media.Air.MoistAir.saturationPressureLiquid\"> liquid</a> region, respectively, are combined using the first derivative continuous <a href=\"modelica://Modelica.Media.Air.MoistAir.Utilities.spliceFunction\">spliceFunction</a>. This functions range of validity is from 190 to 647.096 K. For more information on the type of correlation used, see the documentation of the linked functions.
</html>"));
        end saturationPressure;

        function saturationPressure_der
          "Derivative function for 'saturationPressure'"
          extends Modelica.Icons.Function;
          input Temperature Tsat "Saturation temperature";
          input Real dTsat(unit="K/s") "Time derivative of saturation temperature";
          output Real psat_der(unit="Pa/s") "Saturation pressure";

        algorithm
          /*psat := Utilities.spliceFunction(saturationPressureLiquid(Tsat),sublimationPressureIce(Tsat),Tsat-273.16,1.0);*/
          psat_der := Utilities.spliceFunction_der(
                saturationPressureLiquid(Tsat),
                sublimationPressureIce(Tsat),
                Tsat - 273.16,
                1.0,
                saturationPressureLiquid_der(Tsat=Tsat, dTsat=dTsat),
                sublimationPressureIce_der(Tsat=Tsat, dTsat=dTsat),
                dTsat,
                0);
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
Derivative function of <a href=\"modelica://Modelica.Media.Air.MoistAir.saturationPressure\">saturationPressure</a>
</html>"));
        end saturationPressure_der;

        redeclare function extends enthalpyOfVaporization
          "Return enthalpy of vaporization of water as a function of temperature T, 273.16 to 647.096 K"

      protected
          Real Tcritical=647.096 "Critical temperature";
          Real dcritical=322 "Critical density";
          Real pcritical=22.064e6 "Critical pressure";
          Real n[:]={1,1.5,3,3.5,4,7.5} "Powers in equation (1)";
          Real a[:]={-7.85951783,1.84408259,-11.7866497,22.6807411,-15.9618719,
              1.80122502} "Coefficients in equation (1) of [1]";
          Real m[:]={1/3,2/3,5/3,16/3,43/3,110/3} "Powers in equation (2)";
          Real b[:]={1.99274064,1.09965342,-0.510839303,-1.75493479,-45.5170352,-6.74694450e5}
            "Coefficients in equation (2) of [1]";
          Real o[:]={2/6,4/6,8/6,18/6,37/6,71/6} "Powers in equation (3)";
          Real c[:]={-2.03150240,-2.68302940,-5.38626492,-17.2991605,-44.7586581,-63.9201063}
            "Coefficients in equation (3) of [1]";
          Real tau=1 - T/Tcritical "Temperature expression";
          Real r1=(a[1]*Tcritical*tau^n[1])/T + (a[2]*Tcritical*tau^n[2])/T + (a[3]
              *Tcritical*tau^n[3])/T + (a[4]*Tcritical*tau^n[4])/T + (a[5]*
              Tcritical*tau^n[5])/T + (a[6]*Tcritical*tau^n[6])/T "Expression 1";
          Real r2=a[1]*n[1]*tau^n[1] + a[2]*n[2]*tau^n[2] + a[3]*n[3]*tau^n[3] + a[
              4]*n[4]*tau^n[4] + a[5]*n[5]*tau^n[5] + a[6]*n[6]*tau^n[6]
            "Expression 2";
          Real dp=dcritical*(1 + b[1]*tau^m[1] + b[2]*tau^m[2] + b[3]*tau^m[3] + b[
              4]*tau^m[4] + b[5]*tau^m[5] + b[6]*tau^m[6])
            "Density of saturated liquid";
          Real dpp=dcritical*exp(c[1]*tau^o[1] + c[2]*tau^o[2] + c[3]*tau^o[3] + c[
              4]*tau^o[4] + c[5]*tau^o[5] + c[6]*tau^o[6])
            "Density of saturated vapor";
        algorithm
          r0 := -(((dp - dpp)*exp(r1)*pcritical*(r2 + r1*tau))/(dp*dpp*tau))
            "Difference of equations (7) and (6)";
          annotation (
            smoothOrder=2,
            Documentation(info="<html>
<p>Enthalpy of vaporization of water is computed from temperature in the region of 273.16 to 647.096 K.</p>
<p>Source: W Wagner, A Pruss: \"International equations for the saturation properties of ordinary water substance. Revised according to the international temperature scale of 1990\" (1993).</p>
</html>"));
        end enthalpyOfVaporization;

        redeclare function extends enthalpyOfLiquid
          "Return enthalpy of liquid water as a function of temperature T(use enthalpyOfWater instead)"

        algorithm
          h := (T - 273.15)*1e3*(4.2166 - 0.5*(T - 273.15)*(0.0033166 + 0.333333*(T
             - 273.15)*(0.00010295 - 0.25*(T - 273.15)*(1.3819e-6 + 0.2*(T - 273.15)
            *7.3221e-9))));
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
Specific enthalpy of liquid water is computed from temperature using a polynomial approach. Kept for compatibility reasons, better use <a href=\"modelica://Modelica.Media.Air.MoistAir.enthalpyOfWater\">enthalpyOfWater</a> instead.
</html>"));
        end enthalpyOfLiquid;

        redeclare function extends enthalpyOfGas
          "Return specific enthalpy of gas (air and steam) as a function of temperature T and composition X"

        algorithm
          h := Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5)*X[Water] +
            Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684)*(1.0 - X[Water]);
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
Specific enthalpy of moist air is computed from temperature, provided all water is in the gaseous state. The first entry in the composition vector X must be the mass fraction of steam. For a function that also covers the fog region please refer to <a href=\"modelica://Modelica.Media.Air.MoistAir.h_pTX\">h_pTX</a>.
</html>"));
        end enthalpyOfGas;

        redeclare function extends enthalpyOfCondensingGas
          "Return specific enthalpy of steam as a function of temperature T"

        algorithm
          h := Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5);
          annotation (
            Inline=false,
            smoothOrder=5,
            Documentation(info="<html>
Specific enthalpy of steam is computed from temperature.
</html>"));
        end enthalpyOfCondensingGas;

        redeclare function extends enthalpyOfNonCondensingGas
          "Return specific enthalpy of dry air as a function of temperature T"

        algorithm
          h := Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684);
          annotation (
            Inline=false,
            smoothOrder=1,
            Documentation(info="<html>
Specific enthalpy of dry air is computed from temperature.
</html>"));
        end enthalpyOfNonCondensingGas;

        function enthalpyOfWater
          "Computes specific enthalpy of water (solid/liquid) near atmospheric pressure from temperature T"
          extends Modelica.Icons.Function;
          input SIunits.Temperature T "Temperature";
          output SIunits.SpecificEnthalpy h "Specific enthalpy of water";
        algorithm
          /*simple model assuming constant properties:
  heat capacity of liquid water:4200 J/kg
  heat capacity of solid water: 2050 J/kg
  enthalpy of fusion (liquid=>solid): 333000 J/kg*/

          h := Utilities.spliceFunction(
                4200*(T - 273.15),
                2050*(T - 273.15) - 333000,
                T - 273.16,
                0.1);
          annotation (derivative=enthalpyOfWater_der, Documentation(info="<html>
Specific enthalpy of water (liquid and solid) is computed from temperature using constant properties as follows:<br>
<ul>
<li>  heat capacity of liquid water:4200 J/kg</li>
<li>  heat capacity of solid water: 2050 J/kg</li>
<li>  enthalpy of fusion (liquid=>solid): 333000 J/kg</li>
</ul>
Pressure is assumed to be around 1 bar. This function is usually used to determine the specific enthalpy of the liquid or solid fraction of moist air.
</html>"));
        end enthalpyOfWater;

        function enthalpyOfWater_der "Derivative function of enthalpyOfWater"
          extends Modelica.Icons.Function;
          input SIunits.Temperature T "Temperature";
          input Real dT(unit="K/s") "Time derivative of temperature";
          output Real dh(unit="J/(kg.s)") "Time derivative of specific enthalpy";
        algorithm
          /*simple model assuming constant properties:
  heat capacity of liquid water:4200 J/kg
  heat capacity of solid water: 2050 J/kg
  enthalpy of fusion (liquid=>solid): 333000 J/kg*/

          //h:=Utilities.spliceFunction(4200*(T-273.15),2050*(T-273.15)-333000,T-273.16,0.1);
          dh := Utilities.spliceFunction_der(
                4200*(T - 273.15),
                2050*(T - 273.15) - 333000,
                T - 273.16,
                0.1,
                4200*dT,
                2050*dT,
                dT,
                0);
          annotation (Documentation(info="<html>
Derivative function for <a href=\"modelica://Modelica.Media.Air.MoistAir.enthalpyOfWater\">enthalpyOfWater</a>.

</html>"));
        end enthalpyOfWater_der;

        redeclare function extends pressure
          "Returns pressure of ideal gas as a function of the thermodynamic state record"

        algorithm
          p := state.p;
          annotation (smoothOrder=2, Documentation(info="<html>
Pressure is returned from the thermodynamic state record input as a simple assignment.
</html>"));
        end pressure;

        redeclare function extends temperature
          "Return temperature of ideal gas as a function of the thermodynamic state record"

        algorithm
          T := state.T;
          annotation (smoothOrder=2, Documentation(info="<html>
Temperature is returned from the thermodynamic state record input as a simple assignment.
</html>"));
        end temperature;

        function T_phX
          "Return temperature as a function of pressure p, specific enthalpy h and composition X"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          input MassFraction[:] X "Mass fractions of composition";
          output Temperature T "Temperature";

      protected
          package Internal
            "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
            extends Modelica.Media.Common.OneNonLinearEquation;
            redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
              extends Modelica.Media.IdealGases.Common.DataRecord;
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear
            algorithm
              y := h_pTX(
                        p,
                        x,
                        X);
            end f_nonlinear;

            // Dummy definition has to be added for current Dymola
            redeclare function extends solve
            end solve;
          end Internal;

        algorithm
          T := Internal.solve(
                h,
                190,
                647,
                p,
                X[1:nXi],
                steam);
          annotation (Documentation(info="<html>
Temperature is computed from pressure, specific enthalpy and composition via numerical inversion of function <a href=\"modelica://Modelica.Media.Air.MoistAir.h_pTX\">h_pTX</a>.
</html>"));
        end T_phX;

        redeclare function extends density
          "Returns density of ideal gas as a function of the thermodynamic state record"

        algorithm
          d := state.p/(gasConstant(state)*state.T);
          annotation (smoothOrder=2, Documentation(info="<html>
Density is computed from pressure, temperature and composition in the thermodynamic state record applying the ideal gas law.
</html>"));
        end density;

        redeclare function extends specificEnthalpy
          "Return specific enthalpy of moist air as a function of the thermodynamic state record"

        algorithm
          h := h_pTX(
                state.p,
                state.T,
                state.X);
          annotation (smoothOrder=2, Documentation(info="<html>
Specific enthalpy of moist air is computed from the thermodynamic state record. The fog region is included for both, ice and liquid fog.
</html>"));
        end specificEnthalpy;

        function h_pTX
          "Return specific enthalpy of moist air as a function of pressure p, temperature T and composition X"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          output SI.SpecificEnthalpy h "Specific enthalpy at p, T, X";
      protected
          SI.AbsolutePressure p_steam_sat "partial saturation pressure of steam";
          SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
          SI.MassFraction X_liquid "Mass fraction of liquid water";
          SI.MassFraction X_steam "Mass fraction of steam water";
          SI.MassFraction X_air "Mass fraction of air";
        algorithm
          p_steam_sat := saturationPressure(T);
          //p_steam_sat :=min(saturationPressure(T), 0.999*p);
          X_sat := min(p_steam_sat*k_mair/max(100*Constants.eps, p - p_steam_sat)*(
            1 - X[Water]), 1.0);
          X_liquid := max(X[Water] - X_sat, 0.0);
          X_steam := X[Water] - X_liquid;
          X_air := 1 - X[Water];
          /* h        := {SingleGasNasa.h_Tlow(data=steam,  T=T, refChoice=ReferenceEnthalpy.UserDefined, h_off=46479.819+2501014.5),
               SingleGasNasa.h_Tlow(data=dryair, T=T, refChoice=ReferenceEnthalpy.UserDefined, h_off=25104.684)}*
    {X_steam, X_air} + enthalpyOfLiquid(T)*X_liquid;*/
          h := {Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5),
            Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684)}*{X_steam,X_air} + enthalpyOfWater(T)*X_liquid;
          annotation (
            derivative=h_pTX_der,
            Inline=false,
            Documentation(info="<html>
Specific enthalpy of moist air is computed from pressure, temperature and composition with X[1] as the total water mass fraction. The fog region is included for both, ice and liquid fog.
</html>"));
        end h_pTX;

        function h_pTX_der "Derivative function of h_pTX"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          input Real dp(unit="Pa/s") "Pressure derivative";
          input Real dT(unit="K/s") "Temperature derivative";
          input Real dX[:](each unit="1/s") "Composition derivative";
          output Real h_der(unit="J/(kg.s)") "Time derivative of specific enthalpy";
      protected
          SI.AbsolutePressure p_steam_sat "partial saturation pressure of steam";
          SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
          SI.MassFraction X_liquid "Mass fraction of liquid water";
          SI.MassFraction X_steam "Mass fraction of steam water";
          SI.MassFraction X_air "Mass fraction of air";
          SI.MassFraction x_sat
            "Absolute humidity per unit mass of dry air at saturation";
          Real dX_steam(unit="1/s") "Time derivative of steam mass fraction";
          Real dX_air(unit="1/s") "Time derivative of dry air mass fraction";
          Real dX_liq(unit="1/s")
            "Time derivative of liquid/solid water mass fraction";
          Real dps(unit="Pa/s") "Time derivative of saturation pressure";
          Real dx_sat(unit="1/s")
            "Time derivative of absolute humidity per unit mass of dry air";
        algorithm
          p_steam_sat := saturationPressure(T);
          x_sat := p_steam_sat*k_mair/max(100*Modelica.Constants.eps, p -
            p_steam_sat);
          X_sat := min(x_sat*(1 - X[Water]), 1.0);
          X_liquid := Utilities.smoothMax(
                X[Water] - X_sat,
                0.0,
                1e-5);
          X_steam := X[Water] - X_liquid;
          X_air := 1 - X[Water];

          dX_air := -dX[Water];
          dps := saturationPressure_der(Tsat=T, dTsat=dT);
          dx_sat := k_mair*(dps*(p - p_steam_sat) - p_steam_sat*(dp - dps))/(p -
            p_steam_sat)/(p - p_steam_sat);
          dX_liq := Utilities.smoothMax_der(
                X[Water] - X_sat,
                0.0,
                1e-5,
                (1 + x_sat)*dX[Water] - (1 - X[Water])*dx_sat,
                0,
                0);
          dX_steam := dX[Water] - dX_liq;

          h_der := X_steam*Modelica.Media.IdealGases.Common.Functions.h_Tlow_der(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5,
                dT=dT) + dX_steam*Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5) + X_air*
            Modelica.Media.IdealGases.Common.Functions.h_Tlow_der(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684,
                dT=dT) + dX_air*Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684) + X_liquid*enthalpyOfWater_der(T=T, dT=dT) +
            dX_liq*enthalpyOfWater(T);

          annotation (
            Inline=false,
            smoothOrder=1,
            Documentation(info="<html>
Derivative function for <a href=\"modelica://Modelica.Media.Air.MoistAir.h_pTX\">h_pTX</a>.
</html>"));
        end h_pTX_der;

        redeclare function extends isentropicExponent
          "Return isentropic exponent (only for gas fraction!)"
        algorithm
          gamma := specificHeatCapacityCp(state)/specificHeatCapacityCv(state);
        end isentropicExponent;

        redeclare function extends specificInternalEnergy
          "Return specific internal energy of moist air as a function of the thermodynamic state record"
          extends Modelica.Icons.Function;
          output SI.SpecificInternalEnergy u "Specific internal energy";
        algorithm
          u := specificInternalEnergy_pTX(
                state.p,
                state.T,
                state.X);

          annotation (smoothOrder=2, Documentation(info="<html>
Specific internal energy is determined from the thermodynamic state record, assuming that the liquid or solid water volume is negligible.
</html>"));
        end specificInternalEnergy;

        function specificInternalEnergy_pTX
          "Return specific internal energy of moist air as a function of pressure p, temperature T and composition X"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          output SI.SpecificInternalEnergy u "Specific internal energy";
      protected
          SI.AbsolutePressure p_steam_sat "partial saturation pressure of steam";
          SI.MassFraction X_liquid "Mass fraction of liquid water";
          SI.MassFraction X_steam "Mass fraction of steam water";
          SI.MassFraction X_air "Mass fraction of air";
          SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
          Real R_gas "Ideal gas constant";
        algorithm
          p_steam_sat := saturationPressure(T);
          X_sat := min(p_steam_sat*k_mair/max(100*Constants.eps, p - p_steam_sat)*(
            1 - X[Water]), 1.0);
          X_liquid := max(X[Water] - X_sat, 0.0);
          X_steam := X[Water] - X_liquid;
          X_air := 1 - X[Water];
          R_gas := dryair.R*X_air/(1 - X_liquid) + steam.R*X_steam/(1 - X_liquid);
          u := X_steam*Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5) + X_air*
            Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684) + enthalpyOfWater(T)*X_liquid - R_gas*T;

          annotation (derivative=specificInternalEnergy_pTX_der, Documentation(info=
                 "<html>
Specific internal energy is determined from pressure p, temperature T and composition X, assuming that the liquid or solid water volume is negligible.
</html>"));
        end specificInternalEnergy_pTX;

        function specificInternalEnergy_pTX_der
          "Derivative function for specificInternalEnergy_pTX"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          input Real dp(unit="Pa/s") "Pressure derivative";
          input Real dT(unit="K/s") "Temperature derivative";
          input Real dX[:](each unit="1/s") "Mass fraction derivatives";
          output Real u_der(unit="J/(kg.s)") "Specific internal energy derivative";
      protected
          SI.AbsolutePressure p_steam_sat "partial saturation pressure of steam";
          SI.MassFraction X_liquid "Mass fraction of liquid water";
          SI.MassFraction X_steam "Mass fraction of steam water";
          SI.MassFraction X_air "Mass fraction of air";
          SI.MassFraction X_sat "Absolute humidity per unit mass of moist air";
          SI.SpecificHeatCapacity R_gas "Ideal gas constant";

          SI.MassFraction x_sat
            "Absolute humidity per unit mass of dry air at saturation";
          Real dX_steam(unit="1/s") "Time derivative of steam mass fraction";
          Real dX_air(unit="1/s") "Time derivative of dry air mass fraction";
          Real dX_liq(unit="1/s")
            "Time derivative of liquid/solid water mass fraction";
          Real dps(unit="Pa/s") "Time derivative of saturation pressure";
          Real dx_sat(unit="1/s")
            "Time derivative of absolute humidity per unit mass of dry air";
          Real dR_gas(unit="J/(kg.K.s)") "Time derivative of ideal gas constant";
        algorithm
          p_steam_sat := saturationPressure(T);
          x_sat := p_steam_sat*k_mair/max(100*Modelica.Constants.eps, p -
            p_steam_sat);
          X_sat := min(x_sat*(1 - X[Water]), 1.0);
          X_liquid := Utilities.spliceFunction(
                X[Water] - X_sat,
                0.0,
                X[Water] - X_sat,
                1e-6);
          X_steam := X[Water] - X_liquid;
          X_air := 1 - X[Water];
          R_gas := steam.R*X_steam/(1 - X_liquid) + dryair.R*X_air/(1 - X_liquid);

          dX_air := -dX[Water];
          dps := saturationPressure_der(Tsat=T, dTsat=dT);
          dx_sat := k_mair*(dps*(p - p_steam_sat) - p_steam_sat*(dp - dps))/(p -
            p_steam_sat)/(p - p_steam_sat);
          dX_liq := Utilities.spliceFunction_der(
                X[Water] - X_sat,
                0.0,
                X[Water] - X_sat,
                1e-6,
                (1 + x_sat)*dX[Water] - (1 - X[Water])*dx_sat,
                0.0,
                (1 + x_sat)*dX[Water] - (1 - X[Water])*dx_sat,
                0.0);
          dX_steam := dX[Water] - dX_liq;
          dR_gas := (steam.R*(dX_steam*(1 - X_liquid) + dX_liq*X_steam) + dryair.R*
            (dX_air*(1 - X_liquid) + dX_liq*X_air))/(1 - X_liquid)/(1 - X_liquid);

          u_der := X_steam*Modelica.Media.IdealGases.Common.Functions.h_Tlow_der(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5,
                dT=dT) + dX_steam*Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=steam,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=46479.819 + 2501014.5) + X_air*
            Modelica.Media.IdealGases.Common.Functions.h_Tlow_der(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684,
                dT=dT) + dX_air*Modelica.Media.IdealGases.Common.Functions.h_Tlow(
                data=dryair,
                T=T,
                refChoice=ReferenceEnthalpy.UserDefined,
                h_off=25104.684) + X_liquid*enthalpyOfWater_der(T=T, dT=dT) +
            dX_liq*enthalpyOfWater(T) - dR_gas*T - R_gas*dT;
          annotation (Documentation(info="<html>
Derivative function for <a href=\"modelica://Modelica.Media.Air.MoistAir.specificInternalEnergy_pTX\">specificInternalEnergy_pTX</a>.
</html>"));
        end specificInternalEnergy_pTX_der;

        redeclare function extends specificEntropy
          "Return specific entropy from thermodynamic state record, only valid for phi<1"

        algorithm
          s := s_pTX(
                state.p,
                state.T,
                state.X);
          annotation (
            Inline=false,
            smoothOrder=2,
            Documentation(info="<html>
Specific entropy is calculated from the thermodynamic state record, assuming ideal gas behavior and including entropy of mixing. Liquid or solid water is not taken into account, the entire water content X[1] is assumed to be in the vapor state (relative humidity below 1.0).
</html>"));
        end specificEntropy;

        redeclare function extends specificGibbsEnergy
          "Return specific Gibbs energy as a function of the thermodynamic state record, only valid for phi<1"
          extends Modelica.Icons.Function;
        algorithm
          g := h_pTX(
                state.p,
                state.T,
                state.X) - state.T*specificEntropy(state);
          annotation (smoothOrder=2, Documentation(info="<html>
The Gibbs Energy is computed from the thermodynamic state record for moist air with a water content below saturation.
</html>"));
        end specificGibbsEnergy;

        redeclare function extends specificHelmholtzEnergy
          "Return specific Helmholtz energy as a function of the thermodynamic state record, only valid for phi<1"
          extends Modelica.Icons.Function;
        algorithm
          f := h_pTX(
                state.p,
                state.T,
                state.X) - gasConstant(state)*state.T - state.T*specificEntropy(
            state);
          annotation (smoothOrder=2, Documentation(info="<html>
The Specific Helmholtz Energy is computed from the thermodynamic state record for moist air with a water content below saturation.
</html>"));
        end specificHelmholtzEnergy;

        redeclare function extends specificHeatCapacityCp
          "Return specific heat capacity at constant pressure as a function of the thermodynamic state record"

      protected
          Real dT(unit="s/K") = 1.0;
        algorithm
          cp := h_pTX_der(
                state.p,
                state.T,
                state.X,
                0.0,
                1.0,
                zeros(size(state.X, 1)))*dT "Definition of cp: dh/dT @ constant p";
          //      cp:= SingleGasNasa.cp_Tlow(dryair, state.T)*(1-state.X[Water])
          //        + SingleGasNasa.cp_Tlow(steam, state.T)*state.X[Water];
          annotation (
            Inline=false,
            smoothOrder=2,
            Documentation(info="<html>
The specific heat capacity at constant pressure <strong>cp</strong> is computed from temperature and composition for a mixture of steam (X[1]) and dry air. All water is assumed to be in the vapor state.
</html>"));
        end specificHeatCapacityCp;

        redeclare function extends specificHeatCapacityCv
          "Return specific heat capacity at constant volume as a function of the thermodynamic state record"

        algorithm
          cv := Modelica.Media.IdealGases.Common.Functions.cp_Tlow(dryair, state.T)
            *(1 - state.X[Water]) +
            Modelica.Media.IdealGases.Common.Functions.cp_Tlow(steam, state.T)*
            state.X[Water] - gasConstant(state);
          annotation (
            Inline=false,
            smoothOrder=2,
            Documentation(info="<html>
The specific heat capacity at constant density <strong>cv</strong> is computed from temperature and composition for a mixture of steam (X[1]) and dry air. All water is assumed to be in the vapor state.
</html>"));
        end specificHeatCapacityCv;

      redeclare function extends dynamicViscosity
          "Return dynamic viscosity as a function of the thermodynamic state record, valid from 123.15 K to 1273.15 K"

        import Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
      algorithm
        eta := 1e-6*Polynomials_Temp.evaluateWithRange(
            {9.7391102886305869E-15,-3.1353724870333906E-11,4.3004876595642225E-08,
            -3.8228016291758240E-05,5.0427874367180762E-02,1.7239260139242528E+01},
            Cv.to_degC(123.15),
            Cv.to_degC(1273.15),
            Cv.to_degC(state.T));
        annotation (smoothOrder=2, Documentation(info="<html>
<p>Dynamic viscosity is computed from temperature using a simple polynomial for dry air. Range of validity is from 123.15 K to 1273.15 K. The influence of pressure and moisture is neglected.</p>
<p>Source: VDI Waermeatlas, 8th edition.</p>
</html>"));
      end dynamicViscosity;

      redeclare function extends thermalConductivity
          "Return thermal conductivity as a function of the thermodynamic state record, valid from 123.15 K to 1273.15 K"
        import Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
        import Cv = Modelica.SIunits.Conversions;
      algorithm
        lambda := 1e-3*Polynomials_Temp.evaluateWithRange(
            {6.5691470817717812E-15,-3.4025961923050509E-11,5.3279284846303157E-08,
            -4.5340839289219472E-05,7.6129675309037664E-02,2.4169481088097051E+01},
            Cv.to_degC(123.15),
            Cv.to_degC(1273.15),
            Cv.to_degC(state.T));

        annotation (smoothOrder=2, Documentation(info="<html>
<p>Thermal conductivity is computed from temperature using a simple polynomial for dry air. Range of validity is from 123.15 K to 1273.15 K. The influence of pressure and moisture is neglected.</p>
<p>Source: VDI Waermeatlas, 8th edition.</p>
</html>"));
      end thermalConductivity;

        redeclare function extends velocityOfSound
        algorithm
          a := sqrt(isentropicExponent(state)*gasConstant(state)*temperature(state));
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end velocityOfSound;

        redeclare function extends isobaricExpansionCoefficient

        algorithm
          beta := 1/temperature(state);
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end isobaricExpansionCoefficient;

        redeclare function extends isothermalCompressibility

        algorithm
          kappa := 1/pressure(state);
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end isothermalCompressibility;

        redeclare function extends density_derp_h

        algorithm
          ddph := 1/(gasConstant(state)*temperature(state));

          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end density_derp_h;

        redeclare function extends density_derh_p

        algorithm
          ddhp := -density(state)/(specificHeatCapacityCp(state)*temperature(state));
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end density_derh_p;

        redeclare function extends density_derp_T

        algorithm
          ddpT := 1/(gasConstant(state)*temperature(state));

          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end density_derp_T;

        redeclare function extends density_derT_p

        algorithm
          ddTp := -density(state)/temperature(state);
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end density_derT_p;

        redeclare function extends density_derX

        algorithm
          dddX[Water] := pressure(state)*(steam.R - dryair.R)/((steam.R - dryair.R)
            *state.X[Water]*temperature(state) + dryair.R*temperature(state))^2;
          dddX[Air] := pressure(state)*(dryair.R - steam.R)/((dryair.R - steam.R)*
            state.X[Air]*temperature(state) + steam.R*temperature(state))^2;

          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end density_derX;

        redeclare function extends molarMass
        algorithm
          MM := Modelica.Constants.R/Modelica.Media.Air.MoistAir.gasConstant(state);
          annotation (Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end molarMass;

        function T_psX
          "Return temperature as a function of pressure p, specific entropy s and composition X"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEntropy s "Specific entropy";
          input MassFraction[:] X "Mass fractions of composition";
          output Temperature T "Temperature";

      protected
          package Internal "Solve s(data,T) for T with given s"
            extends Modelica.Media.Common.OneNonLinearEquation;
            redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
              extends Modelica.Media.IdealGases.Common.DataRecord;
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear
            algorithm
              y := s_pTX(
                        p,
                        x,
                        X);
            end f_nonlinear;

            // Dummy definition has to be added for current Dymola
            redeclare function extends solve
            end solve;
          end Internal;

        algorithm
          T := Internal.solve(
                s,
                190,
                647,
                p,
                X[1:nX],
                steam);
          annotation (Documentation(info="<html>
Temperature is computed from pressure, specific entropy and composition via numerical inversion of function <a href=\"modelica://Modelica.Media.Air.MoistAir.specificEntropy\">specificEntropy</a>.
</html>",     revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end T_psX;

        redeclare function extends setState_psX
        algorithm
          state := if size(X, 1) == nX then ThermodynamicState(
                p=p,
                T=T_psX(
                  p,
                  s,
                  X),
                X=X) else ThermodynamicState(
                p=p,
                T=T_psX(
                  p,
                  s,
                  X),
                X=cat(
                  1,
                  X,
                  {1 - sum(X)}));
          annotation (smoothOrder=2, Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state record</a> is computed from pressure p, specific enthalpy h and composition X.
</html>",     revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end setState_psX;

        function s_pTX
          "Return specific entropy of moist air as a function of pressure p, temperature T and composition X (only valid for phi<1)"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          output SI.SpecificEntropy s "Specific entropy at p, T, X";
      protected
          MoleFraction[2] Y=massToMoleFractions(X, {steam.MM,dryair.MM})
            "Molar fraction";

        algorithm
          s := Modelica.Media.IdealGases.Common.Functions.s0_Tlow(dryair, T)*(1 - X[
            Water]) + Modelica.Media.IdealGases.Common.Functions.s0_Tlow(steam, T)*
            X[Water] - Modelica.Constants.R*(Utilities.smoothMax(
                X[Water]/MMX[Water]*Modelica.Math.log(max(Y[Water], Modelica.Constants.eps)
              *p/reference_p),
                0.0,
                1e-9) - Utilities.smoothMax(
                (1 - X[Water])/MMX[Air]*Modelica.Math.log(max(Y[Air], Modelica.Constants.eps)
              *p/reference_p),
                0.0,
                1e-9));
          annotation (
            derivative=s_pTX_der,
            Inline=false,
            Documentation(info="<html>
Specific entropy of moist air is computed from pressure, temperature and composition with X[1] as the total water mass fraction.
</html>",     revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"),  Icon(graphics={Text(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,127,0},
                  textString="f")}));
        end s_pTX;

        function s_pTX_der
          "Return specific entropy of moist air as a function of pressure p, temperature T and composition X (only valid for phi<1)"
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input SI.MassFraction X[:] "Mass fractions of moist air";
          input Real dp(unit="Pa/s") "Derivative of pressure";
          input Real dT(unit="K/s") "Derivative of temperature";
          input Real dX[nX](each unit="1/s") "Derivative of mass fractions";
          output Real ds(unit="J/(kg.K.s)") "Specific entropy at p, T, X";
      protected
          MoleFraction[2] Y=massToMoleFractions(X, {steam.MM,dryair.MM})
            "Molar fraction";

        algorithm
          ds := Modelica.Media.IdealGases.Common.Functions.s0_Tlow_der(
                dryair,
                T,
                dT)*(1 - X[Water]) +
            Modelica.Media.IdealGases.Common.Functions.s0_Tlow_der(
                steam,
                T,
                dT)*X[Water] + Modelica.Media.IdealGases.Common.Functions.s0_Tlow(
            dryair, T)*dX[Air] + Modelica.Media.IdealGases.Common.Functions.s0_Tlow(
            steam, T)*dX[Water] - Modelica.Constants.R*(1/MMX[Water]*
            Utilities.smoothMax_der(
                X[Water]*Modelica.Math.log(max(Y[Water], Modelica.Constants.eps)*p/
              reference_p),
                0.0,
                1e-9,
                (Modelica.Math.log(max(Y[Water], Modelica.Constants.eps)*p/
              reference_p) + (X[Water]/Y[Water]*(X[Air]*MMX[Water]/(X[Air]*MMX[
              Water] + X[Water]*MMX[Air])^2)))*dX[Water] + X[Water]*reference_p/p*
              dp,
                0,
                0) - 1/MMX[Air]*Utilities.smoothMax_der(
                (1 - X[Water])*Modelica.Math.log(max(Y[Air], Modelica.Constants.eps)
              *p/reference_p),
                0.0,
                1e-9,
                (Modelica.Math.log(max(Y[Air], Modelica.Constants.eps)*p/
              reference_p) + (X[Air]/Y[Air]*(X[Water]*MMX[Air]/(X[Air]*MMX[Water]
               + X[Water]*MMX[Air])^2)))*dX[Air] + X[Air]*reference_p/p*dp,
                0,
                0));
          annotation (
            Inline=false,
            smoothOrder=1,
            Documentation(info="<html>
Specific entropy of moist air is computed from pressure, temperature and composition with X[1] as the total water mass fraction.
</html>",     revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"),  Icon(graphics={Text(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,127,0},
                  textString="f")}));
        end s_pTX_der;

        redeclare function extends isentropicEnthalpy
          "Isentropic enthalpy (only valid for phi<1)"
          extends Modelica.Icons.Function;
        algorithm
          h_is := Modelica.Media.Air.MoistAir.h_pTX(
                p_downstream,
                Modelica.Media.Air.MoistAir.T_psX(
                  p_downstream,
                  Modelica.Media.Air.MoistAir.specificEntropy(refState),
                  refState.X),
                refState.X);

          annotation (Icon(graphics={Text(
                  extent={{-100,100},{100,-100}},
                  lineColor={255,127,0},
                  textString="f")}), Documentation(revisions="<html>
<p>2012-01-12        Stefan Wischhusen: Initial Release.</p>
</html>"));
        end isentropicEnthalpy;

        package Utilities "Utility functions"
          extends Modelica.Icons.UtilitiesPackage;

          function spliceFunction "Spline interpolation of two functions"
            extends Modelica.Icons.Function;
            input Real pos "Returned value for x-deltax >= 0";
            input Real neg "Returned value for x+deltax <= 0";
            input Real x "Function argument";
            input Real deltax=1 "Region around x with spline interpolation";
            output Real out;
        protected
            Real scaledX;
            Real scaledX1;
            Real y;
          algorithm
            scaledX1 := x/deltax;
            scaledX := scaledX1*Modelica.Math.asin(1);
            if scaledX1 <= -0.999999999 then
              y := 0;
            elseif scaledX1 >= 0.999999999 then
              y := 1;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
            end if;
            out := pos*y + (1 - y)*neg;
            annotation (derivative=spliceFunction_der);
          end spliceFunction;

          function spliceFunction_der "Derivative of spliceFunction"
            extends Modelica.Icons.Function;
            input Real pos;
            input Real neg;
            input Real x;
            input Real deltax=1;
            input Real dpos;
            input Real dneg;
            input Real dx;
            input Real ddeltax=0;
            output Real out;
        protected
            Real scaledX;
            Real scaledX1;
            Real dscaledX1;
            Real y;
          algorithm
            scaledX1 := x/deltax;
            scaledX := scaledX1*Modelica.Math.asin(1);
            dscaledX1 := (dx - scaledX1*ddeltax)/deltax;
            if scaledX1 <= -0.99999999999 then
              y := 0;
            elseif scaledX1 >= 0.9999999999 then
              y := 1;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
            end if;
            out := dpos*y + (1 - y)*dneg;
            if (abs(scaledX1) < 1) then
              out := out + (pos - neg)*dscaledX1*Modelica.Math.asin(1)/2/(
                Modelica.Math.cosh(Modelica.Math.tan(scaledX))*Modelica.Math.cos(
                scaledX))^2;
            end if;
          end spliceFunction_der;

          function smoothMax
            extends Modelica.Icons.Function;
            import Modelica.Math;

            input Real x1 "First argument of smooth max operator";
            input Real x2 "Second argument of smooth max operator";
            input Real dx
              "Approximate difference between x1 and x2, below which regularization starts";
            output Real y "Result of smooth max operator";
          algorithm
            y := max(x1, x2) + Math.log((exp((4/dx)*(x1 - max(x1, x2)))) + (exp((4/
              dx)*(x2 - max(x1, x2)))))/(4/dx);
            annotation (smoothOrder=2, Documentation(info="<html>
<p>An implementation of Kreisselmeier Steinhauser smooth maximum</p>
</html>"));
          end smoothMax;

          function smoothMax_der
            extends Modelica.Icons.Function;

            import Modelica.Math.exp;
            import Modelica.Math.log;

            input Real x1 "First argument of smooth max operator";
            input Real x2 "Second argument of smooth max operator";
            input Real dx
              "Approximate difference between x1 and x2, below which regularization starts";
            input Real dx1;
            input Real dx2;
            input Real ddx;
            output Real dy "Derivative of smooth max operator";
          algorithm
            dy := (if x1 > x2 then dx1 else dx2) + 0.25*(((4*(dx1 - (if x1 > x2
               then dx1 else dx2))/dx - 4*(x1 - max(x1, x2))*ddx/dx^2)*exp(4*(x1 -
              max(x1, x2))/dx) + (4*(dx2 - (if x1 > x2 then dx1 else dx2))/dx - 4*(
              x2 - max(x1, x2))*ddx/dx^2)*exp(4*(x2 - max(x1, x2))/dx))*dx/(exp(4*(
              x1 - max(x1, x2))/dx) + exp(4*(x2 - max(x1, x2))/dx)) + log(exp(4*(x1
               - max(x1, x2))/dx) + exp(4*(x2 - max(x1, x2))/dx))*ddx);

            annotation (Documentation(info="<html>
<p>An implementation of Kreisselmeier Steinhauser smooth maximum</p>
</html>"));
          end smoothMax_der;
        end Utilities;
        annotation (Documentation(info="<html>
<h4>Thermodynamic Model</h4>
<p>This package provides a full thermodynamic model of moist air including the fog region and temperatures below zero degC.
The governing assumptions in this model are:</p>
<ul>
<li>the perfect gas law applies</li>
<li>water volume other than that of steam is neglected</li></ul>
<p>All extensive properties are expressed in terms of the total mass in order to comply with other media in this library. However, for moist air it is rather common to express the absolute humidity in terms of mass of dry air only, which has advantages when working with charts. In addition, care must be taken, when working with mass fractions with respect to total mass, that all properties refer to the same water content when being used in mathematical operations (which is always the case if based on dry air only). Therefore two absolute humidities are computed in the <strong>BaseProperties</strong> model: <strong>X</strong> denotes the absolute humidity in terms of the total mass while <strong>x</strong> denotes the absolute humidity per unit mass of dry air. In addition, the relative humidity <strong>phi</strong> is also computed.</p>
<p>At the triple point temperature of water of 0.01 &deg;C or 273.16 K and a relative humidity greater than 1 fog may be present as liquid and as ice resulting in a specific enthalpy somewhere between those of the two isotherms for solid and liquid fog, respectively. For numerical reasons a coexisting mixture of 50% solid and 50% liquid fog is assumed in the fog region at the triple point in this model.</p>

<h4>Range of validity</h4>
<p>From the assumptions mentioned above it follows that the <strong>pressure</strong> should be in the region around <strong>atmospheric</strong> conditions or below (a few bars may still be fine though). Additionally a very high water content at low temperatures would yield incorrect densities, because the volume of the liquid or solid phase would not be negligible anymore. The model does not provide information on limits for water drop size in the fog region or transport information for the actual condensation or evaporation process in combination with surfaces. All excess water which is not in its vapour state is assumed to be still present in the air regarding its energy but not in terms of its spatial extent.<br><br>
The thermodynamic model may be used for <strong>temperatures</strong> ranging from <strong>190 ... 647 K</strong>. This holds for all functions unless otherwise stated in their description. However, although the model works at temperatures above the saturation temperature it is questionable to use the term \"relative humidity\" in this region. Please note, that although several functions compute pure water properties, they are designed to be used within the moist air medium model where properties are dominated by air and steam in their vapor states, and not for pure liquid water applications.</p>

<h4>Transport Properties</h4>
<p>Several additional functions that are not needed to describe the thermodynamic system, but are required to model transport processes, like heat and mass transfer, may be called. They usually neglect the moisture influence unless otherwise stated.</p>

<h4>Application</h4>
<p>The model's main area of application is all processes that involve moist air cooling under near atmospheric pressure with possible moisture condensation. This is the case in all domestic and industrial air conditioning applications. Another large domain of moist air applications covers all processes that deal with dehydration of bulk material using air as a transport medium. Engineering tasks involving moist air are often performed (or at least visualized) by using charts that contain all relevant thermodynamic data for a moist air system. These so called psychrometric charts can be generated from the medium properties in this package. The model <a href=\"modelica://Modelica.Media.Examples.PsychrometricData\">PsychrometricData</a> may be used for this purpose in order to obtain data for figures like those below (the plotting itself is not part of the model though).</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Media/Air/Mollier.png\"><br>
<img src=\"modelica://Modelica/Resources/Images/Media/Air/PsycroChart.png\">
</p>

<p>
<strong>Legend:</strong> blue - constant specific enthalpy, red - constant temperature, black - constant relative humidity</p>

</html>"));
      end MoistAir;
      annotation (Documentation(info="<html>
  <p>This package contains different medium models for air:</p>
<ul>
<li><strong>SimpleAir</strong><br>
    Simple dry air medium in a limited temperature range.</li>
<li><strong>DryAirNasa</strong><br>
    Dry air as an ideal gas from Media.IdealGases.MixtureGases.Air.</li>
<li><strong>MoistAir</strong><br>
    Moist air as an ideal gas mixture of steam and dry air with fog below and above the triple point temperature.</li>
</ul>
</html>"));
    end Air;

    package IdealGases
    "Data and models of ideal gases (single, fixed and dynamic mixtures) from NASA source"
      extends Modelica.Icons.VariantsPackage;

      package Common "Common packages and data for the ideal gas models"
      extends Modelica.Icons.Package;

      record DataRecord
        "Coefficient data record for properties of ideal gases based on NASA source"
        extends Modelica.Icons.Record;
        String name "Name of ideal gas";
        SI.MolarMass MM "Molar mass";
        SI.SpecificEnthalpy Hf "Enthalpy of formation at 298.15K";
        SI.SpecificEnthalpy H0 "H0(298.15K) - H0(0K)";
        SI.Temperature Tlimit "Temperature limit between low and high data sets";
        Real alow[7] "Low temperature coefficients a";
        Real blow[2] "Low temperature constants b";
        Real ahigh[7] "High temperature coefficients a";
        Real bhigh[2] "High temperature constants b";
        SI.SpecificHeatCapacity R "Gas constant";
        annotation (Documentation(info="<html>
<p>
This data record contains the coefficients for the
ideal gas equations according to:
</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>
<p>
The equations have the following structure:
</p>
<img src=\"modelica://Modelica/Resources/Images/Media/IdealGases/singleEquations.png\">
<p>
The polynomials for h(T) and s0(T) are derived via integration from the one for cp(T)  and contain the integration constants b1, b2 that define the reference specific enthalpy and entropy. For entropy differences the reference pressure p0 is arbitrary, but not for absolute entropies. It is chosen as 1 standard atmosphere (101325 Pa).
</p>
<p>
For most gases, the region of validity is from 200 K to 6000 K.
The equations are split into two regions that are separated
by Tlimit (usually 1000 K). In both regions the gas is described
by the data above. The two branches are continuous and in most
gases also differentiable at Tlimit.
</p>
</html>"));
      end DataRecord;

        package Functions
        "Basic Functions for ideal gases: cp, h, s, thermal conductivity, viscosity"
          extends Modelica.Icons.FunctionsPackage;

          constant Boolean excludeEnthalpyOfFormation=true
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";

          constant Modelica.Media.Interfaces.Choices.ReferenceEnthalpy referenceChoice=Modelica.Media.Interfaces.Choices.ReferenceEnthalpy.ZeroAt0K
            "Choice of reference enthalpy";

          constant Modelica.Media.Interfaces.Types.SpecificEnthalpy h_offset=0.0
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";

          constant Integer methodForThermalConductivity(min=1,max=2)=1;

          function cp_T
            "Compute specific heat capacity at constant pressure from temperature and gas data"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            output SI.SpecificHeatCapacity cp "Specific heat capacity at temperature T";
          algorithm
            cp := smooth(0,if T < data.Tlimit then data.R*(1/(T*T)*(data.alow[1] + T*(
              data.alow[2] + T*(1.*data.alow[3] + T*(data.alow[4] + T*(data.alow[5] + T
              *(data.alow[6] + data.alow[7]*T))))))) else data.R*(1/(T*T)*(data.ahigh[1]
               + T*(data.ahigh[2] + T*(1.*data.ahigh[3] + T*(data.ahigh[4] + T*(data.
              ahigh[5] + T*(data.ahigh[6] + data.ahigh[7]*T))))))));
            annotation (Inline=true,smoothOrder=2);
          end cp_T;

          function cp_Tlow
            "Compute specific heat capacity at constant pressure, low T region"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            output SI.SpecificHeatCapacity cp "Specific heat capacity at temperature T";
          algorithm
            cp := data.R*(1/(T*T)*(data.alow[1] + T*(
              data.alow[2] + T*(1.*data.alow[3] + T*(data.alow[4] + T*(data.alow[5] + T
              *(data.alow[6] + data.alow[7]*T)))))));
            annotation (Inline=false, derivative(zeroDerivative=data) = cp_Tlow_der);
          end cp_Tlow;

          function cp_Tlow_der
            "Compute specific heat capacity at constant pressure, low T region"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            input Real dT "Temperature derivative";
            output Real cp_der "Derivative of specific heat capacity";
          algorithm
            cp_der := dT*data.R/(T*T*T)*(-2*data.alow[1] + T*(
              -data.alow[2] + T*T*(data.alow[4] + T*(2.*data.alow[5] + T
              *(3.*data.alow[6] + 4.*data.alow[7]*T)))));
            annotation(smoothOrder=2);
          end cp_Tlow_der;

          function h_T "Compute specific enthalpy from temperature and gas data; reference is decided by the
    refChoice input, or by the referenceChoice package constant by default"
            import Modelica.Media.Interfaces.Choices;
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            input Boolean exclEnthForm=excludeEnthalpyOfFormation
              "If true, enthalpy of formation Hf is not included in specific enthalpy h";
            input Modelica.Media.Interfaces.Choices.ReferenceEnthalpy
                                            refChoice=referenceChoice
              "Choice of reference enthalpy";
            input SI.SpecificEnthalpy h_off=h_offset
              "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
            output SI.SpecificEnthalpy h "Specific enthalpy at temperature T";

          algorithm
            h := smooth(0,(if T < data.Tlimit then data.R*((-data.alow[1] + T*(data.
              blow[1] + data.alow[2]*Math.log(T) + T*(1.*data.alow[3] + T*(0.5*data.
              alow[4] + T*(1/3*data.alow[5] + T*(0.25*data.alow[6] + 0.2*data.alow[7]*T))))))
              /T) else data.R*((-data.ahigh[1] + T*(data.bhigh[1] + data.ahigh[2]*
              Math.log(T) + T*(1.*data.ahigh[3] + T*(0.5*data.ahigh[4] + T*(1/3*data.
              ahigh[5] + T*(0.25*data.ahigh[6] + 0.2*data.ahigh[7]*T))))))/T)) + (if
              exclEnthForm then -data.Hf else 0.0) + (if (refChoice
               == Choices.ReferenceEnthalpy.ZeroAt0K) then data.H0 else 0.0) + (if
              refChoice == Choices.ReferenceEnthalpy.UserDefined then h_off else
                    0.0));
            annotation (Inline=false,smoothOrder=2);
          end h_T;

          function h_Tlow "Compute specific enthalpy, low T region; reference is decided by the
    refChoice input, or by the referenceChoice package constant by default"
            import Modelica.Media.Interfaces.Choices;
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            input Boolean exclEnthForm=excludeEnthalpyOfFormation
              "If true, enthalpy of formation Hf is not included in specific enthalpy h";
            input Modelica.Media.Interfaces.Choices.ReferenceEnthalpy
                                            refChoice=referenceChoice
              "Choice of reference enthalpy";
            input SI.SpecificEnthalpy h_off=h_offset
              "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
            output SI.SpecificEnthalpy h "Specific enthalpy at temperature T";

          algorithm
            h := data.R*((-data.alow[1] + T*(data.
              blow[1] + data.alow[2]*Math.log(T) + T*(1.*data.alow[3] + T*(0.5*data.
              alow[4] + T*(1/3*data.alow[5] + T*(0.25*data.alow[6] + 0.2*data.alow[7]*T))))))
              /T) + (if
              exclEnthForm then -data.Hf else 0.0) + (if (refChoice
               == Choices.ReferenceEnthalpy.ZeroAt0K) then data.H0 else 0.0) + (if
              refChoice == Choices.ReferenceEnthalpy.UserDefined then h_off else
                    0.0);
            annotation(Inline=false,smoothOrder=2);
          end h_Tlow;

          function h_Tlow_der "Compute specific enthalpy, low T region; reference is decided by the
    refChoice input, or by the referenceChoice package constant by default"
            import Modelica.Media.Interfaces.Choices;
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            input Boolean exclEnthForm=excludeEnthalpyOfFormation
              "If true, enthalpy of formation Hf is not included in specific enthalpy h";
            input Modelica.Media.Interfaces.Choices.ReferenceEnthalpy
                                            refChoice=referenceChoice
              "Choice of reference enthalpy";
            input SI.SpecificEnthalpy h_off=h_offset
              "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
            input Real dT(unit="K/s") "Temperature derivative";
            output Real h_der(unit="J/(kg.s)")
              "Derivative of specific enthalpy at temperature T";
          algorithm
            h_der := dT*Modelica.Media.IdealGases.Common.Functions.cp_Tlow(
                                data,T);
            annotation(Inline=true,smoothOrder=2);
          end h_Tlow_der;

          function s0_T "Compute specific entropy from temperature and gas data"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            output SI.SpecificEntropy s "Specific entropy at temperature T";
          algorithm
            s := if T < data.Tlimit then data.R*(data.blow[2] - 0.5*data.alow[
              1]/(T*T) - data.alow[2]/T + data.alow[3]*Math.log(T) + T*(
              data.alow[4] + T*(0.5*data.alow[5] + T*(1/3*data.alow[6] + 0.25*data.alow[
              7]*T)))) else data.R*(data.bhigh[2] - 0.5*data.ahigh[1]/(T*T) - data.
              ahigh[2]/T + data.ahigh[3]*Math.log(T) + T*(data.ahigh[4]
               + T*(0.5*data.ahigh[5] + T*(1/3*data.ahigh[6] + 0.25*data.ahigh[7]*T))));
            annotation (Inline=true, smoothOrder=2);
          end s0_T;

          function s0_Tlow "Compute specific entropy, low T region"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            output SI.SpecificEntropy s "Specific entropy at temperature T";
          algorithm
            s := data.R*(data.blow[2] - 0.5*data.alow[
              1]/(T*T) - data.alow[2]/T + data.alow[3]*Math.log(T) + T*(
              data.alow[4] + T*(0.5*data.alow[5] + T*(1/3*data.alow[6] + 0.25*data.alow[
              7]*T))));
            annotation (Inline=true);
          end s0_Tlow;

          function s0_Tlow_der "Compute derivative of specific entropy, low T region"
            extends Modelica.Icons.Function;
            input IdealGases.Common.DataRecord data "Ideal gas data";
            input SI.Temperature T "Temperature";
            input Real T_der "Temperature derivative";
            output SI.SpecificEntropy s "Specific entropy at temperature T";
          algorithm
            s := data.R*(data.blow[2] - 0.5*data.alow[
              1]/(T*T) - data.alow[2]/T + data.alow[3]*Math.log(T) + T*(
              data.alow[4] + T*(0.5*data.alow[5] + T*(1/3*data.alow[6] + 0.25*data.alow[
              7]*T))));
            annotation (Inline=true);
          end s0_Tlow_der;

          function dynamicViscosityLowPressure
            "Dynamic viscosity of low pressure gases"
            extends Modelica.Icons.Function;
            input SI.Temp_K T "Gas temperature";
            input SI.Temp_K Tc "Critical temperature of gas";
            input SI.MolarMass M "Molar mass of gas";
            input SI.MolarVolume Vc "Critical molar volume of gas";
            input Real w "Acentric factor of gas";
            input Modelica.Media.Interfaces.Types.DipoleMoment mu
              "Dipole moment of gas molecule";
            input Real k =  0.0 "Special correction for highly polar substances";
            output SI.DynamicViscosity eta "Dynamic viscosity of gas";
        protected
            parameter Real Const1_SI=40.785*10^(-9.5)
              "Constant in formula for eta converted to SI units";
            parameter Real Const2_SI=131.3/1000.0
              "Constant in formula for mur converted to SI units";
            Real mur=Const2_SI*mu/sqrt(Vc*Tc)
              "Dimensionless dipole moment of gas molecule";
            Real Fc=1 - 0.2756*w + 0.059035*mur^4 + k
              "Factor to account for molecular shape and polarities of gas";
            Real Tstar "Dimensionless temperature defined by equation below";
            Real Ov "Viscosity collision integral for the gas";

          algorithm
            Tstar := 1.2593*T/Tc;
            Ov := 1.16145*Tstar^(-0.14874) + 0.52487*Modelica.Math.exp(-0.7732*Tstar) + 2.16178*Modelica.Math.exp(-2.43787
              *Tstar);
            eta := Const1_SI*Fc*sqrt(M*T)/(Vc^(2/3)*Ov);
            annotation (smoothOrder=2,
                        Documentation(info="<html>
<p>
The used formula are based on the method of Chung et al (1984, 1988) referred to in ref [1] chapter 9.
The formula 9-4.10 is the one being used. The Formula is given in non-SI units, the following conversion constants were used to
transform the formula to SI units:
</p>

<ul>
<li> <strong>Const1_SI:</strong> The factor 10^(-9.5) =10^(-2.5)*1e-7 where the
     factor 10^(-2.5) originates from the conversion of g/mol->kg/mol + cm^3/mol->m^3/mol
      and the factor 1e-7 is due to conversion from microPoise->Pa.s.</li>
<li>  <strong>Const2_SI:</strong> The factor 1/3.335641e-27 = 1e-3/3.335641e-30
      where the factor 3.335641e-30 comes from debye->C.m and
      1e-3 is due to conversion from cm^3/mol->m^3/mol</li>
</ul>

<h4>References:</h4>
<p>
[1] Bruce E. Poling, John E. Prausnitz, John P. O'Connell, \"The Properties of Gases and Liquids\" 5th Ed. Mc Graw Hill.
</p>

<h4>Author</h4>
<p>T. Skoglund, Lund, Sweden, 2004-08-31</p>

</html>"));
          end dynamicViscosityLowPressure;

          function thermalConductivityEstimate
            "Thermal conductivity of polyatomic gases (Eucken and Modified Eucken correlation)"
            extends Modelica.Icons.Function;
            input Modelica.Media.Interfaces.Types.SpecificHeatCapacity Cp
              "Constant pressure heat capacity";
            input Modelica.Media.Interfaces.Types.DynamicViscosity eta
              "Dynamic viscosity";
            input Integer method(min=1,max=2)=1
              "1: Eucken Method, 2: Modified Eucken Method";
            input IdealGases.Common.DataRecord data "Ideal gas data";
            output Modelica.Media.Interfaces.Types.ThermalConductivity lambda
              "Thermal conductivity [W/(m.k)]";
          algorithm
            lambda := if method == 1 then eta*(Cp - data.R + (9/4)*data.R)
                                     else eta*(Cp - data.R)*(1.32 + 1.77/((Cp/data.R) - 1.0));
            annotation (smoothOrder=2,
                        Documentation(info="<html>
<p>
This function provides two similar methods for estimating the
thermal conductivity of polyatomic gases.
The Eucken method (input method == 1) gives good results for low temperatures,
but it tends to give an underestimated value of the thermal conductivity
(lambda) at higher temperatures.<br>
The Modified Eucken method (input method == 2) gives good results for
high-temperatures, but it tends to give an overestimated value of the
thermal conductivity (lambda) at low temperatures.
</p>
</html>"));
          end thermalConductivityEstimate;
        end Functions;

      partial package SingleGasNasa
        "Medium model of an ideal gas based on NASA source"

        extends Interfaces.PartialPureSubstance(
           ThermoStates=Modelica.Media.Interfaces.Choices.IndependentVariables.pT,
           redeclare final record FluidConstants =
              Modelica.Media.Interfaces.Types.IdealGas.FluidConstants,
           mediumName=data.name,
           substanceNames={data.name},
           singleState=false,
           Temperature(min=200, max=6000, start=500, nominal=500),
           SpecificEnthalpy(start=if Functions.referenceChoice==ReferenceEnthalpy.ZeroAt0K then data.H0 else
              if Functions.referenceChoice==ReferenceEnthalpy.UserDefined then Functions.h_offset else 0, nominal=1.0e5),
           Density(start=10, nominal=10),
           AbsolutePressure(start=10e5, nominal=10e5));

        redeclare record extends ThermodynamicState
          "Thermodynamic state variables for ideal gases"
          AbsolutePressure p "Absolute pressure of medium";
          Temperature T "Temperature of medium";
        end ThermodynamicState;

        import Modelica.Math;
        import Modelica.Media.Interfaces.Choices.ReferenceEnthalpy;

        constant IdealGases.Common.DataRecord data
          "Data record of ideal gas substance";

        constant FluidConstants[nS] fluidConstants "Constant data for the fluid";

        redeclare model extends BaseProperties(
         T(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
         p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default))
          "Base properties of ideal gas medium"
        equation
          assert(T >= 200 and T <= 6000, "
Temperature T (= "       + String(T) + " K) is not in the allowed range
200 K <= T <= 6000 K required from medium model \""       + mediumName + "\".
");       MM = data.MM;
          R = data.R;
          h = Modelica.Media.IdealGases.Common.Functions.h_T(
                  data, T,
                  Modelica.Media.IdealGases.Common.Functions.excludeEnthalpyOfFormation,
                  Modelica.Media.IdealGases.Common.Functions.referenceChoice,
                  Modelica.Media.IdealGases.Common.Functions.h_offset);
          u = h - R*T;

          // Has to be written in the form d=f(p,T) in order that static
          // state selection for p and T is possible
          d = p/(R*T);
          // connect state with BaseProperties
          state.T = T;
          state.p = p;
        end BaseProperties;

          redeclare function setState_pTX
          "Return thermodynamic state as function of p, T and composition X"
            extends Modelica.Icons.Function;
            input AbsolutePressure p "Pressure";
            input Temperature T "Temperature";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=p,T=T);
            annotation(Inline=true,smoothOrder=2);
          end setState_pTX;

          redeclare function setState_phX
          "Return thermodynamic state as function of p, h and composition X"
            extends Modelica.Icons.Function;
            input AbsolutePressure p "Pressure";
            input SpecificEnthalpy h "Specific enthalpy";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=p,T=T_h(h));
            annotation(Inline=true,smoothOrder=2);
          end setState_phX;

          redeclare function setState_psX
          "Return thermodynamic state as function of p, s and composition X"
            extends Modelica.Icons.Function;
            input AbsolutePressure p "Pressure";
            input SpecificEntropy s "Specific entropy";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=p,T=T_ps(p,s));
            annotation(Inline=true,smoothOrder=2);
          end setState_psX;

          redeclare function setState_dTX
          "Return thermodynamic state as function of d, T and composition X"
            extends Modelica.Icons.Function;
            input Density d "Density";
            input Temperature T "Temperature";
            input MassFraction X[:]=reference_X "Mass fractions";
            output ThermodynamicState state;
          algorithm
            state := ThermodynamicState(p=d*data.R*T,T=T);
            annotation(Inline=true,smoothOrder=2);
          end setState_dTX;

            redeclare function extends setSmoothState
          "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
            algorithm
              state := ThermodynamicState(p=Media.Common.smoothStep(x, state_a.p, state_b.p, x_small),
                                          T=Media.Common.smoothStep(x, state_a.T, state_b.T, x_small));
              annotation(Inline=true,smoothOrder=2);
            end setSmoothState;

        redeclare function extends pressure "Return pressure of ideal gas"
        algorithm
          p := state.p;
          annotation(Inline=true,smoothOrder=2);
        end pressure;

        redeclare function extends temperature "Return temperature of ideal gas"
        algorithm
          T := state.T;
          annotation(Inline=true,smoothOrder=2);
        end temperature;

        redeclare function extends density "Return density of ideal gas"
        algorithm
          d := state.p/(data.R*state.T);
          annotation(Inline=true,smoothOrder=2);
        end density;

        redeclare function extends specificEnthalpy "Return specific enthalpy"
          extends Modelica.Icons.Function;
        algorithm
          h := Modelica.Media.IdealGases.Common.Functions.h_T(
                   data,state.T);
          annotation(Inline=true,smoothOrder=2);
        end specificEnthalpy;

        redeclare function extends specificInternalEnergy
          "Return specific internal energy"
          extends Modelica.Icons.Function;
        algorithm
          u := Modelica.Media.IdealGases.Common.Functions.h_T(
                   data,state.T) - data.R*state.T;
          annotation(Inline=true,smoothOrder=2);
        end specificInternalEnergy;

        redeclare function extends specificEntropy "Return specific entropy"
          extends Modelica.Icons.Function;
        algorithm
          s := Modelica.Media.IdealGases.Common.Functions.s0_T(
                    data, state.T) - data.R*Modelica.Math.log(state.p/reference_p);
          annotation(Inline=true,smoothOrder=2);
        end specificEntropy;

        redeclare function extends specificGibbsEnergy "Return specific Gibbs energy"
          extends Modelica.Icons.Function;
        algorithm
          g := Modelica.Media.IdealGases.Common.Functions.h_T(
                   data,state.T) - state.T*specificEntropy(state);
          annotation(Inline=true,smoothOrder=2);
        end specificGibbsEnergy;

        redeclare function extends specificHelmholtzEnergy
          "Return specific Helmholtz energy"
          extends Modelica.Icons.Function;
        algorithm
          f := Modelica.Media.IdealGases.Common.Functions.h_T(
                   data,state.T) - data.R*state.T - state.T*specificEntropy(state);
          annotation(Inline=true,smoothOrder=2);
        end specificHelmholtzEnergy;

        redeclare function extends specificHeatCapacityCp
          "Return specific heat capacity at constant pressure"
        algorithm
          cp := Modelica.Media.IdealGases.Common.Functions.cp_T(
                     data, state.T);
          annotation(Inline=true,smoothOrder=2);
        end specificHeatCapacityCp;

        redeclare function extends specificHeatCapacityCv
          "Compute specific heat capacity at constant volume from temperature and gas data"
        algorithm
          cv := Modelica.Media.IdealGases.Common.Functions.cp_T(
                     data, state.T) - data.R;
          annotation(Inline=true,smoothOrder=2);
        end specificHeatCapacityCv;

        redeclare function extends isentropicExponent "Return isentropic exponent"
        algorithm
          gamma := specificHeatCapacityCp(state)/specificHeatCapacityCv(state);
          annotation(Inline=true,smoothOrder=2);
        end isentropicExponent;

        redeclare function extends velocityOfSound "Return velocity of sound"
          extends Modelica.Icons.Function;
        algorithm
          a := sqrt(max(0,data.R*state.T*Modelica.Media.IdealGases.Common.Functions.cp_T(
                                              data, state.T)/specificHeatCapacityCv(state)));
          annotation(Inline=true,smoothOrder=2);
        end velocityOfSound;

        function isentropicEnthalpyApproximation
          "Approximate method of calculating h_is from upstream properties and downstream pressure"
          extends Modelica.Icons.Function;
          input SI.Pressure p2 "Downstream pressure";
          input ThermodynamicState state "Properties at upstream location";
          input Boolean exclEnthForm=Functions.excludeEnthalpyOfFormation
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";
          input ReferenceEnthalpy refChoice=Functions.referenceChoice
            "Choice of reference enthalpy";
          input SpecificEnthalpy h_off=Functions.h_offset
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
          output SI.SpecificEnthalpy h_is "Isentropic enthalpy";
        protected
          IsentropicExponent gamma =  isentropicExponent(state) "Isentropic exponent";
        algorithm
          h_is := Modelica.Media.IdealGases.Common.Functions.h_T(
                      data,state.T,exclEnthForm,refChoice,h_off) +
            gamma/(gamma - 1.0)*state.p/density(state)*((p2/state.p)^((gamma - 1)/gamma) - 1.0);
          annotation(Inline=true,smoothOrder=2);
        end isentropicEnthalpyApproximation;

        redeclare function extends isentropicEnthalpy "Return isentropic enthalpy"
        input Boolean exclEnthForm=Functions.excludeEnthalpyOfFormation
            "If true, enthalpy of formation Hf is not included in specific enthalpy h";
        input ReferenceEnthalpy refChoice=Functions.referenceChoice
            "Choice of reference enthalpy";
        input SpecificEnthalpy h_off=Functions.h_offset
            "User defined offset for reference enthalpy, if referenceChoice = UserDefined";
        algorithm
          h_is := isentropicEnthalpyApproximation(p_downstream,refState,exclEnthForm,refChoice,h_off);
          annotation(Inline=true,smoothOrder=2);
        end isentropicEnthalpy;

        redeclare function extends isobaricExpansionCoefficient
          "Returns overall the isobaric expansion coefficient beta"
        algorithm
          beta := 1/state.T;
          annotation(Inline=true,smoothOrder=2);
        end isobaricExpansionCoefficient;

        redeclare function extends isothermalCompressibility
          "Returns overall the isothermal compressibility factor"
        algorithm
          kappa := 1.0/state.p;
          annotation(Inline=true,smoothOrder=2);
        end isothermalCompressibility;

        redeclare function extends density_derp_T
          "Returns the partial derivative of density with respect to pressure at constant temperature"
        algorithm
          ddpT := 1/(state.T*data.R);
          annotation(Inline=true,smoothOrder=2);
        end density_derp_T;

        redeclare function extends density_derT_p
          "Returns the partial derivative of density with respect to temperature at constant pressure"
        algorithm
          ddTp := -state.p/(state.T*state.T*data.R);
          annotation(Inline=true,smoothOrder=2);
        end density_derT_p;

        redeclare function extends density_derX
          "Returns the partial derivative of density with respect to mass fractions at constant pressure and temperature"
        algorithm
          dddX := fill(0,nX);
          annotation(Inline=true,smoothOrder=2);
        end density_derX;

        redeclare replaceable function extends dynamicViscosity "Dynamic viscosity"
        algorithm
          assert(fluidConstants[1].hasCriticalData,
          "Failed to compute dynamicViscosity: For the species \"" + mediumName + "\" no critical data is available.");
          assert(fluidConstants[1].hasDipoleMoment,
          "Failed to compute dynamicViscosity: For the species \"" + mediumName + "\" no critical data is available.");
          eta := Modelica.Media.IdealGases.Common.Functions.dynamicViscosityLowPressure(
                                             state.T,
                             fluidConstants[1].criticalTemperature,
                             fluidConstants[1].molarMass,
                             fluidConstants[1].criticalMolarVolume,
                             fluidConstants[1].acentricFactor,
                             fluidConstants[1].dipoleMoment);
          annotation (smoothOrder=2);
        end dynamicViscosity;

        redeclare replaceable function extends thermalConductivity
          "Thermal conductivity of gas"
        //  input IdealGases.Common.DataRecord data "Ideal gas data";
          input Integer method=Functions.methodForThermalConductivity
            "1: Eucken Method, 2: Modified Eucken Method";
        algorithm
          assert(fluidConstants[1].hasCriticalData,
          "Failed to compute thermalConductivity: For the species \"" + mediumName + "\" no critical data is available.");
          lambda := Modelica.Media.IdealGases.Common.Functions.thermalConductivityEstimate(
                                                specificHeatCapacityCp(state),
            dynamicViscosity(state), method=method,data=data);
          annotation (smoothOrder=2);
        end thermalConductivity;

        redeclare function extends molarMass "Return the molar mass of the medium"
        algorithm
          MM := data.MM;
          annotation(Inline=true,smoothOrder=2);
        end molarMass;

        function T_h "Compute temperature from specific enthalpy"
          extends Modelica.Icons.Function;
          input SpecificEnthalpy h "Specific enthalpy";
          output Temperature T "Temperature";

        protected
        package Internal
            "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
          extends Modelica.Media.Common.OneNonLinearEquation;
          redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
            extends Modelica.Media.IdealGases.Common.DataRecord;
          end f_nonlinear_Data;

          redeclare function extends f_nonlinear
          algorithm
              y := Modelica.Media.IdealGases.Common.Functions.h_T(
                       f_nonlinear_data,x);
          end f_nonlinear;

          // Dummy definition has to be added for current Dymola
          redeclare function extends solve
          end solve;
        end Internal;

        algorithm
          T := Internal.solve(h, 200, 6000, 1.0e5, {1}, data);
        end T_h;

        function T_ps "Compute temperature from pressure and specific entropy"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEntropy s "Specific entropy";
          output Temperature T "Temperature";

        protected
        package Internal
            "Solve h(data,T) for T with given h (use only indirectly via temperature_phX)"
          extends Modelica.Media.Common.OneNonLinearEquation;
          redeclare record extends f_nonlinear_Data
              "Data to be passed to non-linear function"
            extends Modelica.Media.IdealGases.Common.DataRecord;
          end f_nonlinear_Data;

          redeclare function extends f_nonlinear
          algorithm
              y := Modelica.Media.IdealGases.Common.Functions.s0_T(
                        f_nonlinear_data,x)- data.R*Modelica.Math.log(p/reference_p);
          end f_nonlinear;

          // Dummy definition has to be added for current Dymola
          redeclare function extends solve
          end solve;
        end Internal;

        algorithm
          T := Internal.solve(s, 200, 6000, p, {1}, data);
        end T_ps;

      // the functions below are not strictly necessary, there are just here for compatibility reasons

        function dynamicViscosityLowPressure
          "Dynamic viscosity of low pressure gases"
          extends Modelica.Icons.Function;
          input SI.Temp_K T "Gas temperature";
          input SI.Temp_K Tc "Critical temperature of gas";
          input SI.MolarMass M "Molar mass of gas";
          input SI.MolarVolume Vc "Critical molar volume of gas";
          input Real w "Acentric factor of gas";
          input Modelica.Media.Interfaces.Types.DipoleMoment mu
            "Dipole moment of gas molecule";
          input Real k =  0.0 "Special correction for highly polar substances";
          output Modelica.Media.Interfaces.Types.DynamicViscosity eta
            "Dynamic viscosity of gas";
        protected
          parameter Real Const1_SI=40.785*10^(-9.5)
            "Constant in formula for eta converted to SI units";
          parameter Real Const2_SI=131.3/1000.0
            "Constant in formula for mur converted to SI units";
          Real mur=Const2_SI*mu/sqrt(Vc*Tc)
            "Dimensionless dipole moment of gas molecule";
          Real Fc=1 - 0.2756*w + 0.059035*mur^4 + k
            "Factor to account for molecular shape and polarities of gas";
          Real Tstar "Dimensionless temperature defined by equation below";
          Real Ov "Viscosity collision integral for the gas";

        algorithm
          eta := Functions.dynamicViscosityLowPressure(T,Tc,M,Vc,w,mu,k);
          annotation (smoothOrder=2,
                      Documentation(info="<html>
<p>
The used formula are based on the method of Chung et al (1984, 1988) referred to in ref [1] chapter 9.
The formula 9-4.10 is the one being used. The Formula is given in non-SI units, the following conversion constants were used to
transform the formula to SI units:
</p>

<ul>
<li> <strong>Const1_SI:</strong> The factor 10^(-9.5) =10^(-2.5)*1e-7 where the
     factor 10^(-2.5) originates from the conversion of g/mol->kg/mol + cm^3/mol->m^3/mol
      and the factor 1e-7 is due to conversion from microPoise->Pa.s.</li>
<li>  <strong>Const2_SI:</strong> The factor 1/3.335641e-27 = 1e-3/3.335641e-30
      where the factor 3.335641e-30 comes from debye->C.m and
      1e-3 is due to conversion from cm^3/mol->m^3/mol</li>
</ul>

<h4>References:</h4>
<p>
[1] Bruce E. Poling, John E. Prausnitz, John P. O'Connell, \"The Properties of Gases and Liquids\" 5th Ed. Mc Graw Hill.
</p>

<h4>Author</h4>
<p>T. Skoglund, Lund, Sweden, 2004-08-31</p>

</html>"));
        end dynamicViscosityLowPressure;

        function thermalConductivityEstimate
          "Thermal conductivity of polyatomic gases(Eucken and Modified Eucken correlation)"
          extends Modelica.Icons.Function;
          input Modelica.Media.Interfaces.Types.SpecificHeatCapacity Cp
            "Constant pressure heat capacity";
          input Modelica.Media.Interfaces.Types.DynamicViscosity eta
            "Dynamic viscosity";
          input Integer method(min=1,max=2)=1
            "1: Eucken Method, 2: Modified Eucken Method";
          input IdealGases.Common.DataRecord data "Ideal gas data";
          output Modelica.Media.Interfaces.Types.ThermalConductivity lambda
            "Thermal conductivity [W/(m.k)]";
        algorithm
          lambda := Functions.thermalConductivityEstimate(Cp,eta,method,data);
          annotation (smoothOrder=2,
                      Documentation(info="<html>
<p>
This function provides two similar methods for estimating the
thermal conductivity of polyatomic gases.
The Eucken method (input method == 1) gives good results for low temperatures,
but it tends to give an underestimated value of the thermal conductivity
(lambda) at higher temperatures.<br>
The Modified Eucken method (input method == 2) gives good results for
high-temperatures, but it tends to give an overestimated value of the
thermal conductivity (lambda) at low temperatures.
</p>
</html>"));
        end thermalConductivityEstimate;

        annotation (
          Documentation(info="<html>
<p>
This model calculates medium properties
for an ideal gas of a single substance, or for an ideal
gas consisting of several substances where the
mass fractions are fixed. Independent variables
are temperature <strong>T</strong> and pressure <strong>p</strong>.
Only density is a function of T and p. All other quantities
are solely a function of T. The properties
are valid in the range:
</p>
<pre>
   200 K &le; T &le; 6000 K
</pre>
<p>
The following quantities are always computed:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy h = h(T)</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy u = u(T)</td></tr>
  <tr><td>d</td>
      <td>kg/m^3</td>
      <td>density d = d(p,T)</td></tr>
</table>
<p>
For the other variables, see the functions in
Modelica.Media.IdealGases.Common.SingleGasNasa.
Note, dynamic viscosity and thermal conductivity are only provided
for gases that use a data record from Modelica.Media.IdealGases.FluidData.
Currently these are the following gases:
</p>
<pre>
  Ar
  C2H2_vinylidene
  C2H4
  C2H5OH
  C2H6
  C3H6_propylene
  C3H7OH
  C3H8
  C4H8_1_butene
  C4H9OH
  C4H10_n_butane
  C5H10_1_pentene
  C5H12_n_pentane
  C6H6
  C6H12_1_hexene
  C6H14_n_heptane
  C7H14_1_heptene
  C8H10_ethylbenz
  CH3OH
  CH4
  CL2
  CO
  CO2
  F2
  H2
  H2O
  He
  N2
  N2O
  NH3
  NO
  O2
  SO2
  SO3
</pre>
<p>
<strong>Sources for model and literature:</strong><br>
Original Data: Computer program for calculation of complex chemical
equilibrium compositions and applications. Part 1: Analysis
Document ID: 19950013764 N (95N20180) File Series: NASA Technical Reports
Report Number: NASA-RP-1311  E-8017  NAS 1.61:1311
Authors: Gordon, Sanford (NASA Lewis Research Center)
 Mcbride, Bonnie J. (NASA Lewis Research Center)
Published: Oct 01, 1994.
</p>
<p><strong>Known limits of validity:</strong><br>
The data is valid for
temperatures between 200K and 6000K.  A few of the data sets for
monatomic gases have a discontinuous 1st derivative at 1000K, but
this never caused problems so far.
</p>
<p>
This model has been copied from the ThermoFluid library
and adapted to the Modelica.Media package.
</p>
</html>"));
      end SingleGasNasa;

        package FluidData "Critical data, dipole moments and related data"
          extends Modelica.Icons.Package;
          import Modelica.Media.Interfaces.PartialMixtureMedium;
          import Modelica.Media.IdealGases.Common.SingleGasesData;

          constant Modelica.Media.Interfaces.Types.IdealGas.FluidConstants N2(
                               chemicalFormula =        "N2",
                               iupacName =              "unknown",
                               structureFormula =       "unknown",
                               casRegistryNumber =      "7727-37-9",
                               meltingPoint =            63.15,
                               normalBoilingPoint =      77.35,
                               criticalTemperature =    126.20,
                               criticalPressure =        33.98e5,
                               criticalMolarVolume =     90.10e-6,
                               acentricFactor =           0.037,
                               dipoleMoment =             0.0,
                               molarMass =              SingleGasesData.N2.MM,
                               hasDipoleMoment =       true,
                               hasIdealGasHeatCapacity=true,
                               hasCriticalData =       true,
                               hasAcentricFactor =     true);

          constant Modelica.Media.Interfaces.Types.IdealGas.FluidConstants H2O(
                               chemicalFormula =        "H2O",
                               iupacName =              "oxidane",
                               structureFormula =       "H2O",
                               casRegistryNumber =      "7732-18-5",
                               meltingPoint =           273.15,
                               normalBoilingPoint =     373.124,
                               criticalTemperature =    647.096,
                               criticalPressure =       220.64e5,
                               criticalMolarVolume =     55.95e-6,
                               acentricFactor =           0.344,
                               dipoleMoment =             1.8,
                               molarMass =              SingleGasesData.H2O.MM,
                               hasDipoleMoment =       true,
                               hasIdealGasHeatCapacity=true,
                               hasCriticalData =       true,
                               hasAcentricFactor =     true);
          annotation (Documentation(info="<html>
<p>
This package contains FluidConstants data records for the following 37 gases
(see also the description in
<a href=\"modelica://Modelica.Media.IdealGases\">Modelica.Media.IdealGases</a>):
</p>
<pre>
Argon             Methane          Methanol       Carbon Monoxide  Carbon Dioxide
Acetylene         Ethylene         Ethanol        Ethane           Propylene
Propane           1-Propanol       1-Butene       N-Butane         1-Pentene
N-Pentane         Benzene          1-Hexene       N-Hexane         1-Heptane
N-Heptane         Ethylbenzene     N-Octane       Chlorine         Fluorine
Hydrogen          Steam            Helium         Ammonia          Nitric Oxide
Nitrogen Dioxide  Nitrogen         Nitrous        Oxide            Neon Oxygen
Sulfur Dioxide    Sulfur Trioxide
</pre>

</html>"));
        end FluidData;

        package SingleGasesData
        "Ideal gas data based on the NASA Glenn coefficients"
          extends Modelica.Icons.Package;

          constant IdealGases.Common.DataRecord Air(
            name="Air",
            MM=0.0289651159,
            Hf=-4333.833858403446,
            H0=298609.6803431054,
            Tlimit=1000,
            alow={10099.5016,-196.827561,5.00915511,-0.00576101373,1.06685993e-005,-7.94029797e-009,
                2.18523191e-012},
            blow={-176.796731,-3.921504225},
            ahigh={241521.443,-1257.8746,5.14455867,-0.000213854179,7.06522784e-008,-1.07148349e-011,
                6.57780015e-016},
            bhigh={6462.26319,-8.147411905},
            R=287.0512249529787);

          constant IdealGases.Common.DataRecord CO2(
            name="CO2",
            MM=0.0440095,
            Hf=-8941478.544405185,
            H0=212805.6215135368,
            Tlimit=1000,
            alow={49436.5054,-626.411601,5.30172524,0.002503813816,-2.127308728e-007,-7.68998878e-010,
                2.849677801e-013},
            blow={-45281.9846,-7.04827944},
            ahigh={117696.2419,-1788.791477,8.29152319,-9.22315678e-005,4.86367688e-009,
                -1.891053312e-012,6.330036589999999e-016},
            bhigh={-39083.5059,-26.52669281},
            R=188.9244822140674);

          constant IdealGases.Common.DataRecord H2O(
            name="H2O",
            MM=0.01801528,
            Hf=-13423382.81725291,
            H0=549760.6476280135,
            Tlimit=1000,
            alow={-39479.6083,575.573102,0.931782653,0.00722271286,-7.34255737e-006,
                4.95504349e-009,-1.336933246e-012},
            blow={-33039.7431,17.24205775},
            ahigh={1034972.096,-2412.698562,4.64611078,0.002291998307,-6.836830479999999e-007,
                9.426468930000001e-011,-4.82238053e-015},
            bhigh={-13842.86509,-7.97814851},
            R=461.5233290850878);

          constant IdealGases.Common.DataRecord N2(
            name="N2",
            MM=0.0280134,
            Hf=0,
            H0=309498.4543111511,
            Tlimit=1000,
            alow={22103.71497,-381.846182,6.08273836,-0.00853091441,1.384646189e-005,-9.62579362e-009,
                2.519705809e-012},
            blow={710.846086,-10.76003744},
            ahigh={587712.406,-2239.249073,6.06694922,-0.00061396855,1.491806679e-007,-1.923105485e-011,
                1.061954386e-015},
            bhigh={12832.10415,-15.86640027},
            R=296.8033869505308);
          annotation (Documentation(info="<html>
<p>This package contains ideal gas models for the 1241 ideal gases from</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>

<pre>
 Ag        BaOH+           C2H4O_ethylen_o DF      In2I4    Nb      ScO2
 Ag+       Ba_OH_2         CH3CHO_ethanal  DOCl    In2I6    Nb+     Sc2O
 Ag-       BaS             CH3COOH         DO2     In2O     Nb-     Sc2O2
 Air       Ba2             OHCH2COOH       DO2-    K        NbCl5   Si
 Al        Be              C2H5            D2      K+       NbO     Si+
 Al+       Be+             C2H5Br          D2+     K-       NbOCl3  Si-
 Al-       Be++            C2H6            D2-     KAlF4    NbO2    SiBr
 AlBr      BeBr            CH3N2CH3        D2O     KBO2     Ne      SiBr2
 AlBr2     BeBr2           C2H5OH          D2O2    KBr      Ne+     SiBr3
 AlBr3     BeCl            CH3OCH3         D2S     KCN      Ni      SiBr4
 AlC       BeCl2           CH3O2CH3        e-      KCl      Ni+     SiC
 AlC2      BeF             CCN             F       KF       Ni-     SiC2
 AlCl      BeF2            CNC             F+      KH       NiCl    SiCl
 AlCl+     BeH             OCCN            F-      KI       NiCl2   SiCl2
 AlCl2     BeH+            C2N2            FCN     Kli      NiO     SiCl3
 AlCl3     BeH2            C2O             FCO     KNO2     NiS     SiCl4
 AlF       BeI             C3              FO      KNO3     O       SiF
 AlF+      BeI2            C3H3_1_propynl  FO2_FOO KNa      O+      SiFCl
 AlFCl     BeN             C3H3_2_propynl  FO2_OFO KO       O-      SiF2
 AlFCl2    BeO             C3H4_allene     F2      KOH      OD      SiF3
 AlF2      BeOH            C3H4_propyne    F2O     K2       OD-     SiF4
 AlF2-     BeOH+           C3H4_cyclo      F2O2    K2+      OH      SiH
 AlF2Cl    Be_OH_2         C3H5_allyl      FS2F    K2Br2    OH+     SiH+
 AlF3      BeS             C3H6_propylene  Fe      K2CO3    OH-     SiHBr3
 AlF4-     Be2             C3H6_cyclo      Fe+     K2C2N2   O2      SiHCl
 AlH       Be2Cl4          C3H6O_propylox  Fe_CO_5 K2Cl2    O2+     SiHCl3
 AlHCl     Be2F4           C3H6O_acetone   FeCl    K2F2     O2-     SiHF
 AlHCl2    Be2O            C3H6O_propanal  FeCl2   K2I2     O3      SiHF3
 AlHF      Be2OF2          C3H7_n_propyl   FeCl3   K2O      P       SiHI3
 AlHFCl    Be2O2           C3H7_i_propyl   FeO     K2O+     P+      SiH2
 AlHF2     Be3O3           C3H8            Fe_OH_2 K2O2     P-      SiH2Br2
 AlH2      Be4O4           C3H8O_1propanol Fe2Cl4  K2O2H2   PCl     SiH2Cl2
 AlH2Cl    Br              C3H8O_2propanol Fe2Cl6  K2SO4    PCl2    SiH2F2
 AlH2F     Br+             CNCOCN          Ga      Kr       PCl2-   SiH2I2
 AlH3      Br-             C3O2            Ga+     Kr+      PCl3    SiH3
 AlI       BrCl            C4              GaBr    li       PCl5    SiH3Br
 AlI2      BrF             C4H2_butadiyne  GaBr2   li+      PF      SiH3Cl
 AlI3      BrF3            C4H4_1_3-cyclo  GaBr3   li-      PF+     SiH3F
 AlN       BrF5            C4H6_butadiene  GaCl    liAlF4   PF-     SiH3I
 AlO       BrO             C4H6_1butyne    GaCl2   liBO2    PFCl    SiH4
 AlO+      OBrO            C4H6_2butyne    GaCl3   liBr     PFCl-   SiI
 AlO-      BrOO            C4H6_cyclo      GaF     liCl     PFCl2   SiI2
 AlOCl     BrO3            C4H8_1_butene   GaF2    liF      PFCl4   SiN
 AlOCl2    Br2             C4H8_cis2_buten GaF3    liH      PF2     SiO
 AlOF      BrBrO           C4H8_isobutene  GaH     liI      PF2-    SiO2
 AlOF2     BrOBr           C4H8_cyclo      GaI     liN      PF2Cl   SiS
 AlOF2-    C               C4H9_n_butyl    GaI2    liNO2    PF2Cl3  SiS2
 AlOH      C+              C4H9_i_butyl    GaI3    liNO3    PF3     Si2
 AlOHCl    C-              C4H9_s_butyl    GaO     liO      PF3Cl2  Si2C
 AlOHCl2   CBr             C4H9_t_butyl    GaOH    liOF     PF4Cl   Si2F6
 AlOHF     CBr2            C4H10_n_butane  Ga2Br2  liOH     PF5     Si2N
 AlOHF2    CBr3            C4H10_isobutane Ga2Br4  liON     PH      Si3
 AlO2      CBr4            C4N2            Ga2Br6  li2      PH2     Sn
 AlO2-     CCl             C5              Ga2Cl2  li2+     PH2-    Sn+
 Al_OH_2   CCl2            C5H6_1_3cyclo   Ga2Cl4  li2Br2   PH3     Sn-
 Al_OH_2Cl CCl2Br2         C5H8_cyclo      Ga2Cl6  li2F2    PN      SnBr
 Al_OH_2F  CCl3            C5H10_1_pentene Ga2F2   li2I2    PO      SnBr2
 Al_OH_3   CCl3Br          C5H10_cyclo     Ga2F4   li2O     PO-     SnBr3
 AlS       CCl4            C5H11_pentyl    Ga2F6   li2O+    POCl3   SnBr4
 AlS2      CF              C5H11_t_pentyl  Ga2I2   li2O2    POFCl2  SnCl
 Al2       CF+             C5H12_n_pentane Ga2I4   li2O2H2  POF2Cl  SnCl2
 Al2Br6    CFBr3           C5H12_i_pentane Ga2I6   li2SO4   POF3    SnCl3
 Al2C2     CFCl            CH3C_CH3_2CH3   Ga2O    li3+     PO2     SnCl4
 Al2Cl6    CFClBr2         C6D5_phenyl     Ge      li3Br3   PO2-    SnF
 Al2F6     CFCl2           C6D6            Ge+     li3Cl3   PS      SnF2
 Al2I6     CFCl2Br         C6H2            Ge-     li3F3    P2      SnF3
 Al2O      CFCl3           C6H5_phenyl     GeBr    li3I3    P2O3    SnF4
 Al2O+     CF2             C6H5O_phenoxy   GeBr2   Mg       P2O4    SnI
 Al2O2     CF2+            C6H6            GeBr3   Mg+      P2O5    SnI2
 Al2O2+    CF2Br2          C6H5OH_phenol   GeBr4   MgBr     P3      SnI3
 Al2O3     CF2Cl           C6H10_cyclo     GeCl    MgBr2    P3O6    SnI4
 Al2S      CF2ClBr         C6H12_1_hexene  GeCl2   MgCl     P4      SnO
 Al2S2     CF2Cl2          C6H12_cyclo     GeCl3   MgCl+    P4O6    SnO2
 Ar        CF3             C6H13_n_hexyl   GeCl4   MgCl2    P4O7    SnS
 Ar+       CF3+            C6H14_n_hexane  GeF     MgF      P4O8    SnS2
 B         CF3Br           C7H7_benzyl     GeF2    MgF+     P4O9    Sn2
 B+        CF3Cl           C7H8            GeF3    MgF2     P4O10   Sr
 B-        CF4             C7H8O_cresol_mx GeF4    MgF2+    Pb      Sr+
 BBr       CH+             C7H14_1_heptene GeH4    MgH      Pb+     SrBr
 BBr2      CHBr3           C7H15_n_heptyl  GeI     MgI      Pb-     SrBr2
 BBr3      CHCl            C7H16_n_heptane GeO     MgI2     PbBr    SrCl
 BC        CHClBr2         C7H16_2_methylh GeO2    MgN      PbBr2   SrCl+
 BC2       CHCl2           C8H8_styrene    GeS     MgO      PbBr3   SrCl2
 BCl       CHCl2Br         C8H10_ethylbenz GeS2    MgOH     PbBr4   SrF
 BCl+      CHCl3           C8H16_1_octene  Ge2     MgOH+    PbCl    SrF+
 BClOH     CHF             C8H17_n_octyl   H       Mg_OH_2  PbCl2   SrF2
 BCl_OH_2  CHFBr2          C8H18_n_octane  H+      MgS      PbCl3   SrH
 BCl2      CHFCl           C8H18_isooctane H-      Mg2      PbCl4   SrI
 BCl2+     CHFClBr         C9H19_n_nonyl   HAlO    Mg2F4    PbF     SrI2
 BCl2OH    CHFCl2          C10H8_naphthale HAlO2   Mn       PbF2    SrO
 BF        CHF2            C10H21_n_decyl  HBO     Mn+      PbF3    SrOH
 BFCl      CHF2Br          C12H9_o_bipheny HBO+    Mo       PbF4    SrOH+
 BFCl2     CHF2Cl          C12H10_biphenyl HBO2    Mo+      PbI     Sr_OH_2
 BFOH      CHF3            Ca              HBS     Mo-      PbI2    SrS
 BF_OH_2   CHI3            Ca+             HBS+    MoO      PbI3    Sr2
 BF2       CH2             CaBr            HCN     MoO2     PbI4    Ta
 BF2+      CH2Br2          CaBr2           HCO     MoO3     PbO     Ta+
 BF2-      CH2Cl           CaCl            HCO+    MoO3-    PbO2    Ta-
 BF2Cl     CH2ClBr         CaCl+           HCCN    Mo2O6    PbS     TaCl5
 BF2OH     CH2Cl2          CaCl2           HCCO    Mo3O9    PbS2    TaO
 BF3       CH2F            CaF             HCl     Mo4O12   Rb      TaO2
 BF4-      CH2FBr          CaF+            HD      Mo5O15   Rb+     Ti
 BH        CH2FCl          CaF2            HD+     N        Rb-     Ti+
 BHCl      CH2F2           CaH             HDO     N+       RbBO2   Ti-
 BHCl2     CH2I2           CaI             HDO2    N-       RbBr    TiCl
 BHF       CH3             CaI2            HF      NCO      RbCl    TiCl2
 BHFCl     CH3Br           CaO             HI      ND       RbF     TiCl3
 BHF2      CH3Cl           CaO+            HNC     ND2      RbH     TiCl4
 BH2       CH3F            CaOH            HNCO    ND3      RbI     TiO
 BH2Cl     CH3I            CaOH+           HNO     NF       RbK     TiO+
 BH2F      CH2OH           Ca_OH_2         HNO2    NF2      Rbli    TiOCl
 BH3       CH2OH+          CaS             HNO3    NF3      RbNO2   TiOCl2
 BH3NH3    CH3O            Ca2             HOCl    NH       RbNO3   TiO2
 BH4       CH4             Cd              HOF     NH+      RbNa    U
 BI        CH3OH           Cd+             HO2     NHF      RbO     UF
 BI2       CH3OOH          Cl              HO2-    NHF2     RbOH    UF+
 BI3       CI              Cl+             HPO     NH2      Rb2Br2  UF-
 BN        CI2             Cl-             HSO3F   NH2F     Rb2Cl2  UF2
 BO        CI3             ClCN            H2      NH3      Rb2F2   UF2+
 BO-       CI4             ClF             H2+     NH2OH    Rb2I2   UF2-
 BOCl      CN              ClF3            H2-     NH4+     Rb2O    UF3
 BOCl2     CN+             ClF5            HBOH    NO       Rb2O2   UF3+
 BOF       CN-             ClO             HCOOH   NOCl     Rb2O2H2 UF3-
 BOF2      CNN             ClO2            H2F2    NOF      Rb2SO4  UF4
 BOH       CO              Cl2             H2O     NOF3     Rn      UF4+
 BO2       CO+             Cl2O            H2O+    NO2      Rn+     UF4-
 BO2-      COCl            Co              H2O2    NO2-     S       UF5
 B_OH_2    COCl2           Co+             H2S     NO2Cl    S+      UF5+
 BS        COFCl           Co-             H2SO4   NO2F     S-      UF5-
 BS2       COF2            Cr              H2BOH   NO3      SCl     UF6
 B2        COHCl           Cr+             HB_OH_2 NO3-     SCl2    UF6-
 B2C       COHF            Cr-             H3BO3   NO3F     SCl2+   UO
 B2Cl4     COS             CrN             H3B3O3  N2       SD      UO+
 B2F4      CO2             CrO             H3B3O6  N2+      SF      UOF
 B2H       CO2+            CrO2            H3F3    N2-      SF+     UOF2
 B2H2      COOH            CrO3            H3O+    NCN      SF-     UOF3
 B2H3      CP              CrO3-           H4F4    N2D2_cis SF2     UOF4
 B2H3_db   CS              Cs              H5F5    N2F2     SF2+    UO2
 B2H4      CS2             Cs+             H6F6    N2F4     SF2-    UO2+
 B2H4_db   C2              Cs-             H7F7    N2H2     SF3     UO2-
 B2H5      C2+             CsBO2           He      NH2NO2   SF3+    UO2F
 B2H5_db   C2-             CsBr            He+     N2H4     SF3-    UO2F2
 B2H6      C2Cl            CsCl            Hg      N2O      SF4     UO3
 B2O       C2Cl2           CsF             Hg+     N2O+     SF4+    UO3-
 B2O2      C2Cl3           CsH             HgBr2   N2O3     SF4-    V
 B2O3      C2Cl4           CsI             I       N2O4     SF5     V+
 B2_OH_4   C2Cl6           Csli            I+      N2O5     SF5+    V-
 B2S       C2F             CsNO2           I-      N3       SF5-    VCl4
 B2S2      C2FCl           CsNO3           IF5     N3H      SF6     VN
 B2S3      C2FCl3          CsNa            IF7     Na       SF6-    VO
 B3H7_C2v  C2F2            CsO             I2      Na+      SH      VO2
 B3H7_Cs   C2F2Cl2         CsOH            In      Na-      SH-     V4O10
 B3H9      C2F3            CsRb            In+     NaAlF4   SN      W
 B3N3H6    C2F3Cl          Cs2             InBr    NaBO2    SO      W+
 B3O3Cl3   C2F4            Cs2Br2          InBr2   NaBr     SO-     W-
 B3O3FCl2  C2F6            Cs2CO3          InBr3   NaCN     SOF2    WCl6
 B3O3F2Cl  C2H             Cs2Cl2          InCl    NaCl     SO2     WO
 B3O3F3    C2HCl           Cs2F2           InCl2   NaF      SO2-    WOCl4
 B4H4      C2HCl3          Cs2I2           InCl3   NaH      SO2Cl2  WO2
 B4H10     C2HF            Cs2O            InF     NaI      SO2FCl  WO2Cl2
 B4H12     C2HFCl2         Cs2O+           InF2    Nali     SO2F2   WO3
 B5H9      C2HF2Cl         Cs2O2           InF3    NaNO2    SO3     WO3-
 Ba        C2HF3           Cs2O2H2         InH     NaNO3    S2      Xe
 Ba+       C2H2_vinylidene Cs2SO4          InI     NaO      S2-     Xe+
 BaBr      C2H2Cl2         Cu              InI2    NaOH     S2Cl2   Zn
 BaBr2     C2H2FCl         Cu+             InI3    NaOH+    S2F2    Zn+
 BaCl      C2H2F2          Cu-             InO     Na2      S2O     Zr
 BaCl+     CH2CO_ketene    CuCl            InOH    Na2Br2   S3      Zr+
 BaCl2     O_CH_2O         CuF             In2Br2  Na2Cl2   S4      Zr-
 BaF       HO_CO_2OH       CuF2            In2Br4  Na2F2    S5      ZrN
 BaF+      C2H3_vinyl      CuO             In2Br6  Na2I2    S6      ZrO
 BaF2      CH2Br-COOH      Cu2             In2Cl2  Na2O     S7      ZrO+
 BaH       C2H3Cl          Cu3Cl3          In2Cl4  Na2O+    S8      ZrO2
 BaI       CH2Cl-COOH      D               In2Cl6  Na2O2    Sc
 BaI2      C2H3F           D+              In2F2   Na2O2H2  Sc+
 BaO       CH3CN           D-              In2F4   Na2SO4   Sc-
 BaO+      CH3CO_acetyl    DBr             In2F6   Na3Cl3   ScO
 BaOH      C2H4            DCl             In2I2   Na3F3    ScO+
</pre>
</html>"));
        end SingleGasesData;
      annotation (Documentation(info="<html>

</html>"));
      end Common;
    annotation (Documentation(info="<html>
<p>This package contains data for the 1241 ideal gases from</p>
<blockquote>
  <p>McBride B.J., Zehe M.J., and Gordon S. (2002): <strong>NASA Glenn Coefficients
  for Calculating Thermodynamic Properties of Individual Species</strong>. NASA
  report TP-2002-211556</p>
</blockquote>
<p>Medium models for some of these gases are available in package
<a href=\"modelica://Modelica.Media.IdealGases.SingleGases\">IdealGases.SingleGases</a>
and some examples for mixtures are available in package <a href=\"modelica://Modelica.Media.IdealGases.MixtureGases\">IdealGases.MixtureGases</a>
</p>
<h4>Using and Adapting Medium Models</h4>
<p>
The data records allow computing the ideal gas specific enthalpy, specific entropy and heat capacity of the substances listed below. From them, even the Gibbs energy and equilibrium constants for reactions can be computed. Critical data that is needed for computing the viscosity and thermal conductivity is not included. In order to add mixtures or single substance medium packages that are
subtypes of
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">Interfaces.PartialMedium</a>
(i.e., can be utilized at all places where PartialMedium is defined),
a few additional steps have to be performed:
</p>
<ol>
<li>
All single gas media need to define a constant instance of record
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium.FluidConstants\">IdealGases.Common.SingleGasNasa.FluidConstants</a>.
For 37 ideal gases such records are provided in package
<a href=\"modelica://Modelica.Media.IdealGases.Common.FluidData\">IdealGases.Common.FluidData</a>.
For the other gases, such a record instance has to be provided by the user, e.g., by getting
the data from a commercial or public data base. A public source of the needed data is for example the <a href=\"http://webbook.nist.gov/chemistry/\"> NIST Chemistry WebBook</a></li>

<li>When the data is available, and a user has an instance of a
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium.FluidConstants\">FluidConstants</a> record filled with data, a medium package has to be written. Note that only the dipole moment, the acentric factor and critical data are necessary for the viscosity and thermal conductivity functions.</li>
<li><ul>
<li>For single components, a new package following the pattern in
<a href=\"modelica://Modelica.Media.IdealGases.SingleGases\">IdealGases.SingleGases</a> has to be created, pointing both to a data record for cp and to a user-defined fluidConstants record.</li>
<li>For mixtures of several components, a new package following the pattern in
<a href=\"modelica://Modelica.Media.IdealGases.MixtureGases\">IdealGases.MixtureGases</a> has to be created, building an array of data records for cp and an array of (partly) user-defined fluidConstants records.</li>
</ul></li>
</ol>
<p>Note that many properties can computed for the full set of 1241 gases listed below, but due to the missing viscosity and thermal conductivity functions, no fully Modelica.Media-compliant media can be defined.</p>
<p>
Data records for heat capacity, specific enthalpy and specific entropy exist for the following substances and ions:
</p>
<pre>
 Ag        BaOH+           C2H4O_ethylen_o DF      In2I4    Nb      ScO2
 Ag+       Ba_OH_2         CH3CHO_ethanal  DOCl    In2I6    Nb+     Sc2O
 Ag-       BaS             CH3COOH         DO2     In2O     Nb-     Sc2O2
 Air       Ba2             OHCH2COOH       DO2-    K        NbCl5   Si
 Al        Be              C2H5            D2      K+       NbO     Si+
 Al+       Be+             C2H5Br          D2+     K-       NbOCl3  Si-
 Al-       Be++            C2H6            D2-     KAlF4    NbO2    SiBr
 AlBr      BeBr            CH3N2CH3        D2O     KBO2     Ne      SiBr2
 AlBr2     BeBr2           C2H5OH          D2O2    KBr      Ne+     SiBr3
 AlBr3     BeCl            CH3OCH3         D2S     KCN      Ni      SiBr4
 AlC       BeCl2           CH3O2CH3        e-      KCl      Ni+     SiC
 AlC2      BeF             CCN             F       KF       Ni-     SiC2
 AlCl      BeF2            CNC             F+      KH       NiCl    SiCl
 AlCl+     BeH             OCCN            F-      KI       NiCl2   SiCl2
 AlCl2     BeH+            C2N2            FCN     Kli      NiO     SiCl3
 AlCl3     BeH2            C2O             FCO     KNO2     NiS     SiCl4
 AlF       BeI             C3              FO      KNO3     O       SiF
 AlF+      BeI2            C3H3_1_propynl  FO2_FOO KNa      O+      SiFCl
 AlFCl     BeN             C3H3_2_propynl  FO2_OFO KO       O-      SiF2
 AlFCl2    BeO             C3H4_allene     F2      KOH      OD      SiF3
 AlF2      BeOH            C3H4_propyne    F2O     K2       OD-     SiF4
 AlF2-     BeOH+           C3H4_cyclo      F2O2    K2+      OH      SiH
 AlF2Cl    Be_OH_2         C3H5_allyl      FS2F    K2Br2    OH+     SiH+
 AlF3      BeS             C3H6_propylene  Fe      K2CO3    OH-     SiHBr3
 AlF4-     Be2             C3H6_cyclo      Fe+     K2C2N2   O2      SiHCl
 AlH       Be2Cl4          C3H6O_propylox  Fe_CO_5 K2Cl2    O2+     SiHCl3
 AlHCl     Be2F4           C3H6O_acetone   FeCl    K2F2     O2-     SiHF
 AlHCl2    Be2O            C3H6O_propanal  FeCl2   K2I2     O3      SiHF3
 AlHF      Be2OF2          C3H7_n_propyl   FeCl3   K2O      P       SiHI3
 AlHFCl    Be2O2           C3H7_i_propyl   FeO     K2O+     P+      SiH2
 AlHF2     Be3O3           C3H8            Fe_OH_2 K2O2     P-      SiH2Br2
 AlH2      Be4O4           C3H8O_1propanol Fe2Cl4  K2O2H2   PCl     SiH2Cl2
 AlH2Cl    Br              C3H8O_2propanol Fe2Cl6  K2SO4    PCl2    SiH2F2
 AlH2F     Br+             CNCOCN          Ga      Kr       PCl2-   SiH2I2
 AlH3      Br-             C3O2            Ga+     Kr+      PCl3    SiH3
 AlI       BrCl            C4              GaBr    li       PCl5    SiH3Br
 AlI2      BrF             C4H2_butadiyne  GaBr2   li+      PF      SiH3Cl
 AlI3      BrF3            C4H4_1_3-cyclo  GaBr3   li-      PF+     SiH3F
 AlN       BrF5            C4H6_butadiene  GaCl    liAlF4   PF-     SiH3I
 AlO       BrO             C4H6_1butyne    GaCl2   liBO2    PFCl    SiH4
 AlO+      OBrO            C4H6_2butyne    GaCl3   liBr     PFCl-   SiI
 AlO-      BrOO            C4H6_cyclo      GaF     liCl     PFCl2   SiI2
 AlOCl     BrO3            C4H8_1_butene   GaF2    liF      PFCl4   SiN
 AlOCl2    Br2             C4H8_cis2_buten GaF3    liH      PF2     SiO
 AlOF      BrBrO           C4H8_isobutene  GaH     liI      PF2-    SiO2
 AlOF2     BrOBr           C4H8_cyclo      GaI     liN      PF2Cl   SiS
 AlOF2-    C               C4H9_n_butyl    GaI2    liNO2    PF2Cl3  SiS2
 AlOH      C+              C4H9_i_butyl    GaI3    liNO3    PF3     Si2
 AlOHCl    C-              C4H9_s_butyl    GaO     liO      PF3Cl2  Si2C
 AlOHCl2   CBr             C4H9_t_butyl    GaOH    liOF     PF4Cl   Si2F6
 AlOHF     CBr2            C4H10_n_butane  Ga2Br2  liOH     PF5     Si2N
 AlOHF2    CBr3            C4H10_isobutane Ga2Br4  liON     PH      Si3
 AlO2      CBr4            C4N2            Ga2Br6  li2      PH2     Sn
 AlO2-     CCl             C5              Ga2Cl2  li2+     PH2-    Sn+
 Al_OH_2   CCl2            C5H6_1_3cyclo   Ga2Cl4  li2Br2   PH3     Sn-
 Al_OH_2Cl CCl2Br2         C5H8_cyclo      Ga2Cl6  li2F2    PN      SnBr
 Al_OH_2F  CCl3            C5H10_1_pentene Ga2F2   li2I2    PO      SnBr2
 Al_OH_3   CCl3Br          C5H10_cyclo     Ga2F4   li2O     PO-     SnBr3
 AlS       CCl4            C5H11_pentyl    Ga2F6   li2O+    POCl3   SnBr4
 AlS2      CF              C5H11_t_pentyl  Ga2I2   li2O2    POFCl2  SnCl
 Al2       CF+             C5H12_n_pentane Ga2I4   li2O2H2  POF2Cl  SnCl2
 Al2Br6    CFBr3           C5H12_i_pentane Ga2I6   li2SO4   POF3    SnCl3
 Al2C2     CFCl            CH3C_CH3_2CH3   Ga2O    li3+     PO2     SnCl4
 Al2Cl6    CFClBr2         C6D5_phenyl     Ge      li3Br3   PO2-    SnF
 Al2F6     CFCl2           C6D6            Ge+     li3Cl3   PS      SnF2
 Al2I6     CFCl2Br         C6H2            Ge-     li3F3    P2      SnF3
 Al2O      CFCl3           C6H5_phenyl     GeBr    li3I3    P2O3    SnF4
 Al2O+     CF2             C6H5O_phenoxy   GeBr2   Mg       P2O4    SnI
 Al2O2     CF2+            C6H6            GeBr3   Mg+      P2O5    SnI2
 Al2O2+    CF2Br2          C6H5OH_phenol   GeBr4   MgBr     P3      SnI3
 Al2O3     CF2Cl           C6H10_cyclo     GeCl    MgBr2    P3O6    SnI4
 Al2S      CF2ClBr         C6H12_1_hexene  GeCl2   MgCl     P4      SnO
 Al2S2     CF2Cl2          C6H12_cyclo     GeCl3   MgCl+    P4O6    SnO2
 Ar        CF3             C6H13_n_hexyl   GeCl4   MgCl2    P4O7    SnS
 Ar+       CF3+            C6H14_n_hexane  GeF     MgF      P4O8    SnS2
 B         CF3Br           C7H7_benzyl     GeF2    MgF+     P4O9    Sn2
 B+        CF3Cl           C7H8            GeF3    MgF2     P4O10   Sr
 B-        CF4             C7H8O_cresol_mx GeF4    MgF2+    Pb      Sr+
 BBr       CH+             C7H14_1_heptene GeH4    MgH      Pb+     SrBr
 BBr2      CHBr3           C7H15_n_heptyl  GeI     MgI      Pb-     SrBr2
 BBr3      CHCl            C7H16_n_heptane GeO     MgI2     PbBr    SrCl
 BC        CHClBr2         C7H16_2_methylh GeO2    MgN      PbBr2   SrCl+
 BC2       CHCl2           C8H8_styrene    GeS     MgO      PbBr3   SrCl2
 BCl       CHCl2Br         C8H10_ethylbenz GeS2    MgOH     PbBr4   SrF
 BCl+      CHCl3           C8H16_1_octene  Ge2     MgOH+    PbCl    SrF+
 BClOH     CHF             C8H17_n_octyl   H       Mg_OH_2  PbCl2   SrF2
 BCl_OH_2  CHFBr2          C8H18_n_octane  H+      MgS      PbCl3   SrH
 BCl2      CHFCl           C8H18_isooctane H-      Mg2      PbCl4   SrI
 BCl2+     CHFClBr         C9H19_n_nonyl   HAlO    Mg2F4    PbF     SrI2
 BCl2OH    CHFCl2          C10H8_naphthale HAlO2   Mn       PbF2    SrO
 BF        CHF2            C10H21_n_decyl  HBO     Mn+      PbF3    SrOH
 BFCl      CHF2Br          C12H9_o_bipheny HBO+    Mo       PbF4    SrOH+
 BFCl2     CHF2Cl          C12H10_biphenyl HBO2    Mo+      PbI     Sr_OH_2
 BFOH      CHF3            Ca              HBS     Mo-      PbI2    SrS
 BF_OH_2   CHI3            Ca+             HBS+    MoO      PbI3    Sr2
 BF2       CH2             CaBr            HCN     MoO2     PbI4    Ta
 BF2+      CH2Br2          CaBr2           HCO     MoO3     PbO     Ta+
 BF2-      CH2Cl           CaCl            HCO+    MoO3-    PbO2    Ta-
 BF2Cl     CH2ClBr         CaCl+           HCCN    Mo2O6    PbS     TaCl5
 BF2OH     CH2Cl2          CaCl2           HCCO    Mo3O9    PbS2    TaO
 BF3       CH2F            CaF             HCl     Mo4O12   Rb      TaO2
 BF4-      CH2FBr          CaF+            HD      Mo5O15   Rb+     Ti
 BH        CH2FCl          CaF2            HD+     N        Rb-     Ti+
 BHCl      CH2F2           CaH             HDO     N+       RbBO2   Ti-
 BHCl2     CH2I2           CaI             HDO2    N-       RbBr    TiCl
 BHF       CH3             CaI2            HF      NCO      RbCl    TiCl2
 BHFCl     CH3Br           CaO             HI      ND       RbF     TiCl3
 BHF2      CH3Cl           CaO+            HNC     ND2      RbH     TiCl4
 BH2       CH3F            CaOH            HNCO    ND3      RbI     TiO
 BH2Cl     CH3I            CaOH+           HNO     NF       RbK     TiO+
 BH2F      CH2OH           Ca_OH_2         HNO2    NF2      Rbli    TiOCl
 BH3       CH2OH+          CaS             HNO3    NF3      RbNO2   TiOCl2
 BH3NH3    CH3O            Ca2             HOCl    NH       RbNO3   TiO2
 BH4       CH4             Cd              HOF     NH+      RbNa    U
 BI        CH3OH           Cd+             HO2     NHF      RbO     UF
 BI2       CH3OOH          Cl              HO2-    NHF2     RbOH    UF+
 BI3       CI              Cl+             HPO     NH2      Rb2Br2  UF-
 BN        CI2             Cl-             HSO3F   NH2F     Rb2Cl2  UF2
 BO        CI3             ClCN            H2      NH3      Rb2F2   UF2+
 BO-       CI4             ClF             H2+     NH2OH    Rb2I2   UF2-
 BOCl      CN              ClF3            H2-     NH4+     Rb2O    UF3
 BOCl2     CN+             ClF5            HBOH    NO       Rb2O2   UF3+
 BOF       CN-             ClO             HCOOH   NOCl     Rb2O2H2 UF3-
 BOF2      CNN             ClO2            H2F2    NOF      Rb2SO4  UF4
 BOH       CO              Cl2             H2O     NOF3     Rn      UF4+
 BO2       CO+             Cl2O            H2O+    NO2      Rn+     UF4-
 BO2-      COCl            Co              H2O2    NO2-     S       UF5
 B_OH_2    COCl2           Co+             H2S     NO2Cl    S+      UF5+
 BS        COFCl           Co-             H2SO4   NO2F     S-      UF5-
 BS2       COF2            Cr              H2BOH   NO3      SCl     UF6
 B2        COHCl           Cr+             HB_OH_2 NO3-     SCl2    UF6-
 B2C       COHF            Cr-             H3BO3   NO3F     SCl2+   UO
 B2Cl4     COS             CrN             H3B3O3  N2       SD      UO+
 B2F4      CO2             CrO             H3B3O6  N2+      SF      UOF
 B2H       CO2+            CrO2            H3F3    N2-      SF+     UOF2
 B2H2      COOH            CrO3            H3O+    NCN      SF-     UOF3
 B2H3      CP              CrO3-           H4F4    N2D2_cis SF2     UOF4
 B2H3_db   CS              Cs              H5F5    N2F2     SF2+    UO2
 B2H4      CS2             Cs+             H6F6    N2F4     SF2-    UO2+
 B2H4_db   C2              Cs-             H7F7    N2H2     SF3     UO2-
 B2H5      C2+             CsBO2           He      NH2NO2   SF3+    UO2F
 B2H5_db   C2-             CsBr            He+     N2H4     SF3-    UO2F2
 B2H6      C2Cl            CsCl            Hg      N2O      SF4     UO3
 B2O       C2Cl2           CsF             Hg+     N2O+     SF4+    UO3-
 B2O2      C2Cl3           CsH             HgBr2   N2O3     SF4-    V
 B2O3      C2Cl4           CsI             I       N2O4     SF5     V+
 B2_OH_4   C2Cl6           Csli            I+      N2O5     SF5+    V-
 B2S       C2F             CsNO2           I-      N3       SF5-    VCl4
 B2S2      C2FCl           CsNO3           IF5     N3H      SF6     VN
 B2S3      C2FCl3          CsNa            IF7     Na       SF6-    VO
 B3H7_C2v  C2F2            CsO             I2      Na+      SH      VO2
 B3H7_Cs   C2F2Cl2         CsOH            In      Na-      SH-     V4O10
 B3H9      C2F3            CsRb            In+     NaAlF4   SN      W
 B3N3H6    C2F3Cl          Cs2             InBr    NaBO2    SO      W+
 B3O3Cl3   C2F4            Cs2Br2          InBr2   NaBr     SO-     W-
 B3O3FCl2  C2F6            Cs2CO3          InBr3   NaCN     SOF2    WCl6
 B3O3F2Cl  C2H             Cs2Cl2          InCl    NaCl     SO2     WO
 B3O3F3    C2HCl           Cs2F2           InCl2   NaF      SO2-    WOCl4
 B4H4      C2HCl3          Cs2I2           InCl3   NaH      SO2Cl2  WO2
 B4H10     C2HF            Cs2O            InF     NaI      SO2FCl  WO2Cl2
 B4H12     C2HFCl2         Cs2O+           InF2    Nali     SO2F2   WO3
 B5H9      C2HF2Cl         Cs2O2           InF3    NaNO2    SO3     WO3-
 Ba        C2HF3           Cs2O2H2         InH     NaNO3    S2      Xe
 Ba+       C2H2_vinylidene Cs2SO4          InI     NaO      S2-     Xe+
 BaBr      C2H2Cl2         Cu              InI2    NaOH     S2Cl2   Zn
 BaBr2     C2H2FCl         Cu+             InI3    NaOH+    S2F2    Zn+
 BaCl      C2H2F2          Cu-             InO     Na2      S2O     Zr
 BaCl+     CH2CO_ketene    CuCl            InOH    Na2Br2   S3      Zr+
 BaCl2     O_CH_2O         CuF             In2Br2  Na2Cl2   S4      Zr-
 BaF       HO_CO_2OH       CuF2            In2Br4  Na2F2    S5      ZrN
 BaF+      C2H3_vinyl      CuO             In2Br6  Na2I2    S6      ZrO
 BaF2      CH2Br-COOH      Cu2             In2Cl2  Na2O     S7      ZrO+
 BaH       C2H3Cl          Cu3Cl3          In2Cl4  Na2O+    S8      ZrO2
 BaI       CH2Cl-COOH      D               In2Cl6  Na2O2    Sc
 BaI2      C2H3F           D+              In2F2   Na2O2H2  Sc+
 BaO       CH3CN           D-              In2F4   Na2SO4   Sc-
 BaO+      CH3CO_acetyl    DBr             In2F6   Na3Cl3   ScO
 BaOH      C2H4            DCl             In2I2   Na3F3    ScO+
</pre></html>"));
    end IdealGases;

    package Incompressible
    "Medium model for T-dependent properties, defined by tables or polynomials"
      extends Modelica.Icons.VariantsPackage;
      import Modelica.Constants;
      import Modelica.Math;

      package Common "Common data structures"
        extends Modelica.Icons.Package;

        record BaseProps_Tpoly "Fluid state record"
          extends Modelica.Icons.Record;
          SI.Temperature T "Temperature";
          SI.Pressure p "Pressure";
          //    SI.Density d "Density";
        end BaseProps_Tpoly;
      end Common;

      package TableBased "Incompressible medium properties based on tables"
        import Poly = Modelica.Media.Incompressible.TableBased.Polynomials_Temp;
        extends Modelica.Media.Interfaces.PartialMedium(
           ThermoStates = if enthalpyOfT then Modelica.Media.Interfaces.Choices.IndependentVariables.T
                                                                             else Modelica.Media.Interfaces.Choices.IndependentVariables.pT,
           final reducedX=true,
           final fixedX = true,
           mediumName="tableMedium",
           redeclare record ThermodynamicState=Common.BaseProps_Tpoly,
           singleState=true,
           reference_p = 1.013e5,
           Temperature(min = T_min, max = T_max));

        constant Boolean enthalpyOfT=true
          "True if enthalpy is approximated as a function of T only, (p-dependence neglected)";

        constant Boolean densityOfT = size(tableDensity,1) > 1
          "True if density is a function of temperature";

        constant Modelica.SIunits.Temperature T_min
          "Minimum temperature valid for medium model";

        constant Modelica.SIunits.Temperature T_max
          "Maximum temperature valid for medium model";

        constant Temperature T0=273.15 "Reference Temperature";

        constant SpecificEnthalpy h0=0 "Reference enthalpy at T0, reference_p";

        constant SpecificEntropy s0=0 "Reference entropy at T0, reference_p";

        constant MolarMass MM_const=0.1 "Molar mass";

        constant Integer npol=2 "Degree of polynomial used for fitting";

        constant Integer npolDensity=npol
          "Degree of polynomial used for fitting rho(T)";

        constant Integer npolHeatCapacity=npol
          "Degree of polynomial used for fitting Cp(T)";

        constant Integer npolViscosity=npol
          "Degree of polynomial used for fitting eta(T)";

        constant Integer npolConductivity=npol
          "Degree of polynomial used for fitting lambda(T)";

        constant Integer neta=size(tableViscosity,1)
          "Number of data points for viscosity";

        constant Real[:,2] tableDensity "Table for rho(T)";

        constant Real[:,2] tableHeatCapacity "Table for Cp(T)";

        constant Real[:,2] tableViscosity "Table for eta(T)";

        constant Real[:,2] tableConductivity "Table for lambda(T)";

        constant Boolean TinK "True if T[K],Kelvin used for table temperatures";

        constant Boolean hasDensity = not (size(tableDensity,1)==0)
          "True if table tableDensity is present";

        constant Boolean hasHeatCapacity = not (size(tableHeatCapacity,1)==0)
          "True if table tableHeatCapacity is present";

        constant Boolean hasViscosity = not (size(tableViscosity,1)==0)
          "True if table tableViscosity is present";

        final constant Real invTK[neta] = if size(tableViscosity,1) > 0 then
            (if TinK then 1 ./ tableViscosity[:,1] else 1 ./ Cv.from_degC(tableViscosity[:,1])) else fill(0,neta);

        final constant Real poly_rho[:] = if hasDensity then
                                             Poly.fitting(tableDensity[:,1],tableDensity[:,2],npolDensity) else
                                               zeros(npolDensity+1);

        final constant Real poly_Cp[:] = if hasHeatCapacity then
                                             Poly.fitting(tableHeatCapacity[:,1],tableHeatCapacity[:,2],npolHeatCapacity) else
                                               zeros(npolHeatCapacity+1);

        final constant Real poly_eta[:] = if hasViscosity then
                                             Poly.fitting(invTK, Math.log(tableViscosity[:,2]),npolViscosity) else
                                               zeros(npolViscosity+1);

        final constant Real poly_lam[:] = if size(tableConductivity,1)>0 then
                                             Poly.fitting(tableConductivity[:,1],tableConductivity[:,2],npolConductivity) else
                                               zeros(npolConductivity+1);

        redeclare model extends BaseProperties(
          final standardOrderComponents=true,
          p_bar=Cv.to_bar(p),
          T_degC(start = T_start-273.15)=Cv.to_degC(T),
          T(start = T_start,
            stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default))
          "Base properties of T dependent medium"
        //  redeclare parameter SpecificHeatCapacity R=Modelica.Constants.R,

          SI.SpecificHeatCapacity cp "Specific heat capacity";
          parameter SI.Temperature T_start = 298.15 "Initial temperature";
        equation
          assert(hasDensity,"Medium " + mediumName +
                            " can not be used without assigning tableDensity.");
          assert(T >= T_min and T <= T_max, "Temperature T (= " + String(T) +
                 " K) is not in the allowed range (" + String(T_min) +
                 " K <= T <= " + String(T_max) + " K) required from medium model \""
                 + mediumName + "\".");
          R = Modelica.Constants.R/MM_const;
          cp = Poly.evaluate(poly_Cp,if TinK then T else T_degC);
          h = if enthalpyOfT then h_T(T) else  h_pT(p,T,densityOfT);
          u = h - (if singleState then  reference_p/d else state.p/d);
          d = Poly.evaluate(poly_rho,if TinK then T else T_degC);
          state.T = T;
          state.p = p;
          MM = MM_const;
          annotation(Documentation(info="<html>
<p>
Note that the inner energy neglects the pressure dependence, which is only
true for an incompressible medium with d = constant. The neglected term is
p-reference_p)/rho*(T/rho)*(partial rho /partial T). This is very small for
liquids due to proportionality to 1/d^2, but can be problematic for gases that are
modeled incompressible.
</p>
<p>It should be noted that incompressible media only have 1 state per control volume (usually T),
but have both T and p as inputs for fully correct properties. The error of using only T-dependent
properties is small, therefore a Boolean flag enthalpyOfT exists. If it is true, the
enumeration Choices.independentVariables  is set to  Choices.independentVariables.T otherwise
it is set to Choices.independentVariables.pT.</p>
<p>
Enthalpy is never a function of T only (h = h(T) + (p-reference_p)/d), but the
error is also small and non-linear systems can be avoided. In particular,
non-linear systems are small and local as opposed to large and over all volumes.
</p>

<p>
Entropy is calculated as
</p>
<pre>
  s = s0 + integral(Cp(T)/T,dt)
</pre>
<p>
which is only exactly true for a fluid with constant density d=d0.
</p>
</html>"));
        end BaseProperties;

        redeclare function extends setState_pTX
          "Returns state record, given pressure and temperature"
        algorithm
          state := ThermodynamicState(p=p,T=T);
          annotation(smoothOrder=3);
        end setState_pTX;

        redeclare function extends setState_dTX
          "Returns state record, given pressure and temperature"
        algorithm
          assert(false, "For incompressible media with d(T) only, state can not be set from density and temperature");
        end setState_dTX;

        redeclare function extends setState_phX
          "Returns state record, given pressure and specific enthalpy"
        algorithm
          state :=ThermodynamicState(p=p,T=T_ph(p,h));
          annotation(Inline=true,smoothOrder=3);
        end setState_phX;

        redeclare function extends setState_psX
          "Returns state record, given pressure and specific entropy"
        algorithm
          state :=ThermodynamicState(p=p,T=T_ps(p,s));
          annotation(Inline=true,smoothOrder=3);
        end setState_psX;

            redeclare function extends setSmoothState
        "Return thermodynamic state so that it smoothly approximates: if x > 0 then state_a else state_b"
            algorithm
              state :=ThermodynamicState(p=Media.Common.smoothStep(x, state_a.p, state_b.p, x_small),
                                         T=Media.Common.smoothStep(x, state_a.T, state_b.T, x_small));
              annotation(Inline=true,smoothOrder=3);
            end setSmoothState;

        redeclare function extends specificHeatCapacityCv
          "Specific heat capacity at constant volume (or pressure) of medium"

        algorithm
          assert(hasHeatCapacity,"Specific Heat Capacity, Cv, is not defined for medium "
                                                 + mediumName + ".");
          cv := Poly.evaluate(poly_Cp,if TinK then state.T else state.T - 273.15);
         annotation(smoothOrder=2);
        end specificHeatCapacityCv;

        redeclare function extends specificHeatCapacityCp
          "Specific heat capacity at constant volume (or pressure) of medium"

        algorithm
          assert(hasHeatCapacity,"Specific Heat Capacity, Cv, is not defined for medium "
                                                 + mediumName + ".");
          cp := Poly.evaluate(poly_Cp,if TinK then state.T else state.T - 273.15);
         annotation(smoothOrder=2);
        end specificHeatCapacityCp;

        redeclare function extends dynamicViscosity
          "Return dynamic viscosity as a function of the thermodynamic state record"

        algorithm
          assert(size(tableViscosity,1)>0,"DynamicViscosity, eta, is not defined for medium "
                                                 + mediumName + ".");
          eta := Math.exp(Poly.evaluate(poly_eta, 1/state.T));
         annotation(smoothOrder=2);
        end dynamicViscosity;

        redeclare function extends thermalConductivity
          "Return thermal conductivity as a function of the thermodynamic state record"

        algorithm
          assert(size(tableConductivity,1)>0,"ThermalConductivity, lambda, is not defined for medium "
                                                 + mediumName + ".");
          lambda := Poly.evaluate(poly_lam,if TinK then state.T else Cv.to_degC(state.T));
         annotation(smoothOrder=2);
        end thermalConductivity;

        function s_T "Compute specific entropy"
          extends Modelica.Icons.Function;
          input Temperature T "Temperature";
          output SpecificEntropy s "Specific entropy";
        algorithm
          s := s0 + (if TinK then
            Poly.integralValue(poly_Cp[1:npol],T, T0) else
            Poly.integralValue(poly_Cp[1:npol],Cv.to_degC(T),Cv.to_degC(T0)))
            + Modelica.Math.log(T/T0)*
            Poly.evaluate(poly_Cp,if TinK then 0 else Modelica.Constants.T_zero);
         annotation(Inline=true,smoothOrder=2);
        end s_T;

        redeclare function extends specificEntropy
          "Return specific entropy as a function of the thermodynamic state record"

      protected
          Integer npol=size(poly_Cp,1)-1;
        algorithm
          assert(hasHeatCapacity,"Specific Entropy, s(T), is not defined for medium "
                                                 + mediumName + ".");
          s := s_T(state.T);
         annotation(smoothOrder=2);
        end specificEntropy;

        function h_T "Compute specific enthalpy from temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Temperature T "Temperature";
          output SI.SpecificEnthalpy h "Specific enthalpy at p, T";
        algorithm
          h :=h0 + Poly.integralValue(poly_Cp, if TinK then T else Cv.to_degC(T), if TinK then
          T0 else Cv.to_degC(T0));
         annotation(derivative=h_T_der);
        end h_T;

        function h_T_der "Compute specific enthalpy from temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Temperature T "Temperature";
          input Real dT "Temperature derivative";
          output Real dh "Derivative of Specific enthalpy at T";
        algorithm
          dh :=Poly.evaluate(poly_Cp, if TinK then T else Cv.to_degC(T))*dT;
         annotation(smoothOrder=1);
        end h_T_der;

        function h_pT "Compute specific enthalpy from pressure and temperature"
          import Modelica.SIunits.Conversions.to_degC;
          extends Modelica.Icons.Function;
          input SI.Pressure p "Pressure";
          input SI.Temperature T "Temperature";
          input Boolean densityOfT = false
            "Include or neglect density derivative dependence of enthalpy" annotation(Evaluate);
          output SI.SpecificEnthalpy h "Specific enthalpy at p, T";
        algorithm
          h :=h0 + Poly.integralValue(poly_Cp, if TinK then T else Cv.to_degC(T), if TinK then
          T0 else Cv.to_degC(T0)) + (p - reference_p)/Poly.evaluate(poly_rho, if TinK then
                  T else Cv.to_degC(T))
            *(if densityOfT then (1 + T/Poly.evaluate(poly_rho, if TinK then T else Cv.to_degC(T))
          *Poly.derivativeValue(poly_rho,if TinK then T else Cv.to_degC(T))) else 1.0);
         annotation(smoothOrder=2);
        end h_pT;

        redeclare function extends temperature
          "Return temperature as a function of the thermodynamic state record"
        algorithm
         T := state.T;
         annotation(Inline=true,smoothOrder=2);
        end temperature;

        redeclare function extends pressure
          "Return pressure as a function of the thermodynamic state record"
        algorithm
         p := state.p;
         annotation(Inline=true,smoothOrder=2);
        end pressure;

        redeclare function extends density
          "Return density as a function of the thermodynamic state record"
        algorithm
          d := Poly.evaluate(poly_rho,if TinK then state.T else Cv.to_degC(state.T));
         annotation(Inline=true,smoothOrder=2);
        end density;

        redeclare function extends specificEnthalpy
          "Return specific enthalpy as a function of the thermodynamic state record"
        algorithm
          h := if enthalpyOfT then h_T(state.T) else h_pT(state.p,state.T);
         annotation(Inline=true,smoothOrder=2);
        end specificEnthalpy;

        redeclare function extends specificInternalEnergy
          "Return specific internal energy as a function of the thermodynamic state record"
        algorithm
          u := (if enthalpyOfT then h_T(state.T) else h_pT(state.p,state.T)) - (if singleState then  reference_p else state.p)/density(state);
         annotation(Inline=true,smoothOrder=2);
        end specificInternalEnergy;

        function T_ph "Compute temperature from pressure and specific enthalpy"
          extends Modelica.Icons.Function;
          input AbsolutePressure p "Pressure";
          input SpecificEnthalpy h "Specific enthalpy";
          output Temperature T "Temperature";
      protected
          package Internal
            "Solve h(T) for T with given h (use only indirectly via temperature_phX)"
            extends Modelica.Media.Common.OneNonLinearEquation;

            redeclare record extends f_nonlinear_Data
              "Superfluous record, fix later when better structure of inverse functions exists"
                constant Real[5] dummy = {1,2,3,4,5};
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear "P is smuggled in via vector"
            algorithm
              y := if singleState then h_T(x) else h_pT(p,x);
            end f_nonlinear;

          end Internal;
        algorithm
         T := Internal.solve(h, T_min, T_max, p, {1}, Internal.f_nonlinear_Data());
          annotation(Inline=false, LateInline=true, inverse(h=h_pT(p,T)));
        end T_ph;

        function T_ps "Compute temperature from pressure and specific enthalpy"
          extends Modelica.Icons.Function;

          input AbsolutePressure p "Pressure";
          input SpecificEntropy s "Specific entropy";
          output Temperature T "Temperature";
      protected
          package Internal
            "Solve h(T) for T with given h (use only indirectly via temperature_phX)"
            extends Modelica.Media.Common.OneNonLinearEquation;

            redeclare record extends f_nonlinear_Data
              "Superfluous record, fix later when better structure of inverse functions exists"
                constant Real[5] dummy = {1,2,3,4,5};
            end f_nonlinear_Data;

            redeclare function extends f_nonlinear "P is smuggled in via vector"
            algorithm
              y := s_T(x);
            end f_nonlinear;

          end Internal;
        algorithm
         T := Internal.solve(s, T_min, T_max, p, {1}, Internal.f_nonlinear_Data());
        end T_ps;

        package Polynomials_Temp
        "Temporary Functions operating on polynomials (including polynomial fitting); only to be used in Modelica.Media.Incompressible.TableBased"
          extends Modelica.Icons.Package;

          function evaluate "Evaluate polynomial at a given abscissa value"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            output Real y "Value of polynomial at u";
          algorithm
            y := p[1];
            for j in 2:size(p, 1) loop
              y := p[j] + u*y;
            end for;
            annotation(derivative(zeroDerivative=p)=evaluate_der);
          end evaluate;

          function evaluateWithRange
            "Evaluate polynomial at a given abscissa value with linear extrapolation outside of the defined range"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real uMin "Polynomial valid in the range uMin .. uMax";
            input Real uMax "Polynomial valid in the range uMin .. uMax";
            input Real u "Abscissa value";
            output Real y
              "Value of polynomial at u. Outside of uMin,uMax, linear extrapolation is used";
          algorithm
            if u < uMin then
              y := evaluate(p, uMin) - evaluate_der(
                      p,
                      uMin,
                      uMin - u);
            elseif u > uMax then
              y := evaluate(p, uMax) + evaluate_der(
                      p,
                      uMax,
                      u - uMax);
            else
              y := evaluate(p, u);
            end if;
            annotation (derivative(
                zeroDerivative=p,
                zeroDerivative=uMin,
                zeroDerivative=uMax) = evaluateWithRange_der);
          end evaluateWithRange;

          function derivativeValue
            "Value of derivative of polynomial at abscissa value u"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            output Real y "Value of derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            y := p[1]*(n - 1);
            for j in 2:size(p, 1)-1 loop
              y := p[j]*(n - j) + u*y;
            end for;
            annotation(derivative(zeroDerivative=p)=derivativeValue_der);
          end derivativeValue;

          function secondDerivativeValue
            "Value of 2nd derivative of polynomial at abscissa value u"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            output Real y "Value of 2nd derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            y := p[1]*(n - 1)*(n - 2);
            for j in 2:size(p, 1)-2 loop
              y := p[j]*(n - j)*(n - j - 1) + u*y;
            end for;
          end secondDerivativeValue;

          function integralValue "Integral of polynomial p(u) from u_low to u_high"
            extends Modelica.Icons.Function;
            input Real p[:] "Polynomial coefficients";
            input Real u_high "High integrand value";
            input Real u_low=0 "Low integrand value, default 0";
            output Real integral=0.0
              "Integral of polynomial p from u_low to u_high";
        protected
            Integer n=size(p, 1) "Degree of integrated polynomial";
            Real y_low=0 "Value at lower integrand";
          algorithm
            for j in 1:n loop
              integral := u_high*(p[j]/(n - j + 1) + integral);
              y_low := u_low*(p[j]/(n - j + 1) + y_low);
            end for;
            integral := integral - y_low;
            annotation(derivative(zeroDerivative=p)=integralValue_der);
          end integralValue;

          function fitting
            "Computes the coefficients of a polynomial that fits a set of data points in a least-squares sense"
            extends Modelica.Icons.Function;
            input Real u[:] "Abscissa data values";
            input Real y[size(u, 1)] "Ordinate data values";
            input Integer n(min=1)
              "Order of desired polynomial that fits the data points (u,y)";
            output Real p[n + 1]
              "Polynomial coefficients of polynomial that fits the date points";
        protected
            Real V[size(u, 1), n + 1] "Vandermonde matrix";
          algorithm
            // Construct Vandermonde matrix
            V[:, n + 1] := ones(size(u, 1));
            for j in n:-1:1 loop
              V[:, j] := {u[i] * V[i, j + 1] for i in 1:size(u,1)};
            end for;

            // Solve least squares problem
            p :=Modelica.Math.Matrices.leastSquares(V, y);
            annotation (Documentation(info="<html>
<p>
Polynomials.fitting(u,y,n) computes the coefficients of a polynomial
p(u) of degree \"n\" that fits the data \"p(u[i]) - y[i]\"
in a least squares sense. The polynomial is
returned as a vector p[n+1] that has the following definition:
</p>
<pre>
  p(u) = p[1]*u^n + p[2]*u^(n-1) + ... + p[n]*u + p[n+1];
</pre>
</html>"));
          end fitting;

          function evaluate_der
            "Evaluate derivative of polynomial at a given abscissa value"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            input Real du "Delta of abscissa value";
            output Real dy "Value of derivative of polynomial at u";
        protected
            Integer n=size(p, 1);
          algorithm
            dy := p[1]*(n - 1);
            for j in 2:size(p, 1)-1 loop
              dy := p[j]*(n - j) + u*dy;
            end for;
            dy := dy*du;
          end evaluate_der;

          function evaluateWithRange_der
            "Evaluate derivative of polynomial at a given abscissa value with extrapolation outside of the defined range"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real uMin "Polynomial valid in the range uMin .. uMax";
            input Real uMax "Polynomial valid in the range uMin .. uMax";
            input Real u "Abscissa value";
            input Real du "Delta of abscissa value";
            output Real dy "Value of derivative of polynomial at u";
          algorithm
            if u < uMin then
              dy := evaluate_der(
                      p,
                      uMin,
                      du);
            elseif u > uMax then
              dy := evaluate_der(
                      p,
                      uMax,
                      du);
            else
              dy := evaluate_der(
                      p,
                      u,
                      du);
            end if;
          end evaluateWithRange_der;

          function integralValue_der
            "Time derivative of integral of polynomial p(u) from u_low to u_high, assuming only u_high as time-dependent (Leibniz rule)"
            extends Modelica.Icons.Function;
            input Real p[:] "Polynomial coefficients";
            input Real u_high "High integrand value";
            input Real u_low=0 "Low integrand value, default 0";
            input Real du_high "High integrand value";
            input Real du_low=0 "Low integrand value, default 0";
            output Real dintegral=0.0
              "Integral of polynomial p from u_low to u_high";
          algorithm
            dintegral := evaluate(p,u_high)*du_high;
          end integralValue_der;

          function derivativeValue_der
            "Time derivative of derivative of polynomial"
            extends Modelica.Icons.Function;
            input Real p[:]
              "Polynomial coefficients (p[1] is coefficient of highest power)";
            input Real u "Abscissa value";
            input Real du "Delta of abscissa value";
            output Real dy
              "Time-derivative of derivative of polynomial w.r.t. input variable at u";
        protected
            Integer n=size(p, 1);
          algorithm
            dy := secondDerivativeValue(p,u)*du;
          end derivativeValue_der;
          annotation (Documentation(info="<html>
<p>
This package contains functions to operate on polynomials,
in particular to determine the derivative and the integral
of a polynomial and to use a polynomial to fit a given set
of data points.
</p>

<p>
Copyright &copy; 2004-2019, Modelica Association and contributors
</p>
</html>",         revisions="<html>
<ul>
<li><em>Oct. 22, 2004</em> by Martin Otter (DLR):<br>
       Renamed functions to not have abbreviations.<br>
       Based fitting on LAPACK<br>
       New function to return the polynomial of an indefinite integral</li>
<li><em>Sept. 3, 2004</em> by Jonas Eborn (Scynamics):<br>
       polyderval, polyintval added</li>
<li><em>March 1, 2004</em> by Martin Otter (DLR):<br>
       first version implemented</li>
</ul>
</html>"));
        end Polynomials_Temp;
      annotation(Documentation(info="<html>
<p>
This is the base package for medium models of incompressible fluids based on
tables. The minimal data to provide for a useful medium description is tables
of density and heat capacity as functions of temperature.
</p>

<p>It should be noted that incompressible media only have 1 state per control volume (usually T),
but have both T and p as inputs for fully correct properties. The error of using only T-dependent
properties is small, therefore a Boolean flag enthalpyOfT exists. If it is true, the
enumeration Choices.independentVariables  is set to  Choices.independentVariables.T otherwise
it is set to Choices.independentVariables.pT.</p>

<h4>Using the package TableBased</h4>
<p>
To implement a new medium model, create a package that <strong>extends</strong> TableBased
and provides one or more of the constant tables:
</p>

<pre>
tableDensity        = [T, d];
tableHeatCapacity   = [T, Cp];
tableConductivity   = [T, lam];
tableViscosity      = [T, eta];
tableVaporPressure  = [T, pVap];
</pre>

<p>
The table data is used to fit constant polynomials of order <strong>npol</strong>, the
temperature data points do not need to be same for different properties. Properties
like enthalpy, inner energy and entropy are calculated consistently from integrals
and derivatives of d(T) and Cp(T). The minimal
data for a useful medium model is thus density and heat capacity. Transport
properties and vapor pressure are optional, if the data tables are empty the corresponding
function calls can not be used.
</p>
</html>"));
      end TableBased;
      annotation (
        Documentation(info="<html>
<h4>Incompressible media package</h4>
<p>
This package provides a structure and examples of how to create simple
medium models of incompressible fluids, meaning fluids with very little
pressure influence on density. The medium properties is typically described
in terms of tables, functions or polynomial coefficients.
</p>
<h4>Definitions</h4>
<p>
The common meaning of <em>incompressible</em> is that properties like density
and enthalpy are independent of pressure. Thus properties are conveniently
described as functions of temperature, e.g., as polynomials density(T) and cp(T).
However, enthalpy can not be independent of pressure since h = u - p/d. For liquids
it is anyway
common to neglect this dependence since for constant density the neglected term
is (p - p0)/d, which in comparison with cp is very small for most liquids. For
water, the equivalent change of temperature to increasing pressure 1 bar is
0.025 Kelvin.
</p>
<p>
Two Boolean flags are used to choose how enthalpy and inner energy is calculated:
</p>
<ul>
<li><strong>enthalpyOfT</strong>=true, means assuming that enthalpy is only a function
of temperature, neglecting the pressure dependent term.</li>
<li><strong>singleState</strong>=true, means also neglect the pressure influence on inner
energy, which makes all medium properties pure functions of temperature.</li>
</ul>
<p>
The default setting for both these flags is true, which enables the simulation tool
to choose temperature as the only medium state and avoids non-linear equation
systems, see the section about
<a href=\"modelica://Modelica.Media.UsersGuide.MediumDefinition.StaticStateSelection\">Static
state selection</a> in the Modelica.Media User's Guide.
</p>

<h4>Contents</h4>
<p>
Currently, the package contains the following parts:
</p>
<ol>
<li> <a href=\"modelica://Modelica.Media.Incompressible.TableBased\">
      Table based medium models</a></li>
<li> <a href=\"modelica://Modelica.Media.Incompressible.Examples\">
      Example medium models</a></li>
</ol>

<p>
A few examples are given in the Examples package. The model
<a href=\"modelica://Modelica.Media.Incompressible.Examples.Glycol47\">
Examples.Glycol47</a> shows how the medium models can be used. For more
realistic examples of how to implement volume models with medium properties
look in the <a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage\">Medium
usage section</a> of the User's Guide.
</p>

</html>"));
    end Incompressible;

    package Water "Medium models for water"
    extends Modelica.Icons.VariantsPackage;
    import Modelica.Media.Water.ConstantPropertyLiquidWater.simpleWaterConstants;

    package ConstantPropertyLiquidWater
      "Water: Simple liquid water medium (incompressible, constant data)"

      //   redeclare record extends FluidConstants
      //   end FluidConstants;

      constant Modelica.Media.Interfaces.Types.Basic.FluidConstants[1]
        simpleWaterConstants(
        each chemicalFormula="H2O",
        each structureFormula="H2O",
        each casRegistryNumber="7732-18-5",
        each iupacName="oxidane",
        each molarMass=0.018015268);

      extends Interfaces.PartialSimpleMedium(
        mediumName="SimpleLiquidWater",
        cp_const=4184,
        cv_const=4184,
        d_const=995.586,
        eta_const=1.e-3,
        lambda_const=0.598,
        a_const=1484,
        T_min=Cv.from_degC(-1),
        T_max=Cv.from_degC(130),
        T0=273.15,
        MM_const=0.018015268,
        fluidConstants=simpleWaterConstants);

      annotation (Documentation(info="<html>

</html>"));
    end ConstantPropertyLiquidWater;
    annotation (Documentation(info="<html>
<p>This package contains different medium models for water:</p>
<ul>
<li><strong>ConstantPropertyLiquidWater</strong><br>
    Simple liquid water medium (incompressible, constant data).</li>
<li><strong>IdealSteam</strong><br>
    Steam water medium as ideal gas from Media.IdealGases.SingleGases.H2O</li>
<li><strong>WaterIF97 derived models</strong><br>
    High precision water model according to the IAPWS/IF97 standard
    (liquid, steam, two phase region). Models with different independent
    variables are provided as well as models valid only
    for particular regions. The <strong>WaterIF97_ph</strong> model is valid
    in all regions and is the recommended one to use.</li>
</ul>
<h4>Overview of WaterIF97 derived water models</h4>
<p>
The WaterIF97 models calculate medium properties
for water in the <strong>liquid</strong>, <strong>gas</strong> and <strong>two phase</strong> regions
according to the IAPWS/IF97 standard, i.e., the accepted industrial standard
and best compromise between accuracy and computation time.
It has been part of the ThermoFluid Modelica library and been extended,
reorganized and documented to become part of the Modelica Standard library.</p>
<p>An important feature that distinguishes this implementation of the IF97 steam property standard
is that this implementation has been explicitly designed to work well in dynamic simulations. Computational
performance has been of high importance. This means that there often exist several ways to get the same result
from different functions if one of the functions is called often but can be optimized for that purpose.
</p>
<p>Three variable pairs can be the independent variables of the model:
</p>
<ol>
<li>Pressure <strong>p</strong> and specific enthalpy <strong>h</strong> are
    the most natural choice for general applications.
    This is the recommended choice for most general purpose
    applications, in particular for power plants.</li>
<li>Pressure <strong>p</strong> and temperature <strong>T</strong> are the most natural
    choice for applications where water is always in the same phase,
    both for liquid water and steam.</li>
<li>Density <strong>d</strong> and temperature <strong>T</strong> are explicit
    variables of the Helmholtz function in the near-critical
    region and can be the best choice for applications with
    super-critical or near-critical states.</li>
</ol>
<p>
The following quantities are always computed in Medium.BaseProperties:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Variable</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>T</td>
      <td>K</td>
      <td>temperature</td></tr>
  <tr><td>u</td>
      <td>J/kg</td>
      <td>specific internal energy</td></tr>
  <tr><td>d</td>
      <td>kg/m^3</td>
      <td>density</td></tr>
  <tr><td>p</td>
      <td>Pa</td>
      <td>pressure</td></tr>
  <tr><td>h</td>
      <td>J/kg</td>
      <td>specific enthalpy</td></tr>
</table>
<p>
In some cases additional medium properties are needed.
A component that needs these optional properties has to call
one of the following functions:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Function call</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>Medium.dynamicViscosity(medium.state)</td>
      <td>Pa.s</td>
      <td>dynamic viscosity</td></tr>
  <tr><td>Medium.thermalConductivity(medium.state)</td>
      <td>W/(m.K)</td>
      <td>thermal conductivity</td></tr>
  <tr><td>Medium.prandtlNumber(medium.state)</td>
      <td>1</td>
      <td>Prandtl number</td></tr>
  <tr><td>Medium.specificEntropy(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific entropy</td></tr>
  <tr><td>Medium.heatCapacity_cp(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific heat capacity at constant pressure</td></tr>
  <tr><td>Medium.heatCapacity_cv(medium.state)</td>
      <td>J/(kg.K)</td>
      <td>specific heat capacity at constant density</td></tr>
  <tr><td>Medium.isentropicExponent(medium.state)</td>
      <td>1</td>
      <td>isentropic exponent</td></tr>
  <tr><td>Medium.isentropicEnthalpy(pressure, medium.state)</td>
      <td>J/kg</td>
      <td>isentropic enthalpy</td></tr>
  <tr><td>Medium.velocityOfSound(medium.state)</td>
      <td>m/s</td>
      <td>velocity of sound</td></tr>
  <tr><td>Medium.isobaricExpansionCoefficient(medium.state)</td>
      <td>1/K</td>
      <td>isobaric expansion coefficient</td></tr>
  <tr><td>Medium.isothermalCompressibility(medium.state)</td>
      <td>1/Pa</td>
      <td>isothermal compressibility</td></tr>
  <tr><td>Medium.density_derp_h(medium.state)</td>
      <td>kg/(m3.Pa)</td>
      <td>derivative of density by pressure at constant enthalpy</td></tr>
  <tr><td>Medium.density_derh_p(medium.state)</td>
      <td>kg2/(m3.J)</td>
      <td>derivative of density by enthalpy at constant pressure</td></tr>
  <tr><td>Medium.density_derp_T(medium.state)</td>
      <td>kg/(m3.Pa)</td>
      <td>derivative of density by pressure at constant temperature</td></tr>
  <tr><td>Medium.density_derT_p(medium.state)</td>
      <td>kg/(m3.K)</td>
      <td>derivative of density by temperature at constant pressure</td></tr>
  <tr><td>Medium.density_derX(medium.state)</td>
      <td>kg/m3</td>
      <td>derivative of density by mass fraction</td></tr>
  <tr><td>Medium.molarMass(medium.state)</td>
      <td>kg/mol</td>
      <td>molar mass</td></tr>
</table>
<p>More details are given in
<a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage.OptionalProperties\">
Modelica.Media.UsersGuide.MediumUsage.OptionalProperties</a>.

Many additional optional functions are defined to compute properties of
saturated media, either liquid (bubble point) or vapour (dew point).
The argument to such functions is a SaturationProperties record, which can be
set starting from either the saturation pressure or the saturation temperature.
With reference to a model defining a pressure p, a temperature T, and a
SaturationProperties record sat, the following functions are provided:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td><strong>Function call</strong></td>
      <td><strong>Unit</strong></td>
      <td><strong>Description</strong></td></tr>
  <tr><td>Medium.saturationPressure(T)</td>
      <td>Pa</td>
      <td>Saturation pressure at temperature T</td></tr>
  <tr><td>Medium.saturationTemperature(p)</td>
      <td>K</td>
      <td>Saturation temperature at pressure p</td></tr>
  <tr><td>Medium.saturationTemperature_derp(p)</td>
      <td>K/Pa</td>
      <td>Derivative of saturation temperature with respect to pressure</td></tr>
  <tr><td>Medium.bubbleEnthalpy(sat)</td>
      <td>J/kg</td>
      <td>Specific enthalpy at bubble point</td></tr>
  <tr><td>Medium.dewEnthalpy(sat)</td>
      <td>J/kg</td>
      <td>Specific enthalpy at dew point</td></tr>
  <tr><td>Medium.bubbleEntropy(sat)</td>
      <td>J/(kg.K)</td>
      <td>Specific entropy at bubble point</td></tr>
  <tr><td>Medium.dewEntropy(sat)</td>
      <td>J/(kg.K)</td>
      <td>Specific entropy at dew point</td></tr>
  <tr><td>Medium.bubbleDensity(sat)</td>
      <td>kg/m3</td>
      <td>Density at bubble point</td></tr>
  <tr><td>Medium.dewDensity(sat)</td>
      <td>kg/m3</td>
      <td>Density at dew point</td></tr>
  <tr><td>Medium.dBubbleDensity_dPressure(sat)</td>
      <td>kg/(m3.Pa)</td>
      <td>Derivative of density at bubble point with respect to pressure</td></tr>
  <tr><td>Medium.dDewDensity_dPressure(sat)</td>
      <td>kg/(m3.Pa)</td>
      <td>Derivative of density at dew point with respect to pressure</td></tr>
  <tr><td>Medium.dBubbleEnthalpy_dPressure(sat)</td>
      <td>J/(kg.Pa)</td>
      <td>Derivative of specific enthalpy at bubble point with respect to pressure</td></tr>
  <tr><td>Medium.dDewEnthalpy_dPressure(sat)</td>
      <td>J/(kg.Pa)</td>
      <td>Derivative of specific enthalpy at dew point with respect to pressure</td></tr>
  <tr><td>Medium.surfaceTension(sat)</td>
      <td>N/m</td>
      <td>Surface tension between liquid and vapour phase</td></tr>
</table>
<p>Details on usage and some examples are given in:
<a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage.TwoPhase\">
Modelica.Media.UsersGuide.MediumUsage.TwoPhase</a>.
</p>
<p>Many further properties can be computed. Using the well-known Bridgman's Tables,
all first partial derivatives of the standard thermodynamic variables can be computed easily.
</p>
<p>
The documentation of the IAPWS/IF97 steam properties can be freely
distributed with computer implementations and are included here
(in directory Modelica/Resources/Documentation/Media/Water/IF97documentation):
</p>
<ul>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/IF97.pdf\">IF97.pdf</a> The standards document for the main part of the IF97.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/Back3.pdf\">Back3.pdf</a> The backwards equations for region 3.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/crits.pdf\">crits.pdf</a> The critical point data.</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/meltsub.pdf\">meltsub.pdf</a> The melting- and sublimation line formulation (not implemented)</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/surf.pdf\">surf.pdf</a> The surface tension standard definition</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/thcond.pdf\">thcond.pdf</a> The thermal conductivity standard definition</li>
<li><a href=\"modelica://Modelica/Resources/Documentation/Media/Water/IF97documentation/visc.pdf\">visc.pdf</a> The viscosity standard definition</li>
</ul>
</html>"));
    end Water;
  annotation (preferredView="info",Documentation(info="<html>
<p>
This library contains <a href=\"modelica://Modelica.Media.Interfaces\">interface</a>
definitions for media and the following <strong>property</strong> models for
single and multiple substance fluids with one and multiple phases:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Media.IdealGases\">Ideal gases:</a><br>
     1241 high precision gas models based on the
     NASA Glenn coefficients, plus ideal gas mixture models based
     on the same data.</li>
<li> <a href=\"modelica://Modelica.Media.Water\">Water models:</a><br>
     ConstantPropertyLiquidWater, WaterIF97 (high precision
     water model according to the IAPWS/IF97 standard)</li>
<li> <a href=\"modelica://Modelica.Media.Air\">Air models:</a><br>
     SimpleAir, DryAirNasa, ReferenceAir, MoistAir, ReferenceMoistAir.</li>
<li> <a href=\"modelica://Modelica.Media.Incompressible\">
     Incompressible media:</a><br>
     TableBased incompressible fluid models (properties are defined by tables rho(T),
     HeatCapacity_cp(T), etc.)</li>
<li> <a href=\"modelica://Modelica.Media.CompressibleLiquids\">
     Compressible liquids:</a><br>
     Simple liquid models with linear compressibility</li>
<li> <a href=\"modelica://Modelica.Media.R134a\">Refrigerant Tetrafluoroethane (R134a)</a>.</li>
</ul>
<p>
The following parts are useful, when newly starting with this library:</p>
<ul>
<li> <a href=\"modelica://Modelica.Media.UsersGuide\">Modelica.Media.UsersGuide</a>.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.MediumUsage\">Modelica.Media.UsersGuide.MediumUsage</a>
     describes how to use a medium model in a component model.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.MediumDefinition\">
     Modelica.Media.UsersGuide.MediumDefinition</a>
     describes how a new fluid medium model has to be implemented.</li>
<li> <a href=\"modelica://Modelica.Media.UsersGuide.ReleaseNotes\">Modelica.Media.UsersGuide.ReleaseNotes</a>
     summarizes the changes of the library releases.</li>
<li> <a href=\"modelica://Modelica.Media.Examples\">Modelica.Media.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>February 01, 2017</em> by Thomas Beutlich:<br/>
    Fixed data errors of the NASA Glenn coefficients in some ideal gases (CH2, CH3, CH3OOH, C2CL2, C2CL4, C2CL6, C2HCL, C2HCL3, CH2CO_ketene, O_CH_2O, HO_CO_2OH, CH2BrminusCOOH, C2H3CL, CH2CLminusCOOH, HO2, HO2minus, OD, ODminus), see <a href=\"https://github.com/modelica/ModelicaStandardLibrary/issues/1922\">#1922</a></li>
<li><em>May 16, 2013</em> by Stefan Wischhusen (XRG Simulation):<br/>
    Added new media models Air.ReferenceMoistAir, Air.ReferenceAir, R134a.</li>
<li><em>May 25, 2011</em> by Francesco Casella:<br/>Added min/max attributes to Water, TableBased, MixtureGasNasa, SimpleAir and MoistAir local types.</li>
<li><em>May 25, 2011</em> by Stefan Wischhusen:<br/>Added individual settings for polynomial fittings of properties.</li>
</ul>
</html>"),
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Line(
            points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
            color={64,64,64},
            smooth=Smooth.Bezier),
          Line(
            points={{-40,20},{68,20}},
            color={175,175,175}),
          Line(
            points={{-40,20},{-44,88},{-44,88}},
            color={175,175,175}),
          Line(
            points={{68,20},{86,-58}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{56,-28}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{-74,84},{-74,84}},
            color={175,175,175}),
          Line(
            points={{56,-28},{70,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{38,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{-94,-16},{-94,-16}},
            color={175,175,175})}));
  end Media;

  package Thermal
  "Library of thermal system components to model heat transfer and simple thermo-fluid pipe flow"
    extends Modelica.Icons.Package;

    package HeatTransfer
    "Library of 1-dimensional heat transfer with lumped elements"
      extends Modelica.Icons.Package;

      package Components "Lumped thermal components"
      extends Modelica.Icons.Package;

        model HeatCapacitor "Lumped thermal element storing heat"
          parameter Modelica.SIunits.HeatCapacity C
            "Heat capacity of element (= cp*m)";
          Modelica.SIunits.Temperature T(start=293.15, displayUnit="degC")
            "Temperature of element";
          Modelica.SIunits.TemperatureSlope der_T(start=0)
            "Time derivative of temperature (= der(T))";
          Interfaces.HeatPort_a port annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90)));
        equation
          T = port.T;
          der_T = der(T);
          C*der(T) = port.Q_flow;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,110},{150,70}},
                  textString="%name",
                  lineColor={0,0,255}),
                Polygon(
                  points={{0,67},{-20,63},{-40,57},{-52,43},{-58,35},{-68,25},{-72,
                      13},{-76,-1},{-78,-15},{-76,-31},{-76,-43},{-76,-53},{-70,-65},
                      {-64,-73},{-48,-77},{-30,-83},{-18,-83},{-2,-85},{8,-89},{22,
                      -89},{32,-87},{42,-81},{54,-75},{56,-73},{66,-61},{68,-53},{
                      70,-51},{72,-35},{76,-21},{78,-13},{78,3},{74,15},{66,25},{54,
                      33},{44,41},{36,57},{26,65},{0,67}},
                  lineColor={160,160,164},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-58,35},{-68,25},{-72,13},{-76,-1},{-78,-15},{-76,-31},{
                      -76,-43},{-76,-53},{-70,-65},{-64,-73},{-48,-77},{-30,-83},{-18,
                      -83},{-2,-85},{8,-89},{22,-89},{32,-87},{42,-81},{54,-75},{42,
                      -77},{40,-77},{30,-79},{20,-81},{18,-81},{10,-81},{2,-77},{-12,
                      -73},{-22,-73},{-30,-71},{-40,-65},{-50,-55},{-56,-43},{-58,-35},
                      {-58,-25},{-60,-13},{-60,-5},{-60,7},{-58,17},{-56,19},{-52,
                      27},{-48,35},{-44,45},{-40,57},{-58,35}},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-69,7},{71,-24}},
                  textString="%C")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Polygon(
                  points={{0,67},{-20,63},{-40,57},{-52,43},{-58,35},{-68,25},{-72,
                      13},{-76,-1},{-78,-15},{-76,-31},{-76,-43},{-76,-53},{-70,-65},
                      {-64,-73},{-48,-77},{-30,-83},{-18,-83},{-2,-85},{8,-89},{22,
                      -89},{32,-87},{42,-81},{54,-75},{56,-73},{66,-61},{68,-53},{
                      70,-51},{72,-35},{76,-21},{78,-13},{78,3},{74,15},{66,25},{54,
                      33},{44,41},{36,57},{26,65},{0,67}},
                  lineColor={160,160,164},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-58,35},{-68,25},{-72,13},{-76,-1},{-78,-15},{-76,-31},{
                      -76,-43},{-76,-53},{-70,-65},{-64,-73},{-48,-77},{-30,-83},{-18,
                      -83},{-2,-85},{8,-89},{22,-89},{32,-87},{42,-81},{54,-75},{42,
                      -77},{40,-77},{30,-79},{20,-81},{18,-81},{10,-81},{2,-77},{-12,
                      -73},{-22,-73},{-30,-71},{-40,-65},{-50,-55},{-56,-43},{-58,-35},
                      {-58,-25},{-60,-13},{-60,-5},{-60,7},{-58,17},{-56,19},{-52,
                      27},{-48,35},{-44,45},{-40,57},{-58,35}},
                  fillColor={160,160,164},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-6,-1},{6,-12}},
                  lineColor={255,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{11,13},{50,-25}},
                  textString="T"),
                Line(points={{0,-12},{0,-96}}, color={255,0,0})}),
            Documentation(info="<html>
<p>
This is a generic model for the heat capacity of a material.
No specific geometry is assumed beyond a total volume with
uniform temperature for the entire volume.
Furthermore, it is assumed that the heat capacity
is constant (independent of temperature).
</p>
<p>
The temperature T [Kelvin] of this component is a <strong>state</strong>.
A default of T = 25 degree Celsius (= SIunits.Conversions.from_degC(25))
is used as start value for initialization.
This usually means that at start of integration the temperature of this
component is 25 degrees Celsius. You may, of course, define a different
temperature as start value for initialization. Alternatively, it is possible
to set parameter <strong>steadyStateStart</strong> to <strong>true</strong>. In this case
the additional equation '<strong>der</strong>(T) = 0' is used during
initialization, i.e., the temperature T is computed in such a way that
the component starts in <strong>steady state</strong>. This is useful in cases,
where one would like to start simulation in a suitable operating
point without being forced to integrate for a long time to arrive
at this point.
</p>
<p>
Note, that parameter <strong>steadyStateStart</strong> is not available in
the parameter menu of the simulation window, because its value
is utilized during translation to generate quite different
equations depending on its setting. Therefore, the value of this
parameter can only be changed before translating the model.
</p>
<p>
This component may be used for complicated geometries where
the heat capacity C is determined my measurements. If the component
consists mainly of one type of material, the <strong>mass m</strong> of the
component may be measured or calculated and multiplied with the
<strong>specific heat capacity cp</strong> of the component material to
compute C:
</p>
<pre>
   C = cp*m.
   Typical values for cp at 20 degC in J/(kg.K):
      aluminium   896
      concrete    840
      copper      383
      iron        452
      silver      235
      steel       420 ... 500 (V2A)
      wood       2500
</pre>
</html>"));
        end HeatCapacitor;

        model ThermalConductor
          "Lumped thermal element transporting heat without storing it"
          extends Interfaces.Element1D;
          parameter Modelica.SIunits.ThermalConductance G
            "Constant thermal conductance of material";

        equation
          Q_flow = G*dT;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-90,70},{90,-70}},
                  pattern=LinePattern.None,
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(
                  points={{-90,70},{-90,-70}},
                  thickness=0.5),
                Line(
                  points={{90,70},{90,-70}},
                  thickness=0.5),
                Text(
                  extent={{-150,115},{150,75}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-75},{150,-105}},
                  textString="G=%G")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{-80,0},{80,0}},
                  color={255,0,0},
                  thickness=0.5,
                  arrow={Arrow.None,Arrow.Filled}),
                Text(
                  extent={{-100,-20},{100,-40}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Text(
                  extent={{-100,40},{100,20}},
                  textString="dT = port_a.T - port_b.T")}),
            Documentation(info="<html>
<p>
This is a model for transport of heat without storing it; see also:
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.ThermalResistor\">ThermalResistor</a>.
It may be used for complicated geometries where
the thermal conductance G (= inverse of thermal resistance)
is determined by measurements and is assumed to be constant
over the range of operations. If the component consists mainly of
one type of material and a regular geometry, it may be calculated,
e.g., with one of the following equations:
</p>
<ul>
<li><p>
    Conductance for a <strong>box</strong> geometry under the assumption
    that heat flows along the box length:</p>
    <pre>
    G = k*A/L
    k: Thermal conductivity (material constant)
    A: Area of box
    L: Length of box
    </pre>
    </li>
<li><p>
    Conductance for a <strong>cylindrical</strong> geometry under the assumption
    that heat flows from the inside to the outside radius
    of the cylinder:</p>
    <pre>
    G = 2*pi*k*L/log(r_out/r_in)
    pi   : Modelica.Constants.pi
    k    : Thermal conductivity (material constant)
    L    : Length of cylinder
    log  : Modelica.Math.log;
    r_out: Outer radius of cylinder
    r_in : Inner radius of cylinder
    </pre>
    </li>
</ul>
<pre>
    Typical values for k at 20 degC in W/(m.K):
      aluminium   220
      concrete      1
      copper      384
      iron         74
      silver      407
      steel        45 .. 15 (V2A)
      wood         0.1 ... 0.2
</pre>
</html>"));
        end ThermalConductor;

        model ThermalResistor
          "Lumped thermal element transporting heat without storing it"
          extends Interfaces.Element1D;
          parameter Modelica.SIunits.ThermalResistance R
            "Constant thermal resistance of material";

        equation
          dT = R*Q_flow;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-90,70},{90,-70}},
                  pattern=LinePattern.None,
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Forward),
                Line(
                  points={{-90,70},{-90,-70}},
                  thickness=0.5),
                Line(
                  points={{90,70},{90,-70}},
                  thickness=0.5),
                Text(
                  extent={{-150,115},{150,75}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-75},{150,-105}},
                  textString="R=%R")}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{-80,0},{80,0}},
                  color={255,0,0},
                  thickness=0.5,
                  arrow={Arrow.None,Arrow.Filled}),
                Text(
                  extent={{-100,-20},{100,-40}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Text(
                  extent={{-100,40},{100,20}},
                  textString="dT = port_a.T - port_b.T")}),
            Documentation(info="<html>
<p>
This is a model for transport of heat without storing it, same as the
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.ThermalConductor\">ThermalConductor</a>
but using the thermal resistance instead of the thermal conductance as a parameter.
This is advantageous for series connections of ThermalResistors,
especially if it shall be allowed that a ThermalResistance is defined to be zero (i.e. no temperature difference).
</p>
</html>"));
        end ThermalResistor;

        model Convection
          "Lumped thermal element for heat convection (Q_flow = Gc*dT)"
          Modelica.SIunits.HeatFlowRate Q_flow "Heat flow rate from solid -> fluid";
          Modelica.SIunits.TemperatureDifference dT "= solid.T - fluid.T";
          Modelica.Blocks.Interfaces.RealInput Gc(unit="W/K")
            "Signal representing the convective thermal conductance in [W/K]"
            annotation (Placement(transformation(
                origin={0,100},
                extent={{-20,-20},{20,20}},
                rotation=270)));
          Interfaces.HeatPort_a solid annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Interfaces.HeatPort_b fluid annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
        equation
          dT = solid.T - fluid.T;
          solid.Q_flow = Q_flow;
          fluid.Q_flow = -Q_flow;
          Q_flow = Gc*dT;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-62,80},{98,-80}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{-150,-90},{150,-130}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0}),
                Text(
                  extent={{22,124},{92,98}},
                  textString="Gc")}),
            Documentation(info="<html>
<p>
This is a model of linear heat convection, e.g., the heat transfer between a plate and the surrounding air; see also:
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.ConvectiveResistor\">ConvectiveResistor</a>.
It may be used for complicated solid geometries and fluid flow over the solid by determining the
convective thermal conductance Gc by measurements. The basic constitutive equation for convection is
</p>
<pre>
   Q_flow = Gc*(solid.T - fluid.T);
   Q_flow: Heat flow rate from connector 'solid' (e.g., a plate)
      to connector 'fluid' (e.g., the surrounding air)
</pre>
<p>
Gc = G.signal[1] is an input signal to the component, since Gc is
nearly never constant in practice. For example, Gc may be a function
of the speed of a cooling fan. For simple situations,
Gc may be <em>calculated</em> according to
</p>
<pre>
   Gc = A*h
   A: Convection area (e.g., perimeter*length of a box)
   h: Heat transfer coefficient
</pre>
<p>
where the heat transfer coefficient h is calculated
from properties of the fluid flowing over the solid. Examples:
</p>
<p>
<strong>Machines cooled by air</strong> (empirical, very rough approximation according
to R. Fischer: Elektrische Maschinen, 10th edition, Hanser-Verlag 1999,
p. 378):
</p>
<pre>
    h = 7.8*v^0.78 [W/(m2.K)] (forced convection)
      = 12         [W/(m2.K)] (free convection)
    where
      v: Air velocity in [m/s]
</pre>
<p><strong>Laminar</strong> flow with constant velocity of a fluid along a
<strong>flat plate</strong> where the heat flow rate from the plate
to the fluid (= solid.Q_flow) is kept constant
(according to J.P.Holman: Heat Transfer, 8th edition,
McGraw-Hill, 1997, p.270):
</p>
<pre>
   h  = Nu*k/x;
   Nu = 0.453*Re^(1/2)*Pr^(1/3);
   where
      h  : Heat transfer coefficient
      Nu : = h*x/k       (Nusselt number)
      Re : = v*x*rho/mue (Reynolds number)
      Pr : = cp*mue/k    (Prandtl number)
      v  : Absolute velocity of fluid
      x  : distance from leading edge of flat plate
      rho: density of fluid (material constant
      mue: dynamic viscosity of fluid (material constant)
      cp : specific heat capacity of fluid (material constant)
      k  : thermal conductivity of fluid (material constant)
   and the equation for h holds, provided
      Re &lt; 5e5 and 0.6 &lt; Pr &lt; 50
</pre>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-40,40},{80,20}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0})}));
        end Convection;

        model ConvectiveResistor
          "Lumped thermal element for heat convection (dT = Rc*Q_flow)"
          Modelica.SIunits.HeatFlowRate Q_flow "Heat flow rate from solid -> fluid";
          Modelica.SIunits.TemperatureDifference dT "= solid.T - fluid.T";
          Modelica.Blocks.Interfaces.RealInput Rc(unit="K/W")
            "Signal representing the convective thermal resistance in [K/W]"
            annotation (Placement(transformation(
                origin={0,100},
                extent={{-20,-20},{20,20}},
                rotation=270)));
          Interfaces.HeatPort_a solid annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Interfaces.HeatPort_b fluid annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
        equation
          dT = solid.T - fluid.T;
          solid.Q_flow = Q_flow;
          fluid.Q_flow = -Q_flow;
          dT = Rc*Q_flow;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-62,80},{98,-80}},
                  lineColor={255,255,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Forward),
                Text(
                  extent={{-150,-90},{150,-130}},
                  textString="%name",
                  lineColor={0,0,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0}),
                Text(
                  extent={{22,124},{92,98}},
                  textString="Rc")}),
            Documentation(info="<html>
<p>
This is a model of linear heat convection, e.g., the heat transfer between a plate and the surrounding air; same as the
<a href=\"modelica://Modelica.Thermal.HeatTransfer.Components.Convection\">Convection</a> component
but using the convective resistance instead of the convective conductance as an input.
This is advantageous for series connections of ConvectiveResistors,
especially if it shall be allowed that a convective resistance is defined to be zero (i.e. no temperature difference).
</p>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-90,80},{-60,-80}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Forward),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Line(points={{100,0},{100,0}}, color={0,127,255}),
                Text(
                  extent={{-40,40},{80,20}},
                  lineColor={255,0,0},
                  textString="Q_flow"),
                Line(points={{-60,20},{76,20}}, color={191,0,0}),
                Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                Line(points={{6,80},{6,-80}}, color={0,127,255}),
                Line(points={{40,80},{40,-80}}, color={0,127,255}),
                Line(points={{76,80},{76,-80}}, color={0,127,255}),
                Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                Line(points={{56,10},{76,20}}, color={191,0,0}),
                Line(points={{56,30},{76,20}}, color={191,0,0})}));
        end ConvectiveResistor;
        annotation (Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics={
          Rectangle(
            origin = {12,40},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Backward,
            extent = {{-100,-100},{-70,18}}),
          Line(
            origin = {12,40},
            points = {{-44,16},{-44,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,16},{-4,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,18},{30,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,18},{66,-100}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,-100},{76,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{66,-100},{56,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,-100},{40,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{30,-100},{20,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,-100},{6,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-4,-100},{-14,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-44,-100},{-34,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-44,-100},{-54,-80}},
            color = {0,127,255}),
          Line(
            origin = {12,40},
            points = {{-70,-60},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-70},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-50},{66,-60}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-30},{66,-20}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{46,-10},{66,-20}},
            color = {191,0,0}),
          Line(
            origin = {12,40},
            points = {{-70,-20},{66,-20}},
            color = {191,0,0})}), Documentation(
              info="<html>

</html>"));
      end Components;

      package Sensors "Thermal sensors"
        extends Modelica.Icons.SensorsPackage;

        model TemperatureSensor "Absolute temperature sensor in Kelvin"

          Modelica.Blocks.Interfaces.RealOutput T(unit="K")
            "Absolute temperature as output signal"
            annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          Interfaces.HeatPort_a port annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
        equation
          T = port.T;
          port.Q_flow = 0;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-20,-98},{20,-60}},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-12,40},{12,-68}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{12,0},{90,0}}, color={0,0,255}),
                Line(points={{-94,0},{-14,0}}, color={191,0,0}),
                Polygon(
                  points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{
                      12,80},{12,40},{-12,40}},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-64}},
                  thickness=0.5),
                Line(
                  points={{12,40},{12,-64}},
                  thickness=0.5),
                Line(points={{-40,-20},{-12,-20}}),
                Line(points={{-40,20},{-12,20}}),
                Line(points={{-40,60},{-12,60}}),
                Text(
                  extent={{102,-28},{60,-78}},
                  textString="K")}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Ellipse(
                  extent={{-20,-98},{20,-60}},
                  lineThickness=0.5,
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-12,40},{12,-68}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Line(points={{12,0},{90,0}}, color={0,0,255}),
                Line(points={{-90,0},{-12,0}}, color={191,0,0}),
                Polygon(
                  points={{-12,40},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},
                      {12,80},{12,40},{-12,40}},
                  lineThickness=0.5),
                Line(
                  points={{-12,40},{-12,-64}},
                  thickness=0.5),
                Line(
                  points={{12,40},{12,-64}},
                  thickness=0.5),
                Line(points={{-40,-20},{-12,-20}}),
                Line(points={{-40,20},{-12,20}}),
                Line(points={{-40,60},{-12,60}}),
                Text(
                  extent={{126,-20},{26,-120}},
                  textString="K"),
                Text(
                  extent={{-150,130},{150,90}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
This is an ideal absolute temperature sensor which returns
the temperature of the connected port in Kelvin as an output
signal.  The sensor itself has no thermal interaction with
whatever it is connected to.  Furthermore, no
thermocouple-like lags are associated with this
sensor model.
</p>
</html>"));
        end TemperatureSensor;

        model HeatFlowSensor "Heat flow rate sensor"
          extends Modelica.Icons.RotationalSensor;
          Modelica.Blocks.Interfaces.RealOutput Q_flow(unit="W")
            "Heat flow from port_a to port_b as output signal" annotation (Placement(
                transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=270)));
          Interfaces.HeatPort_a port_a annotation (Placement(transformation(extent={{
                    -110,-10},{-90,10}})));
          Interfaces.HeatPort_b port_b annotation (Placement(transformation(extent={{
                    90,-10},{110,10}})));
        equation
          port_a.T = port_b.T;
          port_a.Q_flow + port_b.Q_flow = 0;
          Q_flow = port_a.Q_flow;
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Line(points={{-70,0},{-95,0}}, color={191,0,0}),
                Line(points={{0,-70},{0,-90}}, color={0,0,127}),
                Line(points={{94,0},{69,0}}, color={191,0,0})}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{5,-86},{116,-110}},
                  textString="Q_flow"),
                Line(points={{-70,0},{-90,0}}, color={191,0,0}),
                Line(points={{69,0},{90,0}}, color={191,0,0}),
                Line(points={{0,-70},{0,-90}}, color={0,0,127}),
                Text(
                  extent={{-150,125},{150,85}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
This model is capable of monitoring the heat flow rate flowing through
this component. The sensed value of heat flow rate is the amount that
passes through this sensor while keeping the temperature drop across the
sensor zero.  This is an ideal model so it does not absorb any energy
and it has no direct effect on the thermal response of a system it is included in.
The output signal is positive, if the heat flows from port_a to port_b.
</p>
</html>"));
        end HeatFlowSensor;
        annotation (Documentation(info="<html>

</html>"));
      end Sensors;

      package Sources "Thermal sources"
      extends Modelica.Icons.SourcesPackage;

        model FixedTemperature "Fixed temperature boundary condition in Kelvin"

          parameter Modelica.SIunits.Temperature T "Fixed temperature at port";
          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
        equation
          port.T = T;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-110},{150,-140}},
                  textString="T=%T"),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  pattern=LinePattern.None,
                  fillColor={159,159,223},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{0,0},{-100,-100}},
                  textString="K"),
                Line(
                  points={{-52,0},{56,0}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{50,-20},{50,20},{90,0},{50,-20}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This model defines a fixed temperature T at its port in Kelvin,
i.e., it defines a fixed temperature as a boundary condition.
</p>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-101}},
                  pattern=LinePattern.None,
                  fillColor={159,159,223},
                  fillPattern=FillPattern.Backward),
                Line(
                  points={{-52,0},{56,0}},
                  color={191,0,0},
                  thickness=0.5),
                Text(
                  extent={{0,0},{-100,-100}},
                  textString="K"),
                Polygon(
                  points={{52,-20},{52,20},{90,0},{52,-20}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}));
        end FixedTemperature;

        model PrescribedTemperature
          "Variable temperature boundary condition in Kelvin"

          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
          Modelica.Blocks.Interfaces.RealInput T(unit="K") annotation (Placement(transformation(
                  extent={{-140,-20},{-100,20}})));
        equation
          port.T = T;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  pattern=LinePattern.None,
                  fillColor={159,159,223},
                  fillPattern=FillPattern.Backward),
                Line(
                  points={{-102,0},{64,0}},
                  color={191,0,0},
                  thickness=0.5),
                Text(
                  extent={{0,0},{-100,-100}},
                  textString="K"),
                Text(
                  extent={{-150,150},{150,110}},
                  textString="%name",
                  lineColor={0,0,255}),
                Polygon(
                  points={{50,-20},{50,20},{90,0},{50,-20}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This model represents a variable temperature boundary condition.
The temperature in [K] is given as input signal <strong>T</strong>
to the model. The effect is that an instance of this model acts as
an infinite reservoir able to absorb or generate as much energy
as required to keep the temperature at the specified value.
</p>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  pattern=LinePattern.None,
                  fillColor={159,159,223},
                  fillPattern=FillPattern.Backward),
                Text(
                  extent={{0,0},{-100,-100}},
                  textString="K"),
                Line(
                  points={{-102,0},{64,0}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{52,-20},{52,20},{90,0},{52,-20}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}));
        end PrescribedTemperature;

        model FixedHeatFlow "Fixed heat flow boundary condition"
          parameter Modelica.SIunits.HeatFlowRate Q_flow
            "Fixed heat flow rate at port";
          parameter Modelica.SIunits.Temperature T_ref=293.15
            "Reference temperature";
          parameter Modelica.SIunits.LinearTemperatureCoefficient alpha=0
            "Temperature coefficient of heat flow rate";
          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
        equation
          port.Q_flow = -Q_flow*(1 + alpha*(port.T - T_ref));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Text(
                  extent={{-150,100},{150,60}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-150,-55},{150,-85}},
                  textString="Q_flow=%Q_flow"),
                Line(
                  points={{-100,-20},{48,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-100,20},{46,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{40,0},{40,40},{70,20},{40,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{40,-40},{40,0},{70,-20},{40,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{70,40},{90,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Text(
                  extent={{-100,40},{0,-36}},
                  textString="Q_flow=const."),
                Line(
                  points={{-48,-20},{60,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-48,20},{60,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{60,0},{60,40},{90,20},{60,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{60,-40},{60,0},{90,-20},{60,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The constant amount of heat
flow rate Q_flow is given as a parameter. The heat flows into the
component to which the component FixedHeatFlow is connected,
if parameter Q_flow is positive.
</p>
<p>
If parameter alpha is &lt;&gt; 0, the heat flow is multiplied by (1 + alpha*(port.T - T_ref))
in order to simulate temperature dependent losses (which are given with respect to reference temperature T_ref).
</p>
</html>"));
        end FixedHeatFlow;

        model PrescribedHeatFlow "Prescribed heat flow boundary condition"
          parameter Modelica.SIunits.Temperature T_ref=293.15
            "Reference temperature";
          parameter Modelica.SIunits.LinearTemperatureCoefficient alpha=0
            "Temperature coefficient of heat flow rate";
          Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
                annotation (Placement(transformation(
                origin={-100,0},
                extent={{20,-20},{-20,20}},
                rotation=180)));
          Interfaces.HeatPort_b port annotation (Placement(transformation(extent={{90,
                    -10},{110,10}})));
        equation
          port.Q_flow = -Q_flow*(1 + alpha*(port.T - T_ref));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={
                Line(
                  points={{-60,-20},{40,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-60,20},{40,20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{40,0},{40,40},{70,20},{40,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{40,-40},{40,0},{70,-20},{40,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{70,40},{90,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{-150,100},{150,60}},
                  textString="%name",
                  lineColor={0,0,255})}),
            Documentation(info="<html>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The amount of heat
is given by the input signal Q_flow into the model. The heat flows into the
component to which the component PrescribedHeatFlow is connected,
if the input signal is positive.
</p>
<p>
If parameter alpha is &lt;&gt; 0, the heat flow is multiplied by (1 + alpha*(port.T - T_ref))
in order to simulate temperature dependent losses (which are given with respect to reference temperature T_ref).
</p>
</html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={
                Line(
                  points={{-60,-20},{68,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-60,20},{68,20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,-20}},
                  color={191,0,0},
                  thickness=0.5),
                Line(
                  points={{-80,0},{-60,20}},
                  color={191,0,0},
                  thickness=0.5),
                Polygon(
                  points={{60,0},{60,40},{90,20},{60,0}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{60,-40},{60,0},{90,-20},{60,-40}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}));
        end PrescribedHeatFlow;
        annotation (Documentation(info="<html>

</html>"));
      end Sources;

      package Interfaces "Connectors and partial models"
        extends Modelica.Icons.InterfacesPackage;

        partial connector HeatPort "Thermal port for 1-dim. heat transfer"
          Modelica.SIunits.Temperature T "Port temperature";
          flow Modelica.SIunits.HeatFlowRate Q_flow
            "Heat flow rate (positive if flowing from outside into the component)";
          annotation (Documentation(info="<html>

</html>"));
        end HeatPort;

        connector HeatPort_a
          "Thermal port for 1-dim. heat transfer (filled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_a",
            Documentation(info="<html>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<pre>
   T       Temperature in [Kelvin].
   Q_flow  Heat flow rate in [Watt].
</pre>
<p>According to the Modelica sign convention, a <strong>positive</strong> heat flow
rate <strong>Q_flow</strong> is considered to flow <strong>into</strong> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <strong>HeatPort_a</strong> and
<strong>HeatPort_b</strong> are identical with the only exception of the different
<strong>icon layout</strong>.</p></html>"),     Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={191,0,0},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-120,120},{100,60}},
                  lineColor={191,0,0},
                  textString="%name")}));
        end HeatPort_a;

        connector HeatPort_b
          "Thermal port for 1-dim. heat transfer (unfilled rectangular icon)"

          extends HeatPort;

          annotation(defaultComponentName = "port_b",
            Documentation(info="<html>
<p>This connector is used for 1-dimensional heat flow between components.
The variables in the connector are:</p>
<pre>
   T       Temperature in [Kelvin].
   Q_flow  Heat flow rate in [Watt].
</pre>
<p>According to the Modelica sign convention, a <strong>positive</strong> heat flow
rate <strong>Q_flow</strong> is considered to flow <strong>into</strong> a component. This
convention has to be used whenever this connector is used in a model
class.</p>
<p>Note, that the two connector classes <strong>HeatPort_a</strong> and
<strong>HeatPort_b</strong> are identical with the only exception of the different
<strong>icon layout</strong>.</p></html>"),     Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
                    {100,100}}), graphics={Rectangle(
                  extent={{-50,50},{50,-50}},
                  lineColor={191,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid), Text(
                  extent={{-100,120},{120,60}},
                  lineColor={191,0,0},
                  textString="%name")}),
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                    100,100}}), graphics={Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={191,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid)}));
        end HeatPort_b;

        partial model Element1D
          "Partial heat transfer element with two HeatPort connectors that does not store energy"

          Modelica.SIunits.HeatFlowRate Q_flow
            "Heat flow rate from port_a -> port_b";
          Modelica.SIunits.TemperatureDifference dT "port_a.T - port_b.T";
      public
          HeatPort_a port_a annotation (Placement(transformation(extent={{-110,-10},
                    {-90,10}})));
          HeatPort_b port_b annotation (Placement(transformation(extent={{90,-10},{
                    110,10}})));
        equation
          dT = port_a.T - port_b.T;
          port_a.Q_flow = Q_flow;
          port_b.Q_flow = -Q_flow;
          annotation (Documentation(info="<html>
<p>
This partial model contains the basic connectors and variables to
allow heat transfer models to be created that <strong>do not store energy</strong>,
This model defines and includes equations for the temperature
drop across the element, <strong>dT</strong>, and the heat flow rate
through the element from port_a to port_b, <strong>Q_flow</strong>.
</p>
<p>
By extending this model, it is possible to write simple
constitutive equations for many types of heat transfer components.
</p>
</html>"));
        end Element1D;
        annotation (Documentation(info="<html>

</html>"));
      end Interfaces;
      annotation (
         Icon(coordinateSystem(preserveAspectRatio = true, extent = {{-100,-100},{100,100}}), graphics={
          Polygon(
            origin = {13.758,27.517},
            lineColor = {128,128,128},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Solid,
            points = {{-54,-6},{-61,-7},{-75,-15},{-79,-24},{-80,-34},{-78,-42},{-73,-49},{-64,-51},{-57,-51},{-47,-50},{-41,-43},{-38,-35},{-40,-27},{-40,-20},{-42,-13},{-47,-7},{-54,-5},{-54,-6}}),
        Polygon(
            origin = {13.758,27.517},
            fillColor = {160,160,164},
            fillPattern = FillPattern.Solid,
            points = {{-75,-15},{-79,-25},{-80,-34},{-78,-42},{-72,-49},{-64,-51},{-57,-51},{-47,-50},{-57,-47},{-65,-45},{-71,-40},{-74,-33},{-76,-23},{-75,-15},{-75,-15}}),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {160,160,164},
            fillColor = {192,192,192},
            fillPattern = FillPattern.Solid,
            points = {{39,-6},{32,-7},{18,-15},{14,-24},{13,-34},{15,-42},{20,-49},{29,-51},{36,-51},{46,-50},{52,-43},{55,-35},{53,-27},{53,-20},{51,-13},{46,-7},{39,-5},{39,-6}}),
          Polygon(
            origin = {13.758,27.517},
            fillColor = {160,160,164},
            fillPattern = FillPattern.Solid,
            points = {{18,-15},{14,-25},{13,-34},{15,-42},{21,-49},{29,-51},{36,-51},{46,-50},{36,-47},{28,-45},{22,-40},{19,-33},{17,-23},{18,-15},{18,-15}}),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {191,0,0},
            fillColor = {191,0,0},
            fillPattern = FillPattern.Solid,
            points = {{-9,-23},{-9,-10},{18,-17},{-9,-23}}),
          Line(
            origin = {13.758,27.517},
            points = {{-41,-17},{-9,-17}},
            color = {191,0,0},
            thickness = 0.5),
          Line(
            origin = {13.758,27.517},
            points = {{-17,-40},{15,-40}},
            color = {191,0,0},
            thickness = 0.5),
          Polygon(
            origin = {13.758,27.517},
            lineColor = {191,0,0},
            fillColor = {191,0,0},
            fillPattern = FillPattern.Solid,
            points = {{-17,-46},{-17,-34},{-40,-40},{-17,-46}})}),
                                Documentation(info="<html>
<p>
This package contains components to model <strong>1-dimensional heat transfer</strong>
with lumped elements. This allows especially to model heat transfer in
machines provided the parameters of the lumped elements, such as
the heat capacity of a part, can be determined by measurements
(due to the complex geometries and many materials used in machines,
calculating the lumped element parameters from some basic analytic
formulas is usually not possible).
</p>
<p>
Example models how to use this library are given in subpackage <strong>Examples</strong>.<br>
For a first simple example, see <strong>Examples.TwoMasses</strong> where two masses
with different initial temperatures are getting in contact to each
other and arriving after some time at a common temperature.<br>
<strong>Examples.ControlledTemperature</strong> shows how to hold a temperature
within desired limits by switching on and off an electric resistor.<br>
A more realistic example is provided in <strong>Examples.Motor</strong> where the
heating of an electrical motor is modelled, see the following screen shot
of this example:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Thermal/HeatTransfer/driveWithHeatTransfer.png\" alt=\"driveWithHeatTransfer\">
</p>

<p>
The <strong>filled</strong> and <strong>non-filled red squares</strong> at the left and
right side of a component represent <strong>thermal ports</strong> (connector HeatPort).
Drawing a line between such squares means that they are thermally connected.
The variables of a HeatPort connector are the temperature <strong>T</strong> at the port
and the heat flow rate <strong>Q_flow</strong> flowing into the component (if Q_flow is positive,
the heat flows into the element, otherwise it flows out of the element):
</p>
<pre>   Modelica.SIunits.Temperature  T  \"absolute temperature at port in Kelvin\";
   Modelica.SIunits.HeatFlowRate Q_flow  \"flow rate at the port in Watt\";
</pre>
<p>
Note, that all temperatures of this package, including initial conditions,
are given in Kelvin. For convenience, in subpackages <strong>HeatTransfer.Celsius</strong>,
 <strong>HeatTransfer.Fahrenheit</strong> and <strong>HeatTransfer.Rankine</strong> components are provided such that source and
sensor information is available in degree Celsius, degree Fahrenheit, or degree Rankine,
respectively. Additionally, in package <strong>SIunits.Conversions</strong> conversion
functions between the units Kelvin and Celsius, Fahrenheit, Rankine are
provided. These functions may be used in the following way:
</p>
<pre>  <strong>import</strong> SI=Modelica.SIunits;
  <strong>import</strong> Modelica.SIunits.Conversions.*;
     ...
  <strong>parameter</strong> SI.Temperature T = from_degC(25);  // convert 25 degree Celsius to Kelvin
</pre>

<p>
There are several other components available, such as AxialConduction (discretized PDE in
axial direction), which have been temporarily removed from this library. The reason is that
these components reference material properties, such as thermal conductivity, and currently
the Modelica design group is discussing a general scheme to describe material properties.
</p>
<p>
For technical details in the design of this library, see the following reference:<br>
<strong>Michael Tiller (2001)</strong>: <a href=\"http://www.amazon.de\">
Introduction to Physical Modeling with Modelica</a>.
Kluwer Academic Publishers Boston.
</p>
<p>
<strong>Acknowledgements:</strong><br>
Several helpful remarks from the following persons are acknowledged:
John Batteh, Ford Motors, Dearborn, U.S.A;
<a href=\"https://www.haumer.at/\">Anton Haumer</a>, Technical Consulting &amp; Electrical Engineering, Germany;
Ludwig Marvan, VA TECH ELIN EBG Elektronik GmbH, Wien, Austria;
Hans Olsson, Dassault Syst&egrave;mes AB, Sweden;
Hubertus Tummescheit, Lund Institute of Technology, Lund, Sweden.
</p>
<dl>
  <dt><strong>Main Authors:</strong></dt>
  <dd>
  <p>
  <a href=\"https://www.haumer.at/\">Anton Haumer</a><br>
  Technical Consulting &amp; Electrical Engineering<br>
  D-93049 Regensburg, Germany<br>
  email: <a href=\"mailto:a.haumer@haumer.at\">a.haumer@haumer.at</a>
</p>
  </dd>
</dl>
<p>
Copyright &copy; 2001-2019, Modelica Association and contributors
</p>
</html>",     revisions="<html>
<ul>
<li><em>July 15, 2002</em>
       by Michael Tiller, <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Nikolaus Sch&uuml;rmann:<br>
       Implemented.
</li>
<li><em>June 13, 2005</em>
       by <a href=\"https://www.haumer.at/\">Anton Haumer</a><br>
       Refined placing of connectors (cosmetic).<br>
       Refined all Examples; removed Examples.FrequencyInverter, introducing Examples.Motor<br>
       Introduced temperature dependent correction (1 + alpha*(T - T_ref)) in Fixed/PrescribedHeatFlow<br>
</li>
  <li> v1.1.1 2007/11/13 Anton Haumer<br>
       components moved to sub-packages</li>
  <li> v1.2.0 2009/08/26 Anton Haumer<br>
       added component ThermalCollector</li>

</ul>
</html>"));
    end HeatTransfer;
    annotation (
     Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Line(
      origin={-47.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={-50.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}}),
      Line(
      origin={2.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={0.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}}),
      Line(
      origin={52.5,11.6667},
      points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},{-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
        smooth=Smooth.Bezier),
      Polygon(
      origin={50.0,68.333},
      pattern=LinePattern.None,
      fillPattern=FillPattern.Solid,
        points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}})}),
      Documentation(info="<html>
<p>
This package contains libraries to model heat transfer
and fluid heat flow.
</p>
</html>"));
  end Thermal;

  package Math
  "Library of mathematical functions (e.g., sin, cos) and of functions operating on vectors and matrices"
  import SI = Modelica.SIunits;
  extends Modelica.Icons.Package;

    package BooleanVectors "Library of functions operating on Boolean vectors"
     extends Modelica.Icons.Package;

    function allTrue
        "Returns true, if all elements of the Boolean input vector are true ('and')"
      extends Modelica.Icons.Function;
      input Boolean b[:] "Boolean vector";
      output Boolean result "= true, if all elements of b are true";
    algorithm
      result := size(b,1) > 0;
      for i in 1:size(b,1) loop
         result := result and b[i];
      end for;
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>allTrue</strong>(b);
</pre></blockquote>

<h4>Description</h4>
<p>
Returns <strong>true</strong> if all elements of the Boolean input vector b are <strong>true</strong>.
Otherwise the function returns <strong>false</strong>. If b is an empty vector,
i.e., size(b,1)=0, the function returns <strong>false</strong>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Boolean b1[3] = {true, true, true};
  Boolean b2[3] = {false, true, false};
  Boolean r1, r2;
<strong>algorithm</strong>
  r1 = allTrue(b1);  // r1 = true
  r2 = allTrue(b2);  // r2 = false
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.BooleanVectors.anyTrue\">anyTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.countTrue\">countTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.enumerate\">enumerate</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.firstTrueIndex\">firstTrueIndex</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.index\">index</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors.oneTrue\">oneTrue</a>.
</p>

</html>"));
    end allTrue;

    function anyTrue
        "Returns true, if at least on element of the Boolean input vector is true ('or')"

      extends Modelica.Icons.Function;
      input Boolean b[:];
      output Boolean result;
    algorithm
      result := false;
      for i in 1:size(b,1) loop
         result := result or b[i];
      end for;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>anyTrue</strong>(b);
</pre></blockquote>

<h4>Description</h4>
<p>
Returns <strong>true</strong> if at least one elements of the input Boolean vector b is <strong>true</strong>.
Otherwise the function returns <strong>false</strong>. If b is an empty vector,
i.e., size(b,1)=0, the function returns <strong>false</strong>.
</p>

<h4>Example</h4>
<blockquote><pre>
  Boolean b1[3] = {false, false, false};
  Boolean b2[3] = {false, true, false};
  Boolean r1, r2;
<strong>algorithm</strong>
  r1 = anyTrue(b1);  // r1 = false
  r2 = anyTrue(b2);  // r2 = true
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.BooleanVectors.allTrue\">allTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.countTrue\">countTrue</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.enumerate\">enumerate</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.firstTrueIndex\">firstTrueIndex</a>,
<a href=\"modelica://Modelica.Math.BooleanVectors.index\">index</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors.oneTrue\">oneTrue</a>.
</p>
</html>"));
    end anyTrue;
      annotation (Documentation(info="<html>
<p>
This library provides functions operating on vectors that have
a Boolean vector as input argument.
</p>
</html>"),     Icon(graphics={Rectangle(
              extent={{-16,62},{14,14}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid), Rectangle(
              extent={{-16,-18},{14,-66}},
              lineColor={255,0,255},
              fillColor={255,0,255},
              fillPattern=FillPattern.Solid)}));
    end BooleanVectors;

  package Matrices "Library of functions operating on matrices"
    extends Modelica.Icons.Package;

    function solve
      "Solve real system of linear equations A*x=b with a b vector (Gaussian elimination with partial pivoting)"

      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)] "Matrix A of A*x = b";
      input Real b[size(A, 1)] "Vector b of A*x = b";
      output Real x[size(b, 1)] "Vector x such that A*x = b";

  protected
      Integer info;
    algorithm
      (x,info) := LAPACK.dgesv_vec(A, b);
      assert(info == 0, "Solving a linear system of equations with function
\"Matrices.solve\" is not possible, because the system has either
no or infinitely many solutions (A is singular).");
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<strong>solve</strong>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <strong>x</strong> of the linear system of equations
</p>
<blockquote>
<p>
<strong>A</strong>*<strong>x</strong> = <strong>b</strong>
</p>
</blockquote>
<p>
If a unique solution <strong>x</strong> does not exist (since <strong>A</strong> is singular),
an assertion is triggered. If this is not desired, use instead
<a href=\"modelica://Modelica.Math.Matrices.leastSquares\">Matrices.leastSquares</a>
and inquire the singularity of the solution with the return argument rank
(a unique solution is computed if rank = size(A,1)).
</p>

<p>
Note, the solution is computed with the LAPACK function \"dgesv\",
i.e., by Gaussian elimination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real b[3] = {10,22,12};
  Real x[3];
<strong>algorithm</strong>
  x := Matrices.solve(A,b);  // x = {3,2,1}
</pre></blockquote>
<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.LU\">Matrices.LU</a>,
<a href=\"modelica://Modelica.Math.Matrices.LU_solve\">Matrices.LU_solve</a>,
<a href=\"modelica://Modelica.Math.Matrices.leastSquares\">Matrices.leastSquares</a>.
</html>"));
    end solve;

    function leastSquares
      "Solve linear equation A*x = b (exactly if possible, or otherwise in a least square sense; A may be non-square and may be rank deficient)"
      extends Modelica.Icons.Function;
      input Real A[:, :] "Matrix A";
      input Real b[size(A, 1)] "Vector b";
      input Real rcond=100*Modelica.Constants.eps
        "Reciprocal condition number to estimate the rank of A";
      output Real x[size(A, 2)]
        "Vector x such that min|A*x-b|^2 if size(A,1) >= size(A,2) or min|x|^2 and A*x=b, if size(A,1) < size(A,2)";
      output Integer rank "Rank of A";
  protected
      Integer info;
      Real xx[max(size(A, 1), size(A, 2))];
    algorithm
      if min(size(A)) > 0 then
        (xx,info,rank) := LAPACK.dgelsy_vec(
              A,
              b,
              rcond);
        x := xx[1:size(A, 2)];
        assert(info == 0,
          "Solving an overdetermined or underdetermined linear system\n" +
          "of equations with function \"Matrices.leastSquares\" failed.");
      else
        x := fill(0.0, size(A, 2));
      end if;
      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<strong>leastSquares</strong>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns a solution of equation A*x = b in a least
square sense (A may be rank deficient):
</p>
<pre>
  minimize | A*x - b |
</pre>

<p>
Several different cases can be distinguished (note, <strong>rank</strong> is an
output argument of this function):
</p>

<p>
<strong>size(A,1) = size(A,2)</strong>
</p>

<p> A solution is returned for a regular, as well as a singular matrix A:
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     A is <strong>regular</strong> and the returned solution x fulfills the equation
     A*x = b uniquely.</li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     A is <strong>singular</strong> and no unique solution for equation A*x = b exists.
     <ul>
     <li>  If an infinite number of solutions exists, the one is selected that fulfills
           the equation and at the same time has the minimum norm |x| for all solution
           vectors that fulfill the equation.</li>
     <li>  If no solution exists, x is selected such that |A*x - b| is as small as
           possible (but A*x - b is not zero).</li>
     </ul></li>
</ul>

<p>
<strong>size(A,1) &gt; size(A,2):</strong>
</p>

<p>
The equation A*x = b has no unique solution. The solution x is selected such that
|A*x - b| is as small as possible. If rank = size(A,2), this minimum norm solution is
unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the
same minimum value of |A*x - b|. From these infinite number of solutions, the one with the
minimum norm |x| is selected. This gives a unique solution that minimizes both
|A*x - b| and |x|.
</p>

<p>
<strong>size(A,1) &lt; size(A,2):</strong>
</p>

<ul>
<li> <strong>rank</strong> = size(A,1):<br>
     There are an infinite number of solutions that fulfill the equation A*x = b.
     From this infinite number, the unique solution is selected that minimizes |x|.
     </li>

<li> <strong>rank</strong> &lt; size(A,1):<br>
     There is either no solution of equation A*x = b, or there are again an infinite
     number of solutions. The unique solution x is returned that minimizes
      both |A*x - b| and |x|.</li>
</ul>

<p>
Note, the solution is computed with the LAPACK function \"dgelsy\",
i.e., QR or LQ factorization of A with column pivoting.
</p>

<h4>Algorithmic details</h4>

<p>
The function first computes a QR factorization with column pivoting:
</p>

<pre>
      A * P = Q * [ R11 R12 ]
                  [  0  R22 ]
</pre>

<p>
with R11 defined as the largest leading submatrix whose estimated
condition number is less than 1/rcond.  The order of R11, <strong>rank</strong>,
is the effective rank of A.
</p>

<p>
Then, R22 is considered to be negligible, and R12 is annihilated
by orthogonal transformations from the right, arriving at the
complete orthogonal factorization:
</p>

<pre>
     A * P = Q * [ T11 0 ] * Z
                 [  0  0 ]
</pre>

<p>
The minimum-norm solution is then
</p>

<pre>
     x = P * Z' [ inv(T11)*Q1'*b ]
                [        0       ]
</pre>

<p>
where Q1 consists of the first \"rank\" columns of Q.
</p>

<h4>See also</h4>

<p>
<a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">Matrices.leastSquares2</a>
(same as leastSquares, but with a right hand side matrix),<br>
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>
(for square, regular matrices A)
</p>

</html>"));
    end leastSquares;

    function inv "Return inverse of a matrix (try to avoid inv(..))"
      extends Modelica.Icons.Function;
      input Real A[:, size(A, 1)];
      output Real invA[size(A, 1), size(A, 2)] "Inverse of matrix A";
  protected
      Integer info;
      Integer pivots[size(A, 1)] "Pivot vector";
      Real LU[size(A, 1), size(A, 2)] "LU factors of A";
    algorithm
      (LU,pivots,info) := LAPACK.dgetrf(A);

      assert(info == 0, "Calculating an inverse matrix with function
\"Matrices.inv\" is not possible, since matrix A is singular.");

      invA := LAPACK.dgetri(LU, pivots);

      annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
invA = Matrices.<strong>inv</strong>(A);
</pre></blockquote>

<h4>Description</h4>
<p>
This function returns the inverse of matrix A, i.e., A*inv(A) = identity(size(A,1))
computed by a LU decomposition with row pivoting.
Usually, this function should not be used, because
there are nearly always better numerical algorithms
as by computing directly the inverse. Example:
</p>

<blockquote>
Use x = <a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>(A,b)
to solve the linear equation A*x = b, instead of computing the solution by
x = inv(A)*b, because this is much more efficient and much more reliable.
</blockquote>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Matrices.solve\">Matrices.solve</a>
<a href=\"modelica://Modelica.Math.Matrices.solve2\">Matrices.solve2</a>
</html>"));
    end inv;

    package LAPACK
    "Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)"
      extends Modelica.Icons.Package;

      function dgelsy_vec
        "Computes the minimum-norm solution to a real linear least squares problem with rank deficient A"

        extends Modelica.Icons.Function;
        input Real A[:, :];
        input Real b[size(A, 1)];
        input Real rcond=0.0 "Reciprocal condition number to estimate rank";
        output Real x[max(size(A, 1), size(A, 2))]=cat(
                  1,
                  b,
                  zeros(max(nrow, ncol) - nrow))
          "solution is in first size(A,2) rows";
        output Integer info;
        output Integer rank "Effective rank of A";
    protected
        Integer nrow=size(A, 1);
        Integer ncol=size(A, 2);
        Integer nrhs=1;
        Integer nx=max(nrow, ncol);
        Integer lwork=max(min(nrow, ncol) + 3*ncol + 1, 2*min(nrow, ncol) + 1);
        Real work[max(min(size(A, 1), size(A, 2)) + 3*size(A, 2) + 1, 2*min(size(A, 1),
          size(A, 2)) + 1)];
        Real Awork[size(A, 1), size(A, 2)]=A;
        Integer jpvt[size(A, 2)]=zeros(ncol);

      external"FORTRAN 77" dgelsy(
                nrow,
                ncol,
                nrhs,
                Awork,
                nrow,
                x,
                nx,
                jpvt,
                rcond,
                rank,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGELSY computes the minimum-norm solution to a real linear least
    squares problem:
        minimize || A * X - B ||
    using a complete orthogonal factorization of A.  A is an M-by-N
    matrix which may be rank-deficient.

    Several right hand side vectors b and solution vectors x can be
    handled in a single call; they are stored as the columns of the
    M-by-NRHS right hand side matrix B and the N-by-NRHS solution
    matrix X.

    The routine first computes a QR factorization with column pivoting:
        A * P = Q * [ R11 R12 ]
                    [  0  R22 ]
    with R11 defined as the largest leading submatrix whose estimated
    condition number is less than 1/RCOND.  The order of R11, RANK,
    is the effective rank of A.

    Then, R22 is considered to be negligible, and R12 is annihilated
    by orthogonal transformations from the right, arriving at the
    complete orthogonal factorization:
       A * P = Q * [ T11 0 ] * Z
                   [  0  0 ]
    The minimum-norm solution is then
       X = P * Z' [ inv(T11)*Q1'*B ]
                  [        0       ]
    where Q1 consists of the first RANK columns of Q.

    This routine is basically identical to the original xGELSX except
    three differences:
      o The call to the subroutine xGEQPF has been substituted by
        the call to the subroutine xGEQP3. This subroutine is a Blas-3
        version of the QR factorization with column pivoting.
      o Matrix B (the right hand side) is updated with Blas-3.
      o The permutation of matrix B (the right hand side) is faster and
        more simple.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    NRHS    (input) INTEGER
            The number of right hand sides, i.e., the number of
            columns of matrices B and X. NRHS >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A has been overwritten by details of its
            complete orthogonal factorization.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the M-by-NRHS right hand side matrix B.
            On exit, the N-by-NRHS solution matrix X.

    LDB     (input) INTEGER
            The leading dimension of the array B. LDB >= max(1,M,N).

    JPVT    (input/output) INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of AP, otherwise column i is a free column.
            On exit, if JPVT(i) = k, then the i-th column of AP
            was the k-th column of A.

    RCOND   (input) DOUBLE PRECISION
            RCOND is used to determine the effective rank of A, which
            is defined as the order of the largest leading triangular
            submatrix R11 in the QR factorization with pivoting of A,
            whose estimated condition number < 1/RCOND.

    RANK    (output) INTEGER
            The effective rank of A, i.e., the order of the submatrix
            R11.  This is the same as the order of the submatrix T11
            in the complete orthogonal factorization of A.

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.
            The unblocked strategy requires that:
               LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),
            where MN = min( M, N ).
            The block algorithm requires that:
               LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),
            where NB is an upper bound on the blocksize returned
            by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR,
            and DORMRZ.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0: successful exit
            < 0: If INFO = -i, the i-th argument had an illegal value.
"));
      end dgelsy_vec;

      function dgesv_vec
        "Solve real system of linear equations A*x=b with a b vector"
        extends Modelica.Icons.Function;
        input Real A[:, size(A, 1)];
        input Real b[size(A, 1)];
        output Real x[size(A, 1)]=b;
        output Integer info;
    protected
        Integer n=size(A, 1);
        Integer nrhs=1;
        Real Awork[size(A, 1), size(A, 1)]=A;
        Integer lda=max(1, size(A, 1));
        Integer ldb=max(1, size(b, 1));
        Integer ipiv[size(A, 1)];

      external"FORTRAN 77" dgesv(
                n,
                nrhs,
                Awork,
                lda,
                ipiv,
                x,
                ldb,
                info) annotation (Library="lapack");
        annotation (Documentation(info="
Same as function LAPACK.dgesv, but right hand side is a vector and not a matrix.
For details of the arguments, see documentation of dgesv.
"));
      end dgesv_vec;

      function dgetrf
        "Compute LU factorization of square or rectangular matrix A (A = P*L*U)"

        extends Modelica.Icons.Function;
        input Real A[:, :] "Square or rectangular matrix";
        output Real LU[size(A, 1), size(A, 2)]=A;
        output Integer pivots[min(size(A, 1), size(A, 2))] "Pivot vector";
        output Integer info "Information";
    protected
        Integer m=size(A, 1);
        Integer n=size(A, 2);
        Integer lda=max(1, size(A, 1));

      external"FORTRAN 77" dgetrf(
                m,
                n,
                LU,
                lda,
                pivots,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGETRF computes an LU factorization of a general M-by-N matrix A
    using partial pivoting with row interchanges.

    The factorization has the form
       A = P * L * U
    where P is a permutation matrix, L is lower triangular with unit
    diagonal elements (lower trapezoidal if m > n), and U is upper
    triangular (upper trapezoidal if m < n).

    This is the right-looking Level 3 BLAS version of the algorithm.

    Arguments
    =========

    M       (input) INTEGER
            The number of rows of the matrix A.  M >= 0.

    N       (input) INTEGER
            The number of columns of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).

    IPIV    (output) INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 <= i <= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
"));
      end dgetrf;

      function dgetri
        "Computes the inverse of a matrix using the LU factorization from dgetrf(..)"

        extends Modelica.Icons.Function;
        input Real LU[:, size(LU, 1)]
          "LU factorization of dgetrf of a square matrix";
        input Integer pivots[size(LU, 1)] "Pivot vector of dgetrf";
        output Real inv[size(LU, 1), size(LU, 2)]=LU "Inverse of matrix P*L*U";
        output Integer info;

    protected
        Integer n=size(LU, 1);
        Integer lda=max(1, size(LU, 1));
        Integer lwork=max(1, min(10, size(LU, 1))*size(LU, 1))
          "Length of work array";
        Real work[max(1, min(10, size(LU, 1))*size(LU, 1))];

      external"FORTRAN 77" dgetri(
                n,
                inv,
                lda,
                pivots,
                work,
                lwork,
                info) annotation (Library="lapack");
        annotation (Documentation(info="Lapack documentation
    Purpose
    =======

    DGETRI computes the inverse of a matrix using the LU factorization
    computed by DGETRF.

    This method inverts U and then computes inv(A) by solving the system
    inv(A)*L = inv(U) for inv(A).

    Arguments
    =========

    N       (input) INTEGER
            The order of the matrix A.  N >= 0.

    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by DGETRF.
            On exit, if INFO = 0, the inverse of the original matrix A.

    LDA     (input) INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).

    IPIV    (input) INTEGER array, dimension (N)
            The pivot indices from DGETRF; for 1<=i<=N, row i of the
            matrix was interchanged with row IPIV(i).

    WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, then WORK(1) returns the optimal LWORK.

    LWORK   (input) INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimal performance LWORK >= N*NB, where NB is
            the optimal blocksize returned by ILAENV.

            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.

    INFO    (output) INTEGER
            = 0:  successful exit
            < 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
"));
      end dgetri;
      annotation (Documentation(info="<html>
<p>
This package contains external Modelica functions as interface to the
LAPACK library
(<a href=\"http://www.netlib.org/lapack\">http://www.netlib.org/lapack</a>)
that provides FORTRAN subroutines to solve linear algebra
tasks. Usually, these functions are not directly called, but only via
the much more convenient interface of
<a href=\"modelica://Modelica.Math.Matrices\">Modelica.Math.Matrices</a>.
The documentation of the LAPACK functions is a copy of the original
FORTRAN code. The details of LAPACK are described in:
</p>

<dl>
<dt>Anderson E., Bai Z., Bischof C., Blackford S., Demmel J., Dongarra J.,
    Du Croz J., Greenbaum A., Hammarling S., McKenney A., and Sorensen D.:</dt>
<dd> <a href=\"http://www.netlib.org/lapack/lug/lapack_lug.html\">Lapack Users' Guide</a>.
     Third Edition, SIAM, 1999.</dd>
</dl>

<p>
See also <a href=\"http://en.wikipedia.org/wiki/Lapack\">http://en.wikipedia.org/wiki/Lapack</a>.
</p>

<p>
This package contains a direct interface to the LAPACK subroutines
</p>

</html>"));
    end LAPACK;
    annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
This library provides functions operating on matrices. Below, the
functions are ordered according to categories and a typical
call of the respective function is shown.
Most functions are solely an interface to the external
<a href=\"modelica://Modelica.Math.Matrices.LAPACK\">LAPACK</a> library.
</p>

<p>
Note: A' is a short hand notation of transpose(A):
</p>

<p><strong>Basic Information</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.toString\">toString</a>(A)
     - returns the string representation of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.isEqual\">isEqual</a>(M1, M2)
     - returns true if matrices M1 and M2 have the same size and the same elements.</li>
</ul>

<p><strong>Linear Equations</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.solve\">solve</a>(A,b)
     - returns solution x of the linear equation A*x=b (where b is a vector,
       and A is a square matrix that must be regular).</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.solve2\">solve2</a>(A,B)
     - returns solution X of the linear equation A*X=B (where B is a matrix,
       and A is a square matrix that must be regular)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares\">leastSquares</a>(A,b)
     - returns solution x of the linear equation A*x=b in a least squares sense
       (where b is a vector and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.leastSquares2\">leastSquares2</a>(A,B)
     - returns solution X of the linear equation A*X=B in a least squares sense
       (where B is a matrix and A may be non-square and may be rank deficient)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.equalityLeastSquares\">equalityLeastSquares</a>(A,a,B,b)
     - returns solution x of a linear equality constrained least squares problem:
       min|A*x-a|^2 subject to B*x=b</li>

<li> (LU,p,info) = <a href=\"modelica://Modelica.Math.Matrices.LU\">LU</a>(A)
     - returns the LU decomposition with row pivoting of a rectangular matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve\">LU_solve</a>(LU,p,b)
     - returns solution x of the linear equation L*U*x[p]=b with a b
       vector and an LU decomposition from \"LU(..)\".</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.LU_solve2\">LU_solve2</a>(LU,p,B)
     - returns solution X of the linear equation L*U*X[p,:]=B with a B
       matrix and an LU decomposition from \"LU(..)\".</li>
</ul>

<p><strong>Matrix Factorizations</strong></p>
<ul>
<li> (eval,evec) = <a href=\"modelica://Modelica.Math.Matrices.eigenValues\">eigenValues</a>(A)
     - returns eigen values \"eval\" and eigen vectors \"evec\" for a real,
       nonsymmetric matrix A in a Real representation.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.eigenValueMatrix\">eigenValueMatrix</a>(eval)
     - returns real valued block diagonal matrix of the eigenvalues \"eval\" of matrix A.</li>

<li> (sigma,U,VT) = <a href=\"modelica://Modelica.Math.Matrices.singularValues\">singularValues</a>(A)
     - returns singular values \"sigma\" and left and right singular vectors U and VT
       of a rectangular matrix A.</li>

<li> (Q,R,p) = <a href=\"modelica://Modelica.Math.Matrices.QR\">QR</a>(A)
     - returns the QR decomposition with column pivoting of a rectangular matrix A
       such that Q*R = A[:,p].</li>

<li> (H,U) = <a href=\"modelica://Modelica.Math.Matrices.hessenberg\">hessenberg</a>(A)
     - returns the upper Hessenberg form H and the orthogonal transformation matrix U
       of a square matrix A such that H = U'*A*U.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.realSchur\">realSchur</a>(A)
     - returns the real Schur form of a square matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.cholesky\">cholesky</a>(A)
     - returns the cholesky factor H of a real symmetric positive definite matrix A so that A = H'*H.</li>

<li> (D,Aimproved) = <a href=\"modelica://Modelica.Math.Matrices.balance\">balance</a>(A)
     - returns an improved form Aimproved of a square matrix A that has a smaller condition as A,
       with Aimproved = inv(diagonal(D))*A*diagonal(D).</li>
</ul>

<p><strong>Matrix Properties</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.trace\">trace</a>(A)
     - returns the trace of square matrix A, i.e., the sum of the diagonal elements.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.det\">det</a>(A)
     - returns the determinant of square matrix A (using LU decomposition; try to avoid det(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.inv\">inv</a>(A)
     - returns the inverse of square matrix A (try to avoid, use instead \"solve2(..) with B=identity(..))</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rank\">rank</a>(A)
     - returns the rank of square matrix A (computed with singular value decomposition)</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.conditionNumber\">conditionNumber</a>(A)
     - returns the condition number norm(A)*norm(inv(A)) of a square matrix A in the range 1..&infin;.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.rcond\">rcond</a>(A)
     - returns the reciprocal condition number 1/conditionNumber(A) of a square matrix A in the range 0..1.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.norm\">norm</a>(A)
     - returns the 1-, 2-, or infinity-norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.frobeniusNorm\">frobeniusNorm</a>(A)
     - returns the Frobenius norm of matrix A.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.nullSpace\">nullSpace</a>(A)
     - returns the null space of matrix A.</li>
</ul>

<p><strong>Matrix Exponentials</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.exp\">exp</a>(A)
     - returns the exponential e^A of a matrix A by adaptive Taylor series
       expansion with scaling and balancing</li>

<li> (phi, gamma) = <a href=\"modelica://Modelica.Math.Matrices.integralExp\">integralExp</a>(A,B)
     - returns the exponential phi=e^A and the integral gamma=integral(exp(A*t)*dt)*B as needed
       for a discretized system with zero order hold.</li>

<li> (phi, gamma, gamma1) = <a href=\"modelica://Modelica.Math.Matrices.integralExpT\">integralExpT</a>(A,B)
     - returns the exponential phi=e^A, the integral gamma=integral(exp(A*t)*dt)*B,
       and the time-weighted integral gamma1 = integral((T-t)*exp(A*t)*dt)*B as needed
       for a discretized system with first order hold.</li>
</ul>

<p><strong>Matrix Equations</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.continuousLyapunov\">continuousLyapunov</a>(A,C)
     - returns solution X of the continuous-time Lyapunov equation X*A + A'*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousSylvester\">continuousSylvester</a>(A,B,C)
     - returns solution X of the continuous-time Sylvester equation A*X + X*B = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.continuousRiccati\">continuousRiccati</a>(A,B,R,Q)
     - returns solution X of the continuous-time algebraic Riccati equation
       A'*X + X*A - X*B*inv(R)*B'*X + Q = 0</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteLyapunov\">discreteLyapunov</a>(A,C)
     - returns solution X of the discrete-time Lyapunov equation A'*X*A + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteSylvester\">discreteSylvester</a>(A,B,C)
     - returns solution X of the discrete-time Sylvester equation A*X*B + sgn*X = C</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.discreteRiccati\">discreteRiccati</a>(A,B,R,Q)
     - returns solution X of the discrete-time algebraic Riccati equation
       A'*X*A - X - A'*X*B*inv(R + B'*X*B)*B'*X*A + Q = 0</li>
</ul>

<p><strong>Matrix Manipulation</strong></p>
<ul>
<li> <a href=\"modelica://Modelica.Math.Matrices.sort\">sort</a>(M)
     - returns the sorted rows or columns of matrix M in ascending or descending order.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipLeftRight\">flipLeftRight</a>(M)
     - returns matrix M so that the columns of M are flipped in left/right direction.</li>

<li> <a href=\"modelica://Modelica.Math.Matrices.flipUpDown\">flipUpDown</a>(M)
     - returns matrix M so that the rows of M are flipped in up/down direction.</li>
</ul>

<h4>See also</h4>
<a href=\"modelica://Modelica.Math.Vectors\">Vectors</a>

</html>"),   Icon(graphics={
          Rectangle(
            extent={{-60,66},{-30,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{28,66},{58,18}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-60,-18},{-30,-66}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{28,-18},{58,-66}},
            lineColor={95,95,95},
            fillColor={175,175,175},
            fillPattern=FillPattern.Solid)}));
  end Matrices;

    package Nonlinear "Library of functions operating on nonlinear equations"
      extends Modelica.Icons.Package;

      package Interfaces "Interfaces for functions"
        extends Modelica.Icons.InterfacesPackage;

      encapsulated partial function partialScalarFunction
          "Interface for a function with one input and one output Real signal"
        import Modelica;
        extends Modelica.Icons.Function;
        input Real u "Independent variable";
        output Real y "Dependent variable y=f(u)";
          annotation (Documentation(info="<html>
<p>
This partial function defines the interface of a function with
one input and one output Real signal. The scalar functions
of <a href=\"modelica://Modelica.Math.Nonlinear\">Modelica.Math.Nonlinear</a>
are derived from this base type by inheritance.
This allows to use these functions directly as function arguments
to a function, see, .e.g.,
<a href=\"modelica://Modelica.Math.Nonlinear.Examples\">Math.Nonlinear.Examples</a>.
</p>

</html>"));
      end partialScalarFunction;
        annotation (Documentation(info="<html>
<p>
Interface definitions of functions. The main purpose is to use functions
derived from these interface definitions as function arguments
to a function, see, .e.g.,
<a href=\"modelica://Modelica.Math.Nonlinear.Examples\">Math.Nonlinear.Examples</a>.
</p>
</html>"));
      end Interfaces;

      function quadratureLobatto
        "Return the integral of an integrand function using an adaptive Lobatto rule"
        extends Modelica.Icons.Function;
        input Modelica.Math.Nonlinear.Interfaces.partialScalarFunction f
          "Integrand function";
        input Real a "Lower limit of integration interval";
        input Real b "Upper limit of integration interval";
        input Real tolerance = 100*Modelica.Constants.eps
          "Relative tolerance for integral value";
        output Real integral "integral value";

    protected
        constant Real x1=0.942882415695480;
        constant Real x2=0.641853342345781;
        constant Real x3=0.236383199662150;
        constant Real eps=10*Modelica.Constants.eps;
        Real m;
        Real h;
        Real alpha;
        Real beta;
        Real x[13];
        Real y[13];
        Real fa;
        Real fb;
        Real i1;
        Real i2;
        Real is;
        Real erri1;
        Real erri2;
        Real R;
        Real tol;
        Integer s;

        function quadStep "Recursive function used by quadrature"
          input Modelica.Math.Nonlinear.Interfaces.partialScalarFunction f;
          input Real a "Right interval end";
          input Real b "Left interval end";
          input Real fa "Function value at a";
          input Real fb "Function value at b";
          input Real is "First approximation of the integral";
          output Real I "integral value";
      protected
          Real m;
          Real h;
          Real alpha;
          Real beta;
          Real x[5];
          Real y[5];
          Real mll;
          Real ml;
          Real mr;
          Real mrr;
          Real fmll;
          Real fml;
          Real fm;
          Real fmr;
          Real fmrr;
          Real i1;
          Real i2;
        algorithm
          h := (b - a)/2;
          m := (a + b)/2;
          alpha := sqrt(2/3);
          beta := 1/sqrt(5);
          mll := m - alpha*h;
          ml := m - beta*h;
          mr := m + beta*h;
          mrr := m + alpha*h;
          x := {mll,ml,m,mr,mrr};
          for i in 1:size(x,1) loop
            y[i] := f(x[i]);
          end for;
          fmll := y[1];
          fml := y[2];
          fm := y[3];
          fmr := y[4];
          fmrr := y[5];
          i2 := (h/6)*(fa + fb + 5*(fml + fmr));
          i1 := (h/1470)*(77*(fa + fb) + 432*(fmll + fmrr) + 625*(fml + fmr) +
            672*fm);

          if (is + (i1 - i2) == is) or (mll <= a) or (b <= mrr) then
            I := i1;

          else
            I := quadStep(f, a, mll, fa, fmll, is) +
                 quadStep(f, mll, ml, fmll, fml, is) +
                 quadStep(f, ml, m, fml, fm, is) +
                 quadStep(f, m, mr, fm, fmr, is) +
                 quadStep(f, mr, mrr, fmr, fmrr, is) +
                 quadStep(f, mrr, b, fmrr, fb, is);
          end if;
        end quadStep;

      algorithm
        /*
        Numerically evaluate integral using adaptive
        Lobatto rule.
        see Walter Gander: Adaptive Quadrature - Revisited, 1998
                        ftp.inf.ethz.ch in pub/publications/tech-reports/3xx/306.ps

        x[:] are the nodes
        y[:] = f(x[:]) are function values at the nodes
        */
        tol := tolerance;
        m := (a + b)/2;
        h := (b - a)/2;
        alpha := sqrt(2/3);
        beta := 1/sqrt(5);
        x := {a,
              m - x1*h,
              m - alpha*h,
              m - x2*h,
              m - beta*h,
              m - x3*h,
              m,
              m + x3*h,
              m + beta*h,
              m + x2*h,
              m + alpha*h,
              m + x1*h,
              b};
        for i in 1:size(x,1) loop
          y[i] := f(x[i]);
        end for;
        fa := y[1];
        fb := y[13];
        i2 := (h/6)*(y[1] + y[13] + 5*(y[5] + y[9]));
        i1 := (h/1470)*(77*(y[1] + y[13]) + 432*(y[3] + y[11]) + 625*(y[5] + y[9])
           + 672*y[7]);
        is := h*(0.0158271919734802*(y[1] + y[13]) +0.0942738402188500 *(y[2] + y[
          12]) +0.155071987336585 *(y[3] + y[11]) +0.188821573960182 *(y[4] + y[10])
           +0.199773405226859 *(y[5] + y[9]) +0.224926465333340 *(y[6] + y[8]) +0.242611071901408
                          *y[7]);
        s := sign(is);
        if (s == 0) then
          s := 1;
        end if;
        erri1 := abs(i1 - is);
        erri2 := abs(i2 - is);
        R := 1;
        if (erri2 <> 0) then
          R := erri1/erri2;
        end if;
        if (R > 0 and R < 1) then
          tol := tol/R;
        end if;
        is := s*abs(is)*tol/eps;
        if (is == 0) then
          is := b - a;
        end if;
        integral := quadStep(
              f,
              a,
              b,
              fa,
              fb,
              is);

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
<strong>quadratureLobatto</strong>(function f(), a, b);
<strong>quadratureLobatto</strong>(function f(), a, b, tolerance=100*Modelica.Constants.eps);
</pre></blockquote>

<h4>Description</h4>

<p>
Compute definite integral over function f(u,...) from u=a up to u=b
using the adaptive Lobatto rule according to:
</p>

<blockquote>
<dl>
<dt>Walter Gander:</dt>
<dd> <strong>Adaptive Quadrature - Revisited</strong>. 1998.
     <a href=\"ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/3xx/306.ps\">ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/3xx/306.ps</a>
     </dd>
</dl>
</blockquote>

<h4>Example</h4>

<p>
See the examples in <a href=\"modelica://Modelica.Math.Nonlinear.Examples\">Modelica.Math.Nonlinear.Examples</a>.
</p>

</html>"));
      end quadratureLobatto;
      annotation (Documentation(info="<html>
<p>
This package contains functions to perform tasks such as numerically integrating
a function, or solving a nonlinear algebraic equation system.
The common feature of the functions in this package is
that the nonlinear characteristics are passed as user definable
functions.
</p>

<p>
For details about how to define and to use functions as input arguments
to functions, see
<a href=\"modelica://ModelicaReference.Classes.'function'\">ModelicaReference.Classes.'function'</a>
or the Modelica Language  Specification, Chapter 12.4.2.
</p>

</html>",     revisions="<html>
<ul>
<li><em>July 2010 </em> by Martin Otter (DLR-RM):<br>
    Included in MSL3.2, adapted, and documentation improved</li>

<li><em>March 2010 </em> by Andreas Pfeiffer (DLR-RM):<br>
    Adapted the quadrature function from Gerhard Schillhuber and
    the solution of one non-linear equation in one unknown from
    Modelica.Media.Common.OneNonLinearEquation so that
    function objects are used.</li>

<li><em>June 2002 </em> by Gerhard Schillhuber (master thesis at DLR-RM):<br>
       Adaptive quadrature to compute the curve length of a Spline.</li>
</ul>
</html>"),     Icon(graphics={Polygon(points={{-44,-52},{-44,-26},{-17.1,
                  44.4},{-11.4,52.6},{-5.8,57.1},{-0.2,57.8},{5.4,54.6},{11.1,47.7},
                  {16.7,37.4},{23.1,22.1},{31.17,-0.8},{48,-52},{-44,-52}},
              lineColor={135,135,135},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid)}));
    end Nonlinear;

    package Special "Library of special mathematical functions"
      extends Modelica.Icons.Package;

      function erf "Error function erf(u) = 2/sqrt(pi)*Integral_0_u exp(-t^2)*d"
        extends Modelica.Icons.Function;
        input Real u "Input argument";
        output Real y "= 2/sqrt(pi)*Integral_0_u exp(-t^2)*dt";
    protected
         Boolean inv;
         Real z;
         Real zz;
         constant Real y1 = 1.044948577880859375;
         constant Real P[5] = {0.0834305892146531832907,
                               -0.338165134459360935041,
                               -0.0509990735146777432841,
                               -0.00772758345802133288487,
                               -0.000322780120964605683831};
         constant Real Q[5] = {1,
                               0.455004033050794024546,
                               0.0875222600142252549554,
                               0.00858571925074406212772,
                               0.000370900071787748000569};
      algorithm
         if u >= 0 then
            z :=u;
            inv :=false;
         else
            z :=-u;
            inv :=true;
         end if;

         if z < 0.5 then
            if z <= 0 then
               y := 0;
            elseif z < 1.0e-10 then
               y := z*1.125 + z*0.003379167095512573896158903121545171688;
            else
               // Maximum Deviation Found:                     1.561e-17
               // Expected Error Term:                         1.561e-17
               // Maximum Relative Change in Control Points:   1.155e-04
               // Max Error found at double precision =        2.961182e-17
               zz := z*z;
               y := z*(y1 + Internal.polyEval(P, zz)/Internal.polyEval(Q, zz));
            end if;

         elseif z < 5.8 then
            y :=1 - Internal.erfcUtil(z);

         else
            y :=1;
         end if;

         if inv then
            y :=-y;
         end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Special.<strong>erf</strong>(u);
</pre></blockquote>

<h4>Description</h4>
<p>
This function computes the error function erf(u) = 2/sqrt(pi)*Integral_0_u exp(-t^2)*dt numerically with a relative precision of about 1e-15. The implementation utilizes the formulation of the Boost library
(53-bit implementation of <a href=\"http://www.boost.org/doc/libs/1_57_0/boost/math/special_functions/erf.hpp\">erf.hpp</a>,
developed by John Maddock). Plot
of the function:
</p>

<blockquote>
<img src=\"modelica://Modelica/Resources/Images/Math/Special/erf.png\">
</blockquote>

<p>
For more details, see <a href=\"http://en.wikipedia.org/wiki/Error_function\">Wikipedia</a>.
</p>

<h4>Example</h4>
<blockquote><pre>
  erf(0)    // = 0
  erf(10)   // = 1
  erf(0.5)  // = 0.520499877813047
</pre></blockquote>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Math.Special.erfc\">erfc</a>,
<a href=\"modelica://Modelica.Math.Special.erfInv\">erfInv</a>,
<a href=\"modelica://Modelica.Math.Special.erfcInv\">erfcInv</a>.
</p>
</html>",       revisions="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=0>
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
      end erf;

      package Internal
      "Internal utility functions that should not be directly utilized by the user"
         extends Modelica.Icons.InternalPackage;

        function polyEval "Evaluate a polynomial c[1] + c[2]*u + c[3]*u^2 + ...."
          extends Modelica.Icons.Function;
          input Real  c[:] "Polynomial coefficients";
          input Real  u "Abscissa value";
          output Real y "= c[1] + u*(c[2] + u*(c[3] + u*(c[4]*u^3 + ...)))";
        algorithm
          y := c[size(c,1)];
          for j in size(c, 1)-1:-1:1 loop
             y := c[j] + u*y;
          end for;
         annotation (Documentation(info="<html>
<p>
Evaluate a polynomial using Horner's scheme.
</p>
</html>",      revisions="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=0>
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
        end polyEval;

        function erfcUtil "Evaluate erfc(z) for 0.5 <= z "
          extends Modelica.Icons.Function;
          input Real z "Input argument 0.5 <= z required (but not checked)";
          output Real y "Result erfc(z) for 0.5 <= z";
      protected
           constant Real y1 = 0.405935764312744140625;
           constant Real P1[6] = {-0.098090592216281240205,
                                   0.178114665841120341155,
                                   0.191003695796775433986,
                                   0.0888900368967884466578,
                                   0.0195049001251218801359,
                                   0.00180424538297014223957};
           constant Real Q1[7] = {1,
                                  1.84759070983002217845,
                                  1.42628004845511324508,
                                  0.578052804889902404909,
                                  0.12385097467900864233,
                                  0.0113385233577001411017,
                                  0.337511472483094676155e-5};

           constant Real y2 = 0.50672817230224609375;
           constant Real P2[6] = {-0.0243500476207698441272,
                                   0.0386540375035707201728,
                                   0.04394818964209516296,
                                   0.0175679436311802092299,
                                   0.00323962406290842133584,
                                   0.000235839115596880717416};
           constant Real Q2[6] = {1,
                                  1.53991494948552447182,
                                  0.982403709157920235114,
                                  0.325732924782444448493,
                                  0.0563921837420478160373,
                                  0.00410369723978904575884};

           constant Real y3 = 0.5405750274658203125;
           constant Real P3[6] = {0.00295276716530971662634,
                                  0.0137384425896355332126,
                                  0.00840807615555585383007,
                                  0.00212825620914618649141,
                                  0.000250269961544794627958,
                                  0.113212406648847561139e-4};
           constant Real Q3[6] = {1,
                                  1.04217814166938418171,
                                  0.442597659481563127003,
                                  0.0958492726301061423444,
                                  0.0105982906484876531489,
                                  0.000479411269521714493907};

           constant Real y4 = 0.5579090118408203125;
           constant Real P4[7] = {0.00628057170626964891937,
                                  0.0175389834052493308818,
                                 -0.212652252872804219852,
                                 -0.687717681153649930619,
                                 -2.5518551727311523996,
                                 -3.22729451764143718517,
                                 -2.8175401114513378771};
           constant Real Q4[7] = {1,
                                  2.79257750980575282228,
                                 11.0567237927800161565,
                                 15.930646027911794143,
                                 22.9367376522880577224,
                                 13.5064170191802889145,
                                  5.48409182238641741584};

        algorithm
           if z < 1.5 then
              // Maximum Deviation Found:                     3.702e-17
              // Expected Error Term:                         3.702e-17
              // Maximum Relative Change in Control Points:   2.845e-04
              // Max Error found at double precision =        4.841816e-17
              y :=y1 + polyEval(P1, z - 0.5)/polyEval(Q1, z - 0.5);

           elseif z < 2.5 then
              // Max Error found at double precision =        6.599585e-18
              // Maximum Deviation Found:                     3.909e-18
              // Expected Error Term:                         3.909e-18
              // Maximum Relative Change in Control Points:   9.886e-05
              y :=y2 + polyEval(P2, z - 1.5)/polyEval(Q2, z - 1.5);

           elseif z < 4.5 then
              // Maximum Deviation Found:                     1.512e-17
              // Expected Error Term:                         1.512e-17
              // Maximum Relative Change in Control Points:   2.222e-04
              // Max Error found at double precision =        2.062515e-17
              y :=y3 + polyEval(P3, z - 3.5)/polyEval(Q3, z - 3.5);

           else
              // Max Error found at double precision =        2.997958e-17
              // Maximum Deviation Found:                     2.860e-17
              // Expected Error Term:                         2.859e-17
              // Maximum Relative Change in Control Points:   1.357e-05
              y :=y4 + polyEval(P4, 1/z)/polyEval(Q4, 1/z);
           end if;

           y := y*(exp(-z * z) / z);
         annotation (Documentation(info="<html>
<p>
Utility function in order to compute part of erf(..) and erfc(..).
</p>
</html>",      revisions="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=0>
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
        end erfcUtil;
        annotation (Documentation(info="<html>
<p>
This package contains internal utility functions for the computation of
erf, erfc, erfInc and erfcInv. These functions should not be directly used
by the user.
</p>
</html>",       revisions="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=0>
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
      end Internal;
    annotation (Icon(graphics={Line(
          points={{-80,-80},{-20,-80},{20,80},{80,80}},
          smooth=Smooth.Bezier)}), Documentation(info="<html>
<p>
This sublibrary contains functions to compute often used mathematical operators that
cannot be expressed analytically.
</p>
</html>",     revisions="<html>
<table border=1 cellspacing=0 cellpadding=2>
<tr><th>Date</th> <th align=\"left\">Description</th></tr>

<tr><td> June 22, 2015 </td>
    <td>

<table border=0>
<tr><td>
         <img src=\"modelica://Modelica/Resources/Images/Logos/dlr_logo.png\">
</td><td valign=\"bottom\">
         Initial version implemented by
         A. Kl&ouml;ckner, F. v.d. Linden, D. Zimmer, M. Otter.<br>
         <a href=\"http://www.dlr.de/rmc/sr/en\">DLR Institute of System Dynamics and Control</a>
</td></tr></table>
</td></tr>

</table>
</html>"));
    end Special;

  package Icons "Icons for Math"
    extends Modelica.Icons.IconsPackage;

    partial function AxisLeft
      "Basic icon for mathematical function with y-axis on left side"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{-80,-80},{-80,68}}, color={192,192,192}),
            Polygon(
              points={{-80,90},{-88,68},{-72,68},{-80,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              lineColor={0,0,255})}),
        Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                100,100}}), graphics={Line(points={{-80,80},{-88,80}}, color={95,95,95}),
              Line(points={{-80,-80},{-88,-80}}, color={95,95,95}),Line(
              points={{-80,-90},{-80,84}}, color={95,95,95}),Text(
                  extent={{-75,104},{-55,84}},
                  lineColor={95,95,95},
                  textString="y"),Polygon(
                  points={{-80,98},{-86,82},{-74,82},{-80,98}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis on the left side.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end AxisLeft;

    partial function AxisCenter
      "Basic icon for mathematical function with y-axis in the center"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                100}}), graphics={
            Rectangle(
              extent={{-100,100},{100,-100}},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid),
            Line(points={{0,-80},{0,68}}, color={192,192,192}),
            Polygon(
              points={{0,90},{-8,68},{8,68},{0,90}},
              lineColor={192,192,192},
              fillColor={192,192,192},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,150},{150,110}},
              textString="%name",
              lineColor={0,0,255})}),
        Diagram(graphics={Line(points={{0,80},{-8,80}}, color={95,95,95}),Line(
              points={{0,-80},{-8,-80}}, color={95,95,95}),Line(points={{0,-90},{
              0,84}}, color={95,95,95}),Text(
                  extent={{5,104},{25,84}},
                  lineColor={95,95,95},
                  textString="y"),Polygon(
                  points={{0,98},{-6,82},{6,82},{0,98}},
                  lineColor={95,95,95},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
        Documentation(info="<html>
<p>
Icon for a mathematical function, consisting of an y-axis in the middle.
It is expected, that an x-axis is added and a plot of the function.
</p>
</html>"));
    end AxisCenter;
  end Icons;

  function sin "Sine"
    extends Modelica.Math.Icons.AxisLeft;
    input Modelica.SIunits.Angle u;
    output Real y;

  external "builtin" y = sin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
                {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},
                {-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},
                {29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{
                57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}),
          Text(
            extent={{12,84},{84,36}},
            lineColor={192,192,192},
            textString="sin")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{100,0},{84,6},{84,-6},{100,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},
              {-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},{-14.9,
              44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},{29.3,-73.1},
              {35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{57.5,-61.9},{63.9,
              -47.2},{72,-24.8},{80,0}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-105,72},{-85,88}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{70,25},{90,5}},
              textString="2*pi",
              lineColor={0,0,255}),Text(
              extent={{-103,-72},{-83,-88}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{82,-6},{102,-26}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-80,80},{-28,80}},
              color={175,175,175}),Line(
              points={{-80,-80},{50,-80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = sin(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/sin.png\">
</p>
</html>"));
  end sin;

  function cos "Cosine"
    extends Modelica.Math.Icons.AxisLeft;
    input SI.Angle u;
    output Real y;

  external "builtin" y = cos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},
                {-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},
                {-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},
                {24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,
                73.4},{75.2,78.6},{80,80}}),
          Text(
            extent={{-36,82},{36,34}},
            lineColor={192,192,192},
            textString="cos")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-103,72},{-83,88}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{-103,-72},{-83,-88}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{70,25},{90,5}},
              textString="2*pi",
              lineColor={0,0,255}),Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,80},{-74.4,78.1},{-68.7,72.3},{-63.1,63},{-56.7,48.7},
              {-48.6,26.6},{-29.3,-32.5},{-22.1,-51.7},{-15.7,-65.3},{-10.1,-73.8},
              {-4.42,-78.8},{1.21,-79.9},{6.83,-77.1},{12.5,-70.6},{18.1,-60.6},{
              24.5,-45.7},{32.6,-23},{50.3,31.3},{57.5,50.7},{63.9,64.6},{69.5,
              73.4},{75.2,78.6},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{78,-6},{98,-26}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-80,-80},{18,-80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = cos(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/cos.png\">
</p>
</html>"));
  end cos;

  function tan "Tangent (u shall not be -pi/2, pi/2, 3*pi/2, ...)"
    extends Modelica.Math.Icons.AxisCenter;
    input SI.Angle u;
    output Real y;

  external "builtin" y = tan(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
                {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
                {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,
                47.4},{76,56.1},{77.6,63.8},{80,80}}),
          Text(
            extent={{-90,72},{-18,24}},
            lineColor={192,192,192},
            textString="tan")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-37,-72},{-17,-88}},
              textString="-5.8",
              lineColor={0,0,255}),Text(
              extent={{-33,86},{-13,70}},
              textString=" 5.8",
              lineColor={0,0,255}),Text(
              extent={{68,-13},{88,-33}},
              textString="1.4",
              lineColor={0,0,255}),Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-78.4,-68.4},{-76.8,-59.7},{-74.4,-50},{-71.2,-40.9},
              {-67.1,-33},{-60.7,-24.8},{-51.1,-17.2},{-35.8,-9.98},{-4.42,-1.07},
              {33.4,9.12},{49.4,16.2},{59.1,23.2},{65.5,30.6},{70.4,39.1},{73.6,
              47.4},{76,56.1},{77.6,63.8},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{82,22},{102,2}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{86,80}},
              color={175,175,175}),Line(
              points={{80,88},{80,-16}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = tan(u), with -&infin; &lt; u &lt; &infin;
(if u is a multiple of (2n-1)*pi/2, y = tan(u) is +/- infinity).
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tan.png\">
</p>
</html>"));
  end tan;

  function asin "Inverse sine (-1 <= u <= 1)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output SI.Angle y;

  external "builtin" y = asin(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-72.8},{-77.6,-67.5},{-73.6,-59.4},{-66.3,
                -49.8},{-53.5,-37.3},{-30.2,-19.7},{37.4,24.8},{57.5,40.8},{68.7,
                52.7},{75.2,62.2},{77.6,67.5},{80,80}}),
          Text(
            extent={{-88,78},{-16,30}},
            lineColor={192,192,192},
            textString="asin")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Text(
              extent={{-40,-72},{-15,-88}},
              textString="-pi/2",
              lineColor={0,0,255}),Text(
              extent={{-38,88},{-13,72}},
              textString=" pi/2",
              lineColor={0,0,255}),Text(
              extent={{68,-9},{88,-29}},
              textString="+1",
              lineColor={0,0,255}),Text(
              extent={{-90,21},{-70,1}},
              textString="-1",
              lineColor={0,0,255}),Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-79.2,-72.8},{-77.6,-67.5},{-73.6,-59.4},{-66.3,
              -49.8},{-53.5,-37.3},{-30.2,-19.7},{37.4,24.8},{57.5,40.8},{68.7,
              52.7},{75.2,62.2},{77.6,67.5},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{82,24},{102,4}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{86,80}},
              color={175,175,175}),Line(
              points={{80,86},{80,-10}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = asin(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/asin.png\">
</p>
</html>"));
  end asin;

  function acos "Inverse cosine (-1 <= u <= 1)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output SI.Angle y;

  external "builtin" y = acos(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-80},{68,-80}}, color={192,192,192}),
          Polygon(
            points={{90,-80},{68,-72},{68,-88},{90,-80}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-79.2,72.8},{-77.6,67.5},{-73.6,59.4},{-66.3,
                49.8},{-53.5,37.3},{-30.2,19.7},{37.4,-24.8},{57.5,-40.8},{68.7,-52.7},
                {75.2,-62.2},{77.6,-67.5},{80,-80}}),
          Text(
            extent={{-86,-14},{-14,-62}},
            lineColor={192,192,192},
            textString="acos")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,-80},{84,-80}}, color={95,95,95}),
            Polygon(
              points={{98,-80},{82,-74},{82,-86},{98,-80}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,80},{-79.2,72.8},{-77.6,67.5},{-73.6,59.4},{-66.3,49.8},
              {-53.5,37.3},{-30.2,19.7},{37.4,-24.8},{57.5,-40.8},{68.7,-52.7},{
              75.2,-62.2},{77.6,-67.5},{80,-80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-30,88},{-5,72}},
              textString=" pi",
              lineColor={0,0,255}),Text(
              extent={{-94,-57},{-74,-77}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{60,-81},{80,-101}},
              textString="+1",
              lineColor={0,0,255}),Text(
              extent={{82,-56},{102,-76}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-2,80},{84,80}},
              color={175,175,175}),Line(
              points={{80,82},{80,-86}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = acos(u), with -1 &le; u &le; +1:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/acos.png\">
</p>
</html>"));
  end acos;

  function atan "Inverse tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output SI.Angle y;

  external "builtin" y = atan(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-52.7,-75.2},{-37.4,-69.7},{-26.9,-63},{-19.7,-55.2},
                {-14.1,-45.8},{-10.1,-36.4},{-6.03,-23.9},{-1.21,-5.06},{5.23,21},
                {9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,
                73.6},{69.5,78.6},{80,80}}),
          Text(
            extent={{-86,68},{-14,20}},
            lineColor={192,192,192},
            textString="atan")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{96,0},{80,6},{80,-6},{96,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-52.7,-75.2},{-37.4,-69.7},{-26.9,-63},{-19.7,-55.2},
              {-14.1,-45.8},{-10.1,-36.4},{-6.03,-23.9},{-1.21,-5.06},{5.23,21},{
              9.25,34.1},{13.3,44.2},{18.1,52.9},{24.5,60.8},{33.4,67.6},{47,73.6},
              {65,77},{80,78}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-34,87},{-14,74}},
              textString="pi/2",
              lineColor={0,0,255}),Text(
              extent={{-32,-71},{-12,-91}},
              textString="-pi/2",
              lineColor={0,0,255}),Text(
              extent={{84,-4},{104,-24}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{-2,80},{84,80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = atan(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/atan.png\">
</p>
</html>"));
  end atan;

  function atan2 "Four quadrant inverse tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u1;
    input Real u2;
    output SI.Angle y;

  external "builtin" y = atan2(u1, u2);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{0,-80},{8.93,-67.2},{17.1,-59.3},{27.3,-53.6},{42.1,-49.4},
                {69.9,-45.8},{80,-45.1}}),
          Line(points={{-80,-34.9},{-46.1,-31.4},{-29.4,-27.1},{-18.3,-21.5},{-10.3,
                -14.5},{-2.03,-3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},{
                62.1,33.5},{80,34.9}}),
          Line(points={{-80,45.1},{-45.9,48.7},{-29.1,52.9},{-18.1,58.6},{-10.2,
                65.8},{-1.82,77.2},{0,80}}),
          Text(
            extent={{-90,-46},{-18,-94}},
            lineColor={192,192,192},
            textString="atan2")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{96,0},{80,6},{80,-6},{96,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{0,-80},{8.93,-67.2},{17.1,-59.3},{27.3,-53.6},{42.1,-49.4},
              {69.9,-45.8},{80,-45.1}},
              color={0,0,255},
              thickness=0.5),Line(
              points={{-80,-34.9},{-46.1,-31.4},{-29.4,-27.1},{-18.3,-21.5},{-10.3,
              -14.5},{-2.03,-3.17},{7.97,11.6},{15.5,19.4},{24.3,25},{39,30},{
              62.1,33.5},{80,34.9}},
              color={0,0,255},
              thickness=0.5),Line(
              points={{-80,45.1},{-45.9,48.7},{-29.1,52.9},{-18.1,58.6},{-10.2,
              65.8},{-1.82,77.2},{0,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-32,89},{-10,74}},
              textString="pi",
              lineColor={0,0,255}),Text(
              extent={{-32,-72},{-4,-88}},
              textString="-pi",
              lineColor={0,0,255}),Text(
              extent={{0,55},{20,42}},
              textString="pi/2",
              lineColor={0,0,255}),Line(points={{0,40},{-8,40}}, color={192,192,192}),
            Line(points={{0,-40},{-8,-40}}, color={192,192,192}),Text(
              extent={{0,-23},{20,-42}},
              textString="-pi/2",
              lineColor={0,0,255}),Text(
              extent={{62,-4},{94,-26}},
              lineColor={95,95,95},
              textString="u1, u2"),Line(
              points={{-88,40},{86,40}},
              color={175,175,175}),Line(
              points={{-86,-40},{86,-40}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = atan2(u1,u2) such that tan(y) = u1/u2 and
y is in the range -pi &lt; y &le; pi. u2 may be zero, provided
u1 is not zero. Usually u1, u2 is provided in such a form that
u1 = sin(y) and u2 = cos(y):
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/atan2.png\">
</p>

</html>"));
  end atan2;

  function cosh "Hyperbolic cosine"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  external "builtin" y = cosh(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-86.083},{68,-86.083}}, color={192,192,192}),
          Polygon(
            points={{90,-86.083},{68,-78.083},{68,-94.083},{90,-86.083}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,80},{-77.6,61.1},{-74.4,39.3},{-71.2,20.7},{-67.1,
                1.29},{-63.1,-14.6},{-58.3,-29.8},{-52.7,-43.5},{-46.2,-55.1},{-39,
                -64.3},{-30.2,-71.7},{-18.9,-77.1},{-4.42,-79.9},{10.9,-79.1},{
                23.7,-75.2},{34.2,-68.7},{42.2,-60.6},{48.6,-51.2},{54.3,-40},{
                59.1,-27.5},{63.1,-14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{
                77.6,61.1},{80,80}}),
          Text(
            extent={{4,66},{66,20}},
            lineColor={192,192,192},
            textString="cosh")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,-84.083},{84,-84.083}}, color=
             {95,95,95}),Polygon(
              points={{98,-84.083},{82,-78.083},{82,-90.083},{98,-84.083}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,80},{-77.6,61.1},{-74.4,39.3},{-71.2,20.7},{-67.1,1.29},
              {-63.1,-14.6},{-58.3,-29.8},{-52.7,-43.5},{-46.2,-55.1},{-39,-64.3},
              {-30.2,-71.7},{-18.9,-77.1},{-4.42,-79.9},{10.9,-79.1},{23.7,-75.2},
              {34.2,-68.7},{42.2,-60.6},{48.6,-51.2},{54.3,-40},{59.1,-27.5},{
              63.1,-14.6},{67.1,1.29},{71.2,20.7},{74.4,39.3},{77.6,61.1},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-31,72},{-11,88}},
              textString="27",
              lineColor={0,0,255}),Text(
              extent={{64,-83},{84,-103}},
              textString="4",
              lineColor={0,0,255}),Text(
              extent={{-94,-63},{-74,-83}},
              textString="-4",
              lineColor={0,0,255}),Text(
              extent={{80,-60},{100,-80}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175}),Line(
              points={{80,84},{80,-90}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = cosh(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/cosh.png\">
</p>
</html>"));
  end cosh;

  function tanh "Hyperbolic tangent"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  external "builtin" y = tanh(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-47.8,-78.7},{-35.8,-75.7},{-27.7,-70.6},{-22.1,
                -64.2},{-17.3,-55.9},{-12.5,-44.3},{-7.64,-29.2},{-1.21,-4.82},{
                6.83,26.3},{11.7,42},{16.5,54.2},{21.3,63.1},{26.9,69.9},{34.2,75},
                {45.4,78.4},{72,79.9},{80,80}}),
          Text(
            extent={{-88,72},{-16,24}},
            lineColor={192,192,192},
            textString="tanh")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{96,0},{80,6},{80,-6},{96,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80.5},{-47.8,-79.2},{-35.8,-76.2},{-27.7,-71.1},{-22.1,
              -64.7},{-17.3,-56.4},{-12.5,-44.8},{-7.64,-29.7},{-1.21,-5.32},{
              6.83,25.8},{11.7,41.5},{16.5,53.7},{21.3,62.6},{26.9,69.4},{34.2,
              74.5},{45.4,77.9},{72,79.4},{80,79.5}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-29,72},{-9,88}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{3,-72},{23,-88}},
              textString="-1",
              lineColor={0,0,255}),Text(
              extent={{82,-2},{102,-22}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = tanh(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/tanh.png\">
</p>
</html>"));
  end tanh;

  function asinh "Inverse of sinh (area hyperbolic sine)"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  algorithm
    y := Modelica.Math.log(u + sqrt(u*u + 1));
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-56.7,-68.4},{-39.8,-56.8},{-26.9,-44.7},{-17.3,
                -32.4},{-9.25,-19},{9.25,19},{17.3,32.4},{26.9,44.7},{39.8,56.8},
                {56.7,68.4},{80,80}}),
          Text(
            extent={{-90,80},{-6,26}},
            lineColor={192,192,192},
            textString="asinh")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-56.7,-68.4},{-39.8,-56.8},{-26.9,-44.7},{-17.3,
              -32.4},{-9.25,-19},{9.25,19},{17.3,32.4},{26.9,44.7},{39.8,56.8},{
              56.7,68.4},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-31,72},{-11,88}},
              textString="2.31",
              lineColor={0,0,255}),Text(
              extent={{-35,-88},{-15,-72}},
              textString="-2.31",
              lineColor={0,0,255}),Text(
              extent={{72,-13},{92,-33}},
              textString="5",
              lineColor={0,0,255}),Text(
              extent={{-96,21},{-76,1}},
              textString="-5",
              lineColor={0,0,255}),Text(
              extent={{80,22},{100,2}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175}),Line(
              points={{80,86},{80,-12}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
The function returns the area hyperbolic sine of its
input argument u. This inverse of sinh(..) is unique
and there is no restriction on the input argument u of
asinh(u) (-&infin; &lt; u &lt; &infin;):
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/asinh.png\">
</p>
</html>"));
  end asinh;

  function exp "Exponential, base e"
    extends Modelica.Math.Icons.AxisCenter;
    input Real u;
    output Real y;

  external "builtin" y = exp(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,-80.3976},{68,-80.3976}}, color={192,192,192}),
          Polygon(
            points={{90,-80.3976},{68,-72.3976},{68,-88.3976},{90,-80.3976}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},
                {34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{
                67.1,18.6},{72,38.2},{76,57.6},{80,80}}),
          Text(
            extent={{-86,50},{-14,2}},
            lineColor={192,192,192},
            textString="exp")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,-80.3976},{84,-80.3976}},
            color={95,95,95}),Polygon(
              points={{98,-80.3976},{82,-74.3976},{82,-86.3976},{98,-80.3976}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-80,-80},{-31,-77.9},{-6.03,-74},{10.9,-68.4},{23.7,-61},{
              34.2,-51.6},{43,-40.3},{50.3,-27.8},{56.7,-13.5},{62.3,2.23},{67.1,
              18.6},{72,38.2},{76,57.6},{80,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-31,72},{-11,88}},
              textString="20",
              lineColor={0,0,255}),Text(
              extent={{-92,-81},{-72,-101}},
              textString="-3",
              lineColor={0,0,255}),Text(
              extent={{66,-81},{86,-101}},
              textString="3",
              lineColor={0,0,255}),Text(
              extent={{2,-69},{22,-89}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{78,-54},{98,-74}},
              lineColor={95,95,95},
              textString="u"),Line(
              points={{0,80},{88,80}},
              color={175,175,175}),Line(
              points={{80,84},{80,-84}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = exp(u), with -&infin; &lt; u &lt; &infin;:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/exp.png\">
</p>
</html>"));
  end exp;

  function log "Natural (base e) logarithm (u shall be > 0)"
    extends Modelica.Math.Icons.AxisLeft;
    input Real u;
    output Real y;

  external "builtin" y = log(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-80,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}}),
          Text(
            extent={{-6,-24},{66,-72}},
            lineColor={192,192,192},
            textString="log")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{100,0},{84,6},{84,-6},{100,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-78,-80},{-77.2,-50.6},{-76.4,-37},{-75.6,-28},{-74.8,-21.3},
              {-73.2,-11.4},{-70.8,-1.31},{-67.5,8.08},{-62.7,17.9},{-55.5,28},{-45,
              38.1},{-29.8,48.1},{-8.1,58},{24.1,68},{70.7,78.1},{82,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{-105,72},{-85,88}},
              textString="3",
              lineColor={0,0,255}),Text(
              extent={{60,-3},{80,-23}},
              textString="20",
              lineColor={0,0,255}),Text(
              extent={{-78,-7},{-58,-27}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{84,26},{104,6}},
              lineColor={95,95,95},
              textString="u"),Text(
              extent={{-100,9},{-80,-11}},
              textString="0",
              lineColor={0,0,255}),Line(
              points={{-80,80},{84,80}},
              color={175,175,175}),Line(
              points={{82,82},{82,-6}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = log(10) (the natural logarithm of u),
with u &gt; 0:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/log.png\">
</p>
</html>"));
  end log;

  function log10 "Base 10 logarithm (u shall be > 0)"
    extends Modelica.Math.Icons.AxisLeft;
    input Real u;
    output Real y;

  external "builtin" y = log10(u);
    annotation (
      Icon(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={
          Line(points={{-90,0},{68,0}}, color={192,192,192}),
          Polygon(
            points={{90,0},{68,8},{68,-8},{90,0}},
            lineColor={192,192,192},
            fillColor={192,192,192},
            fillPattern=FillPattern.Solid),
          Line(points={{-79.8,-80},{-79.2,-50.6},{-78.4,-37},{-77.6,-28},{-76.8,-21.3},
                {-75.2,-11.4},{-72.8,-1.31},{-69.5,8.08},{-64.7,17.9},{-57.5,28},
                {-47,38.1},{-31.8,48.1},{-10.1,58},{22.1,68},{68.7,78.1},{80,80}}),
          Text(
            extent={{-30,-22},{60,-70}},
            lineColor={192,192,192},
            textString="log10")}),
      Diagram(coordinateSystem(
          preserveAspectRatio=true,
          extent={{-100,-100},{100,100}}), graphics={Line(points={{-100,0},{84,0}}, color={95,95,95}),
            Polygon(
              points={{98,0},{82,6},{82,-6},{98,0}},
              lineColor={95,95,95},
              fillColor={95,95,95},
              fillPattern=FillPattern.Solid),Line(
              points={{-77.8,-80},{-77.2,-50.6},{-76.4,-37},{-75.6,-28},{-74.8,-21.3},
              {-73.2,-11.4},{-70.8,-1.31},{-67.5,8.08},{-62.7,17.9},{-55.5,28},{-45,
              38.1},{-29.8,48.1},{-8.1,58},{24.1,68},{70.7,78.1},{82,80}},
              color={0,0,255},
              thickness=0.5),Text(
              extent={{66,-13},{86,-33}},
              textString="20",
              lineColor={0,0,255}),Text(
              extent={{-78,-1},{-58,-21}},
              textString="1",
              lineColor={0,0,255}),Text(
              extent={{-83,62},{-63,78}},
              textString=" 1.3",
              lineColor={0,0,255}),Text(
              extent={{80,24},{100,4}},
              lineColor={95,95,95},
              textString="u"),Text(
              extent={{-100,9},{-80,-11}},
              textString="0",
              lineColor={0,0,255}),Line(
              points={{-80,80},{86,80}},
              color={175,175,175}),Line(
              points={{80,92},{80,-12}},
              color={175,175,175})}),
      Documentation(info="<html>
<p>
This function returns y = log10(u),
with u &gt; 0:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/Math/log10.png\">
</p>
</html>"));
  end log10;
  annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
            {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
              {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
              -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
              -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
              {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
              0,0,0}, smooth=Smooth.Bezier)}), Documentation(info="<html>
<p>
This package contains <strong>basic mathematical functions</strong> (such as sin(..)),
as well as functions operating on
<a href=\"modelica://Modelica.Math.Vectors\">vectors</a>,
<a href=\"modelica://Modelica.Math.Matrices\">matrices</a>,
<a href=\"modelica://Modelica.Math.Nonlinear\">nonlinear functions</a>, and
<a href=\"modelica://Modelica.Math.BooleanVectors\">Boolean vectors</a>.
</p>

<h4>Main Authors</h4>
<p><a href=\"http://www.robotic.dlr.de/Martin.Otter/\"><strong>Martin Otter</strong></a>
and <strong>Marcus Baur</strong><br>
Deutsches Zentrum f&uuml;r Luft- und Raumfahrt e.V. (DLR)<br>
Institut f&uuml;r Systemdynamik und Regelungstechnik (DLR-SR)<br>
Forschungszentrum Oberpfaffenhofen<br>
D-82234 Wessling<br>
Germany<br>
email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a>
</p>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>August 24, 2016</em>
       by Christian Kral: added wrapAngle</li>
<li><em>October 21, 2002</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>
       and Christian Schweiger:<br>
       Function tempInterpol2 added.</li>
<li><em>Oct. 24, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Icons for icon and diagram level introduced.</li>
<li><em>June 30, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>

</html>"));
  end Math;

  package ComplexMath
  "Library of complex mathematical functions (e.g., sin, cos) and of functions operating on complex vectors and matrices"
    extends Modelica.Icons.Package;

    function 'abs' "Absolute value of complex number"
      extends Modelica.Icons.Function;
      input Complex c "Complex number";
      output Real result "= abs(c)";
    algorithm
      result := (c.re^2 + c.im^2)^0.5; //changed from sqrt
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the Real absolute of the Complex input, i.e., its length.</p>
</html>"));
    end 'abs';

    function conj "Conjugate of complex number"
      extends Modelica.Icons.Function;
      input Complex c1 "Complex number";
      output Complex c2 "= c1.re - j*c1.im";
    algorithm
      c2 := Complex(c1.re, -c1.im);
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the Complex conjugate of the Complex input.</p>
</html>"));
    end conj;

    function real "Real part of complex number"
      extends Modelica.Icons.Function;
      input Complex c "Complex number";
      output Real r "= c.re";
    algorithm
      r := c.re;
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the real part of the Complex input.</p>
</html>"));
    end real;

    function imag "Imaginary part of complex number"
      extends Modelica.Icons.Function;
      input Complex c "Complex number";
      output Real r "= c.im";
    algorithm
      r := c.im;
      annotation(Inline=true, Documentation(info="<html>
<p>This function returns the imaginary part of the Complex input.</p>
</html>"));
    end imag;
    annotation (Documentation(info="<html>
<p>
This package contains <strong>basic mathematical functions</strong>
operating on complex numbers (such as sin(..)),
as well as functions operating on vectors of complex numbers.
</p>

</html>"),   Icon(coordinateSystem(extent={{-100,-100},{100,100}},
            preserveAspectRatio=false), graphics={
          Line(points={{32,-86},{32,88}}, color={175,175,175}),
          Line(points={{-84,2},{88,2}}, color={175,175,175}),
          Line(
            points={{-50,75},{-5,30}}),
          Line(
            points={{-50,30},{-5,75}}),
          Line(
            points={{-50,-30},{-5,-75}}),
          Line(
            points={{-50,-75},{-5,-30}})}));
  end ComplexMath;

  package Utilities
  "Library of utility functions dedicated to scripting (operating on files, streams, strings, system)"
    extends Modelica.Icons.UtilitiesPackage;

    package Files "Functions to work with files and directories"
      extends Modelica.Icons.FunctionsPackage;

    function createDirectory
        "Create directory (if directory already exists, ignore call)"
      extends Modelica.Icons.Function;
      input String directoryName
          "Name of directory to be created (if present, ignore call)";
    //..............................................................
    protected
      function existDirectory
          "Inquire whether directory exists; if present and not a directory, trigger an error"
         extends Modelica.Icons.Function;
         input String directoryName;
         output Boolean exists "true if directory exists";
      protected
         Types.FileType fileType = Modelica.Utilities.Internal.FileSystem.stat(
                                                 directoryName);
      algorithm
         if fileType == Types.FileType.RegularFile or
            fileType == Types.FileType.SpecialFile then
            Streams.error("Directory \"" + directoryName + "\" cannot be created\n" +
                          "because this is an existing file.");
         elseif fileType == Types.FileType.Directory then
            exists :=true;
         else
            exists :=false;
         end if;
         annotation(__ModelicaAssociation_Impure=true);
      end existDirectory;

      function assertCorrectIndex
          "Print error, if index to last essential character in directory is wrong"
         extends Modelica.Icons.Function;
         input Integer index "Index must be > 0";
         input String directoryName "Directory name for error message";
      algorithm
         if index < 1 then
            Streams.error("It is not possible to create the directory\n" +
                          "\"" + directoryName + "\"\n" +
                          "because this directory name is not valid");
         end if;
      end assertCorrectIndex;

    //..............................................................
      String fullName;
      Integer index;
      Integer oldIndex;
      Integer lastIndex;
      Boolean found;
      Boolean finished;
      Integer nDirectories = 0 "Number of directories that need to be generated";
    algorithm
      // Ignore call, if directory exists
      if not existDirectory(directoryName) then
         fullName := Files.fullPathName(directoryName);

         // Remove a trailing "/"
            index :=Strings.length(fullName);
            if Strings.substring(fullName,index,index) == "/" then
               index :=index - 1;
               assertCorrectIndex(index,fullName);
            end if;
            lastIndex := index;
            fullName := Strings.substring(fullName,1,index);

         // Search upper directories until a directory is found that exists
         // ??? check the following while loop later, if also cases such as
         //  "c:/", "c:", "//name" are handled correctly ???
            found := false;
            while not found loop
               oldIndex := index;
               index := Strings.findLast(fullName,"/",startIndex=index);
               if index == 0 then
                  index := oldIndex;
                  found := true;
               else
                  index := index - 1;
                  assertCorrectIndex(index, fullName);
                  found := existDirectory(Strings.substring(fullName,1,index));
               end if;
            end while;
            index := oldIndex;

         // Create directories
            finished := false;
            while not finished loop
               Modelica.Utilities.Internal.FileSystem.mkdir(
                              Strings.substring(fullName,1,index));
               if index >= lastIndex then
                  finished := true;
               elseif index < lastIndex then
                  index := Strings.find(fullName, "/", startIndex=index+2);
                  if index == 0 then
                     index :=lastIndex;
                  end if;
               end if;
            end while;
      end if;

      annotation (__ModelicaAssociation_Impure=true,
    Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Files.<strong>createDirectory</strong>(directoryName);
</pre></blockquote>
<h4>Description</h4>
<p>
Creates directory \"directoryName\". If this directory already exists,
the function call is ignored. If several directories in \"directoryName\"
do not exist, all of them are created. For example, assume
that directory \"E:/test1\" exists and that directory
\"E:/test1/test2/test3\" shall be created. In this case
the directories \"test2\" in \"test1\" and \"test3\" in \"test2\"
are created.
</p>
<p>
This function is silent, i.e., it does not print a message.
In case of error (e.g., \"directoryName\" is an existing regular
file), an assert is triggered.
</p>
</html>"));
    end createDirectory;

    function exist "Inquire whether file or directory exists"
      extends Modelica.Icons.Function;
      input String name "Name of file or directory";
      output Boolean result "= true, if file or directory exists";
    algorithm
      result := Modelica.Utilities.Internal.FileSystem.stat(
                              name) > Types.FileType.NoFile;

      annotation (__ModelicaAssociation_Impure=true,
    Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = Files.<strong>exist</strong>(name);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns true, if \"name\" is an existing file or directory.
If this is not the case, the function returns false.
</p>
</html>"));
    end exist;

    function fullPathName "Get full path name of file or directory name"
      extends Modelica.Icons.Function;
      input String name "Absolute or relative file or directory name";
      output String fullName "Full path of 'name'";
    external "C" fullName = ModelicaInternal_fullPathName(name) annotation(Library="ModelicaExternalC");

      annotation (__ModelicaAssociation_Impure=true,
    Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
fullName = Files.<strong>fullPathName</strong>(name);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the full path name of a file or directory \"name\".
</p>
</html>"));
    end fullPathName;

      function loadResource
        "Return the absolute path name of a URI or local file name"
         extends
        Modelica.Utilities.Internal.PartialModelicaServices.ExternalReferences.PartialLoadResource;
         extends ModelicaServices.ExternalReferences.loadResource;
        annotation (
          Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
fileReference = Files.<strong>loadResource</strong>(uri);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call \"<code>Files.<strong>loadResource</strong>(uri)</code>\" returns the
<strong>absolute path name</strong> of the file that is either defined by an URI or by a local
path name. With the returned file name it is possible to
access the file with function calls of the C standard library.
If the data or file is stored in a data-base,
this might require copying the resource to a temporary folder and referencing that.
</p>

<p>
The implementation of this function is tool specific. However, at least Modelica URIs
(see \"chapter 13.2.3 External Resources\" of the Modelica Specification),
as well as absolute local file path names are supported.
</p>

<h4>Example</h4>
<blockquote><pre>
  file1 = loadResource(\"modelica://Modelica/Resources/Data/Utilities/Examples_readRealParameters.txt\")
          // file1 is the absolute path name of the file
  file2 = loadResource(\"C:\\\\data\\\\readParameters.txt\")
          file2 = \"C:/data/readParameters.txt\"
</pre></blockquote>
</html>"));
      end loadResource;
        annotation (
    Documentation(info="<html>
<p>
This package contains functions to work with files and directories.
As a general convention of this package, '/' is used as directory
separator both for input and output arguments of all functions.
For example:
</p>
<pre>
   exist(\"Modelica/Mechanics/Rotational.mo\");
</pre>
<p>
The functions provide the mapping to the directory separator of the
underlying operating system. Note, that on Windows system the usage
of '\\' as directory separator would be inconvenient, because this
character is also the escape character in Modelica and C Strings.
</p>
<p>
In the table below an example call to every function is given:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.list\">list</a>(name)</td>
      <td> List content of file or of directory.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.copy\">copy</a>(oldName, newName)<br>
          <a href=\"modelica://Modelica.Utilities.Files.copy\">copy</a>(oldName, newName, replace=false)</td>
      <td> Generate a copy of a file or of a directory.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.move\">move</a>(oldName, newName)<br>
          <a href=\"modelica://Modelica.Utilities.Files.move\">move</a>(oldName, newName, replace=false)</td>
      <td> Move a file or a directory to another place.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.remove\">remove</a>(name)</td>
      <td> Remove file or directory (ignore call, if it does not exist).</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.removeFile\">removeFile</a>(name)</td>
      <td> Remove file (ignore call, if it does not exist)</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.createDirectory\">createDirectory</a>(name)</td>
      <td> Create directory (if directory already exists, ignore call).</td>
  </tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Files.exist\">exist</a>(name)</td>
      <td> Inquire whether file or directory exists.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Files.assertNew\">assertNew</a>(name,message)</td>
      <td> Trigger an assert, if a file or directory exists.</td>
  </tr>
  <tr><td>fullName = <a href=\"modelica://Modelica.Utilities.Files.fullPathName\">fullPathName</a>(name)</td>
      <td> Get full path name of file or directory name.</td>
  </tr>
  <tr><td>(directory, name, extension) = <a href=\"modelica://Modelica.Utilities.Files.splitPathName\">splitPathName</a>(name)</td>
      <td> Split path name in directory, file name kernel, file name extension.</td>
  </tr>
  <tr><td>fileName = <a href=\"modelica://Modelica.Utilities.Files.temporaryFileName\">temporaryFileName</a>()</td>
      <td> Return arbitrary name of a file that does not exist<br>
           and is in a directory where access rights allow to<br>
           write to this file (useful for temporary output of files).</td>
  </tr>
  <tr><td>fileReference = <a href=\"modelica://Modelica.Utilities.Files.loadResource\">loadResource</a>(uri)</td>
      <td>Return the absolute path name of a URI or local file name.</td>
  </tr>
</table>
</html>"));
    end Files;

    package Streams "Read from files and write to files"
      extends Modelica.Icons.FunctionsPackage;

      function print "Print string to terminal or file"
        extends Modelica.Icons.Function;
        input String string="" "String to be printed";
        input String fileName=""
          "File where to print (empty string is the terminal)"
                     annotation(Dialog(saveSelector(filter="Text files (*.txt)",
                            caption="Text file to store the output of print(..)")));
      external "C" ModelicaInternal_print(string, fileName) annotation(Library="ModelicaExternalC");

        annotation (__ModelicaAssociation_Impure=true, Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>print</strong>(string);
Streams.<strong>print</strong>(string,fileName);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>print</strong>(..) opens automatically the given file, if
it is not yet open. If the file does not exist, it is created.
If the file does exist, the given string is appended to the file.
If this is not desired, call \"Files.remove(fileName)\" before calling print
(\"remove(..)\" is silent, if the file does not exist).
The Modelica environment may close the file whenever appropriate.
This can be enforced by calling <strong>Streams.close</strong>(fileName).
After every call of \"print(..)\" a \"new line\" is printed automatically.
</p>
<h4>Example</h4>
<blockquote><pre>
  Streams.print(\"x = \" + String(x));
  Streams.print(\"y = \" + String(y));
  Streams.print(\"x = \" + String(y), \"mytestfile.txt\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.error\">Streams.error</a>,
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>
</p>
</html>"));
      end print;

      function readLine "Read a line of text from a file and return it in a string"
        extends Modelica.Icons.Function;
        input String fileName "Name of the file that shall be read"
                            annotation(Dialog(loadSelector(filter="Text files (*.txt)",
                            caption="Open text file for reading")));
        input Integer lineNumber(min=1) "Number of line to read";
        output String string "Line of text";
        output Boolean endOfFile
          "If true, end-of-file was reached when trying to read line";
       external "C" string = ModelicaInternal_readLine(fileName,lineNumber,endOfFile) annotation(Library="ModelicaExternalC");
        annotation (__ModelicaAssociation_Impure=true, Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
(string, endOfFile) = Streams.<strong>readLine</strong>(fileName, lineNumber)
</pre></blockquote>
<h4>Description</h4>
<p>
Function <strong>readLine</strong>(..) opens the given file, reads enough of the
content to get the requested line, and returns the line as a string.
Lines are separated by LF or CR-LF; the returned string does not
contain the line separator. The file might remain open after
the call.
</p>
<p>
If lineNumber > countLines(fileName), an empty string is returned
and endOfFile=true. Otherwise endOfFile=false.
</p>
</html>"));
      end readLine;

      function error "Print error message and cancel all actions - in case of an unrecoverable error"
        extends Modelica.Icons.Function;
        input String string "String to be printed to error message window";
        external "C" ModelicaError(string) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Streams.<strong>error</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
In case of an unrecoverable error (i.e., if the solver is unable to recover from the error),
print the string \"string\" as error message and cancel all actions.
This function is semantically equivalent with the built-in function <strong>assert</strong> if called with the (default) <strong>AssertionLevel.error</strong>.
Line breaks are characterized by \"\\n\" in the string.
</p>
<h4>Example</h4>
<blockquote><pre>
  Streams.error(\"x (= \" + String(x) + \")\\nhas to be in the range 0 .. 1\");
</pre></blockquote>
<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>,
<a href=\"modelica://Modelica.Utilities.Streams.print\">Streams.print</a>,
<a href=\"modelica://ModelicaReference.Operators.'assert()'\">ModelicaReference.Operators.'assert()'</a>
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>
</p>
</html>"));
      end error;

      function readRealMatrix "Read Real matrix from MATLAB MAT file"
        extends Modelica.Icons.Function;
        input String fileName "File where external data is stored" annotation(Dialog(loadSelector(filter="MATLAB MAT files (*.mat)", caption="Open MATLAB MAT file")));
        input String matrixName "Name / identifier of the 2D Real array on the file";
        input Integer nrow "Number of rows of the 2D Real array";
        input Integer ncol "Number of columns of the 2D Real array";
        input Boolean verboseRead = true
          "= true: Print info message; = false: No info message";
        output Real matrix[nrow, ncol] "2D Real array";
        external "C" ModelicaIO_readRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), verboseRead)
        annotation(Library={"ModelicaIO", "ModelicaMatIO", "zlib"});
        annotation (Documentation(info=
                       "<html>
<h4>Syntax</h4>
<blockquote><pre>
matrix = Streams.<strong>readRealMatrix</strong>(fileName, matrixName, nrow, ncol, verboseRead)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <strong>readRealMatrix</strong>(..) opens the given MATLAB MAT file
(in format v4, v6, v7, and if HDF is supported in the Modelica tool, also v7.3),
and reads the given matrix from this file. The dimensions of this matrix must first
be inquired with function
<a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>
and passed via arguments nrow and ncol to this function.
</p>

<h4>Example</h4>
<p>
See <a href=\"modelica://Modelica.Utilities.Examples.ReadRealMatrixFromFile\">Examples.ReadRealMatrixFromFile</a>.
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>,
<a href=\"modelica://Modelica.Utilities.Streams.writeRealMatrix\">writeRealMatrix</a>
</p>
</html>"));
      end readRealMatrix;

      function writeRealMatrix "Write Real matrix to a MATLAB MAT file"
        extends Modelica.Icons.Function;
        input String fileName "File where external data is to be stored" annotation(Dialog(saveSelector(filter="MATLAB MAT files (*.mat)", caption="Save MATLAB MAT file")));
        input String matrixName "Name / identifier of the 2D Real array on the file";
        input Real matrix[:,:] "2D Real array";
        input Boolean append = false "Append values to file";
        input String format = "4" "MATLAB MAT file version: \"4\" -> v4, \"6\" -> v6, \"7\" -> v7"
          annotation(choices(choice="4" "MATLAB v4 MAT file",
                             choice="6" "MATLAB v6 MAT file",
                             choice="7" "MATLAB v7 MAT file"));
        output Boolean success "true if successful";
        external "C" success = ModelicaIO_writeRealMatrix(fileName, matrixName, matrix, size(matrix, 1), size(matrix, 2), append, format)
        annotation(Library={"ModelicaIO", "ModelicaMatIO", "zlib"});

        annotation(__ModelicaAssociation_Impure=true, Documentation(info=
                       "<html>

<h4>Syntax</h4>
<blockquote><pre>
success = Streams.<strong>writeRealMatrix</strong>(fileName, matrixName, matrix, append, format)
</pre></blockquote>

<h4>Description</h4>
<p>
Function <strong>writeRealMatrix</strong>(..) writes the given matrix to a new or an existing MATLAB MAT file
(in format v4, v6, v7, and if HDF is supported in the Modelica tool, also v7.3).
If <code>append = false</code> (= default), the file is newly created
(or an existing file is deleted and re-created).
If <code>append = true</code>, the matrix is included in an existing file or if the
file does not yet exists this flag is ignored. If the file exists and
<code>append = true</code>, argument format is ignored.
</p>

<p>
Parameter <strong>format</strong> defines the format in which the values are stored on file.
The following formats are supported:<br>&nbsp;
</p>

<table border=1 cellspacing=0 cellpadding=2>
<tr><td>format = </td><td>Type of format</td></tr>
<tr><td>\"4\"  </td><td>MATLAB MAT version v4</td></tr>
<tr><td>\"6\"  </td><td>MATLAB MAT version v6</td></tr>
<tr><td>\"7\"  </td><td>MATLAB MAT version v7</td></tr>
<tr><td>\"7.3\"</td><td>MATLAB MAT version v7.3<br>
                      (requires HDF support in the Modelica tool)</td></tr>
</table>

<p>
The function returns <code>success = true</code> if the matrix was successfully written
to file. Otherwise, an error message is printed and the function returns with
<code>success = false</code>.
</p>

<h4>Example</h4>
<p>
See <a href=\"modelica://Modelica.Utilities.Examples.WriteRealMatrixToFile\">Examples.WriteRealMatrixToFile</a>.
</p>

<h4>See also</h4>
<p>
<a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>,
<a href=\"modelica://Modelica.Utilities.Streams.readRealMatrix\">readRealMatrix</a>
</p>
</html>"));
      end writeRealMatrix;
      annotation (
        Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Streams</strong> contains functions to input and output strings
to a message window or on files, as well as reading matrices from file
and writing matrices to file. Note that a string is interpreted
and displayed as html text (e.g., with print(..) or error(..))
if it is enclosed with the Modelica html quotation, e.g.,
</p>
<blockquote><p>
string = \"&lt;html&gt; first line &lt;br&gt; second line &lt;/html&gt;\".
</p></blockquote>
<p>
It is a quality of implementation, whether (a) all tags of html are supported
or only a subset, (b) how html tags are interpreted if the output device
does not allow to display formatted text.
</p>
<p>
In the table below an example call to every function is given:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function/type</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string)<br>
          <a href=\"modelica://Modelica.Utilities.Streams.print\">print</a>(string,fileName)</td>
      <td> Print string \"string\" or vector of strings to message window or on
           file \"fileName\".</td>
  </tr>
  <tr><td>stringVector =
         <a href=\"modelica://Modelica.Utilities.Streams.readFile\">readFile</a>(fileName)</td>
      <td> Read complete text file and return it as a vector of strings.</td>
  </tr>
  <tr><td>(string, endOfFile) =
         <a href=\"modelica://Modelica.Utilities.Streams.readLine\">readLine</a>(fileName, lineNumber)</td>
      <td>Returns from the file the content of line lineNumber.</td>
  </tr>
  <tr><td>lines =
         <a href=\"modelica://Modelica.Utilities.Streams.countLines\">countLines</a>(fileName)</td>
      <td>Returns the number of lines in a file.</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.error\">error</a>(string)</td>
      <td> Print error message \"string\" to message window
           and cancel all actions</td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.close\">close</a>(fileName)</td>
      <td> Close file if it is still open. Ignore call if
           file is already closed or does not exist. </td>
  </tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.readMatrixSize\">readMatrixSize</a>(fileName, matrixName)</td>
      <td> Read dimensions of a Real matrix from a MATLAB MAT file. </td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.readRealMatrix\">readRealMatrix</a>(fileName, matrixName, nrow, ncol)</td>
      <td> Read a Real matrix from a MATLAB MAT file. </td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Streams.writeRealMatrix\">writeRealMatrix</a>(fileName, matrixName, matrix, append, format)</td>
      <td> Write Real matrix to a MATLAB MAT file. </td></tr>
</table>
<p>
Use functions <strong>scanXXX</strong> from package
<a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
to parse a string.
</p>
<p>
If Real, Integer or Boolean values shall be printed
or used in an error message, they have to be first converted
to strings with the builtin operator
<a href=\"modelica://ModelicaReference.Operators.'String()'\">ModelicaReference.Operators.'String()'</a>(...).
Example:
</p>
<pre>
  <strong>if</strong> x &lt; 0 <strong>or</strong> x &gt; 1 <strong>then</strong>
     Streams.error(\"x (= \" + String(x) + \") has to be in the range 0 .. 1\");
  <strong>end if</strong>;
</pre>
</html>"));
    end Streams;

    package Strings "Operations on strings"
      extends Modelica.Icons.FunctionsPackage;

      function length "Return length of string"
        extends Modelica.Icons.Function;
        input String string;
        output Integer result "Number of characters of string";
      external "C" result = ModelicaStrings_length(string) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>length</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the number of characters of \"string\".
</p>
</html>"));
      end length;

      function substring "Return a substring defined by start and end index"

        extends Modelica.Icons.Function;
        input String string "String from which a substring is inquired";
        input Integer startIndex(min=1)
          "Character position of substring begin (index=1 is first character in string)";
        input Integer endIndex(min=1) "Character position of substring end";
        output String result
          "String containing substring string[startIndex:endIndex]";
      external "C" result=ModelicaStrings_substring(string,startIndex,endIndex) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
string2 = Strings.<strong>substring</strong>(string, startIndex, endIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns
the substring from position startIndex
up to and including position endIndex of \"string\" .
</p>
<p>
If index, startIndex, or endIndex are not correct, e.g.,
if endIndex &gt; length(string), an assert is triggered.
</p>
<h4>Example</h4>
<blockquote><pre>
  string1 := \"This is line 111\";
  string2 := Strings.substring(string1,9,12); // string2 = \"line\"
</pre></blockquote>
</html>"));
      end substring;

      function compare "Compare two strings lexicographically"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true "= false, if case of letters is ignored";
        output Modelica.Utilities.Types.Compare result "Result of comparison";
      external "C" result = ModelicaStrings_compare(string1, string2, caseSensitive) annotation(Library="ModelicaExternalC");
        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
result = Strings.<strong>compare</strong>(string1, string2);
result = Strings.<strong>compare</strong>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compares two strings. If the optional argument caseSensitive=false,
upper case letters are treated as if they would be lower case letters.
The result of the comparison is returned as:
</p>
<pre>
  result = Modelica.Utilities.Types.Compare.Less     // string1 &lt; string2
         = Modelica.Utilities.Types.Compare.Equal    // string1 = string2
         = Modelica.Utilities.Types.Compare.Greater  // string1 &gt; string2
</pre>
<p>
Comparison is with regards to lexicographical order,
e.g., \"a\" &lt; \"b\";
</p>
</html>"));
      end compare;

      function isEqual "Determine whether two strings are identical"
        extends Modelica.Icons.Function;
        input String string1;
        input String string2;
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the comparison";
        output Boolean identical "True, if string1 is identical to string2";
      algorithm
        identical :=compare(string1, string2, caseSensitive) == Types.Compare.Equal;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>isEqual</strong>(string1, string2);
Strings.<strong>isEqual</strong>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compare whether two strings are identical,
optionally ignoring case.
</p>
</html>"));
      end isEqual;

      function isEmpty
        "Return true if a string is empty (has only white space characters)"
        extends Modelica.Icons.Function;
        input String string;
        output Boolean result "True, if string is empty";
    protected
        Integer nextIndex;
        Integer len;
      algorithm
        nextIndex := Strings.Advanced.skipWhiteSpace(string);
        len := Strings.length(string);
        if len < 1 or nextIndex > len then
          result := true;
        else
          result := false;
        end if;

        annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<strong>isEmpty</strong>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns true if the string has no characters or if the string consists
only of white space characters. Otherwise, false is returned.
</p>

<h4>Example</h4>
<blockquote><pre>
  isEmpty(\"\");       // returns true
  isEmpty(\"   \");    // returns true
  isEmpty(\"  abc\");  // returns false
  isEmpty(\"a\");      // returns false
</pre></blockquote>
</html>"));
      end isEmpty;

      function find "Find first occurrence of a string within another string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=1)=1 "Start search at index startIndex";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the search";
         output Integer index
          "Index of the beginning of the first occurrence of 'searchString' within 'string', or zero if not present";
    protected
        Integer lengthSearchString = length(searchString);
        Integer len = lengthSearchString-1;
        Integer i = startIndex;
        Integer i_max = length(string) - lengthSearchString + 1;
      algorithm
        index := 0;
        while i <= i_max loop
           if isEqual(substring(string,i,i+len),
                      searchString, caseSensitive) then
              index := i;
              i := i_max + 1;
           else
              i := i+1;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<strong>find</strong>(string, searchString);
index = Strings.<strong>find</strong>(string, searchString, startIndex=1,
                     caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurrence of \"searchString\" within \"string\"
and return the corresponding index.
Start search at index \"startIndex\" (default = 1).
If the optional argument \"caseSensitive\" is false, lower
and upper case are ignored for the search.
If \"searchString\" is not found, a value of \"0\" is returned.
</p>
</html>"));
      end find;

      function findLast "Find last occurrence of a string within another string"
        extends Modelica.Icons.Function;
        input String string "String that is analyzed";
        input String searchString "String that is searched for in string";
        input Integer startIndex(min=0)=0
          "Start search at index startIndex. If startIndex = 0, start at length(string)";
        input Boolean caseSensitive=true
          "= false, if lower and upper case are ignored for the search";
        output Integer index
          "Index of the beginning of the last occurrence of 'searchString' within 'string', or zero if not present";
    protected
        Integer lenString = length(string);
        Integer lenSearchString = length(searchString);
        Integer iMax=lenString - lenSearchString + 1;
        Integer i;
      algorithm
        i := if startIndex == 0 or startIndex > iMax then iMax else startIndex;
        index := 0;
        while i >= 1 loop
           if isEqual(substring(string,i,i+lenSearchString-1),
                      searchString, caseSensitive) then
              index := i;
              i := 0;
           else
              i := i-1;
           end if;
        end while;
        annotation (
      Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<strong>findLast</strong>(string, searchString);
index = Strings.<strong>findLast</strong>(string, searchString,
                         startIndex=length(string), caseSensitive=true,
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurrence of \"searchString\" within \"string\"
when searching from the last character of \"string\"
backwards, and return the corresponding index.
Start search at index \"startIndex\" (default = 0;
if startIndex = 0, search starts at length(string)).
If the optional argument \"caseSensitive\" is false, lower
and upper case are ignored for the search.
If \"searchString\" is not found, a value of \"0\" is returned.
</p>
</html>"));
      end findLast;

      package Advanced "Advanced scanning functions"
        extends Modelica.Icons.FunctionsPackage;

        function scanReal "Scan a signed real number"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1 "Index where scanning starts";
          input Boolean unsigned=false
            "= true, if number shall not start with '+' or '-'";
          output Integer nextIndex
            "Index after the found token (success=true) or index at which scanning failed (success=false)";
          output Real number "Value of Real number";
          external "C" ModelicaStrings_scanReal(string, startIndex, unsigned, nextIndex, number) annotation(Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
(nextIndex, realNumber) = <strong>scanReal</strong>(string, startIndex=1, unsigned=false);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\".
First skips white space and scans afterwards a number
of type Real with an optional sign according to the Modelica grammar:
</p>
<pre>
    real     ::= [sign] unsigned [fraction] [exponent]
    sign     ::= '+' | '-'
    unsigned ::= digit [unsigned]
    fraction ::= '.' [unsigned]
    exponent ::= ('e' | 'E') [sign] unsigned
    digit    ::= '0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9'
</pre>
<p>
If successful, the function returns nextIndex = index of character
directly after the found real number, as well as the value
in the second output argument.
</p>
<p>
If not successful, on return nextIndex = startIndex and
the second output argument is zero.
</p>
<p>
If the optional argument \"unsigned\" is <strong>true</strong>, the number
shall not start with '+' or '-'. The default of \"unsigned\" is <strong>false</strong>.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end scanReal;

        function skipWhiteSpace "Scan white space"
          extends Modelica.Icons.Function;
          input String string;
          input Integer startIndex(min=1)=1;
          output Integer nextIndex;
          external "C" nextIndex = ModelicaStrings_skipWhiteSpace(string, startIndex) annotation(Library="ModelicaExternalC");
          annotation (Documentation(info="<html>
<h4>Syntax</h4>
<blockquote><pre>
nextIndex = <strong>skipWhiteSpace</strong>(string, startIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
Starts scanning of \"string\" at position \"startIndex\" and
skips white space. The function returns nextIndex = index of character
of the first non white space character.
</p>
<h4>See also</h4>
<a href=\"modelica://Modelica.Utilities.Strings.Advanced\">Strings.Advanced</a>.
</html>"));
        end skipWhiteSpace;
        annotation (Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Strings.Advanced</strong> contains basic scanning
functions. These functions should be <strong>not called</strong> directly, because
it is much simpler to utilize the higher level functions \"Strings.scanXXX\".
The functions of the \"Strings.Advanced\" library provide
the basic interface in order to implement the higher level
functions in package \"Strings\".
</p>
<p>
Library \"Advanced\" provides the following functions:
</p>
<pre>
  (nextIndex, realNumber)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>        (string, startIndex, unsigned=false);
  (nextIndex, integerNumber) = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>     (string, startIndex, unsigned=false);
  (nextIndex, string2)       = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>      (string, startIndex);
  (nextIndex, identifier)    = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>  (string, startIndex);
   nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipWhiteSpace\">skipWhiteSpace</a>  (string, startIndex);
   nextIndex                 = <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a>(string, startIndex);
</pre>
<p>
All functions perform the following actions:
</p>
<ol>
<li> Scanning starts at character position \"startIndex\" of
     \"string\" (startIndex has a default of 1).</li>
<li> First, white space is skipped, such as blanks (\" \"), tabs (\"\\t\"), or newline (\"\\n\")</li>
<li> Afterwards, the required token is scanned.</li>
<li> If successful, on return nextIndex = index of character
     directly after the found token and the token value is returned
     as second output argument.<br>
     If not successful, on return nextIndex = startIndex.
     </li>
</ol>
<p>
The following additional rules apply for the scanning:
</p>
<ul>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanReal\">scanReal</a>:<br>
     Scans a full number including one optional leading \"+\" or \"-\" (if unsigned=false)
     according to the Modelica grammar. For example, \"+1.23e-5\", \"0.123\" are
     Real numbers, but \".1\" is not.
     Note, an Integer number, such as \"123\" is also treated as a Real number.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanInteger\">scanInteger</a>:<br>
     Scans an Integer number including one optional leading \"+\"
     or \"-\" (if unsigned=false) according to the Modelica (and C/C++) grammar.
     For example, \"+123\", \"20\" are Integer numbers.
     Note, a Real number, such as \"123.4\" is not an Integer and
     scanInteger returns nextIndex = startIndex.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanString\">scanString</a>:<br>
     Scans a String according to the Modelica (and C/C++) grammar, e.g.,
     \"This is a \"string\"\" is a valid string token.<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.scanIdentifier\">scanIdentifier</a>:<br>
     Scans a Modelica identifier, i.e., the identifier starts either
     with a letter, followed by letters, digits or \"_\".
     For example, \"w_rel\", \"T12\".<br>&nbsp;</li>
<li> Function <a href=\"modelica://Modelica.Utilities.Strings.Advanced.skipLineComments\">skipLineComments</a><br>
     Skips white space and Modelica (C/C++) line comments iteratively.
     A line comment starts with \"//\" and ends either with an
     end-of-line (\"\\n\") or the end of the \"string\".</li>
</ul>
</html>"));
      end Advanced;
      annotation (
        Documentation(info="<html>
<h4>Library content</h4>
<p>
Package <strong>Strings</strong> contains functions to manipulate strings.
</p>
<p>
In the table below an example
call to every function is given using the <strong>default</strong> options.
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><strong><em>Function</em></strong></th><th><strong><em>Description</em></strong></th></tr>
  <tr><td>len = <a href=\"modelica://Modelica.Utilities.Strings.length\">length</a>(string)</td>
      <td>Returns length of string</td></tr>
  <tr><td>string2 = <a href=\"modelica://Modelica.Utilities.Strings.substring\">substring</a>(string1,startIndex,endIndex)
       </td>
      <td>Returns a substring defined by start and end index</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n)<br>
 result = <a href=\"modelica://Modelica.Utilities.Strings.repeat\">repeat</a>(n,string)</td>
      <td>Repeat a blank or a string n times.</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.compare\">compare</a>(string1, string2)</td>
      <td>Compares two substrings with regards to alphabetical order</td></tr>
  <tr><td>identical =
<a href=\"modelica://Modelica.Utilities.Strings.isEqual\">isEqual</a>(string1,string2)</td>
      <td>Determine whether two strings are identical</td></tr>
  <tr><td>result = <a href=\"modelica://Modelica.Utilities.Strings.count\">count</a>(string,searchString)</td>
      <td>Count the number of occurrences of a string</td></tr>
  <tr>
<td>index = <a href=\"modelica://Modelica.Utilities.Strings.find\">find</a>(string,searchString)</td>
      <td>Find first occurrence of a string in another string</td></tr>
<tr>
<td>index = <a href=\"modelica://Modelica.Utilities.Strings.findLast\">findLast</a>(string,searchString)</td>
      <td>Find last occurrence of a string in another string</td></tr>
  <tr><td>string2 = <a href=\"modelica://Modelica.Utilities.Strings.replace\">replace</a>(string,searchString,replaceString)</td>
      <td>Replace one or all occurrences of a string</td></tr>
  <tr><td>stringVector2 = <a href=\"modelica://Modelica.Utilities.Strings.sort\">sort</a>(stringVector1)</td>
      <td>Sort vector of strings in alphabetic order</td></tr>
  <tr><td>hash = <a href=\"modelica://Modelica.Utilities.Strings.hashString\">hashString</a>(string)</td>
      <td>Create a hash value of a string</td></tr>
  <tr><td>(token, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanToken\">scanToken</a>(string,startIndex)</td>
      <td>Scan for a token (Real/Integer/Boolean/String/Identifier/Delimiter/NoToken)</td></tr>
  <tr><td>(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanReal\">scanReal</a>(string,startIndex)</td>
      <td>Scan for a Real constant</td></tr>
  <tr><td>(number, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanInteger\">scanInteger</a>(string,startIndex)</td>
      <td>Scan for an Integer constant</td></tr>
  <tr><td>(boolean, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanBoolean\">scanBoolean</a>(string,startIndex)</td>
      <td>Scan for a Boolean constant</td></tr>
  <tr><td>(string2, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanString\">scanString</a>(string,startIndex)</td>
      <td>Scan for a String constant</td></tr>
  <tr><td>(identifier, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanIdentifier\">scanIdentifier</a>(string,startIndex)</td>
      <td>Scan for an identifier</td></tr>
  <tr><td>(delimiter, index) = <a href=\"modelica://Modelica.Utilities.Strings.scanDelimiter\">scanDelimiter</a>(string,startIndex)</td>
      <td>Scan for delimiters</td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Strings.scanNoToken\">scanNoToken</a>(string,startIndex)</td>
      <td>Check that remaining part of string consists solely of<br>
          white space or line comments (\"// ...\\n\").</td></tr>
  <tr><td><a href=\"modelica://Modelica.Utilities.Strings.syntaxError\">syntaxError</a>(string,index,message)</td>
      <td> Print a \"syntax error message\" as well as a string and the<br>
           index at which scanning detected an error</td></tr>
</table>
<p>
The functions \"compare\", \"isEqual\", \"count\", \"find\", \"findLast\", \"replace\", \"sort\"
have the optional
input argument <strong>caseSensitive</strong> with default <strong>true</strong>.
If <strong>false</strong>, the operation is carried out without taking
into account whether a character is upper or lower case.
</p>
</html>"));
    end Strings;

    package Types "Type definitions used in package Modelica.Utilities"
      extends Modelica.Icons.TypesPackage;

      type Compare = enumeration(
        Less   "String 1 is lexicographically less than string 2",
        Equal   "String 1 is identical to string 2",
        Greater   "String 1 is lexicographically greater than string 2")
        "Enumeration defining comparison of two strings";

      type FileType = enumeration(
        NoFile   "No file exists",
        RegularFile   "Regular file",
        Directory   "Directory",
        SpecialFile   "Special file (pipe, FIFO, device, etc.)")
        "Enumeration defining the type of a file";
      annotation (Documentation(info="<html>
<p>
This package contains type definitions used in Modelica.Utilities.
</p>

</html>"));
    end Types;

    package Internal
    "Internal components that a user should usually not directly utilize"
      extends Modelica.Icons.InternalPackage;

    partial package PartialModelicaServices
        "Interfaces of components requiring a tool specific implementation"
        extends Modelica.Icons.InternalPackage;
      package Animation "Models and functions for 3-dim. animation"
        extends Modelica.Icons.Package;
      partial model PartialShape "Interface for 3D animation of elementary shapes"

            import SI = Modelica.SIunits;
            import Modelica.Mechanics.MultiBody.Frames;
            import Modelica.Mechanics.MultiBody.Types;

        parameter Types.ShapeType shapeType="box"
              "Type of shape (box, sphere, cylinder, pipecylinder, cone, pipe, beam, gearwheel, spring, <external shape>)";
        input Frames.Orientation R=Frames.nullRotation()
              "Orientation object to rotate the world frame into the object frame"
                                                                                annotation(Dialog);
        input SI.Position r[3]={0,0,0}
              "Position vector from origin of world frame to origin of object frame, resolved in world frame"
                                                                                                          annotation(Dialog);
        input SI.Position r_shape[3]={0,0,0}
              "Position vector from origin of object frame to shape origin, resolved in object frame"
                                                                                                  annotation(Dialog);
        input Real lengthDirection[3](each final unit="1")={1,0,0}
              "Vector in length direction, resolved in object frame"
                                                                  annotation(Dialog);
        input Real widthDirection[3](each final unit="1")={0,1,0}
              "Vector in width direction, resolved in object frame"
                                                                 annotation(Dialog);
        input SI.Length length=0 "Length of visual object" annotation(Dialog);
        input SI.Length width=0 "Width of visual object" annotation(Dialog);
        input SI.Length height=0 "Height of visual object" annotation(Dialog);
        input Types.ShapeExtra extra=0.0
              "Additional size data for some of the shape types" annotation(Dialog);
        input Real color[3]={255,0,0} "Color of shape" annotation(Dialog(colorSelector=true));
        input Types.SpecularCoefficient specularCoefficient = 0.7
              "Reflection of ambient light (= 0: light is completely absorbed)"
                                                                            annotation(Dialog);
        annotation (
          Documentation(info="<html>

<p>
This model is documented at
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Shape</a>.
</p>

</html>"));

      end PartialShape;

        model PartialSurface "Interface for 3D animation of surfaces"

            import Modelica.Mechanics.MultiBody.Frames;
            import Modelica.Mechanics.MultiBody.Types;

          input Frames.Orientation R=Frames.nullRotation()
              "Orientation object to rotate the world frame into the surface frame"
            annotation(Dialog(group="Surface frame"));
          input Modelica.SIunits.Position r_0[3]={0,0,0}
              "Position vector from origin of world frame to origin of surface frame, resolved in world frame"
            annotation(Dialog(group="Surface frame"));

          parameter Integer nu=2 "Number of points in u-Dimension" annotation(Dialog(group="Surface properties"));
          parameter Integer nv=2 "Number of points in v-Dimension" annotation(Dialog(group="Surface properties"));
          replaceable function surfaceCharacteristic =
             Modelica.Mechanics.MultiBody.Interfaces.partialSurfaceCharacteristic
              "Function defining the surface characteristic"
                  annotation(choicesAllMatching=true,Dialog(group="Surface properties"));

          parameter Boolean wireframe=false
              "= true: 3D model will be displayed without faces"
            annotation (Dialog(group="Material properties"),choices(checkBox=true));
          parameter Boolean multiColoredSurface=false
              "= true: Color is defined for each surface point"
              annotation(Dialog(group="Material properties"),choices(checkBox=true));
          input Real color[3]={255,0,0} "Color of surface" annotation(Dialog(colorSelector=true,group="Material properties", enable=not multiColoredSurface));
          input Types.SpecularCoefficient specularCoefficient = 0.7
              "Reflection of ambient light (= 0: light is completely absorbed)"
                                                                              annotation(Dialog(group="Material properties"));
          input Real transparency=0
              "Transparency of shape: 0 (= opaque) ... 1 (= fully transparent)"
                                       annotation(Dialog(group="Material properties"));
          annotation (Documentation(info="<html>
<p>
This model is documented at
<a href=\"modelica://Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface\">Modelica.Mechanics.MultiBody.Visualizers.Advanced.Surface</a>.
</p>

</html>"));
        end PartialSurface;
      end Animation;

      package ExternalReferences "Functions to access external resources"
        extends Modelica.Icons.InternalPackage;
        partial function PartialLoadResource
            "Interface for tool specific function to return the absolute path name of a URI or local file name"
          extends Modelica.Icons.Function;
          input String uri "URI or local file name";
          output String fileReference "Absolute path name of file";
          annotation (Documentation(info="<html>
<p>
This partial function defines the function interface of a tool-specific implementation
in package ModelicaServices. The interface is documented at
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">Modelica.Utilities.Internal.FileSystem.loadResource</a>.
</p>

</html>"));
        end PartialLoadResource;
      end ExternalReferences;

      package System "System dependent functions"
        extends Modelica.Icons.InternalPackage;
        partial function exitBase "Interface for tool specific function to terminate the execution of the Modelica environment"
          extends Modelica.Icons.Function;
          input Integer status=0 "Result to be returned by environment (0 means success)";
          annotation (Documentation(info="<html>
<p>
This partial function defines the function interface of a tool-specific implementation
in package ModelicaServices.
</p>
</html>"));
        end exitBase;
      end System;
        annotation (Documentation(info="<html>

<p>
This package contains interfaces of a set of functions and models used in the
Modelica Standard Library that requires a <strong>tool specific implementation</strong>.
There is an associated package called <strong>ModelicaServices</strong>. A tool vendor
should provide a proper implementation of this library for the corresponding
tool. The default implementation is \"do nothing\".
In the Modelica Standard Library, the models and functions of ModelicaServices
are used.
</p>
</html>"));
    end PartialModelicaServices;

    package FileSystem
      "Internal package with external functions as interface to the file system"
     extends Modelica.Icons.InternalPackage;

      function mkdir "Make directory (POSIX: 'mkdir')"
        extends Modelica.Icons.Function;
        input String directoryName "Make a new directory";
      external "C" ModelicaInternal_mkdir(directoryName) annotation(Library="ModelicaExternalC");
      annotation(__ModelicaAssociation_Impure=true);
      end mkdir;

      function stat "Inquire file information (POSIX function 'stat')"
        extends Modelica.Icons.Function;
        input String name "Name of file, directory, pipe etc.";
        output Types.FileType fileType "Type of file";
      external "C" fileType = ModelicaInternal_stat(name) annotation(Library="ModelicaExternalC");
      annotation(__ModelicaAssociation_Impure=true);
      end stat;
      annotation (
    Documentation(info="<html>
<p>
Package <strong>Internal.FileSystem</strong> is an internal package that contains
low level functions as interface to the file system.
These functions should not be called directly in a scripting
environment since more convenient functions are provided
in packages Files and Systems.
</p>
<p>
Note, the functions in this package are direct interfaces to
functions of POSIX and of the standard C library. Errors
occurring in these functions are treated by triggering
a Modelica assert. Therefore, the functions in this package
return only for a successful operation. Furthermore, the
representation of a string is hidden by this interface,
especially if the operating system supports Unicode characters.
</p>
</html>"));
    end FileSystem;
    end Internal;
      annotation (
  Documentation(info="<html>
<p>
This package contains Modelica <strong>functions</strong> that are
especially suited for <strong>scripting</strong>. The functions might
be used to work with strings, read data from file, write data
to file or copy, move and remove files.
</p>
<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.UsersGuide\">Modelica.Utilities.User's Guide</a>
     discusses the most important aspects of this library.</li>
<li> <a href=\"modelica://Modelica.Utilities.Examples\">Modelica.Utilities.Examples</a>
     contains examples that demonstrate the usage of this library.</li>
</ul>
<p>
The following main sublibraries are available:
</p>
<ul>
<li> <a href=\"modelica://Modelica.Utilities.Files\">Files</a>
     provides functions to operate on files and directories, e.g.,
     to copy, move, remove files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Streams\">Streams</a>
     provides functions to read from files and write to files.</li>
<li> <a href=\"modelica://Modelica.Utilities.Strings\">Strings</a>
     provides functions to operate on strings. E.g.
     substring, find, replace, sort, scanToken.</li>
<li> <a href=\"modelica://Modelica.Utilities.System\">System</a>
     provides functions to interact with the environment.
     E.g., get or set the working directory or environment
     variables and to send a command to the default shell.</li>
</ul>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>"));
  end Utilities;

  package Constants
  "Library of mathematical constants and constants of nature (e.g., pi, eps, R, sigma)"
    import SI = Modelica.SIunits;
    import NonSI = Modelica.SIunits.Conversions.NonSIunits;
    extends Modelica.Icons.Package;

    final constant Real pi=2*Modelica.Math.asin(1.0);

    final constant Real eps=ModelicaServices.Machine.eps
      "Biggest number such that 1.0 + eps = 1.0";

    final constant Real small=ModelicaServices.Machine.small
      "Smallest number such that small and -small are representable on the machine";

    final constant Real inf=ModelicaServices.Machine.inf
      "Biggest Real number such that inf and -inf are representable on the machine";

    final constant SI.Acceleration g_n=9.80665
      "Standard acceleration of gravity on earth";

    final constant Real R(final unit="J/(mol.K)") = 8.3144598
      "Molar gas constant (previous value: 8.314472)";

    final constant Real sigma(final unit="W/(m2.K4)") = 5.670367e-8
      "Stefan-Boltzmann constant (previous value: 5.670400e-8)";

    final constant NonSI.Temperature_degC T_zero=-273.15
      "Absolute zero temperature";
    annotation (
      Documentation(info="<html>
<p>
This package provides often needed constants from mathematics, machine
dependent constants and constants from nature. The latter constants
(name, value, description) are from the following source:
</p>

<dl>
<dt>Peter J. Mohr, David B. Newell, and Barry N. Taylor:</dt>
<dd><strong>CODATA Recommended Values of the Fundamental Physical Constants: 2014</strong>.
<a href= \"http://dx.doi.org/10.5281/zenodo.22826\">http://dx.doi.org/10.5281/zenodo.22826</a>, 2015. See also <a href=
\"http://physics.nist.gov/cuu/Constants/index.html\">http://physics.nist.gov/cuu/Constants/index.html</a></dd>
</dl>

<p>CODATA is the Committee on Data for Science and Technology.</p>

<dl>
<dt><strong>Main Author:</strong></dt>
<dd><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a><br>
    Deutsches Zentrum f&uuml;r Luft und Raumfahrt e. V. (DLR)<br>
    Oberpfaffenhofen<br>
    Postfach 1116<br>
    D-82230 We&szlig;ling<br>
    email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
</dl>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>Nov 4, 2015</em>
       by Thomas Beutlich:<br>
       Constants updated according to 2014 CODATA values.</li>
<li><em>Nov 8, 2004</em>
       by Christian Schweiger:<br>
       Constants updated according to 2002 CODATA values.</li>
<li><em>Dec 9, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants updated according to 1998 CODATA values. Using names, values
       and description text from this source. Included magnetic and
       electric constant.</li>
<li><em>Sep 18, 1999</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Constants eps, inf, small introduced.</li>
<li><em>Nov 15, 1997</em>
       by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br>
       Realized.</li>
</ul>
</html>"),
      Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Polygon(
          origin={-9.2597,25.6673},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
          smooth=Smooth.Bezier),
        Polygon(
          origin={-19.9923,-8.3993},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
          smooth=Smooth.Bezier),
        Polygon(
          origin={23.753,-11.5422},
          fillColor={102,102,102},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
          smooth=Smooth.Bezier)}));
  end Constants;

  package Icons "Library of icons"
    extends Icons.Package;

    partial package ExamplesPackage
      "Icon for packages containing runnable examples"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(
              origin={8.0,14.0},
              lineColor={78,138,73},
              fillColor={78,138,73},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-58.0,46.0},{42.0,-14.0},{-58.0,-74.0},{-58.0,46.0}})}), Documentation(info="<html>
<p>This icon indicates a package that contains executable examples.</p>
</html>"));
    end ExamplesPackage;

    partial package Package "Icon for standard packages"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              lineColor={200,200,200},
              fillColor={248,248,248},
              fillPattern=FillPattern.HorizontalCylinder,
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0),
            Rectangle(
              lineColor={128,128,128},
              extent={{-100.0,-100.0},{100.0,100.0}},
              radius=25.0)}), Documentation(info="<html>
<p>Standard package icon.</p>
</html>"));
    end Package;

    partial package BasesPackage "Icon for packages containing base classes"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(
              extent={{-30.0,-30.0},{30.0,30.0}},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid)}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains base models and classes, respectively.</p>
</html>"));
    end BasesPackage;

    partial package VariantsPackage "Icon for package containing variants"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                {100,100}}), graphics={
            Ellipse(
              origin={10.0,10.0},
              fillColor={76,76,76},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-80.0,-80.0},{-20.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,-80.0},{60.0,-20.0}}),
            Ellipse(
              origin={10.0,10.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{0.0,0.0},{60.0,60.0}}),
            Ellipse(
              origin={10.0,10.0},
              lineColor={128,128,128},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              extent={{-80.0,0.0},{-20.0,60.0}})}),
                                Documentation(info="<html>
<p>This icon shall be used for a package/library that contains several variants of one component.</p>
</html>"));
    end VariantsPackage;

    partial package InterfacesPackage "Icon for packages containing interfaces"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(origin={20.0,0.0},
              lineColor={64,64,64},
              fillColor={255,255,255},
              fillPattern=FillPattern.Solid,
              points={{-10.0,70.0},{10.0,70.0},{40.0,20.0},{80.0,20.0},{80.0,-20.0},{40.0,-20.0},{10.0,-70.0},{-10.0,-70.0}}),
            Polygon(fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-100.0,20.0},{-60.0,20.0},{-30.0,70.0},{-10.0,70.0},{-10.0,-70.0},{-30.0,-70.0},{-60.0,-20.0},{-100.0,-20.0}})}),
                                Documentation(info="<html>
<p>This icon indicates packages containing interfaces.</p>
</html>"));
    end InterfacesPackage;

    partial package SourcesPackage "Icon for packages containing sources"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Polygon(origin={23.3333,0.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-23.333,30.0},{46.667,0.0},{-23.333,-30.0}}),
            Rectangle(
              fillColor = {128,128,128},
              pattern = LinePattern.None,
              fillPattern = FillPattern.Solid,
              extent = {{-70,-4.5},{0,4.5}})}),
                                Documentation(info="<html>
<p>This icon indicates a package which contains sources.</p>
</html>"));
    end SourcesPackage;

    partial package SensorsPackage "Icon for packages containing sensors"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(origin={0.0,-30.0},
              fillColor={255,255,255},
              extent={{-90.0,-90.0},{90.0,90.0}},
              startAngle=20.0,
              endAngle=160.0),
            Ellipse(origin={0.0,-30.0},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-20.0,-20.0},{20.0,20.0}}),
            Line(origin={0.0,-30.0},
              points={{0.0,60.0},{0.0,90.0}}),
            Ellipse(origin={-0.0,-30.0},
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-10.0,-10.0},{10.0,10.0}}),
            Polygon(
              origin={-0.0,-30.0},
              rotation=-35.0,
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-7.0,0.0},{-3.0,85.0},{0.0,90.0},{3.0,85.0},{7.0,0.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a package containing sensors.</p>
</html>"));
    end SensorsPackage;

    partial package UtilitiesPackage "Icon for utility packages"
      extends Modelica.Icons.Package;
       annotation (Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}),
      Documentation(info="<html>
<p>This icon indicates a package containing utility classes.</p>
</html>"));
    end UtilitiesPackage;

    partial package TypesPackage "Icon for packages containing type definitions"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-12.167,-23},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{12.167,65},{14.167,93},{36.167,89},{24.167,20},{4.167,-30},
                  {14.167,-30},{24.167,-30},{24.167,-40},{-5.833,-50},{-15.833,
                  -30},{4.167,20},{12.167,65}},
              smooth=Smooth.Bezier), Polygon(
              origin={2.7403,1.6673},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{49.2597,22.3327},{31.2597,24.3327},{7.2597,18.3327},{-26.7403,
                10.3327},{-46.7403,14.3327},{-48.7403,6.3327},{-32.7403,0.3327},{-6.7403,
                4.3327},{33.2597,14.3327},{49.2597,14.3327},{49.2597,22.3327}},
              smooth=Smooth.Bezier)}));
    end TypesPackage;

    partial package FunctionsPackage "Icon for packages containing functions"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
              Text(
                lineColor={128,128,128},
                extent={{-90,-90},{90,90}},
                textString="f")}));
    end FunctionsPackage;

    partial package IconsPackage "Icon for packages containing icons"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-8.167,-17},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                  4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                  -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier), Ellipse(
              origin={-0.5,56.5},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}));
    end IconsPackage;

    partial package InternalPackage
      "Icon for an internal package (indicating that the package should not be directly utilized by user)"

    annotation (
      Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
              100}}), graphics={
          Rectangle(
            lineColor={215,215,215},
            fillColor={255,255,255},
            fillPattern=FillPattern.HorizontalCylinder,
            extent={{-100,-100},{100,100}},
            radius=25),
          Rectangle(
            lineColor={215,215,215},
            extent={{-100,-100},{100,100}},
            radius=25),
          Ellipse(
            extent={{-80,80},{80,-80}},
            lineColor={215,215,215},
            fillColor={215,215,215},
            fillPattern=FillPattern.Solid),
          Ellipse(
            extent={{-55,55},{55,-55}},
            lineColor={255,255,255},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid),
          Rectangle(
            extent={{-60,14},{60,-14}},
            lineColor={215,215,215},
            fillColor={215,215,215},
            fillPattern=FillPattern.Solid,
            rotation=45)}),
      Documentation(info="<html>

<p>
This icon shall be used for a package that contains internal classes not to be
directly utilized by a user.
</p>
</html>"));
    end InternalPackage;

    partial package MaterialPropertiesPackage
      "Icon for package containing property classes"
      extends Modelica.Icons.Package;
      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={
            Ellipse(
              lineColor={102,102,102},
              fillColor={204,204,204},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Sphere,
              extent={{-60.0,-60.0},{60.0,60.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a package that contains properties</p>
</html>"));
    end MaterialPropertiesPackage;

    partial class MaterialProperty "Icon for property classes"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,100}}), graphics={
            Ellipse(lineColor={102,102,102},
              fillColor={204,204,204},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Sphere,
              extent={{-100.0,-100.0},{100.0,100.0}})}),
                                Documentation(info="<html>
<p>This icon indicates a property class.</p>
</html>"));
    end MaterialProperty;

    partial class RotationalSensor "Icon representing a round measurement device"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Ellipse(
              fillColor={245,245,245},
              fillPattern=FillPattern.Solid,
              extent={{-70.0,-70.0},{70.0,70.0}}),
            Line(points={{0.0,70.0},{0.0,40.0}}),
            Line(points={{22.9,32.8},{40.2,57.3}}),
            Line(points={{-22.9,32.8},{-40.2,57.3}}),
            Line(points={{37.6,13.7},{65.8,23.9}}),
            Line(points={{-37.6,13.7},{-65.8,23.9}}),
            Ellipse(
              lineColor={64,64,64},
              fillColor={255,255,255},
              extent={{-12.0,-12.0},{12.0,12.0}}),
            Polygon(
              rotation=-17.5,
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-5.0,0.0},{-2.0,60.0},{0.0,65.0},{2.0,60.0},{5.0,0.0}}),
            Ellipse(
              fillColor={64,64,64},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-7.0,-7.0},{7.0,7.0}})}),
        Documentation(info="<html>
<p>
This icon is designed for a <strong>rotational sensor</strong> model.
</p>
</html>"));
    end RotationalSensor;

    partial class TranslationalSensor
      "Icon representing a linear measurement device"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Rectangle(
              fillColor={245,245,245},
              fillPattern=FillPattern.Solid,
              extent={{-70.0,-60.0},{70.0,20.0}}),
            Polygon(
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{0.0,-40.0},{-10.0,-16.0},{10.0,-16.0},{0.0,-40.0}}),
            Line(points={{0.0,0.0},{0.0,-16.0}}),
            Line(points={{-70.0,0.0},{0.0,0.0}}),
            Line(points={{-50.0,-40.0},{-50.0,-60.0}}),
            Line(points={{-30.0,-40.0},{-30.0,-60.0}}),
            Line(points={{-10.0,-40.0},{-10.0,-60.0}}),
            Line(points={{10.0,-40.0},{10.0,-60.0}}),
            Line(points={{30.0,-40.0},{30.0,-60.0}}),
            Line(points={{50.0,-40.0},{50.0,-60.0}})}),
        Documentation(info="<html>
<p>
This icon is designed for a <strong>translational sensor</strong> model.
</p></html>"));
    end TranslationalSensor;

    partial function Function "Icon for functions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
            Text(
              lineColor={0,0,255},
              extent={{-150,105},{150,145}},
              textString="%name"),
            Ellipse(
              lineColor = {108,88,49},
              fillColor = {255,215,136},
              fillPattern = FillPattern.Solid,
              extent = {{-100,-100},{100,100}}),
            Text(
              lineColor={108,88,49},
              extent={{-90.0,-90.0},{90.0,90.0}},
              textString="f")}),
    Documentation(info="<html>
<p>This icon indicates Modelica functions.</p>
</html>"));
    end Function;

    partial record Record "Icon for records"

      annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,100}}), graphics={
            Text(
              lineColor={0,0,255},
              extent={{-150,60},{150,100}},
              textString="%name"),
            Rectangle(
              origin={0.0,-25.0},
              lineColor={64,64,64},
              fillColor={255,215,136},
              fillPattern=FillPattern.Solid,
              extent={{-100.0,-75.0},{100.0,75.0}},
              radius=25.0),
            Line(
              points={{-100.0,0.0},{100.0,0.0}},
              color={64,64,64}),
            Line(
              origin={0.0,-50.0},
              points={{-100.0,0.0},{100.0,0.0}},
              color={64,64,64}),
            Line(
              origin={0.0,-25.0},
              points={{0.0,75.0},{0.0,-75.0}},
              color={64,64,64})}), Documentation(info="<html>
<p>
This icon is indicates a record.
</p>
</html>"));
    end Record;

    type TypeReal "Icon for Real types"
        extends Real;
        annotation(Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                lineColor={160,160,164},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Text(
                lineColor={255,255,255},
                extent={{-90.0,-50.0},{90.0,50.0}},
                textString="R")}),Documentation(info="<html>
<p>
This icon is designed for a <strong>Real</strong> type.
</p>
</html>"));
    end TypeReal;

    type TypeString "Icon for String types"
        extends String;
        annotation(Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
              Rectangle(
                lineColor={160,160,164},
                fillColor={160,160,164},
                fillPattern=FillPattern.Solid,
                extent={{-100.0,-100.0},{100.0,100.0}},
                radius=25.0),
              Text(
                lineColor={255,255,255},
                extent={{-90.0,-50.0},{90.0,50.0}},
                textString="S")}),Documentation(info="<html>
<p>
This icon is designed for a <strong>String</strong> type.
</p>
</html>"));
    end TypeString;

    expandable connector SignalBus "Icon for signal bus"

      annotation (
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}, initialScale=0.2), graphics={
              Rectangle(
                lineColor={255,204,51},
                lineThickness=0.5,
                extent={{-20.0,-2.0},{20.0,2.0}}),
              Polygon(
                fillColor={255,215,136},
                fillPattern=FillPattern.Solid,
                points={{-80.0,50.0},{80.0,50.0},{100.0,30.0},{80.0,-40.0},{60.0,-50.0},{-60.0,-50.0},{-80.0,-40.0},{-100.0,30.0}},
                smooth=Smooth.Bezier),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-65.0,15.0},{-55.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-5.0,15.0},{5.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{55.0,15.0},{65.0,25.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{-35.0,-25.0},{-25.0,-15.0}}),
              Ellipse(
                fillPattern=FillPattern.Solid,
                extent={{25.0,-25.0},{35.0,-15.0}})}),
        Diagram(coordinateSystem(
            preserveAspectRatio=false,
            extent={{-100,-100},{100,100}},
            initialScale=0.2), graphics={
            Polygon(
              points={{-40,25},{40,25},{50,15},{40,-20},{30,-25},{-30,-25},{-40,-20},{-50,15}},
              fillColor={255,204,51},
              fillPattern=FillPattern.Solid,
              smooth=Smooth.Bezier),
            Ellipse(
              extent={{-32.5,7.5},{-27.5,12.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-2.5,12.5},{2.5,7.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{27.5,12.5},{32.5,7.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{-17.5,-7.5},{-12.5,-12.5}},
              fillPattern=FillPattern.Solid),
            Ellipse(
              extent={{12.5,-7.5},{17.5,-12.5}},
              fillPattern=FillPattern.Solid),
            Text(
              extent={{-150,70},{150,40}},
              textString="%name")}),
        Documentation(info="<html>
This icon is designed for a <strong>signal bus</strong> connector.
</html>"));
    end SignalBus;

    partial class ObsoleteModel
      "Icon for classes that are obsolete and will be removed in later versions"

      annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Rectangle(
              extent={{-102,102},{102,-102}},
              lineColor={255,0,0},
              pattern=LinePattern.Dash,
              lineThickness=0.5)}), Documentation(info="<html>
<p>
This partial class is intended to provide a <u>default icon
for an obsolete model</u> that will be removed from the
corresponding library in a future release.
</p>
</html>"));
    end ObsoleteModel;
    annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                -100},{100,100}}), graphics={Polygon(
              origin={-8.167,-17},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-15.833,20.0},{-15.833,30.0},{14.167,40.0},{24.167,20.0},{
                  4.167,-30.0},{14.167,-30.0},{24.167,-30.0},{24.167,-40.0},{-5.833,
                  -50.0},{-15.833,-30.0},{4.167,20.0},{-5.833,20.0}},
              smooth=Smooth.Bezier), Ellipse(
              origin={-0.5,56.5},
              fillColor={128,128,128},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              extent={{-12.5,-12.5},{12.5,12.5}})}), Documentation(info="<html>
<p>This package contains definitions for the graphical layout of components which may be used in different libraries. The icons can be utilized by inheriting them in the desired class using &quot;extends&quot; or by directly copying the &quot;icon&quot; layer.</p>

<h4>Main Authors:</h4>

<dl>
<dt><a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a></dt>
    <dd>Deutsches Zentrum fuer Luft und Raumfahrt e.V. (DLR)</dd>
    <dd>Oberpfaffenhofen</dd>
    <dd>Postfach 1116</dd>
    <dd>D-82230 Wessling</dd>
    <dd>email: <a href=\"mailto:Martin.Otter@dlr.de\">Martin.Otter@dlr.de</a></dd>
<dt>Christian Kral</dt>

    <dd>  <a href=\"https://christiankral.net/\">Electric Machines, Drives and Systems</a><br>
</dd>
    <dd>1060 Vienna, Austria</dd>
    <dd>email: <a href=\"mailto:dr.christian.kral@gmail.com\">dr.christian.kral@gmail.com</a></dd>
<dt>Johan Andreasson</dt>
    <dd><a href=\"http://www.modelon.se/\">Modelon AB</a></dd>
    <dd>Ideon Science Park</dd>
    <dd>22370 Lund, Sweden</dd>
    <dd>email: <a href=\"mailto:johan.andreasson@modelon.se\">johan.andreasson@modelon.se</a></dd>
</dl>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>"));
  end Icons;

  package SIunits
  "Library of type and unit definitions based on SI units according to ISO 31-1992"
    extends Modelica.Icons.Package;

    package Icons "Icons for SIunits"
      extends Modelica.Icons.IconsPackage;

      partial function Conversion "Base icon for conversion functions"

        annotation (Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={191,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-90,0},{30,0}}, color={191,0,0}),
              Polygon(
                points={{90,0},{30,20},{30,-20},{90,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-115,155},{115,105}},
                textString="%name",
                lineColor={0,0,255})}));
      end Conversion;
    end Icons;

    package Conversions
    "Conversion functions to/from non SI units and type definitions of non SI units"
      extends Modelica.Icons.Package;

      package NonSIunits "Type definitions of non SI units"
        extends Modelica.Icons.Package;

        type Temperature_degC = Real (final quantity="ThermodynamicTemperature",
              final unit="degC")
          "Absolute temperature in degree Celsius (for relative temperature use SIunits.TemperatureDifference)" annotation(absoluteValue=true);

        type Angle_deg = Real (final quantity="Angle", final unit="deg")
          "Angle in degree";

        type AngularVelocity_rpm = Real (final quantity="AngularVelocity", final unit=
                   "rev/min")
          "Angular velocity in revolutions per minute. Alias unit names that are outside of the SI system: rpm, r/min, rev/min";

        type Time_hour = Real (final quantity="Time", final unit="h")
          "Time in hours";

        type Pressure_bar = Real (final quantity="Pressure", final unit="bar")
          "Absolute pressure in bar";
        annotation (Documentation(info="<html>
<p>
This package provides predefined types, such as <strong>Angle_deg</strong> (angle in
degree), <strong>AngularVelocity_rpm</strong> (angular velocity in revolutions per
minute) or <strong>Temperature_degF</strong> (temperature in degree Fahrenheit),
which are in common use but are not part of the international standard on
units according to ISO 31-1992 \"General principles concerning quantities,
units and symbols\" and ISO 1000-1992 \"SI units and recommendations for
the use of their multiples and of certain other units\".</p>
<p>If possible, the types in this package should not be used. Use instead
types of package Modelica.SIunits. For more information on units, see also
the book of Francois Cardarelli <strong>Scientific Unit Conversion - A
Practical Guide to Metrication</strong> (Springer 1997).</p>
<p>Some units, such as <strong>Temperature_degC/Temp_C</strong> are both defined in
Modelica.SIunits and in Modelica.Conversions.NonSIunits. The reason is that these
definitions have been placed erroneously in Modelica.SIunits although they
are not SIunits. For backward compatibility, these type definitions are
still kept in Modelica.SIunits.</p>
</html>"),   Icon(coordinateSystem(extent={{-100,-100},{100,100}}), graphics={
        Text(
          origin={15.0,51.8518},
          extent={{-105.0,-86.8518},{75.0,-16.8518}},
          textString="[km/h]")}));
      end NonSIunits;

      function to_degC "Convert from Kelvin to degCelsius"
        extends Modelica.SIunits.Icons.Conversion;
        input Temperature Kelvin "Kelvin value";
        output NonSIunits.Temperature_degC Celsius "Celsius value";
      algorithm
        Celsius := Kelvin + Modelica.Constants.T_zero;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-20,100},{-100,20}},
                textString="K"), Text(
                extent={{100,-20},{20,-100}},
                textString="degC")}));
      end to_degC;

      function from_degC "Convert from degCelsius to Kelvin"
        extends Modelica.SIunits.Icons.Conversion;
        input NonSIunits.Temperature_degC Celsius "Celsius value";
        output Temperature Kelvin "Kelvin value";
      algorithm
        Kelvin := Celsius - Modelica.Constants.T_zero;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-20,100},{-100,20}},
                textString="degC"), Text(
                extent={{100,-20},{20,-100}},
                textString="K")}));
      end from_degC;

      function from_deg "Convert from degree to radian"
        extends Modelica.SIunits.Icons.Conversion;
        input NonSIunits.Angle_deg degree "degree value";
        output Angle radian "radian value";
      algorithm
        radian := (Modelica.Constants.pi/180.0)*degree;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{4,100},{-102,46}},
                textString="deg"), Text(
                extent={{100,-32},{-18,-100}},
                textString="rad")}));
      end from_deg;

      function to_hour "Convert from second to hour"
        extends Modelica.SIunits.Icons.Conversion;
        input Time s "second value";
        output NonSIunits.Time_hour hour "hour value";
      algorithm
        hour := s/3600;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{12,100},{-100,50}},
                textString="s"), Text(
                extent={{100,-56},{-20,-100}},
                textString="hour")}));
      end to_hour;

      function to_bar "Convert from Pascal to bar"
        extends Modelica.SIunits.Icons.Conversion;
        input Pressure Pa "Pascal value";
        output NonSIunits.Pressure_bar bar "bar value";
      algorithm
        bar := Pa/1e5;
        annotation (Inline=true,Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,
                  -100},{100,100}}), graphics={Text(
                extent={{-12,100},{-100,56}},
                textString="Pa"), Text(
                extent={{98,-52},{-4,-100}},
                textString="bar")}));
      end to_bar;
      annotation (Documentation(info="<html>
<p>This package provides conversion functions from the non SI Units
defined in package Modelica.SIunits.Conversions.NonSIunits to the
corresponding SI Units defined in package Modelica.SIunits and vice
versa. It is recommended to use these functions in the following
way (note, that all functions have one Real input and one Real output
argument):</p>
<pre>
  <strong>import</strong> SI = Modelica.SIunits;
  <strong>import</strong> Modelica.SIunits.Conversions.*;
     ...
  <strong>parameter</strong> SI.Temperature     T   = from_degC(25);   // convert 25 degree Celsius to Kelvin
  <strong>parameter</strong> SI.Angle           phi = from_deg(180);   // convert 180 degree to radian
  <strong>parameter</strong> SI.AngularVelocity w   = from_rpm(3600);  // convert 3600 revolutions per minutes
                                                      // to radian per seconds
</pre>

</html>"));
    end Conversions;

    type Angle = Real (
        final quantity="Angle",
        final unit="rad",
        displayUnit="deg");

    type Length = Real (final quantity="Length", final unit="m");

    type Position = Length;

    type Distance = Length (min=0);

    type Height = Length(min=0);

    type Radius = Length(min=0);

    type Diameter = Length(min=0);

    type Area = Real (final quantity="Area", final unit="m2");

    type Volume = Real (final quantity="Volume", final unit="m3");

    type Time = Real (final quantity="Time", final unit="s");

    type Duration = Time;

    type AngularVelocity = Real (
        final quantity="AngularVelocity",
        final unit="rad/s");

    type Velocity = Real (final quantity="Velocity", final unit="m/s");

    type Acceleration = Real (final quantity="Acceleration", final unit="m/s2");

    type Frequency = Real (final quantity="Frequency", final unit="Hz");

    type Mass = Real (
        quantity="Mass",
        final unit="kg",
        min=0);

    type Density = Real (
        final quantity="Density",
        final unit="kg/m3",
        displayUnit="g/cm3",
        min=0.0);

    type SpecificVolume = Real (
        final quantity="SpecificVolume",
        final unit="m3/kg",
        min=0.0);

    type Pressure = Real (
        final quantity="Pressure",
        final unit="Pa",
        displayUnit="bar");

    type AbsolutePressure = Pressure (min=0.0, nominal = 1e5);

    type PressureDifference = Pressure;

    type DynamicViscosity = Real (
        final quantity="DynamicViscosity",
        final unit="Pa.s",
        min=0);

    type KinematicViscosity = Real (
        final quantity="KinematicViscosity",
        final unit="m2/s",
        min=0);

    type Energy = Real (final quantity="Energy", final unit="J");

    type Power = Real (final quantity="Power", final unit="W");

    type EnthalpyFlowRate = Real (final quantity="EnthalpyFlowRate", final unit=
            "W");

    type Efficiency = Real (
        final quantity="Efficiency",
        final unit="1",
        min=0);

    type MassFlowRate = Real (quantity="MassFlowRate", final unit="kg/s");

    type VolumeFlowRate = Real (final quantity="VolumeFlowRate", final unit=
            "m3/s");

    type ThermodynamicTemperature = Real (
        final quantity="ThermodynamicTemperature",
        final unit="K",
        min = 0.0,
        start = 288.15,
        nominal = 300,
        displayUnit="degC")
      "Absolute temperature (use type TemperatureDifference for relative temperatures)" annotation(absoluteValue=true);

    type Temp_K = ThermodynamicTemperature;

    type Temperature = ThermodynamicTemperature;

    type TemperatureDifference = Real (
        final quantity="ThermodynamicTemperature",
        final unit="K") annotation(absoluteValue=false);

    type TemperatureSlope = Real (final quantity="TemperatureSlope",
        final unit="K/s");

    type LinearTemperatureCoefficient = Real(final quantity = "LinearTemperatureCoefficient", final unit="1/K");

    type Compressibility = Real (final quantity="Compressibility", final unit=
            "1/Pa");

    type IsothermalCompressibility = Compressibility;

    type Heat = Real (final quantity="Energy", final unit="J");

    type HeatFlowRate = Real (final quantity="Power", final unit="W");

    type HeatFlux = Real (final quantity="HeatFlux", final unit="W/m2");

    type ThermalConductivity = Real (final quantity="ThermalConductivity", final unit=
               "W/(m.K)");

    type CoefficientOfHeatTransfer = Real (final quantity=
            "CoefficientOfHeatTransfer", final unit="W/(m2.K)");

    type ThermalInsulance = Real (final quantity="ThermalInsulance", final unit=
            "m2.K/W");

    type ThermalResistance = Real (final quantity="ThermalResistance", final unit=
           "K/W");

    type ThermalConductance = Real (final quantity="ThermalConductance", final unit=
               "W/K");

    type ThermalDiffusivity = Real (final quantity="ThermalDiffusivity", final unit=
               "m2/s");

    type HeatCapacity = Real (final quantity="HeatCapacity", final unit="J/K");

    type SpecificHeatCapacity = Real (final quantity="SpecificHeatCapacity",
          final unit="J/(kg.K)");

    type RatioOfSpecificHeatCapacities = Real (final quantity=
            "RatioOfSpecificHeatCapacities", final unit="1");

    type IsentropicExponent = Real (final quantity="IsentropicExponent", final unit=
               "1");

    type SpecificEntropy = Real (final quantity="SpecificEntropy",
                                 final unit="J/(kg.K)");

    type SpecificEnergy = Real (final quantity="SpecificEnergy",
                                final unit="J/kg");

    type SpecificInternalEnergy = SpecificEnergy;

    type SpecificEnthalpy = SpecificEnergy;

    type DerDensityByEnthalpy = Real (final unit="kg.s2/m5");

    type DerDensityByPressure = Real (final unit="s2/m2");

    type DerDensityByTemperature = Real (final unit="kg/(m3.K)");

    type ElectricCurrent = Real (final quantity="ElectricCurrent", final unit="A");

    type Current = ElectricCurrent;

    type ElectricPotential = Real (final quantity="ElectricPotential", final unit=
           "V");

    type RadiantEnergyFluenceRate = Real (final quantity=
            "RadiantEnergyFluenceRate", final unit="W/m2");

    type Irradiance = Real (final quantity="Irradiance", final unit="W/m2");

    type Emissivity = Real (final quantity="Emissivity", final unit="1");

    type Illuminance = Real (final quantity="Illuminance", final unit="lx");

    type LuminousEfficacy = Real (final quantity="LuminousEfficacy", final unit=
            "lm/W");

    type MolarMass = Real (final quantity="MolarMass", final unit="kg/mol",min=0);

    type MolarVolume = Real (final quantity="MolarVolume", final unit="m3/mol", min=0);

    type MassFraction = Real (final quantity="MassFraction", final unit="1",
                              min=0, max=1);

    type MoleFraction = Real (final quantity="MoleFraction", final unit="1",
                              min = 0, max = 1);

    type ReynoldsNumber = Real (final quantity="ReynoldsNumber", final unit="1");

    type PrandtlNumber = Real (final quantity="PrandtlNumber", final unit="1");

    operator record ComplexCurrent =
      Complex(redeclare Modelica.SIunits.Current re "Real part of complex current",
              redeclare Modelica.SIunits.Current im "Imaginary part of complex current")
      "Complex electrical current";

    operator record ComplexElectricPotential =
      Complex(redeclare Modelica.SIunits.ElectricPotential re "Imaginary part of complex electric potential",
              redeclare Modelica.SIunits.ElectricPotential im "Real part of complex electrical potential")
      "Complex electric potential";
    annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
              -100},{100,100}}), graphics={
        Polygon(
          fillColor = {128,128,128},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{-80,-40},{-80,-40},{-55,50},{-52.5,62.5},{-65,60},{-65,65},{-35,77.5},{-32.5,60},{-50,0},{-50,0},{-30,15},{-20,27.5},{-32.5,27.5},{-32.5,27.5},{-32.5,32.5},{-32.5,32.5},{2.5,32.5},{2.5,32.5},{2.5,27.5},{2.5,27.5},{-7.5,27.5},{-30,7.5},{-30,7.5},{-25,-25},{-17.5,-28.75},{-10,-25},{-5,-26.25},{-5,-32.5},{-16.25,-41.25},{-31.25,-43.75},{-40,-33.75},{-45,-5},{-45,-5},{-52.5,-10},{-52.5,-10},{-60,-40},{-60,-40}},
          smooth = Smooth.Bezier),
        Polygon(
          fillColor = {128,128,128},
          pattern = LinePattern.None,
          fillPattern = FillPattern.Solid,
          points = {{87.5,30},{62.5,30},{62.5,30},{55,33.75},{36.25,35},{16.25,25},{7.5,6.25},{11.25,-7.5},{22.5,-12.5},{22.5,-12.5},{6.25,-22.5},{6.25,-35},{16.25,-38.75},{16.25,-38.75},{21.25,-41.25},{21.25,-41.25},{45,-48.75},{47.5,-61.25},{32.5,-70},{12.5,-65},{7.5,-51.25},{21.25,-41.25},{21.25,-41.25},{16.25,-38.75},{16.25,-38.75},{6.25,-41.25},{-6.25,-50},{-3.75,-68.75},{30,-76.25},{65,-62.5},{63.75,-35},{27.5,-26.25},{22.5,-20},{27.5,-15},{27.5,-15},{30,-7.5},{30,-7.5},{27.5,-2.5},{28.75,11.25},{36.25,27.5},{47.5,30},{53.75,22.5},{51.25,8.75},{45,-6.25},{35,-11.25},{30,-7.5},{30,-7.5},{27.5,-15},{27.5,-15},{43.75,-16.25},{65,-6.25},{72.5,10},{70,20},{70,20},{80,20}},
          smooth = Smooth.Bezier)}), Documentation(info="<html>
<p>This package provides predefined types, such as <em>Mass</em>,
<em>Angle</em>, <em>Time</em>, based on the international standard
on units, e.g.,
</p>

<pre>   <strong>type</strong> Angle = Real(<strong>final</strong> quantity = \"Angle\",
                     <strong>final</strong> unit     = \"rad\",
                     displayUnit    = \"deg\");
</pre>

<p>
Some of the types are derived SI units that are utilized in package Modelica
(such as ComplexCurrent, which is a complex number where both the real and imaginary
part have the SI unit Ampere).
</p>

<p>
Furthermore, conversion functions from non SI-units to SI-units and vice versa
are provided in subpackage
<a href=\"modelica://Modelica.SIunits.Conversions\">Conversions</a>.
</p>

<p>
For an introduction how units are used in the Modelica standard library
with package SIunits, have a look at:
<a href=\"modelica://Modelica.SIunits.UsersGuide.HowToUseSIunits\">How to use SIunits</a>.
</p>

<p>
Copyright &copy; 1998-2019, Modelica Association and contributors
</p>
</html>",   revisions="<html>
<ul>
<li><em>May 25, 2011</em> by Stefan Wischhusen:<br/>Added molar units for energy and enthalpy.</li>
<li><em>Jan. 27, 2010</em> by Christian Kral:<br/>Added complex units.</li>
<li><em>Dec. 14, 2005</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Add User&#39;s Guide and removed &quot;min&quot; values for Resistance and Conductance.</li>
<li><em>October 21, 2002</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Christian Schweiger:<br/>Added new package <strong>Conversions</strong>. Corrected typo <em>Wavelenght</em>.</li>
<li><em>June 6, 2000</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Introduced the following new types<br/>type Temperature = ThermodynamicTemperature;<br/>types DerDensityByEnthalpy, DerDensityByPressure, DerDensityByTemperature, DerEnthalpyByPressure, DerEnergyByDensity, DerEnergyByPressure<br/>Attribute &quot;final&quot; removed from min and max values in order that these values can still be changed to narrow the allowed range of values.<br/>Quantity=&quot;Stress&quot; removed from type &quot;Stress&quot;, in order that a type &quot;Stress&quot; can be connected to a type &quot;Pressure&quot;.</li>
<li><em>Oct. 27, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>New types due to electrical library: Transconductance, InversePotential, Damping.</li>
<li><em>Sept. 18, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Renamed from SIunit to SIunits. Subpackages expanded, i.e., the SIunits package, does no longer contain subpackages.</li>
<li><em>Aug 12, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Type &quot;Pressure&quot; renamed to &quot;AbsolutePressure&quot; and introduced a new type &quot;Pressure&quot; which does not contain a minimum of zero in order to allow convenient handling of relative pressure. Redefined BulkModulus as an alias to AbsolutePressure instead of Stress, since needed in hydraulics.</li>
<li><em>June 29, 1999</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a>:<br/>Bug-fix: Double definition of &quot;Compressibility&quot; removed and appropriate &quot;extends Heat&quot; clause introduced in package SolidStatePhysics to incorporate ThermodynamicTemperature.</li>
<li><em>April 8, 1998</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Astrid Jaschinski:<br/>Complete ISO 31 chapters realized.</li>
<li><em>Nov. 15, 1997</em> by <a href=\"http://www.robotic.dlr.de/Martin.Otter/\">Martin Otter</a> and Hubertus Tummescheit:<br/>Some chapters realized.</li>
</ul>
</html>"));
  end SIunits;
annotation (
preferredView="info",
version="3.2.3",
versionBuild=2,
versionDate="2019-01-23",
dateModified = "2019-03-20 12:00:00Z",
revisionId="8f65f621a 2019-03-20 09:22:19 +0100",
uses(Complex(version="3.2.3"), ModelicaServices(version="3.2.3")),
conversion(
 noneFromVersion="3.2.2",
 noneFromVersion="3.2.1",
 noneFromVersion="3.2",
 noneFromVersion="3.1",
 noneFromVersion="3.0.1",
 noneFromVersion="3.0",
 from(version="2.1", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2.1", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos"),
 from(version="2.2.2", script="modelica://Modelica/Resources/Scripts/Dymola/ConvertModelica_from_2.2.2_to_3.0.mos")),
Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
  Polygon(
    origin={-6.9888,20.048},
    pattern=LinePattern.None,
    fillPattern=FillPattern.Solid,
    points={{-93.0112,10.3188},{-93.0112,10.3188},{-73.011,24.6},{-63.011,31.221},{-51.219,36.777},{-39.842,38.629},{-31.376,36.248},{-25.819,29.369},{-24.232,22.49},{-23.703,17.463},{-15.501,25.135},{-6.24,32.015},{3.02,36.777},{15.191,39.423},{27.097,37.306},{32.653,29.633},{35.035,20.108},{43.501,28.046},{54.085,35.19},{65.991,39.952},{77.897,39.688},{87.422,33.338},{91.126,21.696},{90.068,9.525},{86.099,-1.058},{79.749,-10.054},{71.283,-21.431},{62.816,-33.337},{60.964,-32.808},{70.489,-16.14},{77.368,-2.381},{81.072,10.054},{79.749,19.05},{72.605,24.342},{61.758,23.019},{49.587,14.817},{39.003,4.763},{29.214,-6.085},{21.012,-16.669},{13.339,-26.458},{5.401,-36.777},{-1.213,-46.037},{-6.24,-53.446},{-8.092,-52.387},{-0.684,-40.746},{5.401,-30.692},{12.81,-17.198},{19.424,-3.969},{23.658,7.938},{22.335,18.785},{16.514,23.283},{8.047,23.019},{-1.478,19.05},{-11.267,11.113},{-19.734,2.381},{-29.259,-8.202},{-38.519,-19.579},{-48.044,-31.221},{-56.511,-43.392},{-64.449,-55.298},{-72.386,-66.939},{-77.678,-74.612},{-79.53,-74.083},{-71.857,-61.383},{-62.861,-46.037},{-52.278,-28.046},{-44.869,-15.346},{-38.784,-2.117},{-35.344,8.731},{-36.403,19.844},{-42.488,23.813},{-52.013,22.49},{-60.744,16.933},{-68.947,10.054},{-76.884,2.646},{-93.0112,-12.1707},{-93.0112,-12.1707}},
    smooth=Smooth.Bezier),
  Ellipse(
    origin={40.8208,-37.7602},
    fillColor={161,0,4},
    pattern=LinePattern.None,
    fillPattern=FillPattern.Solid,
    extent={{-17.8562,-17.8563},{17.8563,17.8562}})}),
Documentation(info="<html>
<p>
Package <strong>Modelica&reg;</strong> is a <strong>standardized</strong> and <strong>free</strong> package
that is developed together with the Modelica&reg; language from the
Modelica Association, see
<a href=\"https://www.Modelica.org\">https://www.Modelica.org</a>.
It is also called <strong>Modelica Standard Library</strong>.
It provides model components in many domains that are based on
standardized interface definitions. Some typical examples are shown
in the next figure:
</p>

<p>
<img src=\"modelica://Modelica/Resources/Images/UsersGuide/ModelicaLibraries.png\">
</p>

<p>
For an introduction, have especially a look at:
</p>
<ul>
<li> <a href=\"modelica://Modelica.UsersGuide.Overview\">Overview</a>
  provides an overview of the Modelica Standard Library
  inside the <a href=\"modelica://Modelica.UsersGuide\">User's Guide</a>.</li>
<li><a href=\"modelica://Modelica.UsersGuide.ReleaseNotes\">Release Notes</a>
 summarizes the changes of new versions of this package.</li>
<li> <a href=\"modelica://Modelica.UsersGuide.Contact\">Contact</a>
  lists the contributors of the Modelica Standard Library.</li>
<li> The <strong>Examples</strong> packages in the various libraries, demonstrate
  how to use the components of the corresponding sublibrary.</li>
</ul>

<p>
This version of the Modelica Standard Library consists of
</p>
<ul>
<li><strong>1288</strong> component models and blocks,</li>
<li><strong>404</strong> example models, and</li>
<li><strong>1227</strong> functions</li>
</ul>
<p>
that are directly usable (= number of public, non-partial, non-internal and non-obsolete classes). It is fully compliant
to <a href=\"https://www.modelica.org/documents/ModelicaSpec32Revision2.pdf\">Modelica Specification Version 3.2 Revision 2</a>
and it has been tested with Modelica tools from different vendors.
</p>

<p>
<strong>Licensed by the Modelica Association under the 3-Clause BSD License</strong><br>
Copyright &copy; 1998-2019, Modelica Association and <a href=\"modelica://Modelica.UsersGuide.Contact\">contributors</a>.
</p>

<p>
<em>This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>; it can be redistributed and/or modified under the terms of the 3-Clause BSD license. For license conditions (including the disclaimer of warranty) visit <a href=\"https://modelica.org/licenses/modelica-3-clause-bsd\">https://modelica.org/licenses/modelica-3-clause-bsd</a>.</em>
</p>

<p>
<strong>Modelica&reg;</strong> is a registered trademark of the Modelica Association.
</p>
</html>"));
end Modelica;

package IDEAS "Integrated District Energy Assessment Simulation"
extends Modelica.Icons.Package;
import SI = Modelica.SIunits;

  package BoundaryConditions "Package with models for boundary conditions"
    extends Modelica.Icons.Package;

    model SimInfoManager
      "Simulation information manager for handling time and climate data required in each for simulation."
      extends BoundaryConditions.Interfaces.PartialSimInfoManager;

  protected
      Modelica.Blocks.Routing.RealPassThrough HDirNorData;
      Modelica.Blocks.Routing.RealPassThrough HGloHorData;
      Modelica.Blocks.Routing.RealPassThrough HDiffHorData;
      Modelica.Blocks.Routing.RealPassThrough TDryBulData;
      Modelica.Blocks.Routing.RealPassThrough relHumData;
      Modelica.Blocks.Routing.RealPassThrough TDewPoiData;
      Modelica.Blocks.Routing.RealPassThrough nOpaData;
      Modelica.Blocks.Routing.RealPassThrough winSpeData;
      Modelica.Blocks.Routing.RealPassThrough winDirData;
      Modelica.Blocks.Routing.RealPassThrough TBlaSkyData;
    equation
      Te = TDryBul.y;
      TeAv = Te;
      Tground=TdesGround;
      relHum = phiEnv.y;
      TDewPoi = TDewPoiData.y;
      Tsky = TBlaSkyData.y;
      Va = winSpeData.y;
      Vdir = winDirData.y;

      connect(HDirNorData.u, weaDatBus.HDirNor);
      connect(HGloHorData.u, weaDatBus.HGloHor);
      connect(HDiffHorData.u, weaDatBus.HDifHor);
      connect(TDryBulData.u, weaDatBus.TDryBul);
      connect(relHumData.u, weaDatBus.relHum);
      connect(TDewPoiData.u, weaDatBus.TDewPoi);
      connect(nOpaData.u, weaDatBus.nOpa);
      connect(winSpeData.u, weaDatBus.winSpe);
      connect(winDirData.u, weaDatBus.winDir);
      connect(TBlaSkyData.u, weaDatBus.TBlaSky);
      annotation (
        defaultComponentName="sim",
        defaultComponentPrefixes="inner",
        missingInnerMessage=
            "Your model is using an outer \"sim\" component. An inner \"sim\" component is not defined. For simulation drag IDEAS.BoundaryConditions.SimInfoManager into your model.",
        Icon(coordinateSystem(extent={{-100,-100},{100,100}}),
             graphics={
            Bitmap(extent={{22,-8},{20,-8}}, fileName="")}),
        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                100,160}})),
        Documentation(info="<html>
<p>
The SimInfoManager manages all simulation information. 
It loads TMY3 weather data files and applies transformations 
for computing the solar irradiance on the zone surfaces. 
</p>
<h4>Typical use and important parameters</h4>
<ul>
<li>
Parameters <code>filNam</code> and <code>filDir</code> can be used to set the path to the TMY3 weather file.
This file should include the latitude, longitude and time zone corresponding to the weather file.
See the included weather files for the correct format.
</li>
</ul>
<h4>Options</h4>
<ul>
<li>
IDEAS contains an efficient implementation for computing the solar 
incidence angles on surfaces that are part of large building models.
When a model has many parallel surfaces the default implementation computes
the solar irradiance separately for each of these surfaces, 
while the result for all of them should be the same.
The SimInfoManager computes five default orientations (azimuth angels): 
south, west, east, north and horizontal.
Whenever a surface needs the solar incidence angels for one of these orientations
these precomputed values will be used.
The default orientations can be changed using parameters 
<code>incAndAziInBus</code>.
<code>incAndAziInBus</code> determines for which inclination and azimuth the solar radiation is pre-computed.
</li>
<li>Conservation of energy within the building can be checked by setting <code>computeConservationOfEnergy=true</code>.
Conservation of energy is checked by computing the internal energy for 
all components that are within \"the system\" and by adding to this the 
integral of all heat flows entering/leaving the system.
There are two options for choosing the extent of the system based 
on parameter <code>openSystemConservationOfEnergy</code>. 
Either conservation of energy for a closed system is computed, 
or it is computed for an open system. <br/>
When choosing the closed system the conservation of energy 
check should always work when using IDEAS as intended. 
In this case conservation of energy is only checked for all components in the <code>Buildings</code> package. 
I.e. all heat flows at embedded ports <code>port_emb</code> of walls, 
fluid ports of the zones, <code>zone.gainCon</code> and <code>zone.gainRad</code> are 
considered to be a heat gain to the system and every other component 
is considered to be outside of the system for which conservation of energy is checked. <br/>
When computing an open system by setting <code>openSystemConservationOfEnergy=true</code> 
these heat flow rates are not taken into account because they are assumed 
to flow between components that are both within the bounds of the system.
The user then needs to choose how large the system is and he should make sure that
all heat flow rates entering the system are added to <code>sim.Qgai.Q_flow</code> and 
that all internal energy of the system is added to <code>sim.E.E</code>.
</li>
<li>
The default latitude and longitude, which are read by the TMY3 reader, can be overwritten. 
This should only be done if a custom weather data reader instead 
of the TMY3 weather data reader is used.
</li>
</ul>
<h4>TMY3 weather data files</h4>
IDEAS uses TMY3 input files. For detailed documentation see 
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.ReaderTMY3\">IDEAS.BoundaryConditions.WeatherData.ReaderTMY3</a>.
</html>",     revisions="<html>
<ul>
<li>
November 28, 2019 by Ian Beausoleil-Morrison:<br/>
Make wind direction available on WeaBus.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1089\">
#1089</a>
</li>
<li>
January 21, 2019 by Filip Jorissen:<br/>
Improved documentation by adding weather data reader
reference and more TMY3 file examples.
This is for
<a href=\"https://github.com/open-ideas/IDEAS/issues/956\">#956</a>.
</li>
<li>
June 7, 2018 by Filip Jorissen:<br/>
Overwriting TSky, Va and Fc from the extends clause
such that they can be overwriten again in BESTEST SimInfoManager.
This is for
<a href=\"https://github.com/open-ideas/IDEAS/issues/838\">#838</a>.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Added documentation
</li>
</ul>
</html>"));
    end SimInfoManager;

    package SkyTemperature "Package with models to compute the sky temperature"
      extends Modelica.Icons.VariantsPackage;

      block BlackBody "Calculate black body sky temperature"
        extends Modelica.Blocks.Icons.Block;
        parameter IDEAS.BoundaryConditions.Types.SkyTemperatureCalculation calTSky=
          IDEAS.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover
          "Computation of black-body sky temperature"
          annotation(choicesAllMatching=true,
                     Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dry bulb temperature at ground level"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput TDewPoi(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Dew point temperature"
          annotation (Placement(transformation(extent={{-140,10},{-100,50}})));
        Modelica.Blocks.Interfaces.RealInput nOpa( min=0, max=1, unit="1")
          "Opaque sky cover [0, 1]"
          annotation (Placement(transformation(extent={{-140,-50},{-100,-10}})));
        Modelica.Blocks.Interfaces.RealOutput TBlaSky(
          final quantity="ThermodynamicTemperature",
          displayUnit="degC",
          final unit="K") "Black-body sky temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput HHorIR(
          unit="W/m2",
          min=0,
          nominal=100) "Horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
    protected
        Modelica.SIunits.Temperature TDewPoiK "Dewpoint temperature";
        Modelica.SIunits.Emissivity epsSky "Black-body absorptivity of sky";
        Real nOpa10(min=0, max=10) "Opaque sky cover in [0, 10]";
      equation
        if calTSky == IDEAS.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover then
          TDewPoiK =  IDEAS.Utilities.Math.Functions.smoothMin(TDryBul, TDewPoi, 0.1);
          nOpa10 =  10*nOpa "Input nOpa is scaled to [0,1] instead of [0,10]";
          epsSky =  (0.787 + 0.764*Modelica.Math.log(-TDewPoiK/Modelica.Constants.T_zero))*(1 + 0.0224*nOpa10 -
            0.0035*(nOpa10^2) + 0.00028*(nOpa10^3));
          TBlaSky =  TDryBul*(epsSky^0.25);
        else
          TDewPoiK =  273.15;
          nOpa10   =  0.0;
          epsSky   =  0.0;
          TBlaSky  =  (HHorIR/Modelica.Constants.sigma)^0.25;
        end if;
        annotation (
          defaultComponentName="TBlaSky",
          Documentation(info="<html>
<p>
This component computes the black-body sky temperature.
</p>
<p>
For <code>calTSky = 0</code>, the model uses horizontal infrared irradiation.
Otherwise, it uses dry buld temperature, dew point temperature and opaque sky cover.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2017, by Michael Wetter:<br/>
Removed <code>import</code> statement.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/852\">#852</a>.
</li>
<li>
January 6, 2016, by Moritz Lauster:<br/>
Changed unit and comment of input <code>nOpa</code> for correct display of units
in <code>weaBus</code> and input <code>radHorIR</code> to <code>HHorIR</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code>.
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Used enumeration to set the sky temperature computation.
Fixed error in <code>if-then</code> statement that led to
a selection of the wrong branch to compute the sky temperature.
</li>
<li>
March 16, 2011, by Michael Wetter:<br/>
Added types for parameters and attributes for variables.
Removed default parameter value.
</li>
<li>
March 15, 2011, by Wangda Zuo:<br/>
Use <code>smoothMin()</code> instead of <code>min()</code>.
</li>
<li>
June 1, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{-50,44},{56,-40}},
                lineColor={0,0,255},
                textString="T"),
              Text(
                extent={{-96,84},{-66,74}},
                lineColor={0,0,127},
                textString="TDry"),
              Text(
                extent={{-90,36},{-66,24}},
                lineColor={0,0,127},
                textString="TDewPoi"),
              Text(
                extent={{-92,-74},{-62,-88}},
                lineColor={0,0,127},
                textString="radHorIR"),
              Text(
                extent={{16,-6},{54,-28}},
                lineColor={0,0,255},
                textString="bs"),
              Text(
                extent={{-88,-24},{-64,-36}},
                lineColor={0,0,127},
                textString="nOpa")}));
      end BlackBody;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the black body sky temperature.
</html>"));
    end SkyTemperature;

    package SolarGeometry "Package with models to compute solar geometry"
      extends Modelica.Icons.VariantsPackage;

      package BaseClasses
      "Package with base classes for IDEAS.BoundaryConditions.SolarGeometry"
        extends Modelica.Icons.BasesPackage;

        block AltitudeAngle "Solar altitude angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
            "Zenith angle"
        annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput alt(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar altitude angle"
        annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          alt = (Modelica.Constants.pi/2) - zen;
          annotation (Icon(graphics={Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/AltitudeAngle.png")}),
            defaultComponentName="altAng", Documentation(info="<html>
<p>
This block computes the altitude angle of the sun with respect to a horizontal surface.
The altitude angle is the angle between the sun ray and the projection of the ray
on a horizontal surface.
It is the complementory angle to the zenith angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of the output connector as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
Feb 01, 2012, by Kaustubh Phalak:<br/>
First implementation.
</li>
</ul>
</html>"));
        end AltitudeAngle;

        block Declination "Declination angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput nDay(quantity="Time", unit="s")
            "Day number with units of seconds"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput decAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar declination angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          constant Real k1 = sin(23.45*2*Modelica.Constants.pi/360) "Constant";
          constant Real k2 = 2*Modelica.Constants.pi/365.25 "Constant";
        equation
          decAng = Modelica.Math.asin(-k1 * Modelica.Math.cos((nDay/86400 + 10)*k2))
            "(A4.5)";
          annotation (
            defaultComponentName="decAng",
            Documentation(info="<html>
<p>
This component computes the solar declination, which is
the angle between the equatorial plane and the solar beam.
The input signal <code>nDay</code> is the one-based number of the day, but in seconds.
Hence, during January 1, we should have <code>nDay = 86400</code> seconds.
Since the effect of using a continuous number rather than an integer is small,
we approximate this so that <code>nDay = 0</code> at the start of January 1,
and <code>nDay = 86400</code> at the end of January 1.
</p>
<h4>Validation</h4>
<p>
A validation with a more detailed calculation can be found at
<a href=\"modelica://IDEAS.BoundaryConditions.SolarGeometry.BaseClasses.Examples.Declination\">
IDEAS.BoundaryConditions.SolarGeometry.BaseClasses.Examples.Declination</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 6, 2015, by Michael Wetter:<br/>
Updated documentation and added validation.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/382\">issue 382</a>.
</li>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of output signal as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
November 11, 2015, by Michael Wetter:<br/>
Corrected typo in documentation.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={  Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/Declination.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end Declination;

        block IncidenceAngle "The solar incidence angle on a tilted surface"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle lat "Latitude";
          parameter Modelica.SIunits.Angle azi(displayUnit="deg")
            "Surface azimuth. azi=-90 degree if surface outward unit normal points toward east; azi=0 if it points toward south";
          parameter Modelica.SIunits.Angle til(displayUnit="deg")
            "Surface tilt. til=90 degree for walls; til=0 for ceilings; til=180 for roof";
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
            "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Declination"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}})));
          Modelica.Blocks.Interfaces.RealOutput incAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Incidence angle on a tilted surface"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real dec_c=Modelica.Math.cos(decAng) "Cosine of declination angle";
          Real dec_s=Modelica.Math.sin(decAng) "Sine of declination angle";
          Real sol_c=Modelica.Math.cos(solHouAng) "Cosine of solar hour angle";
          Real sol_s=Modelica.Math.sin(solHouAng) "Sine of solar hour angle";
          Real lat_c=Modelica.Math.cos(lat) "Cosine of latitude";
          Real lat_s=Modelica.Math.sin(lat) "Sine of latitude";
        equation
          incAng = Modelica.Math.acos(Modelica.Math.cos(til)*(dec_c*sol_c*lat_c + dec_s
            *lat_s) + Modelica.Math.sin(til)*(Modelica.Math.sin(azi)*dec_c*sol_s +
            Modelica.Math.cos(azi)*(dec_c*sol_c*lat_s - dec_s*lat_c))) "(A.4.13)";
          annotation (
            defaultComponentName="incAng",
            Documentation(info="<html>
<p>
This component computes the solar incidence angle on a tilted surface using the solar hour angle and the declination angle as input.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IDEAS, issue 912</a>.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 19, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/IncidenceAngle.png"),
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-98,60},{-56,50}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-42},{-42,-54}},
                  lineColor={0,0,127},
                  textString="solHouAng")}));
        end IncidenceAngle;

        block SolarAzimuth "Solar azimuth"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle lat "Latitude";
          Modelica.Blocks.Interfaces.RealInput zen(quantity="Angle", unit="rad")
            "Zenith angle"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
            "Solar time" annotation (Placement(transformation(extent={{-140,-80},{-100,
                    -40}}), iconTransformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealOutput solAzi(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar Azimuth"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Declination angle"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
      protected
          Real arg "cos(solAzi) after data validity check";
          Real tmp "cos(solAzi) before data validity check";
          Real solAziTem "Temporary variable for solar azimuth";
          constant Modelica.SIunits.Time day=86400 "Number of seconds in a day";
          constant Modelica.SIunits.Angle polarCircle = 1.1617
            "Latitude of polar circle (66 degree 33 min 44 sec)";
          final parameter Boolean outsidePolarCircle = lat < polarCircle and lat > -polarCircle
            "Flag, true if latitude is outside polar region";
        equation
          tmp = (Modelica.Math.sin(lat)*Modelica.Math.cos(zen) - Modelica.Math.sin(
            decAng))/(Modelica.Math.cos(lat)*Modelica.Math.sin(zen));
          arg = min(1.0, max(-1.0, tmp));
          solAziTem =  Modelica.Math.acos(arg); // Solar azimuth (A4.9a and b) as a positive number
          if outsidePolarCircle then
            // Outside the polar circle, the only non-differentiability is at night when the sun is set.
            // Hence, we use noEvent.
            if noEvent(solTim - integer(solTim/day)*day < 43200) then
              solAzi =-solAziTem;
            else
              solAzi = solAziTem;
            end if;
          else
            // Inside the polar circle, there is a jump at (solar-)midnight when the sun can
            // be above the horizon. Hence, we do not use noEvent(...)
            if solTim - integer(solTim/day)*day < 43200 then
              solAzi =-solAziTem;
            else
              solAzi = solAziTem;
            end if;
          end if;
          annotation (
            defaultComponentName="solAzi",
            Documentation(info="<html>
<p>
This component computes the solar azimuth angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 13, 2017, by Michael Wetter:<br/>
Reformulated to use equation rather than algorithm section.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/834\">issue 834</a>.
</li>
<li>
July 5, 2012, by Michael Wetter:<br/>
Changed model to avoid an event at solar noon.
</li>
<li>
February 28, 2012, by Wangda Zuo:<br/>
Add solar time conversion since it is removed from <code>solTim</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarAzimuth.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-100,68},{-58,58}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{-102,-54},{-60,-64}},
                  lineColor={0,0,127},
                  textString="solTim"),
                Text(
                  extent={{-102,6},{-60,-4}},
                  lineColor={0,0,127},
                  textString="decAng")}));
        end SolarAzimuth;

        block SolarHourAngle "Solar hour angle"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput solTim(quantity="Time", unit="s")
            "Solar time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput solHouAng(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Solar hour angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          solHouAng = (solTim/3600 - 12)*2*Modelica.Constants.pi/24
            "Our unit is s instead of h in (A4.6)";
          annotation (
            defaultComponentName="solHouAng",
            Documentation(info="<html>
<p>
This component computes the solar hour angle,
which is defined as the angle between the circle
that passes through an observer, the north pole and the south pole,
and the circle that passes through the sun, the north and the south pole.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={  Bitmap(extent={{-90,-90},{90,90}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/SolarHourAngle.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end SolarHourAngle;

        block ZenithAngle "Zenith angle"
          extends Modelica.Blocks.Icons.Block;
          parameter Modelica.SIunits.Angle lat "Latitude";
          Modelica.Blocks.Interfaces.RealInput solHouAng(quantity="Angle", unit="rad")
            "Solar hour angle"
            annotation (Placement(transformation(extent={{-140,-68},{-100,-28}})));
          Modelica.Blocks.Interfaces.RealInput decAng(quantity="Angle", unit="rad")
            "Solar declination angle"
            annotation (Placement(transformation(extent={{-142,34},{-102,74}}),
                iconTransformation(extent={{-140,34},{-100,74}})));
          Modelica.Blocks.Interfaces.RealOutput zen(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Zenith angle"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          zen =  Modelica.Math.acos(Modelica.Math.cos(lat)*Modelica.Math.cos(decAng)*
            Modelica.Math.cos(solHouAng) + Modelica.Math.sin(lat)*Modelica.Math.sin(
            decAng)) "(A4.8)";
          annotation (
            defaultComponentName="zen",
            Documentation(info="<html>
<p>
This component computes the zenith angle, which is the angle between the earth surface normal and the sun's beam.
Input are the solar hour angle and the declination angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 5, 2015, by Michael Wetter:<br/>
Updated comment of the input connector as this is used in the weather bus connector.
This is for
issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">376</a>.
</li>
<li>
Dec 7, 2010, by Michael Wetter:<br/>
Rewrote equation in explicit form to avoid nonlinear equations in room model.
</li>
<li>
May 17, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Bitmap(extent={{-86,-88},{94,92}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/SolarGeometry/BaseClasses/ZenithAngle.png"),
                                      Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-98,62},{-46,46}},
                  lineColor={0,0,127},
                  textString="decAng"),
                Text(
                  extent={{-98,-40},{-22,-58}},
                  lineColor={0,0,127},
                  textString="solHouAng")}));
        end ZenithAngle;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.BoundaryConditions.SolarGeometry\">IDEAS.BoundaryConditions.SolarGeometry</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to compute the solar geometry and incidence
angles on tilted surfaces.
</html>"));
    end SolarGeometry;

    package SolarIrradiation "Package with models to compute solar irradition"
      extends Modelica.Icons.VariantsPackage;

      model RadSol "Block that computes surface-dependent environment data"
        extends Modelica.Blocks.Interfaces.BlockIcon;

        parameter Real rho=0.2 "Ground reflectance";
        parameter Modelica.SIunits.Angle inc(displayUnit="degree") "inclination";
        parameter Modelica.SIunits.Angle azi(displayUnit="degree") "azimuth";
        parameter Modelica.SIunits.Angle lat(displayUnit="degree") "latitude";
        parameter Boolean remDefVals = false "Remove default signal values";
        parameter Boolean outputAngles=true "Set to false when linearising only";

        output Buildings.Components.Interfaces.SolBus solBus(outputAngles=
              outputAngles)
          annotation (Placement(transformation(extent={{80,-20},{120,20}})));

        Modelica.Blocks.Interfaces.RealInput angZen "Zenith angle"
          annotation (Placement(transformation(extent={{-124,-60},{-84,-20}})));
        Modelica.Blocks.Interfaces.RealInput solDifHor
          "Diffuse solar irradiation on horizontal surface"
          annotation (Placement(transformation(extent={{-124,40},{-84,80}})));
        Modelica.Blocks.Interfaces.RealInput solGloHor
          "Global solar irradiation on horizontal surface"
          annotation (Placement(transformation(extent={{-124,60},{-84,100}})));
        Modelica.Blocks.Interfaces.RealInput F1 "Circumsolar brightening coefficient"
          annotation (Placement(transformation(extent={{-124,-100},{-84,-60}})));
        Modelica.Blocks.Interfaces.RealInput F2 "Horizon brightening coefficient"
          annotation (Placement(transformation(extent={{-124,-120},{-84,-80}})));
        Modelica.Blocks.Interfaces.RealInput solDirPer
          "Beam solar irradiation on surface perpendicular to beam direction"
          annotation (Placement(transformation(extent={{-124,80},{-84,120}})));
        Modelica.Blocks.Interfaces.RealInput angHou "Hour angle"
          annotation (Placement(transformation(extent={{-124,-40},{-84,0}})));
        Modelica.Blocks.Interfaces.RealInput angDec "Declination angle"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=0,
              origin={-104,0})));
        Modelica.Blocks.Interfaces.RealInput solTim "Solar time" annotation (
            Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=0,
              origin={-104,30})));
        SolarGeometry.BaseClasses.IncidenceAngle incAng(
          lat=lat,
          azi=azi,
          til=inc) "Inclination angle"
          annotation (Placement(transformation(extent={{-40,60},{-20,40}})));
        SolarIrradiation.BaseClasses.DiffusePerez HDifTil(rho=rho, til=inc)
          "Computation of diffuse solar irradiation on tilted surface"
          annotation (Placement(transformation(extent={{0,-20},{20,0}})));

        Modelica.Blocks.Interfaces.RealInput winSpe "Wind speed" annotation (
            Placement(transformation(
              extent={{20,-20},{-20,20}},
              rotation=90,
              origin={-60,120})));
        Modelica.Blocks.Interfaces.RealInput winDir "Wind direction" annotation (
            Placement(transformation(
              extent={{20,-20},{-20,20}},
              rotation=90,
              origin={-20,120})));
    protected
        SolarIrradiation.BaseClasses.DirectTiltedSurface
                              solDirTil
          "Computation of direct solar irradiation on tilted surface"
          annotation (Placement(transformation(extent={{0,20},{20,40}})));
        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.ExtConvForcedCoeff
          extConvCoeff(final inc=inc, final azi=azi)
          "Calculate coefficient for forced convection for exterior surface"
          annotation (Placement(transformation(extent={{20,60},{40,80}})));

        Modelica.Blocks.Sources.Constant dummyValAzi(k=0) if not remDefVals
          "angAzi dummy value when not needed"
          annotation (Placement(transformation(extent={{48,-98},{60,-86}})));
        Modelica.Blocks.Sources.Constant dummyValTenv(k=Modelica.Constants.inf) if
                                                           not remDefVals
          "Tenv dummy value when not needed"
          annotation (Placement(transformation(extent={{48,-76},{60,-64}})));


      equation
        connect(angZen, solBus.angZen) annotation (Line(points={{-104,-40},{100.1,-40},
                {100.1,0.1}}, color={0,0,127}));
        connect(dummyValAzi.y, solBus.angAzi) annotation (Line(
            points={{60.6,-92},{100.1,-92},{100.1,0.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(dummyValTenv.y, solBus.Tenv) annotation (Line(
            points={{60.6,-70},{100.1,-70},{100.1,0.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solDirTil.HDirNor, solDirPer) annotation (Line(points={{-2,36},{-8,36},
                {-8,100},{-104,100}}, color={0,0,127}));
        connect(incAng.incAng, solBus.angInc) annotation (Line(points={{-19,50},{
                100.1,50},{100.1,0.1}}, color={0,0,127}));
        connect(incAng.decAng, angDec) annotation (Line(points={{-42.2,44.6},{-62,44.6},
                {-62,0},{-104,0}},       color={0,0,127}));
        connect(incAng.solHouAng, angHou) annotation (Line(points={{-42,54.8},{-60,54.8},
                {-60,46},{-60,-20},{-104,-20}},       color={0,0,127}));
        connect(HDifTil.HGloHor, solGloHor) annotation (Line(points={{-2,-2},{-46,-2},
                {-46,80},{-104,80}}, color={0,0,127}));
        connect(HDifTil.HDifHor, solDifHor) annotation (Line(points={{-2,-5},{-48,-5},
                {-48,60},{-104,60}}, color={0,0,127}));
        connect(HDifTil.briCof2, F2) annotation (Line(points={{-2,-11},{-48,-11},{-48,
                -32},{-48,-100},{-104,-100}}, color={0,0,127}));
        connect(HDifTil.briCof1, F1) annotation (Line(points={{-2,-8},{-50,-8},{-50,
                -80},{-104,-80}}, color={0,0,127}));
        connect(HDifTil.incAng, incAng.incAng) annotation (Line(points={{-2,-17},{-14,
                -17},{-14,50},{-19,50}}, color={0,0,127}));
        connect(HDifTil.zen, angZen) annotation (Line(points={{-2,-14},{-2,-16},{-52,
                -16},{-52,-40},{-104,-40}}, color={0,0,127}));
        connect(HDifTil.HSkyDifTil, solBus.HSkyDifTil) annotation (Line(points={{21,
                -6},{100.1,-6},{100.1,0.1}}, color={0,0,127}));
        connect(HDifTil.HGroDifTil, solBus.HGroDifTil) annotation (Line(points={{21,
                -14},{36,-14},{100.1,-14},{100.1,0.1}}, color={0,0,127}));
        connect(solDirTil.HDirTil, solBus.HDirTil) annotation (Line(points={{21,30},{
                100.1,30},{100.1,0.1}}, color={0,0,127}));
        connect(extConvCoeff.hForcedConExt, solBus.hForcedConExt) annotation (Line(points={{41,70},
                {60,70},{60,0.1},{100.1,0.1}},        color={0,0,127}));
        connect(extConvCoeff.winSpe, winSpe)
          annotation (Line(points={{18,74},{-60,74},{-60,120}}, color={0,0,127}));
        connect(extConvCoeff.winDir, winDir)
          annotation (Line(points={{18,66},{-20,66},{-20,120}}, color={0,0,127}));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}})),  Icon(coordinateSystem(extent={{-100,-120},{100,
                  100}}),                   graphics={
              Polygon(
                points={{-90,-80},{-40,-40},{40,-40},{90,-80},{-90,-80}},
                lineColor={95,95,95},
                smooth=Smooth.None),
              Polygon(
                points={{16,-46},{22,-72},{-72,-4},{-18,-22},{16,-46}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Ellipse(
                extent={{88,84},{40,38}},
                lineColor={255,255,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid)}),
          Documentation(revisions="<html>
<ul>
<li>
November 28, 2019, by Ian Beausoleil-Morrison:<br/>
Add RealInput's for wind speed and wind direction.<br/>
Instantiate extConvForcedCoeff.mo and place resulting coefficient for forced convection on SolBus.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1089\">
#1089</a>
</li>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Added input <code>solTim</code> for azimuth computations.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/753\">
#753</a>.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
September 22, 2016 by Filip Jorissen:<br/>
Reworked implementation such that we use Annex 60 baseclasses.
</li>
<li>
March 25, 2016 by Filip Jorissen:<br/>
Reworked radSol implementation to use RealInputs instead of weaBus.
This simplifies translation and interpretation.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>"));
      end RadSol;

      model RadSolData "Selects or generates correct solar data for this surface"
        parameter Modelica.SIunits.Angle inc "inclination";
        parameter Modelica.SIunits.Angle azi "azimuth";
        parameter Modelica.SIunits.Angle lat "latitude";
        parameter Boolean useLinearisation = false
          "Set to true if used for linearisation";
        parameter Integer numIncAndAziInBus "Number of pre-computed combination of inc and azi for solar radiation";
        parameter Modelica.SIunits.Angle[numIncAndAziInBus,2] incAndAziInBus "Combination of {inclination, azimuth} for which the solar data is available in weaBus.";
        parameter Boolean outputAngles=true "Set to false when linearising only";

        input IDEAS.Buildings.Components.Interfaces.WeaBus
          weaBus(numSolBus=numIncAndAziInBus,
              outputAngles=outputAngles)
          annotation (HideResults=true,Placement(transformation(extent={{90,70},{110,90}})));

        Modelica.Blocks.Interfaces.RealOutput HDirTil
          "Direct solar irradiation on a tilted surface"
          annotation (Placement(transformation(extent={{96,30},{116,50}})));
        Modelica.Blocks.Interfaces.RealOutput HGroDifTil
          "Diffuse sky solar irradiance on a tilted surface"
          annotation (Placement(transformation(extent={{96,-10},{116,10}})));
        Modelica.Blocks.Interfaces.RealOutput HSkyDifTil
          "Diffuse sky solar irradiance on a tilted surface"
          annotation (Placement(transformation(extent={{96,10},{116,30}})));
        Modelica.Blocks.Interfaces.RealOutput angInc
          annotation (Placement(transformation(extent={{96,-50},{116,-30}})));
        Modelica.Blocks.Interfaces.RealOutput angZen
          annotation (Placement(transformation(extent={{96,-70},{116,-50}})));
        Modelica.Blocks.Interfaces.RealOutput angAzi
          annotation (Placement(transformation(extent={{96,-90},{116,-70}})));
        Modelica.Blocks.Interfaces.RealOutput angHou "Hour angle"
          annotation (Placement(transformation(extent={{96,-110},{116,-90}})));
        Modelica.Blocks.Interfaces.RealOutput Tenv "Environment temperature"
          annotation (Placement(transformation(extent={{96,-30},{116,-10}})));
        Modelica.Blocks.Interfaces.RealOutput hForcedConExt
          "Forced flow convection coefficient at an external surface"
          annotation (Placement(transformation(extent={{96,-132},{116,-112}})));
    protected
        final parameter Integer numMatches=
          sum( {if     IDEAS.Utilities.Math.Functions.isAngle(incAndAziInBus[i,1],inc)
                   and IDEAS.Utilities.Math.Functions.isAngle(incAndAziInBus[i,2],azi)
                then 1
                else 0 for i in 1:numIncAndAziInBus});
        final parameter Boolean solDataInBus = numMatches==1
          "True if the {inc,azi} combination is found in incAndAziInBus" annotation(Evaluate=true);
        final parameter Integer solDataIndex=
          sum( {if     IDEAS.Utilities.Math.Functions.isAngle(incAndAziInBus[i,1],inc)
                   and IDEAS.Utilities.Math.Functions.isAngle(incAndAziInBus[i,2],azi)
                then i
                else 0 for i in 1:numIncAndAziInBus})
          "Index of the {inc,azi} combination in incAndAziInBus" annotation(Evaluate=true);
        IDEAS.BoundaryConditions.SolarIrradiation.ShadedRadSol radSol(
          final inc=inc,
          final azi=azi,
          lat=lat,
          outputAngles=outputAngles) if
                            not solDataInBus
          "determination of incident solar radiation on wall based on inclination and azimuth"
          annotation (Placement(transformation(extent={{-80,20},{-60,40}})));

        output Buildings.Components.Interfaces.SolBus
                                               solBusDummy(outputAngles=outputAngles)
          "Required for avoiding warnings?"
                                           annotation (HideResults=true, Placement(
              transformation(extent={{-60,10},{-20,50}})));

        Modelica.Blocks.Sources.Constant constAngLin(k=1) if
                                                       solDataInBus and not outputAngles
          "Dummy inputs when linearising. This avoids unnecessary state space inputs."
          annotation (Placement(transformation(extent={{-100,-70},{-80,-50}})));
      equation
          assert(numMatches<=1, "In "+getInstanceName()+
            ": The parameter sim.incAndAziInBus contains duplicates. 
      This is not allowed. Remove the duplicate entry.");
          assert( not useLinearisation or (useLinearisation and solDataInBus), "The solar data must come
      from the weabus when the model is linearised. Add the combination {inc,azi} = {"      +String(inc)+","+String(azi)+"}
      to the parameter incAndAziInBus of the SimInfoManager.");
        connect(radSol.solBus, solBusDummy) annotation (Line(
            points={{-60,30},{-40,30}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        if solDataInBus then
          connect(weaBus.solBus[solDataIndex], solBusDummy) annotation (Line(
            points={{100.05,80.05},{-40,80.05},{-40,30}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        end if;
        connect(HDirTil, solBusDummy.HDirTil) annotation (Line(
            points={{106,40},{-39.9,40},{-39.9,30.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(Tenv, solBusDummy.Tenv) annotation (Line(
            points={{106,-20},{-39.9,-20},{-39.9,30.1}},
            color={0,0,127},
            smooth=Smooth.None));
        if not (solDataInBus and not outputAngles) then
        connect(angInc, solBusDummy.angInc) annotation (Line(
            points={{106,-40},{-40,-40},{-40,-42},{-39.9,-42},{-39.9,30.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(angZen, solBusDummy.angZen) annotation (Line(
            points={{106,-60},{-39.9,-60},{-39.9,30.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(angAzi, solBusDummy.angAzi) annotation (Line(
            points={{106,-80},{-39.9,-80},{-39.9,30.1}},
            color={0,0,127},
            smooth=Smooth.None));
        end if;
        connect(radSol.TePow4, weaBus.TePow4) annotation (Line(points={{-64,41.8},{
                -64,54},{100.05,54},{100.05,80.05}},
                                        color={0,0,127}));
        connect(radSol.TskyPow4, weaBus.TskyPow4) annotation (Line(points={{-68,42},{
                -68,56},{100.05,56},{100.05,80.05}},
                                             color={0,0,127}));
        connect(radSol.solDirPer, weaBus.solDirPer) annotation (Line(points={{-80.4,40},
                {-80.4,58},{100.05,58},{100.05,80.05}},
                                               color={0,0,127}));
        connect(radSol.solGloHor, weaBus.solGloHor) annotation (Line(points={{-80.4,38},
                {-82,38},{-82,60},{100.05,60},{100.05,80.05}}, color={0,0,127}));
        connect(radSol.solDifHor, weaBus.solDifHor) annotation (Line(points={{-80.4,36},
                {-84,36},{-84,62},{100.05,62},{100.05,80.05}},
                                                      color={0,0,127}));
        connect(radSol.angDec, weaBus.angDec) annotation (Line(points={{-80.4,30},{-88,
                30},{-88,66},{100.05,66},{100.05,80.05}},
                                                 color={0,0,127}));
        connect(radSol.angHou, weaBus.angHou) annotation (Line(points={{-80.4,28},{-90,
                28},{-90,68},{100.05,68},{100.05,80.05}},
                                                 color={0,0,127}));
        connect(radSol.angZen, weaBus.angZen) annotation (Line(points={{-80.4,26},{-92,
                26},{-92,70},{100.05,70},{100.05,80.05}},
                                                 color={0,0,127}));
        connect(radSol.F1, weaBus.F1) annotation (Line(points={{-80.4,22},{-94,22},{-94,
                72},{100.05,72},{100.05,80.05}},
                                        color={0,0,127}));
        connect(radSol.F2, weaBus.F2) annotation (Line(points={{-80.4,20},{-96,20},{-96,
                74},{100.05,74},{100.05,80.05}},
                                        color={0,0,127}));
          connect(constAngLin.y, angInc) annotation (Line(points={{-79,-60},{-78,-60},{-78,
                -40},{106,-40}}, color={0,0,127}));
        connect(constAngLin.y, angZen)
          annotation (Line(points={{-79,-60},{-78,-60},{106,-60}}, color={0,0,127}));
        connect(constAngLin.y, angAzi)
                                      annotation (Line(points={{-79,-60},{-78,-60},{-78,
                -80},{106,-80}}, color={0,0,127}));
        connect(HSkyDifTil, solBusDummy.HSkyDifTil) annotation (Line(points={{106,20},
                {-39.9,20},{-39.9,30.1}}, color={0,0,127}));
        connect(HGroDifTil, solBusDummy.HGroDifTil) annotation (Line(points={{106,0},
                {-39.9,0},{-39.9,30.1}}, color={0,0,127}));
        connect(angHou, weaBus.angHou) annotation (Line(points={{106,-100},{80,-100},
                {80,80.05},{100.05,80.05}}, color={0,0,127}));
        connect(radSol.solTim, weaBus.solTim) annotation (Line(points={{-80.4,33},{-86,
                33},{-86,64},{100.05,64},{100.05,80.05}},
                                                      color={0,0,127}));
        connect(hForcedConExt, solBusDummy.hForcedConExt) annotation (Line(points={{106,
                -122},{-39.9,-122},{-39.9,30.1}},
                                           color={0,0,127}));
        connect(radSol.winDir, weaBus.Vdir) annotation (Line(points={{-72,42},{-72,
                80.05},{100.05,80.05}},                          color={0,0,127}));
        connect(radSol.winSpe, weaBus.Va) annotation (Line(points={{-76,42},{-76,76},
                {100,76},{100,80.05},{100.05,80.05}},                          color=
                {0,0,127}));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -140},{120,100}})),           Documentation(info="<html>
<p>
This model usually takes the appropriate solar data from the bus. 
If the correct data is not contained by the bus, custom solar data is calculated.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 28, 2019 by Ian Beausoleil-Morrison:<br/>
Add RealOutput for coefficient for forced convection and get this from SolBus.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1089\">
#1089</a>
</li>
<li>
August 9, 2018 by Filip Jorissen:<br/>
Revised implementation for checking solData index and added 
assert to avoid duplicate entries in <code>incAndAziInBus</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/881\">
#881</a>.
</li>
<li>
March 26, 2018 by Iago Cupeiro &amp; Damien Picard:<br/>
Solved bug in linearisation
</li>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Added <code>solTim</code> connection for revised azimuth computations.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/753\">
#753</a>.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
March 25, 2016 by Filip Jorissen:<br/>
Reworked radSol implementation to use RealInputs instead of weaBus.
This simplifies translation and interpretation.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
      end RadSolData;

      model ShadedRadSol "Block that computes surface-dependent environment data"
        extends IDEAS.BoundaryConditions.SolarIrradiation.RadSol(
          final remDefVals = true);

        Modelica.Blocks.Interfaces.RealInput TskyPow4
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=270,
              origin={20,120})));
        Modelica.Blocks.Interfaces.RealInput TePow4
          annotation (Placement(transformation(extent={{-18,-18},{18,18}},
              rotation=270,
              origin={60,118})));
        IDEAS.BoundaryConditions.SolarGeometry.BaseClasses.SolarAzimuth solAzi(lat=lat) "Solar azimuth angle"
          annotation (Placement(transformation(extent={{36,-18},{56,-38}})));
        Modelica.Blocks.Math.Add relAzi(k2=-1)
          "Azimuth angle relative to surface azimuth"
          annotation (Placement(transformation(extent={{68,-52},{88,-32}})));
        Modelica.Blocks.Sources.Constant surfAzi(k=azi) "Surface azimuth angle"
          annotation (Placement(transformation(extent={{-20,-54},{-8,-42}})));


    protected
        final parameter Real Fssky=(1 + cos(inc))/2
          "radiant-interchange configuration factor between surface and sky";
        final parameter Real beta = cos(inc/2)
          "Additional factor for taking into account the line of sight through the atmosphere";
        final parameter Real coeffSky = Fssky*beta
          "Dummy parameter for speeding up computations";
        final parameter Real coeffEnv = 1-Fssky*beta
          "Dummy parameter for speeding up computations";

        Modelica.Blocks.Sources.RealExpression TenvExpr(
          y=(coeffSky*TskyPow4 + coeffEnv*TePow4)^0.25)
          "Environment temperature"
          annotation (Placement(transformation(extent={{0,70},{60,90}})));


      equation
        connect(TenvExpr.y, solBus.Tenv) annotation (Line(
            points={{63,80},{100.1,80},{100.1,0.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(solDirTil.incAng, incAng.incAng) annotation (Line(points={{-2,24},{
                -14,24},{-14,50},{-19,50}}, color={0,0,127}));
        connect(solAzi.zen, angZen) annotation (Line(points={{34,-34},{34,-40},{-104,
                -40}},       color={0,0,127}));
        connect(surfAzi.y, relAzi.u2)
          annotation (Line(points={{-7.4,-48},{66,-48}}, color={0,0,127}));
        connect(relAzi.u1, solAzi.solAzi) annotation (Line(points={{66,-36},{60,-36},
                {60,-28},{57,-28}},color={0,0,127}));
        connect(solAzi.solTim, solTim) annotation (Line(points={{34,-22},{-64,-22},{
                -64,30},{-104,30}},
                                color={0,0,127}));
        connect(relAzi.y, solBus.angAzi) annotation (Line(points={{89,-42},{100.1,-42},
                {100.1,0.1}}, color={0,0,127}));
        connect(solAzi.decAng, angDec) annotation (Line(points={{34,-28},{-62,-28},{
                -62,0},{-104,0}},
                              color={0,0,127}));
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}})),  Icon(coordinateSystem(preserveAspectRatio=false,
                extent={{-100,-100},{100,100}}),
                                            graphics={
              Polygon(
                points={{-90,-80},{-40,-40},{40,-40},{90,-80},{-90,-80}},
                lineColor={95,95,95},
                smooth=Smooth.None),
              Polygon(
                points={{16,-46},{22,-72},{-72,-4},{-18,-22},{16,-46}},
                lineColor={0,0,0},
                smooth=Smooth.None,
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Ellipse(
                extent={{88,84},{40,38}},
                lineColor={255,255,0},
                fillColor={255,255,0},
                fillPattern=FillPattern.Solid)}),
          Documentation(revisions="<html>
<ul>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Revised azimuth angle computation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/753\">
#753</a>.
</li>
<li>
January 20, 2017 by Filip Jorissen:<br/>
Changed computation of Tenv.
See issue 
<a href=https://github.com/open-ideas/IDEAS/issues/623>#623</a>.
</li>
<li>
September 22, 2016 by Filip Jorissen:<br/>
Reworked implementation such that we use Annex 60 baseclasses.
</li>
<li>
March 25, 2016 by Filip Jorissen:<br/>
Reworked radSol implementation to use RealInputs instead of weaBus.
This simplifies translation and interpretation.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>",       info="<html>
<p>
Model of equivalent radiative temperature is according to page 73 in
</p>
<p>
Walton, G. N. 1983. Thermal Analysis Research Program Reference Manual. NBSSIR 83-2655. National Bureau of Standards
</p>
</html>"));
      end ShadedRadSol;

      package BaseClasses
      "Package with base classes for IDEAS.BoundaryConditions.SolarIrradiation"
        extends Modelica.Icons.BasesPackage;

        block BrighteningCoefficient "Circumsolar and horizon brightening coefficients"
          extends Modelica.Blocks.Icons.Block;
          import H = IDEAS.Utilities.Math.Functions.regStep;
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput skyCle
            "Sky clearness. skyCle=1: overcast sky; skyCle=8 clear sky"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealInput skyBri "Sky brightness [0,1]"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput F1
            "Circumsolar brightening coefficient"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));
          Modelica.Blocks.Interfaces.RealOutput F2 "Horizon brightening coefficient"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
      protected
          Real F11;
          Real F12;
          Real F13;
          Real F21;
          Real F22;
          Real F23;
          Real d=0.01;
          Real a1;
          Real a2;
          Real a3;
          Real a4;
          Real a5;
          Real a6;
          Real a7;
          Real a8;
          Real b1;
          Real b2;
          Real b3;
          Real b4;
          Real b5;
          Real b6;
          Real b7;
          Real b8;
        equation
          b1 = H(
            y1=1,
            y2=0,
            x=1.065 - skyCle,
            x_small=d);
          b2 = H(
            y1=1,
            y2=0,
            x=1.23 - skyCle,
            x_small=d);
          b3 = H(
            y1=1,
            y2=0,
            x=1.50 - skyCle,
            x_small=d);
          b4 = H(
            y1=1,
            y2=0,
            x=1.95 - skyCle,
            x_small=d);
          b5 = H(
            y1=1,
            y2=0,
            x=2.80 - skyCle,
            x_small=d);
          b6 = H(
            y1=1,
            y2=0,
            x=4.50 - skyCle,
            x_small=d);
          b7 = H(
            y1=1,
            y2=0,
            x=6.20 - skyCle,
            x_small=d);
          b8 = H(
            y1=1,
            y2=0,
            x=skyCle - 6.20,
            x_small=d);
          a1 = b1;
          a2 = b2 - b1;
          a3 = b3 - b2;
          a4 = b4 - b3;
          a5 = b5 - b4;
          a6 = b6 - b5;
          a7 = b7 - b6;
          a8 = b8;
          F11 = -0.0083117*a1 + 0.1299457*a2 + 0.3296958*a3 + 0.5682053*a4 + 0.8730280*
            a5 + 1.1326077*a6 + 1.0601591*a7 + 0.6777470*a8;
          F12 = 0.5877285*a1 + 0.6825954*a2 + 0.4868735*a3 + 0.1874525*a4 - 0.3920403*
            a5 - 1.2367284*a6 - 1.5999137*a7 - 0.3272588*a8;
          F13 = -0.0620636*a1 - 0.1513725*a2 - 0.2210958*a3 - 0.2951290*a4 - 0.3616149*
            a5 - 0.4118494*a6 - 0.3589221*a7 - 0.2504286*a8;
          F21 = -0.0596012*a1 - 0.0189325*a2 + 0.0554140*a3 + 0.1088631*a4 + 0.2255647*
            a5 + 0.2877813*a6 + 0.2642124*a7 + 0.1561313*a8;
          F22 = 0.0721249*a1 + 0.0659650*a2 - 0.0639588*a3 - 0.1519229*a4 - 0.4620442*
            a5 - 0.8230357*a6 - 1.1272340*a7 - 1.3765031*a8;
          F23 = -0.0220216*a1 - 0.0288748*a2 - 0.0260542*a3 - 0.0139754*a4 + 0.0012448*
            a5 + 0.0558651*a6 + 0.1310694*a7 + 0.2506212*a8;
          F1 = IDEAS.Utilities.Math.Functions.smoothMax(
            0,
            F11 + F12*skyBri + F13*zen,
            0.01);
          F2 = F21 + F22*skyBri + F23*zen;
          annotation (
            defaultComponentName="briCoe",
            Documentation(info="<html>
<p>
This component computes the circumsolar and horizon brightening coefficients.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IDEAS, issue 912</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
May 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-96,72},{-52,50}},
                  lineColor={0,0,127},
                  textString="skyCle"),
                Text(
                  extent={{-96,14},{-52,-8}},
                  lineColor={0,0,127},
                  textString="skyBri"),
                Text(
                  extent={{-96,-46},{-52,-68}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{62,50},{106,28}},
                  lineColor={0,0,127},
                  textString="F1"),
                Text(
                  extent={{60,-30},{104,-52}},
                  lineColor={0,0,127},
                  textString="F2")}));
        end BrighteningCoefficient;

        block DiffusePerez
          "Hemispherical diffuse irradiation on a tilted surface with Perez's anisotropic model"
          extends Modelica.Blocks.Icons.Block;
          parameter Real rho=0.2 "Ground reflectance";
          parameter Modelica.SIunits.Angle til(displayUnit="deg") "Surface tilt angle";
          Modelica.Blocks.Interfaces.RealInput briCof1 "Brightening Coeffcient F1"
            annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
          Modelica.Blocks.Interfaces.RealInput briCof2 "Brightening Coeffcient F2"
            annotation (Placement(transformation(extent={{-140,-30},{-100,10}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Diffuse horizontal solar radiation"
            annotation (Placement(transformation(extent={{-140,30},{-100,70}})));
          Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2") "Global horizontal radiation"
            annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput incAng(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Solar incidence angle on the surface"
            annotation (Placement(transformation(extent={{-140,-90},{-100,-50}})));
          Modelica.Blocks.Interfaces.RealOutput HGroDifTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Hemispherical diffuse solar irradiation on a tilted surface from the ground"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
          Modelica.Blocks.Interfaces.RealOutput HSkyDifTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Hemispherical diffuse solar irradiation on a tilted surface from the sky"
            annotation (Placement(transformation(extent={{100,30},{120,50}})));
      protected
          Real a;
          Real b;
          constant Real bMin=Modelica.Math.cos(Modelica.Constants.pi*85/180)
            "Lower bound for b";
        equation
          a = IDEAS.Utilities.Math.Functions.smoothMax(
            0,
            Modelica.Math.cos(incAng),
            0.01);
          b = IDEAS.Utilities.Math.Functions.smoothMax(
            bMin,
            Modelica.Math.cos(zen),
            0.01);
          HSkyDifTil = HDifHor*(0.5*(1 - briCof1)*(1 + Modelica.Math.cos(til)) +
            briCof1*a/b + briCof2*Modelica.Math.sin(til));
          HGroDifTil = HGloHor*0.5*rho*(1 - Modelica.Math.cos(til));
          annotation (
            defaultComponentName="HDifTil",
            Documentation(info="<html>
<p>
This component computes the hemispherical diffuse irradiation on a tilted surface by using an anisotropic model proposed by Perez.
</p>
<h4>References</h4>
<ul>
<li>
P. Ineichen, R. Perez and R. Seals (1987).
<i>The Importance of Correct Albedo Determination for Adequately Modeling Energy Received by Tilted Surface</i>,
Solar Energy, 39(4): 301-305.
</li>
<li>
R. Perez, R. Seals, P. Ineichen, R. Stewart and D. Menicucci (1987).
<i>A New Simplified Version of the Perez Diffuse Irradiance Model for Tilted Surface</i>,
Solar Energy, 39(3): 221-231.
</li>
<li>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</li>
</ul>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IDEAS, issue 912</a>.
</li>
<li>
June 6, 2012, by Wangda Zuo:<br/>
Separated the contribution from the sky and the ground.
</li>
</ul>
<ul>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-48,74},{-100,86}},
                  lineColor={0,0,127},
                  textString="HGloHor"),
                Text(
                  extent={{-50,44},{-102,56}},
                  lineColor={0,0,127},
                  textString="HDifHor"),
                Text(
                  extent={{-50,14},{-102,26}},
                  lineColor={0,0,127},
                  textString="briCof1"),
                Text(
                  extent={{-50,-16},{-102,-4}},
                  lineColor={0,0,127},
                  textString="briCof2"),
                Text(
                  extent={{-50,-46},{-102,-34}},
                  lineColor={0,0,127},
                  textString="zen"),
                Text(
                  extent={{-52,-76},{-104,-64}},
                  lineColor={0,0,127},
                  textString="incAng")}));
        end DiffusePerez;

        block DirectTiltedSurface "Direct solar irradiation on a tilted surface"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput incAng(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Incidence angle of the sun beam on a tilted surface"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput HDirNor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2") "Direct normal radiation"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput HDirTil(final quantity=
                "RadiantEnergyFluenceRate", final unit="W/m2")
            "Direct solar irradiation on a tilted surface"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          HDirTil =  max(0, Modelica.Math.cos(incAng)*HDirNor);
          annotation (
            defaultComponentName="HDirTil",
            Documentation(info="<html>
<p>
This component computes the direct solar irradiation on a tilted surface.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IDEAS, issue 912</a>.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
May 24, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-50,56},{-102,68}},
                  lineColor={0,0,127},
                  textString="HDirNor"),
                Text(
                  extent={{-54,-66},{-106,-54}},
                  lineColor={0,0,127},
                  textString="incAng")}));
        end DirectTiltedSurface;

        block RelativeAirMass "Relative air mass"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="deg") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relAirMas "Relative air mass"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real zenLim "Zenith angle bounded from above by 90 degree";
          Real zenDeg "Zenith angle in degree";
        equation
          zenLim = IDEAS.Utilities.Math.Functions.smoothMin(
            zen,
            Modelica.Constants.pi/2,
            0.01);
          zenDeg = zenLim*180/Modelica.Constants.pi;
          relAirMas = 1/(Modelica.Math.cos(zenLim) + 0.15*(93.9 - zenDeg)^(-1.253));
          annotation (
            defaultComponentName="relAirMas",
            Documentation(info="<html>
<p>
This component computes the relative air mass for sky brightness.
</p>
<h4>References</h4>
R. Perez (1999).
<i>Fortran Function irrpz.f</i>,
Emailed by R. Perez to F.C. Winkelmann on May 21, 1999.<br/>
</html>",         revisions="<html>
<ul>
<li>
April 27, 2018, by Michael Wetter:<br/>
Corrected <code>displayUnit</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/912\">IDEAS, issue 912</a>.
</li>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end RelativeAirMass;

        block SkyBrightness "Sky brightness"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput relAirMas "Relative air mass"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal diffuse solar radiation"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealOutput skyBri "Sky brightness"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          skyBri = IDEAS.Utilities.Math.Functions.smoothMin(
            HDifHor*relAirMas/1367,
            1,
            0.025);
          annotation (
            defaultComponentName="skyBri",
            Documentation(info="<html>
<p>
This component computes the sky brightness.
</p>
<h4>References</h4>
R. Perez, P. Ineichen, R. Seals, J. Michalsky and R. Stewart (1990).
<i>Modeling Dyalight Availability and Irradiance Componets From Direct and Global Irradiance</i>,
Solar Energy, 44(5):271-289.
</html>",         revisions="<html>
<ul>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-44,36},{-96,48}},
                  lineColor={0,0,127},
                  textString="relAirMas"),
                Text(
                  extent={{-44,-46},{-96,-34}},
                  lineColor={0,0,127},
                  textString="HDifHor")}));
        end SkyBrightness;

        block SkyClearness "Sky clearness"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput zen(
            quantity="Angle",
            unit="rad",
            displayUnit="degreeC") "Zenith angle of the sun beam"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealInput HDifHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal diffuse solar radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealInput HGloHor(quantity=
                "RadiantEnergyFluenceRate", unit="W/m2")
            "Horizontal global solar radiation"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput skyCle
            "Sky clearness. skyCle=1: overast sky; skyCle=8: clear sky"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          // Set hSmall so that hSmall + deltaX < 1E-4. See info section.
      protected
          constant Modelica.SIunits.Irradiance hSmall = 0.5e-4
            "Small radiation for regularization";
          constant Modelica.SIunits.Irradiance deltaX = hSmall/2
            "Small radiation for regularization";
          constant Real k = 5.534e-6*(180/Modelica.Constants.pi)^3 "Constant factor";
          Real tmp1 "Intermediate variable";
          Modelica.SIunits.Irradiance HDifHorBou
            "Diffuse horizontal irradiation, bounded away from zero";
        equation
          tmp1 =  k*zen^3;
          HDifHorBou = IDEAS.Utilities.Math.Functions.smoothMax(
                         x1 = HDifHor,
                         x2 = hSmall,
                         deltaX = deltaX);
          // In the Buildings library, HGloHor is always larger than 1E-4
          // (minus some small undershoot due to regularization. Hence,
          // it makes no sense to simplify the equation for
          // HGloHor < Modelica.Constants.small.
          skyCle = IDEAS.Utilities.Math.Functions.smoothLimit(
                x = (HGloHor/HDifHorBou + tmp1)/(1 + tmp1),
                l = 1,
                u = 8,
                deltaX = 0.01);
          annotation (
            defaultComponentName="skyCle",
            Documentation(info="<html>
<p>
This component computes the sky clearness.
</p>
<h4>Implementation</h4>
<p>
In the <code>IDEAS</code> library, <code>HGloHor</code>
is always larger than <i>1E-4</i>,
minus some small undershoot due to regularization. Hence,
the implementation is not simplified for
<code>HGloHor &lt; Modelica.Constants.small</code>.
</p>
<p>
The function call
<code>IDEAS.Utilities.Math.Functions.smoothMax</code>
is such that the regularization is usually not triggered.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 23, 2016, by Michael Wetter:<br/>
Changed <code>deltaX</code> from <code>0.1</code> to <code>0.01</code>,
and also optimized the code.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/521\">issue 521</a>.
</li>
<li>
May 5, 2015, by Michael Wetter:<br/>
Introduced constant <code>k</code> to reduce number of operations.
</li>
<li>
May 5, 2015, by Filip Jorissen:<br/>
Converted <code>algorithm</code> section into
<code>equation</code> section for easier differentiability.
</li>
<li>
July 07, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-48,-6},{-100,6}},
                  lineColor={0,0,127},
                  textString="HDifHor"),
                Text(
                  extent={{-48,54},{-100,66}},
                  lineColor={0,0,127},
                  textString="HGloHor"),
                Text(
                  extent={{-48,-66},{-100,-54}},
                  lineColor={0,0,127},
                  textString="zen")}));
        end SkyClearness;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.BoundaryConditions.SolarIrradiation\">IDEAS.BoundaryConditions.SolarIrradiation</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models that compute the solar irradiation
with different sky models.
</html>"));
    end SolarIrradiation;

    package WeatherData "Weather data reader"
      extends Modelica.Icons.VariantsPackage;

      expandable connector Bus "Data bus that stores weather data"
        extends Modelica.Icons.SignalBus;
        annotation (
          defaultComponentName="weaBus",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-20,2},{22,-2}},
                lineColor={255,204,51},
                lineThickness=0.5)}),
          Documentation(info="<html>
<p>
This component is an expandable connector that is used to implement a bus that contains the weather data.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Bus;

      block ReaderTMY3 "Reader for TMY3 weather data"

        parameter Boolean computeWetBulbTemperature = true
          "If true, then this model computes the wet bulb temperature"
          annotation(Evaluate=true);
        //--------------------------------------------------------------
        // Atmospheric pressure
        parameter IDEAS.BoundaryConditions.Types.DataSource pAtmSou=IDEAS.BoundaryConditions.Types.DataSource.Parameter
          "Atmospheric pressure"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Pressure pAtm=101325
          "Atmospheric pressure (used if pAtmSou=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput pAtm_in(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="Pa") if (pAtmSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input pressure"
          annotation (Placement(transformation(extent={{-240,254},{-200,294}}),
              iconTransformation(extent={{-240,254},{-200,294}})));
        //--------------------------------------------------------------
        // Ceiling height
        parameter IDEAS.BoundaryConditions.Types.DataSource ceiHeiSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Ceiling height" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real ceiHei(
          final quantity="Height",
          final unit="m",
          displayUnit="m") = 20000 "Ceiling height (used if ceiHei=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput ceiHei_in(
          final quantity="Height",
          final unit="m",
          displayUnit="m") if (ceiHeiSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input ceiling height"
          annotation (Placement(transformation(extent={{-242,-14},{-202,26}}),
              iconTransformation(extent={{-242,-14},{-202,26}})));
        //--------------------------------------------------------------
        // Total sky cover
        parameter IDEAS.BoundaryConditions.Types.DataSource totSkyCovSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Total sky cover" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real totSkyCov(
          min=0,
          max=1,
          unit="1") = 0.5
          "Total sky cover (used if totSkyCov=Parameter). Use 0 <= totSkyCov <= 1"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput totSkyCov_in(
          min=0,
          max=1,
          unit="1") if (totSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input total sky cover"
          annotation (Placement(transformation(extent={{-240,-58},{-200,-18}}),
              iconTransformation(extent={{-240,-58},{-200,-18}})));
        // Opaque sky cover
        parameter IDEAS.BoundaryConditions.Types.DataSource opaSkyCovSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Opaque sky cover" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real opaSkyCov(
          min=0,
          max=1,
          unit="1") = 0.5
          "Opaque sky cover (used if opaSkyCov=Parameter). Use 0 <= opaSkyCov <= 1"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput opaSkyCov_in(
          min=0,
          max=1,
          unit="1") if (opaSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input opaque sky cover"
          annotation (Placement(transformation(extent={{-240,32},{-200,72}}),
              iconTransformation(extent={{-240,32},{-200,72}})));
        //--------------------------------------------------------------
        // Dry bulb temperature
        parameter IDEAS.BoundaryConditions.Types.DataSource TDryBulSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Dry bulb temperature"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Temperature TDryBul(displayUnit="degC") = 293.15
          "Dry bulb temperature (used if TDryBul=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDryBul_in(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") if (TDryBulSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input dry bulb temperature"
          annotation (Placement(transformation(extent={{-240,160},{-200,200}})));

        //--------------------------------------------------------------
        // Dew point temperature
        parameter IDEAS.BoundaryConditions.Types.DataSource TDewPoiSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Dew point temperature"
          annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Temperature TDewPoi(displayUnit="degC") = 283.15
          "Dew point temperature (used if TDewPoi=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput TDewPoi_in(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") if (TDewPoiSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input dew point temperature"
          annotation (Placement(transformation(extent={{-240,204},{-200,244}})));

        //--------------------------------------------------------------
        // Black body sky temperature
        parameter IDEAS.BoundaryConditions.Types.DataSource TBlaSkySou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Black-body sky temperature" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Temperature TBlaSky=273.15
          "Black-body sky temperature (used if TBlaSkySou=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput TBlaSky_in(
          final quantity="ThermodynamicTemperature",
          displayUnit="degC",
          final unit="K") if
          (TBlaSkySou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Black-body sky temperature"
          annotation (Placement(transformation(extent={{-240,120},{-200,160}}),
              iconTransformation(extent={{-240,120},{-200,160}})));
        //--------------------------------------------------------------
        // Relative humidity
        parameter IDEAS.BoundaryConditions.Types.DataSource relHumSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Relative humidity" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Real relHum(
          min=0,
          max=1,
          unit="1") = 0.5 "Relative humidity (used if relHum=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput relHum_in(
          min=0,
          max=1,
          unit="1") if (relHumSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input relative humidity"
          annotation (Placement(transformation(extent={{-240,80},{-200,120}}),
              iconTransformation(extent={{-240,80},{-200,120}})));
        //--------------------------------------------------------------
        // Wind speed
        parameter IDEAS.BoundaryConditions.Types.DataSource winSpeSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Wind speed" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Velocity winSpe(min=0) = 1
          "Wind speed (used if winSpe=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput winSpe_in(
          final quantity="Velocity",
          final unit="m/s",
          min=0) if (winSpeSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input wind speed"
          annotation (Placement(transformation(extent={{-240,-98},{-200,-58}}),
              iconTransformation(extent={{-240,-98},{-200,-58}})));
        //--------------------------------------------------------------
        // Wind direction
        parameter IDEAS.BoundaryConditions.Types.DataSource winDirSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Wind direction" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.Angle winDir=1.0
          "Wind direction (used if winDir=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput winDir_in(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") if (winDirSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input wind direction"
          annotation (Placement(transformation(extent={{-240,-140},{-200,-100}}),
              iconTransformation(extent={{-240,-140},{-200,-100}})));
        //--------------------------------------------------------------
        // Infrared horizontal radiation
        parameter IDEAS.BoundaryConditions.Types.DataSource HInfHorSou=IDEAS.BoundaryConditions.Types.DataSource.File
          "Infrared horizontal radiation" annotation (Evaluate=true, Dialog(group="Data source"));
        parameter Modelica.SIunits.HeatFlux HInfHor=0.0
          "Infrared horizontal radiation (used if HInfHorSou=Parameter)"
          annotation (Dialog(group="Data source"));
        Modelica.Blocks.Interfaces.RealInput HInfHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HInfHorSou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Input infrared horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-210},{-200,-170}}),
              iconTransformation(extent={{-240,-210},{-200,-170}})));

         parameter IDEAS.BoundaryConditions.Types.RadiationDataSource HSou=IDEAS.BoundaryConditions.Types.RadiationDataSource.File
          "Global, diffuse, and direct normal radiation"
           annotation (Evaluate=true, Dialog(group="Data source"));
        //--------------------------------------------------------------
        // Global horizontal radiation
        Modelica.Blocks.Interfaces.RealInput HGloHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
          "Input global horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-280},{-200,-240}}),
              iconTransformation(extent={{-240,-280},{-200,-240}})));
        //--------------------------------------------------------------
        // Diffuse horizontal radiation
        Modelica.Blocks.Interfaces.RealInput HDifHor_in(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") if (HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor)
          "Input diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{-240,-276},{-200,-236}}),
              iconTransformation(extent={{-240,-172},{-200,-132}})));
        //--------------------------------------------------------------
        // Direct normal radiation
        Modelica.Blocks.Interfaces.RealInput HDirNor_in(final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") if
                                (HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor)
          "Input direct normal radiation"
          annotation (Placement(transformation(extent={{-240,-320},{-200,-280}}),
              iconTransformation(extent={{-240,-240},{-200,-200}})));

        //--------------------------------------------------------------
        parameter String filNam="" "Name of weather data file" annotation (
          Dialog(loadSelector(filter="Weather files (*.mos)",
                              caption="Select weather file")));
        final parameter Modelica.SIunits.Angle lon(displayUnit="deg")=
          IDEAS.BoundaryConditions.WeatherData.BaseClasses.getLongitudeTMY3(
          filNam) "Longitude";
        final parameter Modelica.SIunits.Angle lat(displayUnit="deg")=
          IDEAS.BoundaryConditions.WeatherData.BaseClasses.getLatitudeTMY3(
          filNam) "Latitude";
        final parameter Modelica.SIunits.Time timZon(displayUnit="h")=
          IDEAS.BoundaryConditions.WeatherData.BaseClasses.getTimeZoneTMY3(filNam)
          "Time zone";

        Bus weaBus "Weather data bus" annotation (Placement(transformation(extent={{
                  290,-10},{310,10}}), iconTransformation(extent={{190,-10},{210,10}})));

        parameter IDEAS.BoundaryConditions.Types.SkyTemperatureCalculation
          calTSky=IDEAS.BoundaryConditions.Types.SkyTemperatureCalculation.TemperaturesAndSkyCover
          "Computation of black-body sky temperature" annotation (
          choicesAllMatching=true,
          Evaluate=true,
          Dialog(group="Sky temperature"));

        constant Real epsCos = 1e-6 "Small value to avoid division by 0";
        constant Modelica.SIunits.HeatFlux solCon = 1367.7 "Solar constant";

    protected
        final parameter Modelica.SIunits.Time[2] timeSpan=
          IDEAS.BoundaryConditions.WeatherData.BaseClasses.getTimeSpanTMY3(filNam, "tab1")
        "Start time, end time of weather data";

        Modelica.Blocks.Tables.CombiTable1Ds datRea(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=filNam,
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns={2,3,4,5,6,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,
              28,29,30,8}) "Data reader"
          annotation (Placement(transformation(extent={{-80,-40},{-60,-20}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature
          cheTemDryBul "Check dry bulb temperature "
          annotation (Placement(transformation(extent={{160,-200},{180,-180}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature
          cheTemDewPoi "Check dew point temperature"
          annotation (Placement(transformation(extent={{160,-240},{180,-220}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.ConvertRelativeHumidity
          conRelHum "Convert the relative humidity from percentage to [0, 1] "
          annotation (Placement(transformation(extent={{120,20},{140,40}})));
        BaseClasses.CheckPressure chePre "Check the air pressure"
          annotation (Placement(transformation(extent={{160,60},{180,80}})));
        BaseClasses.CheckSkyCover cheTotSkyCov "Check the total sky cover"
          annotation (Placement(transformation(extent={{160,-40},{180,-20}})));
        BaseClasses.CheckSkyCover cheOpaSkyCov "Check the opaque sky cover"
          annotation (Placement(transformation(extent={{160,-160},{180,-140}})));
        BaseClasses.CheckRadiation cheGloHorRad
          "Check the global horizontal radiation"
          annotation (Placement(transformation(extent={{160,180},{180,200}})));
        BaseClasses.CheckRadiation cheDifHorRad
          "Check the diffuse horizontal radiation"
          annotation (Placement(transformation(extent={{160,140},{180,160}})));
        BaseClasses.CheckRadiation cheDirNorRad "Check the direct normal radiation"
          annotation (Placement(transformation(extent={{160,220},{180,240}})));
        BaseClasses.CheckCeilingHeight cheCeiHei "Check the ceiling height"
          annotation (Placement(transformation(extent={{160,-120},{180,-100}})));
        BaseClasses.CheckWindSpeed cheWinSpe "Check the wind speed"
          annotation (Placement(transformation(extent={{160,-80},{180,-60}})));
        BaseClasses.CheckIRRadiation cheHorRad
          "Check the horizontal infrared irradiation"
          annotation (Placement(transformation(extent={{160,100},{180,120}})));
        BaseClasses.CheckWindDirection cheWinDir "Check the wind direction"
          annotation (Placement(transformation(extent={{160,-280},{180,-260}})));
        SkyTemperature.BlackBody TBlaSkyCom(final calTSky=calTSky) if
             not (TBlaSkySou == IDEAS.BoundaryConditions.Types.DataSource.Parameter or
                  TBlaSkySou == IDEAS.BoundaryConditions.Types.DataSource.Input)
          "Computation of the black-body sky temperature"
          annotation (Placement(transformation(extent={{240,-220},{260,-200}})));
        Utilities.Time.ModelTime modTim "Model time"
          annotation (Placement(transformation(extent={{-180,-10},{-160,10}})));
        Modelica.Blocks.Math.Add add
          "Add 30 minutes to time to shift weather data reader"
          annotation (Placement(transformation(extent={{-140,180},{-120,200}})));
        Modelica.Blocks.Sources.Constant con30mins(final k=1800)
          "Constant used to shift weather data reader"
          annotation (Placement(transformation(extent={{-180,212},{-160,232}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.LocalCivilTime locTim(
            final lon=lon, final timZon=timZon) "Local civil time"
          annotation (Placement(transformation(extent={{-120,-160},{-100,-140}})));
        Modelica.Blocks.Tables.CombiTable1Ds datRea1(
          final tableOnFile=true,
          final tableName="tab1",
          final fileName=filNam,
          final smoothness=Modelica.Blocks.Types.Smoothness.ContinuousDerivative,
          final columns=9:11) "Data reader"
          annotation (Placement(transformation(extent={{-80,180},{-60,200}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim1(
          final weaDatStaTim = timeSpan[1],
          final weaDatEndTim = timeSpan[2])
          "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-110,180},{-90,200}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.ConvertTime conTim(
          final weaDatStaTim = timeSpan[1],
          final weaDatEndTim = timeSpan[2])
          "Convert simulation time to calendar time"
          annotation (Placement(transformation(extent={{-120,-40},{-100,-20}})));
        BaseClasses.EquationOfTime eqnTim "Equation of time"
          annotation (Placement(transformation(extent={{-120,-120},{-100,-100}})));
        BaseClasses.SolarTime solTim "Solar time"
          annotation (Placement(transformation(extent={{-80,-140},{-60,-120}})));
        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput pAtm_in_internal(
          final quantity="Pressure",
          final unit="Pa",
          displayUnit="bar") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput ceiHei_in_internal(
          final quantity="Height",
          final unit="m",
          displayUnit="m") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput totSkyCov_in_internal(
          final quantity="1",
          min=0,
          max=1) "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput opaSkyCov_in_internal(
          final quantity="1",
          min=0,
          max=1) "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput TDryBul_in_internal(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput TDewPoi_in_internal(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput TBlaSky_in_internal(
          final quantity="ThermodynamicTemperature",
          final unit="K",
          displayUnit="degC") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput relHum_in_internal(
          final quantity="1",
          min=0,
          max=1) "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput winSpe_in_internal(
          final quantity="Velocity",
          final unit="m/s") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput winDir_in_internal(
          final quantity="Angle",
          final unit="rad",
          displayUnit="deg") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HGloHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HDifHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HDirNor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput HInfHor_in_internal(
          final quantity="RadiantEnergyFluenceRate",
          final unit="W/m2") "Needed to connect to conditional connector";

        Modelica.Blocks.Math.UnitConversions.From_deg conWinDir
          "Convert the wind direction unit from [deg] to [rad]"
          annotation (Placement(transformation(extent={{120,-280},{140,-260}})));
        Modelica.Blocks.Math.UnitConversions.From_degC conTDryBul
          annotation (Placement(transformation(extent={{120,-200},{140,-180}})));
        BaseClasses.ConvertRadiation conHorRad
          annotation (Placement(transformation(extent={{120,100},{140,120}})));
        Modelica.Blocks.Math.UnitConversions.From_degC conTDewPoi
          "Convert the dew point temperature form [degC] to [K]"
          annotation (Placement(transformation(extent={{120,-240},{140,-220}})));
        BaseClasses.ConvertRadiation conDirNorRad
          annotation (Placement(transformation(extent={{120,220},{140,240}})));
        BaseClasses.ConvertRadiation conGloHorRad
          annotation (Placement(transformation(extent={{120,180},{140,200}})));
        BaseClasses.ConvertRadiation conDifHorRad
          annotation (Placement(transformation(extent={{120,140},{140,160}})));
        BaseClasses.CheckRelativeHumidity cheRelHum
          annotation (Placement(transformation(extent={{160,20},{180,40}})));
        SolarGeometry.BaseClasses.AltitudeAngle altAng "Solar altitude angle"
          annotation (Placement(transformation(extent={{-30,-280},{-10,-260}})));
         SolarGeometry.BaseClasses.ZenithAngle zenAng(
           final lat = lat) "Zenith angle"
          annotation (Placement(transformation(extent={{-80,-226},{-60,-206}})));
         SolarGeometry.BaseClasses.Declination decAng "Declination angle"
          annotation (Placement(transformation(extent={{-140,-220},{-120,-200}})));
         SolarGeometry.BaseClasses.SolarHourAngle
          solHouAng
          annotation (Placement(transformation(extent={{-140,-250},{-120,-230}})));
        Latitude latitude(final latitude=lat) "Latitude"
          annotation (Placement(transformation(extent={{-180,-280},{-160,-260}})));
        Longitude longitude(final longitude=lon) "Longitude"
          annotation (Placement(transformation(extent={{-140,-280},{-120,-260}})));

        //---------------------------------------------------------------------------
        // Optional instanciation of a block that computes the wet bulb temperature.
        // This block may be needed for evaporative cooling towers.
        // By default, it is enabled. This introduces a nonlinear equation, but
        // we have not observed an increase in computing time because of this equation.
        IDEAS.Utilities.Psychrometrics.TWetBul_TDryBulPhi tWetBul_TDryBulXi(
            redeclare package Medium = IDEAS.Media.Air,
            TDryBul(displayUnit="degC")) if computeWetBulbTemperature
          annotation (Placement(transformation(extent={{244,-66},{264,-46}})));

        //---------------------------------------------------------------------------
        // Conversion blocks for sky cover
        Modelica.Blocks.Math.Gain conTotSkyCov(final k=0.1) if
             totSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.File
          "Convert sky cover from [0...10] to [0...1]"
          annotation (Placement(transformation(extent={{120,-40},{140,-20}})));
        Modelica.Blocks.Math.Gain conOpaSkyCov(final k=0.1) if
             opaSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.File
          "Convert sky cover from [0...10] to [0...1]"
          annotation (Placement(transformation(extent={{120,-158},{140,-138}})));
        IDEAS.BoundaryConditions.WeatherData.BaseClasses.CheckBlackBodySkyTemperature cheTemBlaSky(TMin=0)
          "Check black body sky temperature"
          annotation (Placement(transformation(extent={{240,-260},{260,-240}})));

        // Blocks that are added in order to set the name of the output signal,
        // which then is displayed in the GUI of the weather data connector.
        block Latitude "Generate constant signal of type Real"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.SIunits.Angle latitude "Latitude";

          Modelica.Blocks.Interfaces.RealOutput y(
            unit="rad",
            displayUnit="deg") "Latitude of the location"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          y = latitude;
          annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-81,32},{84,-24}},
                lineColor={0,0,0},
                  textString="Latitude")}),
          Documentation(info="<html>
<p>
Block to output the latitude of the location.
This block is added so that the latitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the latitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 4, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Latitude;

        block Longitude "Generate constant signal of type Real"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.SIunits.Angle longitude "Longitude";

          Modelica.Blocks.Interfaces.RealOutput y(
            unit="rad",
            displayUnit="deg") "Longitude of the location"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          y = longitude;
          annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}}), graphics={
              Text(
                extent={{-81,32},{84,-24}},
                lineColor={0,0,0},
                  textString="Longitude")}),
          Documentation(info="<html>
<p>
Block to output the longitude of the location.
This block is added so that the longitude is displayed
with a comment in the GUI of the weather bus connector.
</p>
<h4>Implementation</h4>
<p>
If
<a href=\"modelica://Modelica.Blocks.Sources.Constant\">
Modelica.Blocks.Sources.Constant</a> where used, then
the comment for the longitude would be \"Connector of Real output signal\".
As this documentation string cannot be overwritten, a new block
was implemented.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 4, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end Longitude;

      equation
        //---------------------------------------------------------------------------
        // Select atmospheric pressure connector
        if pAtmSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          pAtm_in_internal = pAtm;
        elseif pAtmSou == IDEAS.BoundaryConditions.Types.DataSource.File then
          connect(datRea.y[4], pAtm_in_internal);
        else
          connect(pAtm_in, pAtm_in_internal);
        end if;
        connect(pAtm_in_internal, chePre.PIn);
        //---------------------------------------------------------------------------
        // Select ceiling height connector
        if ceiHeiSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          ceiHei_in_internal = ceiHei;
        elseif ceiHeiSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(ceiHei_in, ceiHei_in_internal);
        else
          connect(datRea.y[16], ceiHei_in_internal);
        end if;
         connect(ceiHei_in_internal, cheCeiHei.ceiHeiIn);

        //---------------------------------------------------------------------------
        // Select total sky cover connector
        if totSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          totSkyCov_in_internal = totSkyCov;
        elseif totSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(totSkyCov_in, totSkyCov_in_internal);
        else
          connect(conTotSkyCov.u, datRea.y[13]) annotation (Line(
            points={{118,-30},{-59,-30}},
            color={0,0,127}));
          connect(conTotSkyCov.y, totSkyCov_in_internal);
        end if;
        connect(totSkyCov_in_internal, cheTotSkyCov.nIn);
        //---------------------------------------------------------------------------
        // Select opaque sky cover connector
        if opaSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          opaSkyCov_in_internal = opaSkyCov;
        elseif opaSkyCovSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(opaSkyCov_in, opaSkyCov_in_internal);
        else
          connect(conOpaSkyCov.u, datRea.y[14]) annotation (Line(
            points={{118,-148},{30,-148},{30,-30},{-59,-30}},
            color={0,0,127}));
          connect(conOpaSkyCov.y, opaSkyCov_in_internal);
        end if;
        connect(opaSkyCov_in_internal, cheOpaSkyCov.nIn);

        //---------------------------------------------------------------------------
        // Select dew point temperature connector
        if TDewPoiSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          TDewPoi_in_internal = TDewPoi;
        elseif TDewPoiSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(TDewPoi_in, TDewPoi_in_internal);
        else
          connect(conTDewPoi.y, TDewPoi_in_internal);
        end if;
        connect(TDewPoi_in_internal, cheTemDewPoi.TIn);
        //---------------------------------------------------------------------------
        // Select dry bulb temperature connector
        if TDryBulSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          TDryBul_in_internal = TDryBul;
        elseif TDryBulSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(TDryBul_in, TDryBul_in_internal);
        else
          connect(conTDryBul.y, TDryBul_in_internal);
        end if;
        connect(TDryBul_in_internal, cheTemDryBul.TIn);
        //---------------------------------------------------------------------------
        // Select sky black body temperature connector
        if TBlaSkySou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          TBlaSky_in_internal = TBlaSky;
        elseif TBlaSkySou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(TBlaSky_in, TBlaSky_in_internal);
        else
          connect(TBlaSkyCom.TBlaSky, TBlaSky_in_internal);
        end if;
        connect(TBlaSky_in_internal, cheTemBlaSky.TIn);
        //---------------------------------------------------------------------------
        // Select relative humidity connector
        if relHumSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          relHum_in_internal = relHum;
        elseif relHumSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(relHum_in, relHum_in_internal);
        else
          connect(conRelHum.relHumOut, relHum_in_internal);
        end if;
        connect(relHum_in_internal, cheRelHum.relHumIn);
        //---------------------------------------------------------------------------
        // Select wind speed connector
        if winSpeSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          winSpe_in_internal = winSpe;
        elseif winSpeSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(winSpe_in, winSpe_in_internal);
        else
          connect(datRea.y[12], winSpe_in_internal);
        end if;
        connect(winSpe_in_internal, cheWinSpe.winSpeIn);
        //---------------------------------------------------------------------------
        // Select wind direction connector
        if winDirSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          winDir_in_internal = winDir;
        elseif winDirSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(winDir_in, winDir_in_internal);
        else
          connect(conWinDir.y, winDir_in_internal);
        end if;
        connect(winDir_in_internal, cheWinDir.nIn);
        //---------------------------------------------------------------------------
        // Select global horizontal radiation connector
        if HSou ==  IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor then
          connect(HGloHor_in, HGloHor_in_internal)
            "Get HGloHor using user input file";
        elseif HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
           HDirNor_in_internal*cos(zenAng.zen)+HDifHor_in_internal = HGloHor_in_internal
            "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
        else
          connect(conGloHorRad.HOut, HGloHor_in_internal)
            "Get HGloHor using weather data file";
        end if;
        connect(HGloHor_in_internal, cheGloHorRad.HIn);
        //---------------------------------------------------------------------------
        // Select diffuse horizontal radiation connector
        if HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
           connect(HDifHor_in, HDifHor_in_internal)
            "Get HDifHor using user input file";
        elseif  HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor then
            HGloHor_in_internal - HDirNor_in_internal*cos(zenAng.zen) = HDifHor_in_internal
            "Calculate the HGloHor using HDirNor and HDifHor according to (A.4.14) and (A.4.15)";
        else
          connect(conDifHorRad.HOut, HDifHor_in_internal)
            "Get HDifHor using weather data file";
        end if;
        connect(HDifHor_in_internal, cheDifHorRad.HIn);
        //---------------------------------------------------------------------------
        // Select direct normal radiation connector
        if HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor then
           connect(HDirNor_in, HDirNor_in_internal)
            "Get HDirNor using user input file";
        elseif  HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor then
            IDEAS.Utilities.Math.Functions.smoothMin(
              solCon,
              (HGloHor_in_internal -HDifHor_in_internal)*
                IDEAS.Utilities.Math.Functions.spliceFunction(
                  x=cos(zenAng.zen),
                  pos=IDEAS.Utilities.Math.Functions.inverseXRegularized(cos(zenAng.zen),epsCos),
                  neg=0,
                  deltax=epsCos),
              0.1)
              = HDirNor_in_internal
            "Calculate the HDirNor using HGloHor and HDifHor according to (A.4.14) and (A.4.15)";
        else
          connect(conDirNorRad.HOut, HDirNor_in_internal)
            "Get HDirNor using weather data file";
        end if;
        connect(HDirNor_in_internal, cheDirNorRad.HIn);

        //---------------------------------------------------------------------------
        // Select infrared radiation connector
        if HInfHorSou == IDEAS.BoundaryConditions.Types.DataSource.Parameter then
          HInfHor_in_internal = HInfHor;
        elseif HInfHorSou == IDEAS.BoundaryConditions.Types.DataSource.Input then
          connect(HInfHor_in, HInfHor_in_internal);
        else
          connect(conHorRad.HOut, HInfHor_in_internal);
        end if;
        connect(HInfHor_in_internal, cheHorRad.HIn);

        connect(chePre.POut, weaBus.pAtm) annotation (Line(
            points={{181,70},{220,70},{220,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTotSkyCov.nOut, weaBus.nTot) annotation (Line(
            points={{181,-30},{220,-30},{220,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheOpaSkyCov.nOut, weaBus.nOpa) annotation (Line(
            points={{181,-150},{220,-150},{220,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheGloHorRad.HOut, weaBus.HGloHor) annotation (Line(
            points={{181,190},{220,190},{220,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheDifHorRad.HOut, weaBus.HDifHor) annotation (Line(
            points={{181,150},{220,150},{220,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheDirNorRad.HOut, weaBus.HDirNor) annotation (Line(
            points={{181,230},{220,230},{220,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheCeiHei.ceiHeiOut, weaBus.celHei) annotation (Line(
            points={{181,-110},{220,-110},{220,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheWinSpe.winSpeOut, weaBus.winSpe) annotation (Line(
            points={{181,-70},{220,-70},{220,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheHorRad.HOut, weaBus.HHorIR) annotation (Line(
            points={{181,110},{220,110},{220,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheWinDir.nOut, weaBus.winDir) annotation (Line(
            points={{181,-270},{280,-270},{280,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheOpaSkyCov.nOut, TBlaSkyCom.nOpa) annotation (Line(
            points={{181,-150},{220,-150},{220,-213},{238,-213}},
            color={0,0,127}));
        connect(cheHorRad.HOut, TBlaSkyCom.HHorIR) annotation (Line(
            points={{181,110},{220,110},{220,-218},{238,-218}},
            color={0,0,127}));
        connect(modTim.y, weaBus.cloTim) annotation (Line(
            points={{-159,6.10623e-16},{34.75,6.10623e-16},{34.75,0},{124.5,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(modTim.y, add.u2) annotation (Line(
            points={{-159,0},{-150,0},{-150,184},{-142,184}},
            color={0,0,127}));
        connect(con30mins.y, add.u1) annotation (Line(
            points={{-159,222},{-150,222},{-150,196},{-142,196}},
            color={0,0,127}));
        connect(add.y, conTim1.modTim) annotation (Line(
            points={{-119,190},{-112,190}},
            color={0,0,127}));
        connect(conTim1.calTim, datRea1.u) annotation (Line(
            points={{-89,190},{-82,190}},
            color={0,0,127}));
        connect(modTim.y, locTim.cloTim) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-150},{-122,-150}},
            color={0,0,127}));
        connect(modTim.y, conTim.modTim) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-30},{-122,-30}},
            color={0,0,127}));
        connect(conTim.calTim, datRea.u) annotation (Line(
            points={{-99,-30},{-82,-30}},
            color={0,0,127}));
        connect(modTim.y, eqnTim.nDay) annotation (Line(
            points={{-159,6.10623e-16},{-150,6.10623e-16},{-150,-110},{-122,-110}},
            color={0,0,127}));
        connect(eqnTim.eqnTim, solTim.equTim) annotation (Line(
            points={{-99,-110},{-88,-110},{-88,-124},{-82,-124}},
            color={0,0,127}));
        connect(locTim.locTim, solTim.locTim) annotation (Line(
            points={{-99,-150},{-88,-150},{-88,-135.4},{-82,-135.4}},
            color={0,0,127}));
        connect(solTim.solTim, weaBus.solTim) annotation (Line(
            points={{-59,-130},{-20,-130},{-20,0},{284,0},{284,0},{300,
                0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(datRea.y[11], conWinDir.u) annotation (Line(
            points={{-59,-30},{20,-30},{20,-270},{118,-270}},
            color={0,0,127}));
        connect(cheTemDryBul.TOut, TBlaSkyCom.TDryBul) annotation (Line(
            points={{181,-190},{220,-190},{220,-202},{238,-202}},
            color={0,0,127}));
        connect(datRea.y[1], conTDryBul.u) annotation (Line(
            points={{-59,-30},{20,-30},{20,-190},{118,-190}},
            color={0,0,127}));
        connect(datRea.y[2], conTDewPoi.u) annotation (Line(
            points={{-59,-30},{20,-30},{20,-230},{118,-230}},
            color={0,0,127}));
        connect(cheTemDewPoi.TOut, weaBus.TDewPoi) annotation (Line(
            points={{181,-230},{280,-230},{280,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(TBlaSkyCom.TDewPoi, cheTemDewPoi.TOut) annotation (Line(
            points={{238,-207},{220,-207},{220,-230},{181,-230}},
            color={0,0,127}));
        connect(datRea1.y[2], conDirNorRad.HIn) annotation (Line(
            points={{-59,190},{20,190},{20,230},{118,230}},
            color={0,0,127}));
        connect(datRea1.y[1], conGloHorRad.HIn) annotation (Line(
            points={{-59,190},{-40,190},{20,190},{118,190}},
            color={0,0,127}));
        connect(datRea1.y[3], conDifHorRad.HIn) annotation (Line(
            points={{-59,190},{20,190},{20,150},{118,150}},
            color={0,0,127}));
        connect(conRelHum.relHumIn, datRea.y[3]) annotation (Line(
            points={{118,30},{20,30},{20,-30},{-59,-30}},
            color={0,0,127}));
        connect(cheRelHum.relHumOut, weaBus.relHum) annotation (Line(
            points={{181,30},{280,30},{280,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTemDryBul.TOut, weaBus.TDryBul) annotation (Line(
            points={{181,-190},{280,-190},{280,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(decAng.decAng, zenAng.decAng)
                                        annotation (Line(
            points={{-119,-210},{-82,-210},{-82,-210.6}},
            color={0,0,127}));
        connect(solHouAng.solHouAng, zenAng.solHouAng)  annotation (Line(
            points={{-119,-240},{-100,-240},{-100,-220.8},{-82,-220.8}},
            color={0,0,127}));
        connect(solHouAng.solTim, solTim.solTim) annotation (Line(
            points={{-142,-240},{-154,-240},{-154,-172},{-20,-172},{-20,-130},{-59,-130}},
            color={0,0,127}));
        connect(decAng.nDay, modTim.y) annotation (Line(
            points={{-142,-210},{-150,-210},{-150,-180},{0,-180},{0,6.10623e-16},{
                -159,6.10623e-16}},
            color={0,0,127}));
        connect(zenAng.zen, altAng.zen) annotation (Line(
            points={{-59,-216},{-40,-216},{-40,-270},{-32,-270}},
            color={0,0,127}));

        // Connectors for wet bulb temperature.
        // These are removed if computeWetBulbTemperature = false
        connect(chePre.POut, tWetBul_TDryBulXi.p) annotation (Line(
            points={{181,70},{220,70},{220,-64},{243,-64}},
            color={0,0,127}));
        connect(tWetBul_TDryBulXi.TWetBul, weaBus.TWetBul) annotation (Line(
            points={{265,-56},{280,-56},{280,0},{292,0},{300,0}},
            color={0,0,127}), Text(
            textString="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(cheTemDryBul.TOut, tWetBul_TDryBulXi.TDryBul) annotation (Line(
            points={{181,-190},{220,-190},{220,-48},{243,-48}},
            color={0,0,127}));
        connect(cheRelHum.relHumOut, tWetBul_TDryBulXi.phi) annotation (Line(
            points={{181,30},{208,30},{208,-56},{243,-56}},
            color={0,0,127}));

        connect(altAng.alt, weaBus.solAlt) annotation (Line(
            points={{-9,-270},{8,-270},{8,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(zenAng.zen, weaBus.solZen) annotation (Line(
            points={{-59,-216},{-40,-216},{-40,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(decAng.decAng, weaBus.solDec) annotation (Line(
            points={{-119,-210},{-110,-210},{-110,-208},{-100,-208},{-100,-290},{290,
                -290},{290,0},{300,0}},
            color={0,0,127}));
        connect(solHouAng.solHouAng, weaBus.solHouAng) annotation (Line(
            points={{-119,-240},{-108,-240},{-108,-238},{-100,-238},{-100,-290},{290,
                -290},{290,0},{300,0}},
            color={0,0,127}));
        connect(longitude.y, weaBus.lon) annotation (Line(
            points={{-119,-270},{-100,-270},{-100,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(latitude.y, weaBus.lat) annotation (Line(
            points={{-159,-270},{-150,-270},{-150,-290},{290,-290},{290,0},{300,0}},
            color={0,0,127}));
        connect(cheTemBlaSky.TOut, weaBus.TBlaSky) annotation (Line(points={{261,-250},
                {261,-250},{280,-250},{280,0},{300,0}}, color={0,0,127}));
        connect(datRea.y[26], conHorRad.HIn) annotation (Line(points={{-59,-30},{20,
                -30},{20,110},{118,110}}, color={0,0,127}));
        annotation (
          defaultComponentName="weaDat",
          Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-200,-200},{200,200}},
              initialScale=0.05), graphics={
              Rectangle(
                extent={{-200,200},{200,-200}},
                lineColor={124,142,255},
                fillColor={124,142,255},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-162,270},{138,230}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                visible=(pAtmSou == IDEAS.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,216},{-164,184}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                visible=(TDryBulSou == IDEAS.BoundaryConditions.Types.DataSource.Input),
                extent={{-194,162},{-118,118}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                visible=(relHumSou == IDEAS.BoundaryConditions.Types.DataSource.Input),
                extent={{-190,92},{-104,66}},
                lineColor={0,0,127},
                textString="relHum"),
              Text(
              visible=(winSpeSou == IDEAS.BoundaryConditions.Types.DataSource.Input),
                extent={{-196,44},{-110,2}},
                lineColor={0,0,127},
                textString="winSpe"),
              Text(
                visible=(winDirSou == IDEAS.BoundaryConditions.Types.DataSource.Input),
                extent={{-192,-18},{-106,-60}},
                lineColor={0,0,127},
                textString="winDir"),
              Text(
              visible=(HSou ==  IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor),
              extent={{-202,-88},{-112,-108}},
                lineColor={0,0,127},
                textString="HGloHor"),
              Text(visible=(HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HGloHor_HDifHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
              extent={{-202,-142},{-116,-164}},
                lineColor={0,0,127},
                textString="HDifHor"),
              Text(
              visible=(HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HGloHor or HSou == IDEAS.BoundaryConditions.Types.RadiationDataSource.Input_HDirNor_HDifHor),
              extent={{-200,-186},{-126,-214}},
                lineColor={0,0,127},
                textString="HDirNor"),
              Ellipse(
                extent={{-146,154},{28,-20}},
                lineColor={255,220,220},
                lineThickness=1,
                fillPattern=FillPattern.Sphere,
                fillColor={255,255,0}),
              Polygon(
                points={{104,76},{87.9727,12.9844},{88,12},{120,22},{148,20},{174,8},
                    {192,-58},{148,-132},{20,-140},{-130,-136},{-156,-60},{-140,-6},{
                    -92,-4},{-68.2109,-21.8418},{-68,-22},{-82,40},{-48,90},{44,110},
                    {104,76}},
                lineColor={220,220,220},
                lineThickness=0.1,
                fillPattern=FillPattern.Sphere,
                smooth=Smooth.Bezier,
                fillColor={230,230,230})}),
          Documentation(info="<html>
<p>
This component reads TMY3 weather data (Wilcox and Marion, 2008) or user specified weather data.
The weather data format is the Typical Meteorological Year (TMY3)
as obtained from the EnergyPlus web site at
<a href=\"http://energyplus.net/weather\">
http://energyplus.net/weather</a>. These
data, which are in the EnergyPlus format, need to be converted as described
below.
</p>
<!-- ============================================== -->
<h4>Output to weaBus</h4>
<p>
The following variables serve as output and are accessible via <code>weaBus</code>:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Name
  </th>
  <th>Unit
  </th>
  <th>Description
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HDifHor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal diffuse solar radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HDifNor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Direct normal radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HGloHor</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal global radiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>HHorIR</code>
  </td>
  <td>
    W/m2
  </td>
  <td>
    Horizontal infrared irradiation.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TBlaSky</code>
  </td>
  <td>
    K
  </td>
  <td>
    Output temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TDewPoi</code>
  </td>
  <td>
    K
  </td>
  <td>
    Dew point temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TDryBul</code>
  </td>
  <td>
    K
  </td>
  <td>
    Dry bulb temperature at ground level.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>TWetBul</code>
  </td>
  <td>
    K
  </td>
  <td>
    Wet bulb temperature.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>celHei</code>
  </td>
  <td>
    m
  </td>
  <td>
    Ceiling height.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>cloTim</code>
  </td>
  <td>
    s
  </td>
  <td>
    One-based day number in seconds.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>lat</code>
  </td>
  <td>
    rad
  </td>
  <td>
  Latitude of the location.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>lon</code>
  </td>
  <td>
    rad
  </td>
  <td>
  Longitude of the location.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>nOpa</code>
  </td>
  <td>
    1
  </td>
  <td>
  Opaque sky cover [0, 1].
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>nTot</code>
  </td>
  <td>
    1
  </td>
  <td>
   Total sky Cover [0, 1].
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>pAtm</code>
  </td>
  <td>
    Pa
  </td>
  <td>
    Atmospheric pressure.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>relHum</code>
  </td>
  <td>
    1
  </td>
  <td>
    Relative humidity.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solAlt</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Altitude angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solDec</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Declination angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solHouAng</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Solar hour angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solTim</code>
  </td>
  <td>
    s
  </td>
  <td>
    Solar time.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>solZen</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Zenith angle.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>winDir</code>
  </td>
  <td>
    rad
  </td>
  <td>
    Wind direction.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    <code>winSpe</code>
  </td>
  <td>
    m/s
  </td>
  <td>
    Wind speed.
  </td>
</tr>
</table>
<!-- ============================================== -->
<h4>Adding new weather data</h4>
<p>
To add new weather data, proceed as follows:
</p>
<ol>
<li>
Download the weather data file with the <code>epw</code> extension from
<a href=\"http://energyplus.net/weather\">
http://energyplus.net/weather</a>.
</li>
<li>
Add the file to <code>IDEAS/Resources/weatherdata</code> (or to any directory
for which you have write permission).
</li>
<li>
On a console window, type<pre>
  cd IDEAS/Resources/weatherdata
  java -jar ../bin/ConvertWeatherData.jar inputFile.epw
</pre>
This will generate the weather data file <code>inputFile.mos</code>, which can be read
by the model
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.ReaderTMY3\">
IDEAS.BoundaryConditions.WeatherData.ReaderTMY3</a>.
</li>
</ol>
<!-- ============================================== -->
<h4>Location data that are read automatically from the weather data file</h4>
<p>
The following location data are automatically read from the weather file:
</p>
<ul>
<li>
The latitude of the weather station, <code>lat</code>,
</li>
<li>
the longitude of the weather station, <code>lon</code>, and
</li>
<li>
the time zone relative to Greenwich Mean Time, <code>timZone</code>.
</li>
</ul>
<!-- ============================================== -->
<h4>Wet bulb temperature</h4>
<p>
By default, the data bus contains the wet bulb temperature.
This introduces a nonlinear equation.
However, we have not observed an increase in computing time because
of this equation.
To disable the computation of the wet bulb temperature, set
<code>computeWetBulbTemperature=false</code>.
</p>
<!-- ============================================== -->
<h4>Using constant or user-defined input signals for weather data</h4>
<p>
This model has the option of using a constant value, using the data from the weather file,
or using data from an input connector for the following variables:
</p>
<ul>
<li>
The atmospheric pressure,
</li>
<li>
the ceiling height,
</li>
<li>
the total sky cover,
</li>
<li>
the opaque sky cover,
</li>
<li>
the dry bulb temperature,
</li>
<li>
the dew point temperature,
</li>
<li>
the sky black body temperature,
</li>
<li>
the relative humidity,
</li>
<li>
the wind direction,
</li>
<li>
the wind speed,
</li>
<li>
the global horizontal radiation, direct normal and diffuse horizontal radiation,
and
</li>
<li>
the infrared horizontal radiation.
</li>
</ul>
<p>
By default, all data are obtained from the weather data file,
except for the atmospheric pressure, which is set to the
parameter <code>pAtm=101325</code> Pascals.
</p>
<p>
The parameter <code>*Sou</code> configures the source of the data.
For the atmospheric pressure, temperatures, relative humidity, wind speed and wind direction,
the enumeration
<a href=\"modelica://IDEAS.BoundaryConditions.Types.DataSource\">
IDEAS.BoundaryConditions.Types.DataSource</a>
is used as follows:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>*Sou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Parameter
  </td>
  <td>
    Use value specified by the parameter.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input
  </td>
  <td>
    Use value from the input connector.
  </td>
</tr>
</table>
<p>
Because global, diffuse and direct radiation are related to each other, the parameter
<code>HSou</code> is treated differently.
It is set to a value of the enumeration
<a href=\"modelica://IDEAS.BoundaryConditions.Types.RadiationDataSource\">
IDEAS.BoundaryConditions.Types.RadiationDataSource</a>,
and allows the following configurations:
</p>
<table summary=\"summary\" border=\"1\" cellspacing=\"0\" cellpadding=\"2\" style=\"border-collapse:collapse;\">
<!-- ============================================== -->
<tr>
  <th>Parameter <code>HSou</code>
  </th>
  <th>Data used to compute weather data.
  </th>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    File
  </td>
  <td>
    Use data from file.
  </td>
</tr>
<!-- ============================================== -->
<tr>
  <td>
    Input_HGloHor_HDifHor
  </td>
  <td>
    Use global horizontal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HDifHor
  </td>
  <td>
    Use direct normal and diffuse horizontal radiation from input connector.
  </td>
</tr>
<tr>
  <td>
    Input_HDirNor_HGloHor
  </td>
  <td>
    Use direct normal and global horizontal radiation from input connector.
  </td>
</tr>
</table>
<!-- ============================================== -->
<h4>Length of weather data and simulation period</h4>
<p>
If weather data span a year, which is the default for TMY3 data, or multiple years,
then this model can be used for simulations that span multiple years. The simulation
start time needs to be set to the clock time of the respective start time. For example,
to start at January 2 at 10am, set start time to <code>t=(24+10)*3600</code> seconds.
For this computation, the used date and time (here January 2, 10 am) must be expressed in the same time zone
as the one that is used to define the TMY3 file. This is usually the local (winter) time zone.
The parameter `timZon` represents the TMY3 file time zone, expressed in seconds compared to UTC.
</p>
<p>
Moreover, weather data need not span a whole year, or it can span across New Year.
In this case, the simulation cannot exceed the time of the weather data file. Otherwise,
the simulation stops with an error.
</p>
<p>
As weather data have one entry at the start of the time interval, the end time of the weather
data file is computed as the last time entry plus the average time increment of the file.
For example, an hourly weather data file has 8760 entries, starting on January 1 at 0:00.
The last entry in the file will be for December 31 at 23:00. As the time increment is 1 hour,
the model assumes the weather file to end at December 31 at 23:00 plus 1 hour, e.g., at January 1 at 0:00.
</p>
<!-- ============================================== -->
<h4>Notes</h4>
<ol>
<li>
<p>
In HVAC systems, when the fan is off, changes in atmospheric pressure can cause small air flow rates
in the duct system due to change in pressure and hence in the mass of air that is stored
in air volumes (such as in fluid junctions or in the room model).
This may increase computing time. Therefore, the default value for the atmospheric pressure is set to a constant.
Furthermore, if the initial pressure of air volumes are different
from the atmospheric pressure, then fast pressure transients can happen in the first few seconds of the simulation.
This can cause numerical problems for the solver. To avoid this problem, set the atmospheric pressure to the
same value as the medium default pressure, which is typically set to the parameter <code>Medium.p_default</code>.
For medium models for moist air and dry air, the default is
<code>Medium.p_default=101325</code> Pascals.
</p>
</li>
<li>
<p>
Different units apply depending on whether data are obtained from a file, or
from a parameter or an input connector:
</p>
<ul>
<li>
When using TMY3 data from a file (e.g. <code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos</code>), the units must be the same as the original TMY3 file used by EnergyPlus (e.g.
<code>USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.epw</code>).
The TMY3 data used by EnergyPlus are in both SI units and non-SI units.
If <code>Resources/bin/ConvertWeatherData.jar</code> is used to convert the <code>.epw</code> file to an <code>.mos</code> file, the units of the TMY3 data are preserved and the file can be directly
used by this data reader.
The data reader will automatically convert units to the SI units used by Modelica.
For example, the dry bulb temperature <code>TDryBul</code> in TMY3 is in degree Celsius.
The data reader will automatically convert the data to Kelvin.
The wind direction <code>winDir</code> in TMY3 is degrees and will be automatically converted to radians.
</li>
<li>
When using data from a parameter or from an input connector,
the data must be in the SI units used by Modelica.
For instance, the unit must be
<code>Pa</code> for pressure,
<code>K</code> for temperature,
<code>W/m2</code> for solar radiations and
<code>rad</code> for wind direction.
</li>
</ul>
</li>
<li>
The ReaderTMY3 should only be used with TMY3 data. It contains a time shift for solar radiation data
that is explained below. This time shift needs to be removed if the user may want to
use the ReaderTMY3 for other weather data types.
</li>
</ol>
<h4>Implementation</h4>
<h5>Start and end data for annual weather data files</h5>
<p>
The TMY3 weather data, as well as the EnergyPlus weather data, start at 1:00 AM
on January 1, and provide hourly data until midnight on December 31.
Thus, the first entry for temperatures, humidity, wind speed etc. are values
at 1:00 AM and not at midnight. Furthermore, the TMY3 weather data files can have
values at midnight of December 31 that may be significantly different from the values
at 1:00 AM on January 1.
Since annual simulations require weather data that start at 0:00 on January 1,
data need to be provided for this hour. Due to the possibly large change in
weatherdata between 1:00 AM on January 1 and midnight at December 31,
the weather data files in the IDEAS library do not use the data entry from
midnight at December 31 as the value for <i>t=0</i>. Rather, the
value from 1:00 AM on January 1 is duplicated and used for 0:00 on January 1.
To maintain a data record with <i>8760</i> hours, the weather data record from
midnight at December 31 is deleted.
These changes in the weather data file are done in the Java program
<code>IDEAS/Resources/bin/ConvertWeatherData.jar</code> that converts
EnergyPlus weather data file to Modelica weather data files, and which is described
above.
The length of the weather data is calculated as the
end time stamp minus start time stamp plus average increment, where the
average increment is equal to the end time stamp minus start time stamp divided
by the number of rows minus 1.
This only works correctly for weather files with equidistant time stamps.
</p>
<h5>Time shift for solar radiation data</h5>
<p>
To read weather data from the TMY3 weather data file, there are
two data readers in this model. One data reader obtains all data
except solar radiation, and the other data reader reads only the
solar radiation data, shifted by <i>30</i> minutes.
The reason for this time shift is as follows:
The TMY3 weather data file contains for solar radiation the
\"...radiation received
on a horizontal surface during
the 60-minute period ending at
the timestamp.\"

Thus, as the figure below shows, a more accurate interpolation is obtained if
time is shifted by <i>30</i> minutes prior to reading the weather data.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/BoundaryConditions/WeatherData/RadiationTimeShift.png\"
border=\"1\" />
</p>
<h4>References</h4>
<ul>
<li>
Wilcox S. and W. Marion. <i>Users Manual for TMY3 Data Sets</i>.
Technical Report, NREL/TP-581-43156, revised May 2008.
</li>
</ul>
</html>",       revisions="<html>
<ul>
<li>
March 5, 2019, by Michael Wetter:<br/>
Updated documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
<li>
September 20, 2018, by Michael Wetter:<br/>
Corrected documentation.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1022\">#1022</a>.
</li>
<li>
December 4, 2017, by Michael Wetter:<br/>
Removed function call to <code>getAbsolutePath</code>, as this causes in Dymola 2018FD01
the error
\"A call of loadResource with a non-literal string remains in the generated code; it will not work for an URI.\"
when exporting <a href=\"modelica://IDEAS.Fluid.FMI.ExportContainers.Examples.FMUs.ThermalZone\">
IDEAS.Fluid.FMI.ExportContainers.Examples.FMUs.ThermalZone</a>
as an FMU. Instead, if the weather file is specified as a Modelica, URI, syntax such as
<code>Modelica.Utilities.Files.loadResource(\"modelica://IDEAS/Resources/weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.mos\")</code>
should be used.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/867\">#867</a>.
</li>
<li>
February 18, 2017, by Filip Jorissen:<br/>
Infrared radiation on horizontal surface is now delayed by 30 minutes
such that the results in
<a href=\"modelica://IDEAS.BoundaryConditions.SkyTemperature.Examples.BlackBody\">TBlaSky</a>
are consistent.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/648\">#648</a>.
</li>
<li>
December 06, 2016, by Thierry S. Nouidui:<br/>
Constrained the direct normal radiation to not be bigger than the solar constant when using
global and diffuse solar radiation data provided via the inputs connectors.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/608\">#608</a>.
</li>
<li>
April 21, 2016, by Michael Wetter:<br/>
Introduced <code>absFilNam</code> to avoid multiple calls to
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
January 6, 2016, by Moritz Lauster:<br/>
Changed output <code>radHorIR</code> to <code>HHorIR</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
January 4, 2016, by Moritz Lauster:<br/>
Added a table in documentation with output variables accessible via <code>weaBus</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/376\">#376</a>.
</li>
<li>
December 15, 2015, by Michael Wetter:<br/>
Added the block <code>cheTemBlaSky</code>. This also allows to graphically
connect the black body sky temperature to the weather bus, which is required
in Dymola 2016 for the variable <code>weaBus.TBlaSky</code> to appear
in the graphical editor.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/377\">#377</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Removed redundant but consistent
<code>connect(TBlaSkyCom.TBlaSky, weaBus.TBlaSky)</code>
statement.
This avoids a warning if
<a href=\"modelica://IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.Examples.SkyClearness\">
IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.Examples.SkyClearness</a>
is translated in pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
March 26, 2015, by Michael Wetter:<br/>
Added option to obtain the black body sky temperature
from a parameter or an input signal.
This is required for
<a href=\"modelica://Buildings.Rooms.Validation.MixedAirInitialization\">
Buildings.Rooms.Validation.MixedAirInitialization</a>.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Corrected error that led the total and opaque sky cover to be ten times
too low if its value was obtained from the parameter or the input connector.
For the standard configuration in which the sky cover is obtained from
the weather data file, the model was correct. This error only affected
the other two possible configurations.
</li>
<li>
September 12, 2014, by Michael Wetter:<br/>
Removed redundant connection <code>connect(conHorRad.HOut, cheHorRad.HIn);</code>.
</li>
<li>
May 30, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
May 5, 2013, by Thierry S. Nouidui:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the ceiling height, the total sky cover, the opaque sky cover, the dew point temperature,
and the infrared horizontal radiation <code>HInfHor</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Improved the algorithm that determines the absolute path of the file.
Now weather files are searched in the path specified, and if not found, the urls
<code>file://</code>, <code>modelica://</code> and <code>modelica://IDEAS</code>
are added in this order to search for the weather file.
This allows using the data reader without having to specify an absolute path,
as long as the <code>IDEAS</code> library
is on the <code>MODELICAPATH</code>.
This change was implemented in
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
and improves this weather data reader.
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
October 16, 2012, by Michael Wetter:<br/>
Added computation of the wet bulb temperature.
Computing the wet bulb temperature introduces a nonlinear
equation. As we have not observed an increase in computing time
because of computing the wet bulb temperature, it is computed
by default. By setting the parameter
<code>computeWetBulbTemperature=false</code>, the computation of the
wet bulb temperature can be removed.
Revised documentation.
</li>
<li>
August 11, 2012, by Wangda Zuo:<br/>
Renamed <code>radHor</code> to <code>radHorIR</code> and
improved the optional inputs for radiation data.
</li>
<li>
July 24, 2012, by Wangda Zuo:<br/>
Corrected the notes of SI unit requirements for input files.
</li>
<li>
July 13, 2012, by Michael Wetter:<br/>
Removed assignment of <code>HGloHor_in</code> in its declaration,
because this gives an overdetermined system if the input connector
is used.
Removed non-required assignments of attribute <code>displayUnit</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Added subbus for solar position, which is needed by irradition and
shading model.
</li>
<li>
November 29, 2011, by Michael Wetter:<br/>
Fixed wrong display unit for <code>pAtm_in_internal</code> and
made propagation of parameter final.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
<ol>
<li>
Added optional connectors for dry bulb temperature, relative humidity, wind speed, wind direction, global horizontal radiation, diffuse horizontal radiation.<br/>
</li>
<li>
Separate the unit conversion for TMY3 data and data validity check.
</li>
</ol>
</li>
<li>
October 3, 2011, by Michael Wetter:<br/>
Propagated value for sky temperature calculation to make it accessible as a parameter.
</li>
<li>
July 20, 2011, by Michael Wetter:<br/>
Added the option to use a constant, an input signal or the weather file as the source
for the atmospheric pressure.
</li><li>
March 15, 2011, by Wangda Zuo:<br/>
Delete the wet bulb temperature since it may cause numerical problem.
</li>
<li>
March 7, 2011, by Wangda Zuo:<br/>
Added wet bulb temperature. Changed reader to read only needed columns.
Added explanation for 30 minutes shift for radiation data.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
Changed implementation to obtain longitude and time zone directly
from weather file.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=false,
           extent={{-200,-300},{300,300}})));
      end ReaderTMY3;

      package BaseClasses
      "Package with base classes for IDEAS.BoundaryConditions.WeatherData"
        extends Modelica.Icons.BasesPackage;

        block CheckBlackBodySkyTemperature
          "Check the validity of the black-body sky temperature data"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Black-body sky temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput TOut(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Black-body sky temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          parameter Modelica.SIunits.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.SIunits.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";
        equation
          TOut = TIn;
          assert(TOut > TMin, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));
          assert(TOut < TMax, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));
          annotation (
            defaultComponentName="cheSkyBlaBodTem",
            Documentation(info="<html>
<p>
This component checks the value of the black-body sky temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 5, 2015 by Michael Wetter:<br/>
First implementation, based on
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature\">
IDEAS.BoundaryConditions.WeatherData.BaseClasses.CheckTemperature</a>.
This was implemented to get the corrected documentation string in the weather bus connector.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{56,12},{-68,-16}},
                  lineColor={0,0,0},
                  textString="TSkyBlaBod")}));
        end CheckBlackBodySkyTemperature;

        block CheckCeilingHeight
          "Ensures that the ceiling height is above a lower bound"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput ceiHeiIn(
            final quantity="Height",
            final unit="m") "Input ceiling height"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput ceiHeiOut(
            final quantity="Height",
            final unit="m") "Ceiling height"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Height ceiHeiMin=0 "Minimum allowed ceiling height";
        equation
          ceiHeiOut = IDEAS.Utilities.Math.Functions.smoothMax(
            ceiHeiIn,
            ceiHeiMin,
            0.1);
          annotation (
            defaultComponentName="cheCeiHei",
            Documentation(info="<html>
<p>
This component ensures that the ceiling height is at least <i>0</i> meters.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="m")}));
        end CheckCeilingHeight;

        block CheckIRRadiation "Ensure that the radiation is not smaller than 0"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput HIn(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Input horizontal infrared irradiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput HOut(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Horizontal infrared irradiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.RadiantEnergyFluenceRate HMin=0.0001
            "Minimum value for radiation";
        equation
          HOut = IDEAS.Utilities.Math.Functions.smoothMax(
            x1=HIn,
            x2=HMin,
            deltaX=HMin/10);
          annotation (
            defaultComponentName="cheRad",
            Documentation(info="<html>
<p>
This block ensures that the radiation is not smaller than <i>0</i>.
The Modelica data reader will interpolate data when it reads the data from a file.
Thus, it is possible to generate negative values due to the interpolation.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 7, 2016, by Michael Wetter:<br/>
Updated comment.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-24,44},{30,-32}},
                  lineColor={0,0,255},
                  textString="H")}));
        end CheckIRRadiation;

        block CheckPressure
          "Ensures that the interpolated pressure is between prescribed bounds"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput PIn(
            final quantity="Pressure",
            final unit="Pa") "Input pressure"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput POut(
            final quantity="Pressure",
            final unit="Pa") "Atmospheric pressure"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Pressure PMin=3100 "Minimum allowed pressure";
          constant Modelica.SIunits.Pressure PMax=120000 "Maximum allowed pressure";
        equation
          assert(PIn > PMin, "Pressure out of bounds.\n" + "   PIn = " + String(PIn));
          assert(PIn < PMax, "Pressure out of bounds.\n" + "   PIn = " + String(PIn));
          POut = PIn;
          annotation (
            defaultComponentName="chePre",
            Documentation(info="<html>
<p>
This component ensures that the interpolated pressure is between <i>31,000</i> Pa and <i>120,000</i> Pa.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="P")}));
        end CheckPressure;

        block CheckRadiation "Ensure that the radiation is not smaller than 0"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput HIn(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Input radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput HOut(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Radiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.RadiantEnergyFluenceRate HMin=0.0001
            "Minimum value for radiation";
        equation
          HOut = IDEAS.Utilities.Math.Functions.smoothMax(
            x1=HIn,
            x2=HMin,
            deltaX=HMin/10);
          annotation (
            defaultComponentName="cheRad",
            Documentation(info="<html>
<p>
This block ensures that the radiation is not smaller than <i>0</i>.
The Modelica data reader will interpolate data when it reads the data from a file.
Thus, it is possible to generate negative values due to the interpolation.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 7, 2016, by Michael Wetter:<br/>
Updated comment.
</li>
<li>
October 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-24,44},{30,-32}},
                  lineColor={0,0,255},
                  textString="H")}));
        end CheckRadiation;

        block CheckRelativeHumidity "Check the validity of relative humidity"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput relHumIn(final unit="1")
            "Input relative humidity"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relHumOut(final unit="1")
            "Relative humidity"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Real delta=0.01 "Smoothing parameter";
      protected
          constant Real relHumMin=delta "Lower bound";
          constant Real relHumMax=1 - delta "Upper bound";
        equation
          relHumOut = IDEAS.Utilities.Math.Functions.smoothLimit(
            relHumIn,
            relHumMin,
            relHumMax,
            delta/10);
          annotation (
            defaultComponentName="cheRelHum",
            Documentation(info="<html>
<p>
This component constrains the value of relative humidity to a range of <i>[0, 1]</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Bitmap(extent={{-74,-78},{76,74}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/WeatherData/BaseClasses/relativeHumidity.png")}));
        end CheckRelativeHumidity;

        block CheckSkyCover "Constrains the sky cover to [0, 1]"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput nIn(min=0, max=1)
            "Input sky cover [0, 10]"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput nOut(min=0, max=1, unit="1")
            "Sky cover [0, 1]"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Real delta=0.01 "Smoothing parameter";
      protected
          constant Real nMin=delta "Lower bound";
          constant Real nMax=10 - delta "Upper bound";
        equation
          nOut = IDEAS.Utilities.Math.Functions.smoothLimit(
            nIn,
            nMin,
            nMax,
            delta/10);
          annotation (
            defaultComponentName="cheSkyCov",
            Documentation(info="<html>
<p>
This component constrains the interpolated sky cover between <i>0</i> and <i>1</i>.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 4, 2015, by Michael Wetter:<br/>
Removed wrong unit string for input signal.
</li>
<li>
October 17, 2014, by Michael Wetter:<br/>
Changed model as
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.ReaderTMY3\">
IDEAS.BoundaryConditions.WeatherData.ReaderTMY3</a>
send a signal between <i>0</i> and <i>1</i>.
Added <code>min</code> and <code>max</code>
attributes.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-64,48},{70,-48}},
                  lineColor={0,0,255},
                  textString="Sky")}));
        end CheckSkyCover;

        block CheckTemperature "Check the validity of temperature data"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput TIn(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Input Temperature"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput TOut(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            displayUnit="degC") "Output temperature"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          parameter Modelica.SIunits.Temperature TMin(displayUnit="degC") = 203.15
            "Minimum allowed temperature";
          parameter Modelica.SIunits.Temperature TMax(displayUnit="degC") = 343.15
            "Maximum allowed temperature";
        equation
          TOut = TIn;
          assert(TOut > TMin, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));
          assert(TOut < TMax, "Temperature out of bounds.\n" + "   TOut = " + String(
            TOut));
          annotation (
            defaultComponentName="cheTem",
            Documentation(info="<html>
<p>
This component checks the value of temperature.
If the temperature is outside <code>TMin</code> and <code>TMax</code>,
the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit conversion part and name it from ConvertTemperature to CheckTemperature.
</li>
<li>
March 23, 2011, by Michael Wetter:<br/>
Set <code>displayUnit</code> argument for temperature output signal.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{42,44},{-38,-36}},
                  lineColor={0,0,0},
                  textString="T")}));
        end CheckTemperature;

        block CheckWindDirection "Constrains the wind direction to [0, 2*pi] degree"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput nIn(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Input wind direction"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput nOut(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") "Wind direction"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Real delta=0.01 "Smoothing parameter";
      protected
          constant Real nMin=0 "Lower bound";
          constant Real nMax=2*Modelica.Constants.pi "Upper bound";
        equation
          nOut = IDEAS.Utilities.Math.Functions.smoothLimit(
            nIn,
            nMin,
            nMax,
            delta/10);
          annotation (
            defaultComponentName="cheWinDir",
            Documentation(info="<html>
<p>
This component constrains the interpolated wind direction between <i>0</i> and <i>360</i> degree.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Delete the unit conversion part since it will be done outside.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end CheckWindDirection;

        block CheckWindSpeed "Ensures that the wind speed is non-negative"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput winSpeIn(final quantity="Velocity",
              final unit="m/s") "Input wind speed"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput winSpeOut(final quantity="Velocity",
              final unit="m/s") "Wind speed"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          constant Modelica.SIunits.Velocity winSpeMin=1e-6
            "Minimum allowed wind speed";
        equation
          // Modelica Table will interpolate data when it reads the weather data file.
          // It can generate negative values due to the interpolation.
          winSpeOut = IDEAS.Utilities.Math.Functions.smoothMax(
            x1=winSpeIn,
            x2=winSpeMin,
            deltaX=winSpeMin/10);
          annotation (
            defaultComponentName="cheWinSpe",
            Documentation(info="<html>
<p>
This component ensures that the wind speed is non-negative.
</p>
</html>",         revisions="<html>
<ul>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-28,42},{26,-34}},
                  lineColor={0,0,255},
                  textString="m/s")}));
        end CheckWindSpeed;

        block ConvertRadiation
          "Convert the unit of solar radiation received from the TMY3 data file"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput HIn(final unit="W.h/m2")
            "Input radiation"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput HOut(
            final quantity="RadiantEnergyFluenceRate",
            final unit="W/m2") "Radiation"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          constant Modelica.SIunits.Time Hou=3600 "1 hour";
        equation
          HOut = HIn/Modelica.SIunits.Conversions.to_hour(Hou);
          annotation (
            defaultComponentName="conRad",
            Documentation(info="<html>
<p>
The TMY3 data for solar radiation is the radiation accumulated in one hour. Thus, it used a unit of <code>Wh/m2</code>.
This component converts <code>Wh/m2</code> to <code>W/m2</code> that is the standard unit in Modelica.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Add the unit conversion and delete the data validity check.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-24,44},{30,-32}},
                  lineColor={0,0,255},
                  textString="H")}));
        end ConvertRadiation;

        block ConvertRelativeHumidity
          "Convert the relative humidity from percentage to real"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput relHumIn(unit="1")
            "Value of relative humidity in percentage"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput relHumOut(unit="1")
            "Relative humidity between 0 and 1"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          relHumOut = relHumIn/100;
          annotation (
            defaultComponentName="conRelHum",
            Documentation(info="<html>
<p>
This component converts the relative humidity from percentage to real.
Input is the relative humidity in percentage, as this is the data
format that is used in the Typical Meteorological Year weather data.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 27, 2011, by Wangda Zuo:<br/>
Separate the checking function to CheckRelativeHumidity.
</li>
<li>
July 14, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Bitmap(extent={{-74,-78},{76,74}}, fileName=
                      "modelica://IDEAS/Resources/Images/BoundaryConditions/WeatherData/BaseClasses/relativeHumidity.png")}));
        end ConvertRelativeHumidity;

        block ConvertTime
          "Converts the simulation time to calendar time in scale of 1 year (365 days), or a multiple of a year"
          extends Modelica.Blocks.Icons.Block;

          parameter Modelica.SIunits.Time weaDatStaTim(displayUnit="d") "Start time of weather data";
          parameter Modelica.SIunits.Time weaDatEndTim(displayUnit="d") "End time of weather data";

          Modelica.Blocks.Interfaces.RealInput modTim(
            final quantity="Time",
            final unit="s") "Simulation time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput calTim(
            final quantity="Time",
            final unit="s") "Calendar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));

      protected
          constant Modelica.SIunits.Time shiftSolarRad=1800 "Number of seconds for the shift for solar radiation calculation";
          parameter Modelica.SIunits.Time lenWea = weaDatEndTim-weaDatStaTim "Length of weather data";

          parameter Boolean canRepeatWeatherFile = abs(mod(lenWea, 365*24*3600)) < 1E-2
            "=true, if the weather file can be repeated, since it has the length of a year or a multiple of it";

          discrete Modelica.SIunits.Time tNext(start=0, fixed=true) "Start time of next period";

        equation
          when {initial(), canRepeatWeatherFile and modTim > pre(tNext)} then
            // simulation time stamp went over the end time of the weather file
            //(last time stamp of the weather file + average increment)
            tNext = if canRepeatWeatherFile then integer(modTim/lenWea)*lenWea + lenWea else time;
          end when;
          calTim = if canRepeatWeatherFile then modTim - tNext + lenWea else modTim;

          assert(canRepeatWeatherFile or (time - weaDatEndTim) < shiftSolarRad,
            "In " + getInstanceName() + ": Insufficient weather data provided for the desired simulation period.
    Based on the provided weather file the following start time "         + String(weaDatStaTim) +
            " and end time " + String(weaDatEndTim) + " (last time stamp + average increment) for the weather data were determined",
            AssertionLevel.error);

          annotation (
            defaultComponentName="conTim",
            Documentation(info="<html>
<p>
This component converts the simulation time to calendar time in a scale of 1 year (365 days),
or a multiple of it, if this is the length of the weather file.
</p>
</html>",         revisions="<html>
<ul>
<li>
June 12, 2019, by Michael Wetter:<br/>
Reformulated model to avoid having to evaluate the weather file during compilation
(as it determined the structural parameter <code>lenWea</code>). The new formulation
allows inclusion of the weather file in JModelica-generated FMUs, and it works with
Dymola as well.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1147\">#1147</a>.
</li>
<li>
May 21, 2019, by Michael Wetter:<br/>
Corrected code to avoid wrong type conversion.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1142\">#1142</a>.
</li>
<li>
March 4, 2019, by Michael Wetter:<br/>
Refactored implementation to correctly account for negative start times.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
<li>
July 27, 2018, by Ana Constantin:<br/>
Added shift for multiple time spans.
</li>
<li>
September 27, 2011, by Wangda Zuo and Michael Wetter:<br/>
Modify it to convert negative value of time.
Use the when-then to allow dymola differentiating this model when
conducting index reduction which is not allowed in previous implementation.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
Renamed the component.
</li>
<li>
July 08, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={
                Text(
                  extent={{-98,6},{-74,-4}},
                  lineColor={0,0,127},
                  textString="modTim"),
                Text(
                  extent={{74,6},{98,-4}},
                  lineColor={0,0,127},
                  textString="calTim"),
                Rectangle(
                  extent={{-66,76},{60,58}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  fillColor={120,120,120}),
                Rectangle(extent={{-66,58},{60,-62}}, lineColor={0,0,0}),
                Line(
                  points={{-24,-62},{-24,58}}),
                Line(
                  points={{18,-62},{18,58}}),
                Line(
                  points={{60,28},{-66,28}}),
                Line(
                  points={{60,-2},{-66,-2}}),
                Line(
                  points={{60,-32},{-66,-32}})}));
        end ConvertTime;

        block EquationOfTime "Equation of time"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput nDay(
            quantity="Time",
            unit="s")
            "Zero-based day number in seconds (January 1=0, January 2=86400)"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          Modelica.Blocks.Interfaces.RealOutput eqnTim(
            final quantity="Time",
            final unit="s",
            displayUnit="min") "Equation of time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          Real Bt "Intermediate variable";
        equation
          Bt = Modelica.Constants.pi*((nDay + 86400)/86400 - 81)/182
            "Our unit is s instead of day in (A.4.2b)";
          eqnTim = 60*(9.87*Modelica.Math.sin(2*Bt) - 7.53*Modelica.Math.cos(Bt) - 1.5*
            Modelica.Math.sin(Bt)) "Our unit is s instead of min in (A.4.2a)";
          annotation (
            defaultComponentName="eqnTim",
            Documentation(info="<html>
<p>
This component computes the difference between solar noon and noon of local civic time.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-58,38},{38,-24}},
                  lineColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-6,4},{52,-24}},
                  lineColor={0,0,255},
                  textString="equ")}));
        end EquationOfTime;

        block LocalCivilTime "Converts the clock time to local civil time."
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput cloTim(
            final quantity="Time",
            final unit="s") "Clock time"
            annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
          parameter Modelica.SIunits.Time timZon(displayUnit="h") "Time zone";
          parameter Modelica.SIunits.Angle lon(displayUnit="deg") "Longitude";
          Modelica.Blocks.Interfaces.RealOutput locTim(
            final quantity="Time",
            final unit="s") "Local civil time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
      protected
          final parameter Modelica.SIunits.Time diff = - timZon + lon*43200/Modelica.Constants.pi
            "Difference between local and clock time";
        equation
          locTim = cloTim + diff;
          annotation (
            defaultComponentName="locTim",
            Documentation(info="<html>
<p>
This component converts the clock time to local civil time.
The parameter <code>timZon</code> represents the time zone of the facility  (relative to Greenwich Mean Time or the 0th meridian). Time zones west of GMT (e.g. North America) are represented as negative;
east of GMT as positive. Fraction of hours are represented in decimals (e.g. for <i>6:30</i>, use <i>6.5</i>).
</p>
<p>
The formula is based on Michael Wetter's thesis (A4.1):
</p>
<pre>
  locTim = greTim + (lon*180/pi)*86400/360 = cloTim - timZon + lon*43200/pi
</pre>
</html>",         revisions="<html>
<ul>
<li>
November 14, 2015, by Michael Wetter:<br/>
Introduced <code>diff</code>.
</li>
<li>
February 27, 2011, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-98,6},{-60,-6}},
                  lineColor={0,0,127},
                  textString="cloTim"), Text(
                  extent={{74,6},{98,-4}},
                  lineColor={0,0,127},
                  textString="calTim")}));
        end LocalCivilTime;

        block SolarTime "Solar time"
          extends Modelica.Blocks.Icons.Block;
          Modelica.Blocks.Interfaces.RealInput locTim(quantity="Time", unit="s")
            "Local time" annotation (Placement(transformation(extent={{-140,-74},{-100,
                    -34}}), iconTransformation(extent={{-140,-74},{-100,-34}})));
          Modelica.Blocks.Interfaces.RealInput equTim(quantity="Time", unit="s")
            "Equation of time" annotation (Placement(transformation(extent={{-140,40},{
                    -100,80}}), iconTransformation(extent={{-140,40},{-100,80}})));
          Modelica.Blocks.Interfaces.RealOutput solTim(
            final quantity="Time",
            final unit="s",
            displayUnit="s") "Solar time"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        equation
          solTim = locTim + equTim "Our unit is s in stead of h in (A.4.3)";
          annotation (
            defaultComponentName="solTim",
            Documentation(info="<html>
<p>
This component computes the local solar time.
</p>
<p>
<b>Note:</b> To avoid events, this block does not convert solar time to a scale of 24 hours.
</p>
</html>",         revisions="<html>
<ul>
<li>
Feb. 16, 2012, by Michael Wetter:<br/>
Removed section that limits solar time to
<code>0 &le; solTim &le; 86400</code> as this triggers
events, and is not needed because solar time is used in
trigonometric functions only.
</li>
<li>
May 13, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Text(
                  extent={{-150,110},{150,150}},
                  textString="%name",
                  lineColor={0,0,255}),
                Text(
                  extent={{-54,38},{42,-24}},
                  lineColor={0,0,255},
                  textString="t"),
                Text(
                  extent={{-4,4},{52,-24}},
                  lineColor={0,0,255},
                  textString="sol"),
                Text(
                  extent={{-94,66},{-42,50}},
                  lineColor={0,0,127},
                  textString="equTim"),
                Text(
                  extent={{-96,-44},{-44,-60}},
                  lineColor={0,0,127},
                  textString="locTim")}));
        end SolarTime;

        function getHeaderElementTMY3
          "Gets an element from the header of a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         input String start "Start of the string that contains the elements";
         input String name "Name of data element, used in error reporting";
         input Integer position(min=1)
            "Position of the element on the line that contains 'start'";
         output String element
            "Element at position 'pos' of the line that starts with 'start'";
      protected
         String lin "Line that is used in parser";
         Integer iLin "Line number";
         Integer index =  0 "Index of string #LOCATION";
         Integer staInd "Start index used when parsing a real number";
         Integer nexInd "Next index used when parsing a real number";
         Boolean found "Flag, true if #LOCATION has been found";
         Boolean EOF "Flag, true if EOF has been reached";
         String fouDel "Found delimiter";
        algorithm
          // Get line that starts with 'start'
          iLin :=0;
          EOF :=false;
          while (not EOF) and (index == 0) loop
            iLin:=iLin + 1;
            (lin, EOF) :=Modelica.Utilities.Streams.readLine(fileName=filNam,
              lineNumber=iLin);
            index :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString=start,
              startIndex=1,
              caseSensitive=false);
          end while;
          assert(not EOF, "Error: Did not find '" + start + "' when scanning the weather file."
                              + "\n   Check for correct weather file syntax.");
          // Loop over the tokens until the position is reached
          nexInd :=1;
          for i in 1:position-1 loop
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString = ",",
              startIndex=nexInd+1);
           assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                lin + "'.");
          end for;
          staInd := nexInd;
          // Find the next delimiter
          nexInd :=Modelica.Utilities.Strings.find(
              string=lin,
              searchString = ",",
              startIndex=nexInd+1);
          assert(nexInd > 0, "Error when scanning weather file. Not enough tokens to find " + name + "."
                 + "\n   Check for correct file syntax." + "\n   The scanned line is '" +
                 lin + "'.");
          // Get the element
          element :=Modelica.Utilities.Strings.substring(lin, startIndex=staInd+1, endIndex=nexInd-1);
          annotation (Inline=false,
          Documentation(info="<html>
This function scans the weather data file for a line that starts with the string <pre>
start
</pre>
where <code>start</code> is a parameter.
When this line is found, the function returns the element at the position number
<code>position</code>, where <code>position</code> is a parameter.
A comma is used as the delimiter of the elements.
</html>",         revisions="<html>
<ul>
<li>
April 21, 2016, by Michael Wetter:<br/>
Removed call to
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath\">
IDEAS.BoundaryConditions.WeatherData.BaseClasses.getAbsolutePath</a>
because this function calls
<a href=\"modelica://Modelica.Utilities.Files.loadResource\">
Modelica.Utilities.Files.loadResource</a>, which needs to be resolved at compilation
time, which is difficult if it is inside a function.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/506\">Buildings, #506</a>.
</li>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
May 2, 2013, by Michael Wetter:<br/>
Added function call to <code>getAbsolutePath</code>.
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
Removed default value for parameter <code>name</code>.
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getHeaderElementTMY3;

        function getLatitudeTMY3 "Gets the latitude from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Angle lat "Latitude from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            IDEAS.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "latitude",
              position=7);
           (nexInd, lat) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the latitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lat :=lat*Modelica.Constants.pi/180;
           // Check if latitude is valid
           assert(abs(lat) <= Modelica.Constants.pi+Modelica.Constants.eps,
               "Wrong value for latitude. Received lat = " +
               String(lat) + " (= " + String(lat*180/Modelica.Constants.pi) + " degrees).");

          annotation (Documentation(info="<html>
This function returns the latitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
February 25, 2012, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLatitudeTMY3;

        function getLongitudeTMY3 "Gets the longitude from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Angle lon "Longitude from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            IDEAS.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "longitude",
              position=8);
           (nexInd, lon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the longitude '" +
                              element + "' from a String to a Real.");
           // Convert from degree to rad
           lon :=lon*Modelica.Constants.pi/180;
           // Check if longitude is valid
           assert(abs(lon) < 2*Modelica.Constants.pi,
               "Wrong value for longitude. Received lon = " +
               String(lon) + " (= " + String(lon*180/Modelica.Constants.pi) + " degrees).");
          annotation (Documentation(info="<html>
This function returns the longitude of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getLongitudeTMY3;

        function getTimeSpanTMY3
            "Get the time span of the weather data from the file"
          extends Modelica.Icons.Function;

          input String filNam "Name of weather data file";
          input String tabNam "Name of table on weather file";
          output Modelica.SIunits.Time[2] timeSpan "Start time, end time of weather data";

        external "C" getTimeSpan(filNam, tabNam, timeSpan)
          annotation (
          Include="#include <getTimeSpan.c>",
          IncludeDirectory="modelica://IDEAS/Resources/C-Sources");

          annotation (Documentation(info="<html>
<p>
This function returns the start time (first time stamp) and end time
(last time stamp plus average increment) of the TMY3 weather data file.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 16, 2019, by Jianjun Hu:<br/>
Reimplemented to use a C function, this is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1108\">#1108</a>.
</li>
<li>
November 15, 2017, by Ana Constantin:<br/>
First implementation, as part of solution to <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/842\">#842</a>.
</li>
</ul>
</html>"));
        end getTimeSpanTMY3;

        function getTimeZoneTMY3 "Gets the time zone from a TMY3 weather data file"
          extends Modelica.Icons.Function;
         input String filNam "Name of weather data file"
         annotation (Dialog(
                loadSelector(filter="Weather files (*.mos)", caption=
                    "Select weather file")));
         output Modelica.SIunits.Time timZon "Time zone from the weather file";
      protected
         Integer nexInd "Next index, used for error handling";
         String element "String representation of the returned element";
        algorithm
          element :=
            IDEAS.BoundaryConditions.WeatherData.BaseClasses.getHeaderElementTMY3(
              filNam=filNam,
              start="#LOCATION",
              name = "longitude",
              position=9);
           (nexInd, timZon) :=Modelica.Utilities.Strings.Advanced.scanReal(
            string=element,
            startIndex=1,
            unsigned=false);
           assert(nexInd > 1, "Error when converting the time zone '" +
                              element + "' from a String to a Real.");
           timZon :=timZon*3600;
           // Check if time zone is valid
           assert(abs(timZon) < 24*3600,
               "Wrong value for time zone. Received timZon = " +
               String(timZon) + " (= " + String(timZon/3600) + " hours).");
          annotation (Documentation(info="<html>
This function returns the time zone of the TMY3 weather data file.
</html>",         revisions="<html>
<ul>
<li>
September 24, 2015, by Marcus Fuchs:<br/>
Replace Dymola specific annotation by <code>loadSelector</code>
for MSL compliancy as reported by @tbeu at
<a href=\"https://github.com/RWTH-EBC/AixLib/pull/107\">RWTH-EBC/AixLib#107</a>
</li>
<li>
March 5, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end getTimeZoneTMY3;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData\">IDEAS.BoundaryConditions.WeatherData</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
This package contains models to read weather data. It also contains
the <code>expandable connector</code>
<a href=\"modelica://IDEAS.BoundaryConditions.WeatherData.Bus\">
IDEAS.BoundaryConditions.WeatherData.Bus</a>
that is used in the library to provide weather data to the different models.
</html>"));
    end WeatherData;

    package Types "Package with type definitions"
     extends Modelica.Icons.TypesPackage;

      type DataSource = enumeration(
        File   "Use data from file",
        Parameter   "Use parameter",
        Input   "Use input connector") "Enumeration to define data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions="<html>
<ul>
<li>
July 20, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));

      type RadiationDataSource = enumeration(
        File   "Use data from file",
        Input_HGloHor_HDifHor
            "Global horizontal and diffuse horizontal radiation from connector",
        Input_HDirNor_HDifHor
            "Direct normal and diffuse horizontal radiation from connector",
        Input_HDirNor_HGloHor
            "Direct normal and global horizontal radiation from connector")
        "Enumeration to define solar radiation data source"
            annotation(Documentation(info="<html>
<p>
Enumeration to define the data source used in the weather data reader.
</p>
</html>",     revisions="<html>
<ul>
<li>
August 13, 2012, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));

      type SkyTemperatureCalculation = enumeration(
        HorizontalRadiation
            "Use horizontal irradiation",
        TemperaturesAndSkyCover
            "Use dry-bulb and dew-point temperatures and sky cover")
        "Enumeration for computation of sky temperature" annotation (
        Documentation(info =       "<html>
<p>
Enumeration to define the method used to compute the sky temperature.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 3, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    annotation (preferredView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
    end Types;

    package Interfaces
    extends Modelica.Icons.InterfacesPackage;

      partial model PartialSimInfoManager
        "Partial providing structure for SimInfoManager"
        parameter String filNam=
          Modelica.Utilities.Files.loadResource("modelica://IDEAS/Resources/weatherdata/Uccle.TMY")
          "File name of TMY3 weather file" annotation(Dialog(loadSelector(filter="TMY-files (*.TMY);;Text files (*.txt);;All files (*.*)", caption="Select the weather file")));
        parameter Modelica.SIunits.Angle lat(displayUnit="deg") = weaDat.lat
          "Latitude of the location"
          annotation(Dialog(tab="Advanced"));
        parameter Modelica.SIunits.Angle lon(displayUnit="deg") = weaDat.lon
          "Longitude of the location"
          annotation(Dialog(tab="Advanced"));
        parameter Modelica.SIunits.Time timZon(displayUnit="h") = weaDat.timZon
          "Time zone for which the simulation time t=0 corresponds to midnight, january 1st";


        parameter Modelica.SIunits.Angle incS = IDEAS.Types.Azimuth.S
          "South inclination"
          annotation(Dialog(tab="Incidence angles"));
        parameter Modelica.SIunits.Angle incW = incS +Modelica.Constants.pi/2
          "West inclination"
            annotation(Dialog(tab="Incidence angles"));
        parameter Modelica.SIunits.Angle incN = incS +Modelica.Constants.pi
          "North inclination"
            annotation(Dialog(tab="Incidence angles"));
        parameter Modelica.SIunits.Angle incE = incS +3*Modelica.Constants.pi/2
          "East inclination"
            annotation(Dialog(tab="Incidence angles"));

        parameter Modelica.SIunits.Angle incAndAziInBus[:,:] = {{IDEAS.Types.Tilt.Ceiling,0},{IDEAS.Types.Tilt.Wall,incS},
                               {IDEAS.Types.Tilt.Wall,incW},{IDEAS.Types.Tilt.Wall,incN},{IDEAS.Types.Tilt.Wall,incE}, {IDEAS.Types.Tilt.Floor,0}}
                              "Combination of inclination and azimuth which are pre-computed and added to solBus." annotation(Dialog(tab="Incidence angles"));
        final parameter Modelica.SIunits.Angle aziOpts[5]={incS, incW, incN, incE, incS}
          "Inclination options, default south";
        final parameter Modelica.SIunits.Angle incOpts[4]={IDEAS.Types.Tilt.Wall, IDEAS.Types.Tilt.Floor, IDEAS.Types.Tilt.Ceiling, IDEAS.Types.Tilt.Wall}
          "Azimuth options, default wall";

        parameter Boolean computeConservationOfEnergy=false
          "Add equations for verifying conservation of energy"
          annotation (Evaluate=true, Dialog(tab="Conservation of energy"));
        parameter Boolean strictConservationOfEnergy=false
          "This adds an assert statement to make sure that energy is conserved"
          annotation (Evaluate=true, Dialog(tab="Conservation of energy", enable=
                computeConservationOfEnergy));
        parameter Boolean openSystemConservationOfEnergy=false
          "Compute conservation of energy for open system" annotation (Evaluate=true,
            Dialog(tab="Conservation of energy", enable=computeConservationOfEnergy));

        parameter Boolean lineariseDymola=false "Linearises building model equations for Dymola linearisation approach"
          annotation (Dialog(tab="Linearisation"));
        parameter Boolean lineariseJModelica=false "Linearises building model equations for optimisations in JModelica"
          annotation (Dialog(tab="Linearisation"));
        parameter Boolean createOutputs = false
          "Creates output connections when linearising windows"
          annotation(Dialog(tab="Linearisation"));
        parameter Boolean outputAngles=not lineariseDymola
          "Output angles in weaBus. Set to false when linearising" annotation(Dialog(tab="Linearisation"));
        parameter Boolean linIntCon=false
          "= true, if interior convective heat transfer should be linearised"
          annotation (Dialog(tab="Linearisation", group="Convection"));
        parameter Boolean linExtCon=false
          "= true, if exterior convective heat transfer should be linearised (uses average wind speed)"
          annotation (Dialog(tab="Linearisation", group="Convection"));
        parameter Boolean linIntRad=true
          "= true, if interior radiative heat transfer should be linearised"
          annotation (Dialog(tab="Linearisation", group="Radiation"));
        parameter Boolean linExtRad=false
          "= true, if exterior radiative heat transfer for walls should be linearised"
          annotation (Dialog(tab="Linearisation", group="Radiation"));
        // separate parameter linExtRadWin since window dynamics are steady state by default
        parameter Boolean linExtRadWin=true
          "= true, if exterior radiative heat transfer for windows should be linearised"
          annotation (Dialog(tab="Linearisation", group="Radiation"));
        parameter Modelica.SIunits.Energy Emax=1
          "Error bound for violation of conservation of energy" annotation (Evaluate=true,
            Dialog(tab="Conservation of energy", enable=strictConservationOfEnergy));
        parameter Modelica.SIunits.Temperature Tenv_nom= 280
          "Nominal ambient temperature, only used when linearising equations";

        parameter Integer nWindow = 1
          "Number of windows in the to be linearised model"
          annotation(Dialog(tab="Linearisation"));
        parameter Integer nLayWin= 3
          "Number of window layers in the to be linearised model; should be maximum of all windows"
          annotation(Dialog(tab="Linearisation"));
        parameter Real ppmCO2 = 400
          "Default CO2 concentration in [ppm] when using air medium containing CO2"
          annotation(Dialog(tab="Advanced", group="CO2"));
        final parameter Integer numIncAndAziInBus = size(incAndAziInBus,1)
          "Number of pre-computed azimuth";
        final parameter Modelica.SIunits.Temperature Tdes=-8 + 273.15
          "design outdoor temperature";
        final parameter Modelica.SIunits.Temperature TdesGround=10 + 273.15
          "design ground temperature";
        final parameter Boolean linearise=lineariseDymola or lineariseJModelica
          "Linearises building model equations"
          annotation (Dialog(tab="Linearisation"));

        Modelica.SIunits.Temperature Te
          "ambient outdoor temperature for determination of sky radiation exchange";
        Modelica.SIunits.Temperature Tsky "effective overall sky temperature";
        Modelica.SIunits.Temperature TeAv
          "running average of ambient outdoor temperature of the last 5 days, not yet implemented";
        Modelica.SIunits.Temperature Tground "ground temperature";
        Modelica.SIunits.Velocity Va "wind speed";
        Modelica.SIunits.Angle Vdir "wind direction";

        Real relHum(final unit="1") "Relative humidity";
        Modelica.SIunits.Temperature TDewPoi "Dewpoint";


        Modelica.SIunits.Energy Etot "Total internal energy";
        Modelica.SIunits.Energy Qint "Total energy from boundary";

        IDEAS.Utilities.Psychrometrics.X_pTphi XiEnv(use_p_in=false)
          annotation (Placement(transformation(extent={{-20,20},{0,40}})));

        // Icon of weaBus is made very small as it is not intended that a user would use it.
        // weaBus is still directly connected in the zone model and the connector should
        // therefore not be protected.
        // Connector weaDatBus is made available for the user and it should be used instead
        // of weaBus.
        IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(numSolBus=numIncAndAziInBus,
            final outputAngles=outputAngles)
          annotation (Placement(transformation(extent={{90,30},{110,50}}),
              iconTransformation(extent={{90,30},{90,30}})));
        IDEAS.BoundaryConditions.SolarIrradiation.ShadedRadSol[numIncAndAziInBus] radSol(
          inc=incAndAziInBus[:, 1],
          azi=incAndAziInBus[:, 2],
          each lat=lat,
          each outputAngles=outputAngles)
          "Model for computing solar irradiation and properties of predefined set of tilted surfaces"
          annotation (Placement(transformation(extent={{40,60},{60,80}})));

        Modelica.Blocks.Sources.RealExpression TskyPow4Expr(y=Tsky^4)
          "Power 4 of sky temperature"
          annotation (Placement(transformation(extent={{-20,94},{0,114}})));
        Modelica.Blocks.Sources.RealExpression TePow4Expr(y=Te^4)
          "Power 4 of ambient temperature"
          annotation (Placement(transformation(extent={{-20,106},{0,126}})));
        Modelica.Blocks.Sources.RealExpression TdesExpr(y=Tdes)
          "Expression for design temperature"
          annotation (Placement(transformation(extent={{60,0},{80,20}})));

        Modelica.Thermal.HeatTransfer.Sources.FixedTemperature fixedTemperature(T=10e6)
          "Fixed temperature";
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a Qgai
          "Thermal gains in model"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
        IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.EnergyPort E
          "Model internal energy"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));

        Modelica.Blocks.Sources.RealExpression CEnv(y=ppmCO2*MMFraction/1e6)
          "Concentration of trace substance in surroundings"
          annotation (Placement(transformation(extent={{60,-30},{80,-10}})));

        input IDEAS.Buildings.Components.Interfaces.WindowBus[nWindow] winBusOut(
            each nLay=nLayWin) if createOutputs
          "Bus for windows in case of linearisation";
        Modelica.Blocks.Routing.RealPassThrough solTim
          "Solar time"
          annotation (Placement(transformation(extent={{-86,-2},{-78,6}})));
        IDEAS.BoundaryConditions.WeatherData.Bus weaDatBus
          "Weather data bus connectable to weaBus connector from Buildings Library"
          annotation (Placement(transformation(extent={{-110,-20},{-90,0}}),
              iconTransformation(
              extent={{-20,-19},{20,19}},
              rotation=270,
              origin={99,3.55271e-015})));

    protected
        final parameter Integer yr=2014 "depcited year for DST only";

        final constant Real MMFraction=1.528635
          "Molar mass of CO2 divided by the molar mass of moist air";
        IDEAS.BoundaryConditions.WeatherData.ReaderTMY3 weaDat(
          filNam=filNam)
          annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
        IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.RelativeAirMass
          relativeAirMass "Computation of relative air mass"
          annotation (Placement(transformation(extent={{-60,60},{-40,80}})));
        IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.SkyBrightness
          skyBrightness "Computation of sky brightness"
          annotation (Placement(transformation(extent={{-30,60},{-10,80}})));
        IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.SkyClearness skyClearness
          "Computation of sky clearness"
          annotation (Placement(transformation(extent={{-60,100},{-40,120}})));

        IDEAS.BoundaryConditions.SolarIrradiation.BaseClasses.BrighteningCoefficient
          skyBrightnessCoefficients
          "Computation of sky brightness coefficients F1 and F2"
          annotation (Placement(transformation(extent={{0,80},{20,100}})));
        Modelica.Blocks.Sources.RealExpression TGround(y=TdesGround)
          annotation (Placement(transformation(extent={{60,-44},{80,-24}})));
        Modelica.Blocks.Sources.RealExpression u_dummy(y=1)
          annotation (Placement(transformation(extent={{60,-58},{80,-38}})));
        Modelica.Blocks.Routing.RealPassThrough solHouAng "Solar hour angle"
          annotation (Placement(transformation(extent={{-86,66},{-78,74}})));
        Modelica.Blocks.Routing.RealPassThrough solDec "Solar declination angle"
          annotation (Placement(transformation(extent={{-86,52},{-78,60}})));
        Modelica.Blocks.Routing.RealPassThrough HDirNor "Beam solar irradiation"
          annotation (Placement(transformation(extent={{-86,40},{-78,48}})));
        Modelica.Blocks.Routing.RealPassThrough phiEnv "Relative humidity"
          annotation (Placement(transformation(extent={{-86,12},{-78,20}})));
        Modelica.Blocks.Routing.RealPassThrough TDryBul "Dry bulb air temperature"
          annotation (Placement(transformation(extent={{-86,26},{-78,34}})));
        Modelica.Blocks.Routing.RealPassThrough angZen "Solar zenith angle"
          annotation (Placement(transformation(extent={{-86,80},{-78,88}})));
        Modelica.Blocks.Routing.RealPassThrough HGloHor
          "Global/total solar irradiation on a horizontal plane"
          annotation (Placement(transformation(extent={{-86,108},{-78,116}})));
        Modelica.Blocks.Routing.RealPassThrough HDifHor
          "Diffuse solar irradiation on a horizontal plane"
          annotation (Placement(transformation(extent={{-86,94},{-78,102}})));

        Modelica.Blocks.Routing.RealPassThrough winSpe "Wind speed"
          annotation (Placement(transformation(extent={{-86,122},{-78,130}})));
        Modelica.Blocks.Routing.RealPassThrough winDir "Wind direction"
          annotation (Placement(transformation(extent={{-86,136},{-78,144}})));
      initial equation
        if not linearise and computeConservationOfEnergy then
          Etot = 0;
        end if;
      equation
        if strictConservationOfEnergy and computeConservationOfEnergy then
          assert(abs(Etot) < Emax, "Conservation of energy violation > Emax J!");
        end if;

        if not linearise and computeConservationOfEnergy then
          der(Qint) = Qgai.Q_flow;
        else
          Qint = 0;
        end if;
        Etot = Qint - E.E;
        E.Etot = Etot;

        connect(skyClearness.skyCle, skyBrightnessCoefficients.skyCle) annotation (
            Line(
            points={{-39,110},{-36,110},{-36,96},{-2,96}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyBrightness.skyBri, skyBrightnessCoefficients.skyBri) annotation (
            Line(
            points={{-9,70},{-8,70},{-8,90},{-2,90}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(relativeAirMass.relAirMas, skyBrightness.relAirMas) annotation (Line(
            points={{-39,70},{-38,70},{-38,74},{-32,74}},
            color={0,0,127},
            smooth=Smooth.None));

        for i in 1:numIncAndAziInBus loop
          connect(solTim.y, radSol[i].solTim) annotation (Line(points={{-77.6,2},{18,2},
                  {18,74},{38,74},{38,73},{39.6,73}},   color={0,0,127}));
          connect(solHouAng.y, radSol[i].angHou) annotation (Line(points={{-77.6,70},{
                  -74,70},{-74,48},{30,48},{30,68},{39.6,68}}, color={0,0,127}));
          connect(angZen.y, radSol[i].angZen) annotation (Line(points={{-77.6,84},{-68,
                  84},{-68,54},{32,54},{32,66},{39.6,66}}, color={0,0,127}));
          connect(solDec.y, radSol[i].angDec) annotation (Line(points={{-77.6,56},{-76,
                  56},{-76,46},{28,46},{28,70},{39.6,70}}, color={0,0,127}));
          connect(radSol[i].solDirPer,HDirNor. y) annotation (Line(points={{39.6,80},{
                  22,80},{22,44},{-77.6,44}}, color={0,0,127}));
          connect(radSol[i].solDifHor,HDifHor. y) annotation (Line(points={{39.6,76},{
                  26,76},{26,52},{-70,52},{-70,98},{-77.6,98}}, color={0,0,127}));
          connect(HGloHor.y, radSol[i].solGloHor) annotation (Line(points={{-77.6,112},
                  {-72,112},{-72,50},{24,50},{24,78},{39.6,78}}, color={0,0,127}));
          connect(radSol[i].F2, skyBrightnessCoefficients.F2) annotation (Line(points={{39.6,60},
                  {28,60},{28,86},{21,86}},         color={0,0,127}));
          connect(radSol[i].F1, skyBrightnessCoefficients.F1) annotation (Line(points={{39.6,62},
                  {26,62},{26,94},{21,94}},         color={0,0,127}));
          connect(TskyPow4Expr.y, radSol[i].TskyPow4) annotation (Line(points={{1,104},
                  {52,104},{52,82}},   color={0,0,127}));
          connect(TePow4Expr.y, radSol[i].TePow4) annotation (Line(points={{1,116},{
                  56,116},{56,81.8}},            color={0,0,127}));
          connect(winSpe.y, radSol[i].winSpe) annotation (Line(points={{-77.6,126},{
                  44,126},{44,82}}, color={0,0,127}));
          connect(winDir.y, radSol[i].winDir) annotation (Line(points={{-77.6,140},{
                  48,140},{48,82}}, color={0,0,127}));
        end for;
        if not lineariseDymola then
          connect(solTim.y, weaBus.solTim) annotation (Line(points={{-77.6,2},{18,2},{
                18,36},{100.05,36},{100.05,40.05}}, color={0,0,127}));
          connect(angZen.y, weaBus.angZen) annotation (Line(
            points={{-77.6,84},{-68,84},{-68,54},{100.05,54},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(solHouAng.y, weaBus.angHou) annotation (Line(
              points={{-77.6,70},{-74,70},{-74,48},{100.05,48},{100.05,40.05}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(solDec.y, weaBus.angDec) annotation (Line(
              points={{-77.6,56},{-76,56},{-76,46},{100.05,46},{100.05,40.05}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HGloHor.y, weaBus.solGloHor) annotation (Line(
              points={{-77.6,112},{-72,112},{-72,50},{100.05,50},{100.05,40.05}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDifHor.y, weaBus.solDifHor) annotation (Line(
              points={{-77.6,98},{-70,98},{-70,40.05},{100.05,40.05}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirNor.y, weaBus.solDirPer) annotation (Line(
              points={{-77.6,44},{100.05,44},{100.05,40.05}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(phiEnv.y, weaBus.phi) annotation (Line(points={{-77.6,16},{-70,16},{
                -70,42},{100.05,42},{100.05,40.05}},
                                                   color={0,0,127}));
          connect(TDryBul.y, weaBus.Te) annotation (Line(points={{-77.6,30},{100.05,30},
                {100.05,40.05}}, color={0,0,127}));
          connect(CEnv.y, weaBus.CEnv) annotation (Line(points={{81,-20},{100.05,-20},
                  {100.05,40.05}},
                               color={0,0,127}));
          connect(XiEnv.X[1], weaBus.X_wEnv) annotation (Line(points={{1,30},{100.05,30},
                  {100.05,40.05}},                             color={0,0,127}));
          connect(TdesExpr.y, weaBus.Tdes) annotation (Line(
            points={{81,10},{100.05,10},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(u_dummy.y, weaBus.dummy) annotation (Line(points={{81,-48},{100.05,-48},
                  {100.05,40.05}},          color={0,0,127}));
          connect(TGround.y, weaBus.TGroundDes) annotation (Line(points={{81,-34},{100.05,
                  -34},{100.05,40.05}},    color={0,0,127}));
          connect(skyBrightnessCoefficients.F1, weaBus.F1) annotation (Line(
            points={{21,94},{26,94},{26,38},{100.05,38},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(skyBrightnessCoefficients.F2, weaBus.F2) annotation (Line(
            points={{21,86},{28,86},{28,34},{100.05,34},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(TskyPow4Expr.y, weaBus.TskyPow4) annotation (Line(
            points={{1,104},{100.05,104},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(TePow4Expr.y, weaBus.TePow4) annotation (Line(
            points={{1,116},{100.05,116},{100.05,40.05}},
            color={0,0,127},
            smooth=Smooth.None));
          connect(winSpe.y, weaBus.Va) annotation (Line(points={{-77.6,126},{10,126},{
                10,40.05},{100.05,40.05}}, color={0,0,127}));
          connect(winDir.y, weaBus.Vdir) annotation (Line(points={{-77.6,140},{10,140},
                {10,40.05},{100.05,40.05}}, color={0,0,127}));
          for i in 1:numIncAndAziInBus loop
            connect(radSol[i].solBus, weaBus.solBus[i]) annotation (Line(
            points={{60,70},{100.05,70},{100.05,40.05}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
          end for;
         end if;
        connect(fixedTemperature.port, Qgai)
          annotation (Line(points={{0,-92},{0,-100}},          color={191,0,0}));
        connect(XiEnv.X[1], weaDatBus.X_wEnv) annotation (Line(points={{1,30},{-100,
                  30},{-100,-10}},                             color={0,0,127}));
        connect(TDryBul.y, XiEnv.T) annotation (Line(
            points={{-77.6,30},{-22,30}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(phiEnv.y, XiEnv.phi) annotation (Line(
            points={{-77.6,16},{-22,16},{-22,24}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyBrightnessCoefficients.zen, angZen.y)
          annotation (Line(points={{-2,84},{-77.6,84}}, color={0,0,127}));
        connect(skyBrightness.HDifHor,HDifHor. y) annotation (Line(points={{-32,66},{-70,
                66},{-70,98},{-77.6,98}}, color={0,0,127}));
        connect(relativeAirMass.zen, angZen.y) annotation (Line(points={{-62,70},{-68,
                70},{-68,84},{-77.6,84}}, color={0,0,127}));
        connect(skyClearness.zen, angZen.y) annotation (Line(points={{-62,104},{-68,104},
                {-68,84},{-77.6,84}}, color={0,0,127}));
        connect(skyClearness.HDifHor,HDifHor. y) annotation (Line(points={{-62,110},{-70,
                110},{-70,98},{-77.6,98}},color={0,0,127}));
        connect(skyClearness.HGloHor,HGloHor. y) annotation (Line(points={{-62,116},{-72,
                116},{-72,112},{-77.6,112}},color={0,0,127}));
        connect(solTim.u, weaDatBus.solTim)
          annotation (Line(points={{-86.8,2},{-100,2},{-100,-10}},color={0,0,127}));
        connect(angZen.u, weaDatBus.solZen) annotation (Line(points={{-86.8,84},{-100,
                84},{-100,-10}},color={0,0,127}));
        connect(HDifHor.u, weaDatBus.HDifHor) annotation (Line(points={{-86.8,98},{
                -100,98},{-100,-10}},
                                color={0,0,127}));
        connect(HGloHor.u, weaDatBus.HGloHor) annotation (Line(points={{-86.8,112},{
                -100,112},{-100,-10}},
                                 color={0,0,127}));
        connect(HDirNor.u, weaDatBus.HDirNor) annotation (Line(points={{-86.8,44},{
                -100,44},{-100,-10}},
                                color={0,0,127}));
        connect(solDec.u, weaDatBus.solDec) annotation (Line(points={{-86.8,56},{-100,
                56},{-100,-10}},color={0,0,127}));
        connect(solHouAng.u, weaDatBus.solHouAng) annotation (Line(points={{-86.8,70},
                {-100,70},{-100,-10}},color={0,0,127}));
        connect(TDryBul.u, weaDatBus.TDryBul) annotation (Line(points={{-86.8,30},{
                -100,30},{-100,-10}},
                                color={0,0,127}));
        connect(phiEnv.u, weaDatBus.relHum) annotation (Line(points={{-86.8,16},{-100,
                16},{-100,-10}},color={0,0,127}));
        connect(weaDat.weaBus, weaDatBus) annotation (Line(
            points={{-80,-50},{-80,-40},{-80,-10},{-100,-10}},
            color={255,204,51},
            thickness=0.5));
        connect(CEnv.y, weaDatBus.CEnv) annotation (Line(points={{81,-20},{82,-20},{
                82,-10},{40,-10},{40,-10},{-100,-10}}, color={0,0,127}));

        connect(winDir.u, weaDatBus.winDir) annotation (Line(points={{-86.8,140},{
                -100,140},{-100,-10}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(winSpe.u, weaDatBus.winSpe) annotation (Line(points={{-86.8,126},{
                -100,126},{-100,-10}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
          annotation (
          defaultComponentName="sim",
          defaultComponentPrefixes="inner",
          missingInnerMessage=
              "Your model is using an outer \"sim\" component. An inner \"sim\" component is not defined. For simulation drag IDEAS.BoundaryConditions.SimInfoManager into your model.",
          Icon(coordinateSystem(extent={{-100,-100},{100,160}}),
               graphics={
              Line(points={{-80,-30},{88,-30}}, color={0,0,0}),
              Line(points={{-76,-68},{-46,-30}}, color={0,0,0}),
              Line(points={{-42,-68},{-12,-30}}, color={0,0,0}),
              Line(points={{-8,-68},{22,-30}}, color={0,0,0}),
              Line(points={{28,-68},{58,-30}}, color={0,0,0}),
              Rectangle(
                extent={{-60,76},{60,-24}},
                lineColor={95,95,95},
                fillPattern=FillPattern.Solid,
                fillColor={95,95,95}),
              Rectangle(
                extent={{-50,66},{50,-4}},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255},
                pattern=LinePattern.None),
              Rectangle(
                extent={{-10,-34},{10,-24}},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{-40,-60},{-40,-60}},
                pattern=LinePattern.None,
                smooth=Smooth.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-40,-34},{40,-34},{50,-44},{-52,-44},{-40,-34}},
                smooth=Smooth.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{44,0},{38,40}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{34,0},{28,12}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{24,0},{18,56}},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{14,0},{8,36}},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Rectangle(
                extent={{4,0},{-2,12}},
                fillColor={0,127,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Line(
                points={{-6,0},{-46,0}},
                color={0,0,127},
                smooth=Smooth.None),
              Text(
                extent={{-50,66},{-20,26}},
                lineColor={95,95,95},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                textStyle={TextStyle.Italic},
                fontName="Bookman Old Style",
                textString="i")}),
          Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                  100,120}})),
          Documentation(info="<html>
</html>",       revisions="<html>
<ul>
<li>
November 28, 2019 by Ian Beausoleil-Morrison:<br/>
Remove calculation of convection coefficient at exterior surfaces 
as this has been moved to a new model. 
Also, removed this coefficient from WeaBus as it is not surface-dependent.<br/>
Make wind direction available on weather bus as this is required for new convection model.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1089\">
#1089</a>
</li>
<li>
October 9, 2019 by Josué Borrajo Bastero:<br/>
Added button to select the weather file graphically.
</li>
<li>
January 25, 2019 by Filip Jorissen:<br/>
Corrected molar mass fraction for consistency.
See <a href=https://github.com/open-ideas/IDEAS/issues/1004>#1004</a>.
</li>
<li>
April 10, 2019 by Filip Jorissen:<br/>
Avoided redundant consistent initial equation for <code>Etot</code>.
See <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
July 27, 2018 by Filip Jorissen:<br/>
Added outputs <code>CEnv</code> and <code>X_wEnv</code> to <code>weaDatBus</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/868\">#868</a>.
</li>
<li>
June 21, 2018, by Damien Picard:<br/>
Reduce the icon size of weaBus to something very small such that users would
not try to connect to it.
Rename and make public the connector weaDatBus such that it can be connected 
to models from the Buildings library.
</li>
<li>
June 12, 2018, by Filip Jorissen:<br/>
Refactored implementation such that we use more computations from the weather
data reader instead of computing them ourself using equations.
</li>
<li>
June 11, 2018, by Filip Jorissen:<br/>
Revised implementation such that longitude, latitude and time zone are read from
the TMY3 weather file.
Removed split between file path and file name to avoid confusion
and incorrectly formatted paths.
</li>
<li>
June 11, 2018, by Filip Jorissen:<br/>
Changed table name of TMY3 file from 'data' to IBPSA final default 'tab1'
for issue <a href=https://github.com/open-ideas/IDEAS/issues/808>#808</a>.
</li>
<li>
June 8, 2018, by Filip Jorissen:<br/>
Moved input TMY3 file.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/821>#821</a>.
</li>
<li>
June 7, 2018 by Filip Jorissen:<br/>
Created 'input' for TSky, Va and Fc such that
they can be overwriten from the extends clause.
This is for
<a href=\"https://github.com/open-ideas/IDEAS/issues/838\">#838</a>.
</li>
<li>
March 27, 2018, by Filip Jorissen:<br/>
Added relative humidity to weather bus.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/780>#780</a>.
</li>
<li>
January 26, 2018, by Filip Jorissen:<br/>
Added floor orientation to set of precomputed boundary conditions.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/764>#764</a>.
</li>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Added <code>solTim</code> connections for revised azimuth computations.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/753\">
#753</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed linearisation implementation for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
January 10, 2017 by Filip Jorissen:<br/>
Set <code>linExtRad = false</code>
and added new parameter <code>linExtRadWin = true</code>
since only for windows is it necessary that
<code>linExtRad</code> is true.
See <a href=https://github.com/open-ideas/IDEAS/issues/615>#615</a>.
</li>
<li>
September 22, 2016 by Filip Jorissen:<br/>
Reworked implementation such that we use Annex 60 
baseclasses for boundary condition computations.
</li>
<li>
March 25, 2016 by Filip Jorissen:<br/>
Reworked radSol implementation to use RealInputs instead of weaBus.
This simplifies translation and interpretation.
Also cleaned up connections.
</li>
<li>
January 29, 2015, Filip Jorissen:<br/>
Made changes for allowing a proper implementation of <code>airLeakage</code>.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>"));
      end PartialSimInfoManager;
    end Interfaces;
  annotation (preferredView="info",
  Documentation(info="<html>
This package contains models to compute boundary conditions such as weather data.
For models that set boundary conditions for fluid flow systems,
see
<a href=\"modelica://IDEAS.Fluid.Sources\">
IDEAS.Fluid.Sources</a>.
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
        graphics={
          Ellipse(
          extent={{-76,80},{6,-2}},
          lineColor={255,255,255},
          lineThickness=1,
          fillPattern=FillPattern.Sphere,
          fillColor={255,255,255}),
        Line(
          points={{32,-24},{76,-82}},
          color={95, 95, 95}),
        Line(
          points={{4,-24},{48,-82}},
          color={95, 95, 95}),
        Line(
          points={{-26,-24},{18,-82}},
          color={95, 95, 95}),
        Line(
          points={{-56,-24},{-12,-82}},
          color={95, 95, 95}),
        Polygon(
          points={{64,6},{50,-2},{40,-18},{70,-24},{78,-52},{26,-52},{-6,-54},{
              -72,-52},{-72,-22},{-52,-10},{-42,10},{-78,34},{-44,52},{40,56},{76,
              40},{64,6}},
          lineColor={150,150,150},
          lineThickness=0.1,
          fillPattern=FillPattern.Sphere,
          smooth=Smooth.Bezier,
          fillColor={150,150,150})}));
  end BoundaryConditions;

  package Buildings "Transient building models and model components"
  extends Modelica.Icons.Package;

    package Components
    "Building components for high-order building models or component analysis"
    extends Modelica.Icons.Package;

      model BoundaryWall "Opaque wall with optional prescribed heat flow rate or temperature boundary conditions"
        extends IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface(
           final nWin=1,
           QTra_design=U_value*A*(273.15 + 21 - TRef_a),
           dT_nominal_a=-1,
          layMul(disableInitPortB=use_T_in or use_T_fixed, monLay(monLayDyn(each addRes_b=(sim.lineariseDymola and (use_T_in or use_T_fixed))))));

        parameter Boolean use_T_fixed = false
          "Get the boundary temperature from the input connector"
          annotation(Dialog(group="Boundary conditions"));
        parameter Modelica.SIunits.Temperature T_fixed = 294.15
          "Fixed boundary temperature"
          annotation(Dialog(group="Boundary conditions",enable=use_T_fixed));
        parameter Boolean use_T_in = false
          "Get the boundary temperature from the input connector"
          annotation(Dialog(group="Boundary conditions"));
        parameter Boolean use_Q_in = false
          "Get the boundary heat flux from the input connector"
          annotation(Dialog(group="Boundary conditions"));

        Modelica.Blocks.Interfaces.RealInput T if use_T_in
          "Input for boundary temperature"                 annotation (Placement(
              transformation(extent={{-120,10},{-100,30}}),iconTransformation(extent={{-120,10},
                  {-100,30}})));
        Modelica.Blocks.Interfaces.RealInput Q_flow if use_Q_in
          "Input for boundary heat flow rate entering the wall" annotation (Placement(
              transformation(extent={{-120,-30},{-100,-10}}),
                                                          iconTransformation(extent={{-120,
                  -30},{-100,-10}})));
        Modelica.Blocks.Math.Product proPreT if  use_T_in or use_T_fixed "Product for linearisation"
          annotation (Placement(transformation(extent={{-86,26},{-74,14}})));
        Modelica.Blocks.Math.Product proPreQ if use_Q_in "Product for linearisation"
          annotation (Placement(transformation(extent={{-86,-14},{-74,-26}})));
        Modelica.Blocks.Sources.Constant TConst(k=T_fixed) if use_T_fixed
          "Constant block for temperature"
          annotation (Placement(transformation(extent={{-110,32},{-100,42}})));

    protected
        final parameter Real U_value=1/(1/8 + sum(constructionType.mats.R) + 1/8)
          "Wall U-value";
        Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preFlo(final alpha=0) if
                             use_Q_in "Prescribed heat flow rate"
          annotation (Placement(transformation(extent={{-60,-30},{-40,-10}})));
        Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature preTem if
                                   use_T_in or use_T_fixed "Prescribed temperature"
          annotation (Placement(transformation(extent={{-60,10},{-40,30}})));

      equation
        assert(not (use_T_in and use_Q_in or use_T_in and use_T_fixed or use_Q_in and use_T_fixed),
          "In "+getInstanceName()+": Only one of the following options can be used simultaneously: use_T_in, use_Q_in, use_T_fixed");
        connect(Q_flow, proPreQ.u1)
          annotation (Line(points={{-110,-20},{-100,-20},{-100,-23.6},{-87.2,-23.6}},
                                                          color={0,0,127}));
        connect(proPreQ.y, preFlo.Q_flow)
          annotation (Line(points={{-73.4,-20},{-60,-20}}, color={0,0,127}));
        connect(proPreQ.u2, propsBusInt.weaBus.dummy) annotation (Line(points={{-87.2,
                  -16.4},{-92,-16.4},{-92,40},{56.09,40},{56.09,19.91}},
                                                                  color={0,0,127}),
            Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(proPreT.y, preTem.T)
            annotation (Line(points={{-73.4,20},{-62,20}}, color={0,0,127}));
        connect(proPreT.u2, propsBusInt.weaBus.dummy) annotation (Line(points={{-87.2,
                  23.6},{-92,23.6},{-92,40},{56.09,40},{56.09,19.91}},
                                                            color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(T, proPreT.u1)
          annotation (Line(points={{-110,20},{-100,20},{-100,16.4},{-87.2,16.4}},
                                                                 color={0,0,127}));
        connect(layMul.port_b, preFlo.port) annotation (Line(points={{-10,0},{-10,0},{
                -20,0},{-20,-20},{-40,-20}}, color={191,0,0}));
        connect(preTem.port, layMul.port_b) annotation (Line(points={{-40,20},{-20,20},
                {-20,0},{-10,0}}, color={191,0,0}));
        connect(TConst.y, proPreT.u1) annotation (Line(points={{-99.5,37},{-96,37},{-96,
                16.4},{-87.2,16.4}},
                               color={0,0,127}));
        annotation (
          Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                  100}})),
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-60,-100},{60,100}}),
              graphics={
              Rectangle(
                extent={{-50,-90},{50,-70}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-50,80},{50,100}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-50,80},{50,80}},
                color={175,175,175}),
              Line(
                points={{-50,-70},{50,-70}},
                color={175,175,175}),
              Line(
                points={{-50,-90},{50,-90}},
                color={175,175,175}),
              Line(
                points={{-50,100},{50,100}},
                color={175,175,175}),
              Rectangle(
                extent={{-10,80},{10,-70}},
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward,
                pattern=LinePattern.None),
              Line(
                points={{-10,80},{-10,-70}},
                smooth=Smooth.None,
                color={175,175,175}),
              Line(
                points={{10,80},{10,-70}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5)}),
          Documentation(info="<html>
<p>
This is a wall model that should be used
to simulate a wall between a zone and a prescribed temperature or prescribed heat flow rate boundary condition.
See <a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface>IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface</a> 
for equations, options, parameters, validation and dynamics that are common for all surfaces.
</p>
<h4>Main equations</h4>
<p>
Specific to this model is that the model does not contain a convection or radiative heat exchange model at the outside of the wall.
Instead a prescribed temperature or heat flow rate may be set.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameters <code>use_T_in</code> and <code>use_Q_in</code> may be used
to enable an input for a prescribed boundary condition temperature or heat flow rate.
Alternatively, parameters <code>use_T_fixed</code> and <code>T_fixed</code> can be used
to specify a fixed boundary condition temperature.
It is not allowed to enabled multiple of these three options. 
If all are disabled then an adiabatic boundary (<code>Q_flow=0</code>) is used.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 25, 2019, by Filip Jorissen:<br/>
Revised initial equation implementation.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
December 2, 2018 by Filip Jorissen:<br/>
Added option for setting fixed boundary condition temperature.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/961\">
#961</a>. 
</li>
<li>
August 10, 2018 by Damien Picard:<br/>
Set nWin final to 1 as this should only be used for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>. 
</li>
<li>
March 22, 2017, by Filip Jorissen:<br/>
Changes for JModelica compatibility.
</li>
<li>
January 2, 2017, by Filip Jorissen:<br/>
Updated icon layer.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
December 7, 2016, by Damien Picard:<br/>
Set placeCapacityAtSurf_b to false for last layer of layMul when T_in is used and the sim.lineariseDymola is true.
Having a capacity connected directly to the prescribed temperature would require to have the derivative of T_in
when linearized.
The dynamics of the last layer is further set to dynamicFreeInitial when T_in is used to avoid an initialization problem.
</li>
<li>
March 8, 2016, by Filip Jorissen:<br/>
Fixed energyDynamics when using fixed temperature boundary condition input.
This is discussed in issue 462.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
</ul>
</html>"));
      end BoundaryWall;

      model InternalWall "interior opaque wall between two zones"
        extends IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface(
          final nWin=1,
           dT_nominal_a=1,
        E(y= if sim.computeConservationOfEnergy then layMul.E else 0),
        Qgai(y=(if sim.openSystemConservationOfEnergy or not sim.computeConservationOfEnergy
               then 0 else sum(port_emb.Q_flow))),
        final QTra_design=U_value*A    *(TRef_a - TRef_b),
          intCon_a);

        parameter Boolean linIntCon_b=sim.linIntCon
          "= true, if convective heat transfer should be linearised"
          annotation(Dialog(tab="Convection"));
        parameter Modelica.SIunits.TemperatureDifference dT_nominal_b=1
          "Nominal temperature difference used for linearisation, negative temperatures indicate the solid is colder"
          annotation(Dialog(tab="Convection"));
        parameter Modelica.SIunits.Temperature TRef_b=291.15
          "Reference temperature of zone on side of propsBus_b, for calculation of design heat loss"
           annotation (Dialog(group="Design power",tab="Advanced"));

        // open door modelling
        parameter Boolean hasCavity = false
          "=true, to model open door or cavity in wall"
          annotation(Dialog(group="Cavity or open door"));
        parameter Modelica.SIunits.Length h = 2
          "Height of (rectangular) cavity in wall"
           annotation(Dialog(enable=hasCavity,group="Cavity or open door"));
        parameter Modelica.SIunits.Length w = 1
          "Width of (rectangular) cavity in wall"
           annotation(Dialog(enable=hasCavity,group="Cavity or open door"));
        parameter Modelica.SIunits.Acceleration g = Modelica.Constants.g_n
          "Gravity, for computation of buoyancy"
          annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        parameter Modelica.SIunits.Pressure p = 101300
          "Absolute pressure for computation of buoyancy"
          annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        parameter Modelica.SIunits.Density rho = p/r/T
          "Nominal density for computation of buoyancy mass flow rate"
          annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        parameter Modelica.SIunits.SpecificHeatCapacity c_p = 1013
         "Nominal heat capacity for computation of buoyancy heat flow rate"
         annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        parameter Modelica.SIunits.Temperature T = 293
         "Nominal temperature for linearising heat flow rate"
         annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
        parameter Modelica.SIunits.TemperatureDifference dT = 1
         "Nominal temperature difference when linearising heat flow rate"
         annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));

        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_emb[constructionType.nGain]
          "port for gains by embedded active layers"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
        IDEAS.Buildings.Components.Interfaces.ZoneBus propsBus_b(
          numIncAndAziInBus=sim.numIncAndAziInBus,
          outputAngles=sim.outputAngles) "If inc = Floor, then propsbus_b should be connected to the zone below this floor.
    If inc = Ceiling, then propsbus_b should be connected to the zone above this ceiling."
              annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-100,20}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-50,20})));

    protected
        final parameter Real U_value=1/(1/8 + sum(constructionType.mats.R) + 1/8)
          "Wall U-value";
        constant Real r = 287 "Gas constant";

        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.InteriorConvection
          intCon_b(
          linearise=linIntCon_b or sim.linearise,
          dT_nominal=dT_nominal_b,
          final inc=incInt + Modelica.Constants.pi,
          final A=A)
          "convective surface heat transimission on the interior side of the wall"
          annotation (Placement(transformation(extent={{-22,-10},{-42,10}})));
        Modelica.Blocks.Sources.RealExpression QDesign_b(y=-QTra_design);
        //Negative, because of its losses from zone side b to zone side a, oposite of calculation of QTra_design

        Modelica.Blocks.Sources.RealExpression incExp1(y=incInt + Modelica.Constants.pi)
          "Inclination angle";
        Modelica.Blocks.Sources.RealExpression aziExp1(y=aziInt + Modelica.Constants.pi)
          "Azimuth angle expression";
        Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow iSolDif1(final Q_flow=0);
        Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow iSolDir1(final Q_flow=0);
        Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow Qgai_b(final Q_flow=0);
        IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.PrescribedEnergy
          E_b;
        Modelica.Blocks.Sources.Constant E0(final k=0)
          "All internal energy is assigned to right side";

        BaseClasses.ConvectiveHeatTransfer.CavityAirflow
                                              theConDoor(
          linearise=sim.linearise or linIntCon_a or linIntCon_b,
          h=h,
          w=w,
          g=g,
          p=p,
          rho=rho,
          c_p=c_p,
          T=T,
          dT=dT) if                                         hasCavity
          "Model for air flow through open door or cavity"
          annotation (Placement(transformation(extent={{-10,40},{10,60}})));
      equation
        assert(hasCavity == false or IDEAS.Utilities.Math.Functions.isAngle(incInt, IDEAS.Types.Tilt.Wall),
          "In " + getInstanceName() + ": Cavities are only supported for vertical walls, but inc=" + String(incInt));
        connect(layMul.port_b, propsBus_b.surfRad) annotation (Line(
            points={{-10,0},{-18,0},{-18,20.1},{-100.1,20.1}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(propsBus_b.surfCon, intCon_b.port_b) annotation (Line(
            points={{-100.1,20.1},{-48,20.1},{-48,0},{-42,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(layMul.port_b, intCon_b.port_a) annotation (Line(
            points={{-10,0},{-22,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(layMul.iEpsSw_b, propsBus_b.epsSw) annotation (Line(
            points={{-10,4},{-22,4},{-22,20.1},{-100.1,20.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(layMul.iEpsLw_b, propsBus_b.epsLw) annotation (Line(
            points={{-10,8},{-20,8},{-20,20.1},{-100.1,20.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(layMul.area, propsBus_b.area) annotation (Line(
            points={{0,10},{0,20.1},{-100.1,20.1}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(iSolDif1.port, propsBus_b.iSolDif);
        connect(iSolDir1.port, propsBus_b.iSolDir);
        connect(QDesign_b.y, propsBus_b.QTra_design);
        connect(incExp1.y, propsBus_b.inc);
        connect(aziExp1.y, propsBus_b.azi);
        connect(Qgai_b.port, propsBus_b.Qgai);
        connect(E_b.port, propsBus_b.E);
        connect(E_b.E, E0.y);

        connect(theConDoor.port_a, propsBus_b.surfCon) annotation (Line(points={{-10,50},
                {-48,50},{-48,20.1},{-100.1,20.1}}, color={191,0,0}));
        connect(theConDoor.port_b, propsBusInt.surfCon) annotation (Line(points={{10,50},
                {46,50},{46,19.91},{56.09,19.91}},
                                                 color={191,0,0}));
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=false,extent={{-60,-100},{60,100}}),
              graphics={
              Rectangle(
                extent={{-52,-90},{48,-70}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-50,80},{50,100}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-10,80},{10,-70}},
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward,
                pattern=LinePattern.None),
              Line(points={{-50,80},{50,80}}, color={175,175,175}),
              Line(points={{-50,-70},{50,-70}}, color={175,175,175}),
              Line(points={{-50,-90},{50,-90}}, color={175,175,175}),
              Line(points={{-50,100},{50,100}}, color={175,175,175}),
              Line(
                points={{-10,80},{-10,-70}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{10,80},{10,-70}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5)}),
          Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-60,-100},{60,
                  100}})),
          Documentation(info="<html>
<p>
This is a wall model that should be used
to simulate a wall or floor between two zones.
See <a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface>IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface</a> 
for equations, options, parameters, validation and dynamics that are common for all surfaces.
</p>
<h4>Typical use and important parameters</h4>
<p>
Each propsbus needs to be connected to a zone, which may be the same zone.
</p>
<p>
Note that this model is not symmetric: the convection equations depend on the inclination <code>inc</code>,
which is turned 180 degrees between both side. The value of <code>inc</code> is applied to the right side of the model.
</p>
<p>
Parameter <code>hasCavity</code> can be set to <code>true</code> to simulate heat transfer
through a cavity such as an open door in a simplified way.
The cavity height <code>h</code> and width <code>w</code> then have to be specified.
We assume that the value of <code>A</code> excludes the surface area of the cavity.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 13, 2019, by Filip Jorissen:<br/>
Refactored the parameter definition of <code>inc</code> 
and <code>azi</code> by adding the option to use radio buttons.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1067\">
#1067</a>
</li>
<li>
August 10, 2018 by Damien Picard:<br/>
Set nWin final to 1 as this should only be used for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>. 
</li>
<li>
May 21, 2018, by Filip Jorissen:<br/>
Added model for air flow through cavity.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/822\">#822</a>.
</li>
<li>
January 2, 2017, by Filip Jorissen:<br/>
Updated icon layer.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
</ul>
</html>"));
      end InternalWall;

      model OuterWall "Opaque building envelope construction"
         extends IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface(
           final nWin=1,
           dT_nominal_a=-3,
           QTra_design(fixed=false));

        parameter Boolean linExtCon=sim.linExtCon
          "= true, if exterior convective heat transfer should be linearised (uses average wind speed)"
          annotation(Dialog(tab="Convection"));
        parameter Boolean linExtRad=sim.linExtRad
          "= true, if exterior radiative heat transfer should be linearised"
          annotation(Dialog(tab="Radiation"));
        parameter Boolean hasBuildingShade = false
          "=true, to enable computation of shade cast by opposite building or object"
          annotation(Dialog(group="Building shade"));
        parameter Modelica.SIunits.Length L(min=0)=0
          "Distance between object and wall, perpendicular to wall"
          annotation(Dialog(group="Building shade",enable=hasBuildingShade));
        parameter Modelica.SIunits.Length dh(min=-hWal)=0
          "Height difference between top of object and top of wall"
          annotation(Dialog(group="Building shade",enable=hasBuildingShade));
        parameter Modelica.SIunits.Length hWal(min=0)=0 "Wall height"
          annotation(Dialog(group="Building shade",enable=hasBuildingShade));
        final parameter Real U_value=1/(1/8 + sum(constructionType.mats.R) + 1/25)
          "Wall U-value";

        replaceable IDEAS.Buildings.Components.Shading.BuildingShade shaType(
          final L=L,
          final dh=dh,
          final hWin=hWal) if hasBuildingShade
        constrainedby
        IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
          final azi=aziInt)
          "Building shade model"
          annotation (Placement(transformation(extent={{-72,-8},{-62,12}})),
            __Dymola_choicesAllMatching=true,
            Dialog(tab="Advanced",group="Shading"));


    protected
        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.ExteriorConvection
          extCon(
            linearise=linExtCon or sim.linearise,
            final A=A,
            final inc=incInt,
            final azi=aziInt)
          "convective surface heat transimission on the exterior side of the wall"
          annotation (Placement(transformation(extent={{-22,-28},{-42,-8}})));
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ExteriorSolarAbsorption
          solAbs(A=A)
          "determination of absorbed solar radiation by wall based on incident radiation"
          annotation (Placement(transformation(extent={{-22,-8},{-42,12}})));
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ExteriorHeatRadiation
          extRad(               linearise=linExtRad or sim.linearise, final A=A)
          "determination of radiant heat exchange with the environment and sky"
          annotation (Placement(transformation(extent={{-22,12},{-42,32}})));
        BoundaryConditions.SolarIrradiation.RadSolData radSolData(
          inc=incInt,
          azi=aziInt,
          lat=sim.lat,
          final outputAngles=sim.outputAngles,
          incAndAziInBus=sim.incAndAziInBus,
          numIncAndAziInBus=sim.numIncAndAziInBus,
          useLinearisation=sim.lineariseDymola)
          annotation (Placement(transformation(extent={{-100,-6},{-80,14}})));
        Modelica.Blocks.Routing.RealPassThrough Tdes "Design temperature passthrough";
        Modelica.Blocks.Math.Add solDif(final k1=1, final k2=1)
          "Sum of ground and sky diffuse solar irradiation"
          annotation (Placement(transformation(extent={{-54,0},{-46,8}})));
      initial equation
        QTra_design =U_value*A*(273.15 + 21 - Tdes.y);

      equation
        if hasBuildingShade then
          assert(L>0, "Shading is enabled in " + getInstanceName() +
          ": Provide a value for L, the distance to the shading object, that is larger than 0.");
          assert(not sim.lineariseDymola, "Shading is enabled in " + getInstanceName() +
          " but this is not supported when linearising a model.");
          assert(hWal>0, "Shading is enabled in " + getInstanceName() +
          ": Provide a value for hWal, the wall height, that is larger than 0.");
        end if;

        connect(extCon.port_a, layMul.port_b) annotation (Line(
            points={{-22,-18},{-18,-18},{-18,0},{-10,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(solAbs.port_a, layMul.port_b) annotation (Line(
            points={{-22,2},{-12,2},{-12,0},{-10,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(extRad.port_a, layMul.port_b) annotation (Line(
            points={{-22,22},{-18,22},{-18,0},{-10,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(layMul.iEpsSw_b,solAbs. epsSw) annotation (Line(
            points={{-10,4},{-16,4},{-16,8},{-22,8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(layMul.iEpsLw_b,extRad. epsLw) annotation (Line(
            points={{-10,8},{-16,8},{-16,25.4},{-22,25.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.weaBus, propsBusInt.weaBus) annotation (Line(
            points={{-81.8182,12.3333},{-81.8182,19.91},{56.09,19.91}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(radSolData.Tenv,extRad. Tenv) annotation (Line(
            points={{-81.2727,4},{-70,4},{-70,38},{-22,38},{-22,28}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(extCon.Te, propsBusInt.weaBus.Te) annotation (Line(
            points={{-22,-22.8},{56.09,-22.8},{56.09,19.91}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(Tdes.u, propsBusInt.weaBus.Tdes);
        connect(solDif.y, solAbs.solDif) annotation (Line(points={{-45.6,4},{-42,4}},
                                     color={0,0,127}));
        connect(radSolData.angInc, shaType.angInc) annotation (Line(
            points={{-81.2727,2.33333},{-76,2.33333},{-76,-2},{-72,-2}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.angAzi, shaType.angAzi) annotation (Line(
            points={{-81.2727,-1},{-78,-1},{-78,-6},{-72,-6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.angZen, shaType.angZen) annotation (Line(
            points={{-81.2727,0.666667},{-76,0.666667},{-76,-4},{-72,-4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.HDirTil, shaType.HDirTil) annotation (Line(points={{
                -81.2727,9},{-76,9},{-76,8},{-72,8}},color={0,0,127}));
        connect(radSolData.HSkyDifTil, shaType.HSkyDifTil) annotation (Line(points={{
                -81.2727,7.33333},{-76,7.33333},{-76,6},{-72,6}},
                                                           color={0,0,127}));
        connect(radSolData.HGroDifTil, shaType.HGroDifTil) annotation (Line(points={{
                -81.2727,5.66667},{-76,5.66667},{-76,4},{-72,4}},
                                                           color={0,0,127}));
        if not hasBuildingShade then
          connect(solDif.u1, radSolData.HSkyDifTil) annotation (Line(points={{-54.8,
                  6.4},{-55.3,6.4},{-55.3,7.33333},{-81.2727,7.33333}},
                                                  color={0,0,127}));
          connect(solDif.u2, radSolData.HGroDifTil) annotation (Line(points={{-54.8,
                  1.6},{-55.3,1.6},{-55.3,5.66667},{-81.2727,5.66667}},
                                                  color={0,0,127}));
          connect(solAbs.solDir, radSolData.HDirTil)
            annotation (Line(points={{-42,8},{-62,8},{-62,9},{-81.2727,9}},
                                                         color={0,0,127}));
        end if;
        connect(shaType.HShaDirTil, solAbs.solDir)
          annotation (Line(points={{-62,8},{-42,8}},           color={0,0,127}));
        connect(shaType.HShaSkyDifTil, solDif.u1) annotation (Line(points={{-62,6},{
                -54.8,6},{-54.8,6.4}},   color={0,0,127}));
        connect(shaType.HShaGroDifTil, solDif.u2) annotation (Line(points={{-62,4},{
                -56,4},{-56,1.6},{-54.8,1.6}},   color={0,0,127}));
        connect(radSolData.hForcedConExt, extCon.hForcedConExt) annotation (Line(points={{
                -81.2727,-4.5},{-46,-4.5},{-46,-34},{-16,-34},{-16,-27},{-22,-27}},
                                                                 color={0,0,127}));
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-60,-100},{60,100}}),
              graphics={
              Rectangle(
                extent={{-50,-90},{50,80}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-50,60},{-30,60},{-30,80},{50,80},{50,100},{-50,100},{-50,60}},
                pattern=LinePattern.None,
                lineThickness=0.5,
                smooth=Smooth.None,
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward),
              Rectangle(
                extent={{-30,-70},{-50,-20}},
                lineThickness=0.5,
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward,
                pattern=LinePattern.None),
              Line(
                points={{-50,60},{-50,66},{-50,100},{50,100}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,60},{-30,60},{-30,80},{50,80}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,-20},{-30,-20},{-30,-70},{-30,-70},{52,-70}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,-20},{-50,-90},{50,-90}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-44,60},{-30,60},{-30,80},{-28,80},{50,80}},
                pattern=LinePattern.None,
                thickness=0.5,
                smooth=Smooth.None),
              Line(
                points={{-44,-20},{-30,-20},{-30,-70}},
                pattern=LinePattern.None,
                thickness=0.5,
                smooth=Smooth.None),
              Line(
                points={{-44,60},{-44,-20}},
                smooth=Smooth.None,
                color={175,175,175}),
              Line(
                points={{-44,-20},{-30,-20},{-30,-70}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{-44,60},{-30,60},{-30,80},{50,80}},
                smooth=Smooth.None,
                color={0,0,0},
                thickness=0.5)}),
          Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                  100}})),
          Documentation(info="<html>
<p>
This is the main wall model that should be used to
simulate a wall or roof between a zone and the outside environment.
</p>
<h4>Typical use and important parameters</h4>
<p>
See <a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface>
IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface</a> 
for equations, options, parameters, validation and dynamics that are common for all surfaces.
</p>
<p>
In addition to these parameters, this model computes the shade cast by an outside
object such as a building using 
<a href=\"IDEAS.Buildings.Components.Shading.BuildingShade\">IDEAS.Buildings.Components.Shading.BuildingShade</a>
if parameter <code>hasBuildingShade=true</code>.
Values for parameters <code>L</code>, <code>dh</code> and <code>hWal</code> then have to be specified.
</p>
<h4>Options</h4>
<p>
The model <a href=\"IDEAS.Buildings.Components.Shading.BuildingShade\">IDEAS.Buildings.Components.Shading.BuildingShade</a> 
is implemented by default but it can be redeclared in the advanced tab. 
In this case the user still has to provide values for <code>L</code>, <code>dh</code> and <code>hWal</code>
to avoid failing an assert that verifies the parameter consistency. The values are however not used in this case.
The correct shading parameter values should then be passed through the redeclaration.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 28, 2019, by Ian Beausoleil-Morrison:<br/>
<code>inc</code> and <code>azi</code> of surface now passed as parameters to ExteriorConvection.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1089\">
#1089</a>
</li>
<li>
October 13, 2019, by Filip Jorissen:<br/>
Refactored the parameter definition of <code>inc</code> 
and <code>azi</code> by adding the option to use radio buttons.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1067\">
#1067</a>
</li>
<li>
August 10, 2018 by Damien Picard:<br/>
Set nWin final to 1 as this should only be used for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>. 
</li>
<li>
May 29, 2018 by Filip Jorissen:<br/>
Added building shade implementation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/576\">
#576</a>.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
January 2, 2017, by Filip Jorissen:<br/>
Updated icon layer.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>"));
      end OuterWall;

      model RectangularZoneTemplate
        "Rectangular zone including walls, floor and ceiling"
        extends
        IDEAS.Buildings.Components.Interfaces.RectangularZoneTemplateInterface;

        Modelica.Blocks.Interfaces.RealInput ctrlA if
                                                     shaTypA.controlled
          "Control input for windows in face A, if controlled"
          annotation (Placement(transformation(extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-171,-111}), iconTransformation(
              extent={{-11,-11},{11,11}},
              rotation=-90,
              origin={84,112})));
        Modelica.Blocks.Interfaces.RealInput ctrlB if
                                                     shaTypB.controlled
          "Control input for windows in face B, if controlled" annotation (Placement(
              transformation(
              extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-155,-111}), iconTransformation(extent={{123,-99},{101,-77}},
                rotation=0)));
        Modelica.Blocks.Interfaces.RealInput ctrlC if
                                                     shaTypC.controlled
          "Control input for windows in face C, if controlled" annotation (Placement(
              transformation(
              extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-139,-111}), iconTransformation(
              extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-88,-112})));
        Modelica.Blocks.Interfaces.RealInput ctrlD if
                                                     shaTypD.controlled
          "Control input for windows in face D, if controlled" annotation (Placement(
              transformation(
              extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-123,-111}), iconTransformation(
              extent={{11,-11},{-11,11}},
              rotation=180,
              origin={-112,72})));
        Modelica.Blocks.Interfaces.RealInput ctrlCei if
                                                     shaTypCei.controlled
          "Control input for windows in ceiling, if controlled" annotation (Placement(
              transformation(
              extent={{11,-11},{-11,11}},
              rotation=-90,
              origin={-107,-111}), iconTransformation(
              extent={{-11,-11},{11,11}},
              rotation=-90,
              origin={50,82})));


      replaceable
        IDEAS.Buildings.Components.Window winA(azi=aziAInt, inc=IDEAS.Types.Tilt.Wall,
          glazing(
            checkLowPerformanceGlazing=glazingA.checkLowPerformanceGlazing,
            nLay=glazingA.nLay,
            mats=glazingA.mats,
            SwAbs=glazingA.SwAbs,
            SwTrans=glazingA.SwTrans,
            SwAbsDif=glazingA.SwAbsDif,
            SwTransDif=glazingA.SwTransDif,
            U_value=glazingA.U_value,
            g_value=glazingA.g_value),
          A=A_winA,
          frac=fracA,
          T_start=T_start,
          linIntCon_a=linIntCon,
          dT_nominal_a=dT_nominal_win,
          linExtCon=linExtCon,
          windowDynamicsType=windowDynamicsType,
          redeclare IDEAS.Buildings.Components.Shading.Shading shaType(shaPro(
        controlled=shaTypA.controlled,
        shaType=shaTypA.shaType,
        hWin=shaTypA.hWin,
        wWin=shaTypA.wWin,
        wLeft=shaTypA.wLeft,
        wRight=shaTypA.wRight,
        ovDep=shaTypA.ovDep,
        ovGap=shaTypA.ovGap,
        hFin=shaTypA.hFin,
        finDep=shaTypA.finDep,
        finGap=shaTypA.finGap,
        L=shaTypA.L,
        dh=shaTypA.dh,
        shaCorr=shaTypA.shaCorr)),
          fraType(present=fraTypA.present,
                  U_value=fraTypA.U_value),
          linExtRad=linExtRadWin,
          nWin=nWinA) if
             hasWinA constrainedby Window(
             azi=aziAInt,
             inc=IDEAS.Types.Tilt.Wall,
             T_start=T_start,
             linIntCon_a=linIntCon,
             dT_nominal_a=dT_nominal_win,
             linExtCon=linExtCon,
             windowDynamicsType=windowDynamicsType,
             linExtRad=linExtRadWin,
             nWin=nWinA)
          "Window for face A of this zone"
          annotation (Dialog(tab="Advanced",group="Windows"),
            enable=hasWinA,
            choicesAllMatching=true,
            Placement(transformation(extent={{-100,0},{-90,20}})));
        replaceable
        IDEAS.Buildings.Components.Window winB(
            inc=IDEAS.Types.Tilt.Wall,
          glazing(
            checkLowPerformanceGlazing=glazingB.checkLowPerformanceGlazing,
            nLay=glazingB.nLay,
            mats=glazingB.mats,
            SwAbs=glazingB.SwAbs,
            SwTrans=glazingB.SwTrans,
            SwAbsDif=glazingB.SwAbsDif,
            SwTransDif=glazingB.SwTransDif,
            U_value=glazingB.U_value,
            g_value=glazingB.g_value),
          A=A_winB,
          frac=fracB,
          azi=aziB,
          T_start=T_start,
          linIntCon_a=linIntCon,
          dT_nominal_a=dT_nominal_win,
          linExtCon=linExtCon,
          windowDynamicsType=windowDynamicsType,
          redeclare IDEAS.Buildings.Components.Shading.Shading shaType(shaPro(
        controlled=shaTypB.controlled,
        shaType=shaTypB.shaType,
        hWin=shaTypB.hWin,
        wWin=shaTypB.wWin,
        wLeft=shaTypB.wLeft,
        wRight=shaTypB.wRight,
        ovDep=shaTypB.ovDep,
        ovGap=shaTypB.ovGap,
        hFin=shaTypB.hFin,
        finDep=shaTypB.finDep,
        finGap=shaTypB.finGap,
        L=shaTypB.L,
        dh=shaTypB.dh,
        shaCorr=shaTypB.shaCorr)),
          fraType(present=fraTypB.present, U_value=fraTypB.U_value),
          linExtRad=linExtRadWin,
          nWin=nWinB) if
             hasWinB constrainedby Window(
             azi=aziB,
             inc=IDEAS.Types.Tilt.Wall,
             T_start=T_start,
             linIntCon_a=linIntCon,
             dT_nominal_a=dT_nominal_win,
             linExtCon=linExtCon,
             windowDynamicsType=windowDynamicsType,
             linExtRad=linExtRadWin,
             nWin=nWinB)
          "Window for face B of this zone" annotation (Dialog(tab="Advanced",group="Windows"),
            enable=hasWinB,
            choicesAllMatching=true,
            Placement(
              transformation(
              extent={{-5,-10},{5,10}},
              rotation=0,
              origin={-95,-10})));
        replaceable
        IDEAS.Buildings.Components.Window winC(inc=IDEAS.Types.Tilt.Wall,
          glazing(
            checkLowPerformanceGlazing=glazingC.checkLowPerformanceGlazing,
            nLay=glazingC.nLay,
            mats=glazingC.mats,
            SwAbs=glazingC.SwAbs,
            SwTrans=glazingC.SwTrans,
            SwAbsDif=glazingC.SwAbsDif,
            SwTransDif=glazingC.SwTransDif,
            U_value=glazingC.U_value,
            g_value=glazingC.g_value),
          A=A_winC,
          frac=fracC,
          azi=aziC,
          T_start=T_start,
          linIntCon_a=linIntCon,
          dT_nominal_a=dT_nominal_win,
          linExtCon=linExtCon,
          windowDynamicsType=windowDynamicsType,
          redeclare IDEAS.Buildings.Components.Shading.Shading shaType(shaPro(
        controlled=shaTypC.controlled,
        shaType=shaTypC.shaType,
        hWin=shaTypC.hWin,
        wWin=shaTypC.wWin,
        wLeft=shaTypC.wLeft,
        wRight=shaTypC.wRight,
        ovDep=shaTypC.ovDep,
        ovGap=shaTypC.ovGap,
        hFin=shaTypC.hFin,
        finDep=shaTypC.finDep,
        finGap=shaTypC.finGap,
        L=shaTypC.L,
        dh=shaTypC.dh,
        shaCorr=shaTypC.shaCorr)),
          fraType(present=fraTypC.present, U_value=fraTypC.U_value),
          linExtRad=linExtRadWin,
          nWin=nWinC) if
             hasWinC constrainedby Window(
             azi=aziC,
             inc=IDEAS.Types.Tilt.Wall,
             T_start=T_start,
             linIntCon_a=linIntCon,
             dT_nominal_a=dT_nominal_win,
             linExtCon=linExtCon,
             windowDynamicsType=windowDynamicsType,
             linExtRad=linExtRadWin,
             nWin=nWinC)
          "Window for face C of this zone" annotation (Dialog(tab="Advanced",group="Windows"),
            enable=hasWinC,
            choicesAllMatching=true,
            Placement(
              transformation(
              extent={{-5,-10},{5,10}},
              rotation=0,
              origin={-95,-30})));
        replaceable
        IDEAS.Buildings.Components.Window winD(inc=IDEAS.Types.Tilt.Wall, azi=aziD,
          glazing(
            checkLowPerformanceGlazing=glazingD.checkLowPerformanceGlazing,
            nLay=glazingD.nLay,
            mats=glazingD.mats,
            SwAbs=glazingD.SwAbs,
            SwTrans=glazingD.SwTrans,
            SwAbsDif=glazingD.SwAbsDif,
            SwTransDif=glazingD.SwTransDif,
            U_value=glazingD.U_value,
            g_value=glazingD.g_value),
          A=A_winD,
          frac=fracD,
          T_start=T_start,
          linIntCon_a=linIntCon,
          dT_nominal_a=dT_nominal_win,
          linExtCon=linExtCon,
          windowDynamicsType=windowDynamicsType,
          redeclare IDEAS.Buildings.Components.Shading.Shading shaType(shaPro(
            controlled=shaTypD.controlled,
        shaType=shaTypD.shaType,
        hWin=shaTypD.hWin,
        wWin=shaTypD.wWin,
        wLeft=shaTypD.wLeft,
        wRight=shaTypD.wRight,
        ovDep=shaTypD.ovDep,
        ovGap=shaTypD.ovGap,
        hFin=shaTypD.hFin,
        finDep=shaTypD.finDep,
        finGap=shaTypD.finGap,
        L=shaTypD.L,
        dh=shaTypD.dh,
        shaCorr=shaTypD.shaCorr)),
          fraType(present=fraTypD.present, U_value=fraTypD.U_value),
          linExtRad=linExtRadWin,
          nWin=nWinD) if
             hasWinD constrainedby Window(
             azi=aziD,
             inc=IDEAS.Types.Tilt.Wall,
             T_start=T_start,
             linIntCon_a=linIntCon,
             dT_nominal_a=dT_nominal_win,
             linExtCon=linExtCon,
             windowDynamicsType=windowDynamicsType,
             linExtRad=linExtRadWin,
             nWin=nWinD)
          "Window for face D of this zone" annotation (Dialog(tab="Advanced",group="Windows"),
            enable=hasWinD,
            choicesAllMatching=true,
            Placement(
              transformation(
              extent={{-5,-10},{5,10}},
              rotation=0,
              origin={-95,-50})));
        replaceable
        IDEAS.Buildings.Components.Window winCei(inc=IDEAS.Types.Tilt.Ceiling, azi=aziAInt,
          glazing(
            checkLowPerformanceGlazing=glazingCei.checkLowPerformanceGlazing,
            nLay=glazingCei.nLay,
            mats=glazingCei.mats,
            SwAbs=glazingCei.SwAbs,
            SwTrans=glazingCei.SwTrans,
            SwAbsDif=glazingCei.SwAbsDif,
            SwTransDif=glazingCei.SwTransDif,
            U_value=glazingCei.U_value,
            g_value=glazingCei.g_value),
          A=A_winCei,
          frac=fracCei,
          T_start=T_start,
          linIntCon_a=linIntCon,
          dT_nominal_a=dT_nominal_win,
          linExtCon=linExtCon,
          windowDynamicsType=windowDynamicsType,
          redeclare IDEAS.Buildings.Components.Shading.Shading shaType(shaPro(
            controlled=shaTypCei.controlled,
        shaType=shaTypCei.shaType,
        hWin=shaTypCei.hWin,
        wWin=shaTypCei.wWin,
        wLeft=shaTypCei.wLeft,
        wRight=shaTypCei.wRight,
        ovDep=shaTypCei.ovDep,
        ovGap=shaTypCei.ovGap,
        hFin=shaTypCei.hFin,
        finDep=shaTypCei.finDep,
        finGap=shaTypCei.finGap,
        L=shaTypCei.L,
        dh=shaTypCei.dh,
        shaCorr=shaTypCei.shaCorr)),
          fraType(present=fraTypCei.present, U_value=fraTypCei.U_value),
          linExtRad=linExtRadWin,
          nWin=nWinCei) if
             hasWinCei constrainedby Window(
             azi=aziAInt,
             inc=IDEAS.Types.Tilt.Wall,
             T_start=T_start,
             linIntCon_a=linIntCon,
             dT_nominal_a=dT_nominal_win,
             linExtCon=linExtCon,
             windowDynamicsType=windowDynamicsType,
             linExtRad=linExtRadWin,
             nWin=nWinCei)
          "Window for ceiling of this zone" annotation (Dialog(tab="Advanced",group="Windows"),
            enable=hasWinCei,
            choicesAllMatching=true,
            Placement(
              transformation(
              extent={{-5,-10},{5,10}},
              rotation=0,
              origin={-95,-90})));
      equation
        connect(winA.propsBus_a, propsBusInt[indWinA]) annotation (Line(
            points={{-90.8333,12},{-88,12},{-88,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));
        connect(winB.propsBus_a, propsBusInt[indWinB]) annotation (Line(
            points={{-90.8333,-8},{-88,-8},{-88,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));
        connect(winC.propsBus_a, propsBusInt[indWinC]) annotation (Line(
            points={{-90.8333,-28},{-88,-28},{-88,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));
        connect(winD.propsBus_a, propsBusInt[indWinD]) annotation (Line(
            points={{-90.8333,-48},{-88,-48},{-88,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));
        connect(winCei.propsBus_a, propsBusInt[indWinCei]) annotation (Line(
            points={{-90.8333,-88},{-88,-88},{-88,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));

        connect(ctrlCei, winCei.Ctrl) annotation (Line(points={{-107,-111},{-106.5,
                -111},{-106.5,-100},{-98.3333,-100}},
                                                color={0,0,127}));
        connect(ctrlD, winD.Ctrl) annotation (Line(points={{-123,-111},{-123,-106},{
                -124,-106},{-124,-100},{-98.3333,-100},{-98.3333,-60}},
                                                                   color={0,0,127}));
        connect(ctrlC, winC.Ctrl) annotation (Line(points={{-139,-111},{-139,-104},{
                -140,-104},{-140,-100},{-98,-100},{-98,-40},{-98.3333,-40}},
                                                                        color={0,0,127}));
        connect(ctrlB, winB.Ctrl) annotation (Line(points={{-155,-111},{-155,-100},{
                -156,-100},{-98,-100},{-98,-20},{-98.3333,-20}},        color={0,0,127}));
        connect(ctrlA, winA.Ctrl) annotation (Line(points={{-171,-111},{-171,-106},{
                -172,-106},{-172,-100},{-98.3333,-100},{-98.3333,0}},
                                                                 color={0,0,127}));



          annotation (Icon(coordinateSystem(preserveAspectRatio=false, initialScale=0.1),
              graphics={
              Text(
                extent={{-60,-72},{-30,-38}},
                lineColor={28,108,200},
                textString="Flo"),
              Text(
                extent={{120,-14},{140,20}},
                lineColor={28,108,200},
                textString="B"),
              Text(
                extent={{-10,-122},{10,-94}},
                lineColor={28,108,200},
                textString="C"),
              Text(
                extent={{-122,-14},{-102,20}},
                lineColor={28,108,200},
                textString="D"),
              Text(
                extent={{18,44},{46,80}},
                lineColor={28,108,200},
                textString="Cei"),
              Text(
                extent={{-10,114},{10,148}},
                lineColor={28,108,200},
                textString="A")}),                                     Diagram(
              coordinateSystem(preserveAspectRatio=false, extent={{-220,-100},{100,100}}),
                          graphics={
              Text(
                extent={{-220,-60},{-200,-80}},
                lineColor={28,108,200},
                textString="Floor"),
              Text(
                extent={{-220,-80},{-200,-100}},
                lineColor={28,108,200},
                textString="Ceiling"),
              Text(
                extent={{-220,-40},{-200,-60}},
                lineColor={28,108,200},
                textString="D"),
              Text(
                extent={{-220,-20},{-200,-40}},
                lineColor={28,108,200},
                textString="C"),
              Text(
                extent={{-220,0},{-200,-20}},
                lineColor={28,108,200},
                textString="B"),
              Text(
                extent={{-220,20},{-200,0}},
                lineColor={28,108,200},
                textString="A")}),
          Documentation(info="<html>
<p>
This model can be used to set up
zones with a rectangular geometry more quickly.
This template consists of a zone, four walls, a horizontal roof and a floor
and five optional windows.
Additional surfaces may also be connected through external bus connector.
For the documentation of the regular zone parameters, see the documentation of 
<a href=\"modelica://IDEAS.Buildings.Components.Zone\">IDEAS.Buildings.Components.Zone</a>.
</p>
<h4>Main equations</h4>
<p>
This model incorporates IDEAS components such as
<a href=modelica://IDEAS.Buildings.Components.OuterWall>
IDEAS.Buildings.Components.OuterWall</a> and reproduces
the same results as a model that would be constructed without 
the use of this template.
</p>
<h4>Assumption and limitations</h4>
<p>
This model assumes that the zone has a rectangular
geometry with width <code>w</code>, length <code>l</code>
and height <code>h</code>.
All walls are vertical and perpendicular to each other and both the roof and
the floor are horizontal.
</p>
<p>
The surface area of each wall is calculated by default using
the parameters <code>w</code> and <code>l</code>. If you want to split a wall
and add external walls using the external bus connector, use the overwrite
length parameters <code>lA, lB, lC, lD</code> from the <code>Face</code> tabs
such that the surface area of the wall is correct. 
Be also aware that the model
<code>slabOnGround</code> has a parameter <code>PWall</code> which specifies the
perimeter of slab on ground. The model cannot detect external walls connected
using the external bus connector. When splitting outer walls by using the external bus connector
you should update this parameter
manually using the parameter <code>PWall</code> from the <code>Advanced</code> tab.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameters width <code>w</code>, length <code>l</code>
and height <code>h</code> need to be defined
and are used to compute the dimensions of each of the surfaces.
Parameter <code>aziA</code> represents the azimuth angle
of surface A (see icon). Other surfaces are rotated (clockwise) by multiples
of ninety degrees with respect to <code>aziA</code>.
Parameter <code>nSurfExt</code> may be used
to connect additional surfaces to the template. 
When doing this, you may need to change the surface areas of
the surfaces in the template as these are not updated automatically.
</p>
<p>
Seven parameter tabs allow to specify further parameters
that are specific for each of the seven surfaces: six surfaces 
for the walls, floor and ceiling and one for an internal wall 
contained within the zone.
For each surface the surface type may be specified
using parameters <code>bouTyp*</code>.
The construction type should be defined
using <code>conTyp*</code>.
Parameter <code>hasWin*</code> may be used
for all orientations except for the floor to add
a window.
In this case the window surface area, shading and glazing 
types need to be provided.
For non-default shading a record needs to be created that specifies
the shading properties.
The surface area of the window is deducted from the surface area
of the wall such that the total surface areas add up.
</p>
<h4>Options</h4>
<p>
Advanced options are found under the <code>Advanced</code> 
parameter tab. 
The model may also be adapted further by
overriding the default parameter assignments in the template.
</p>
<p>
You can also use this model for non-rectangular zones by, for example,
using the <code>None</code> type for a wall and by adding additional walls
corresponding to a different geometry through
the external bus connector. 
This model however then does not guarantee that all parameters are consistent.
Therefore, some internal parameters of this model will need to be
updated manually.
</p>
<p>
In the parameter group <code>Windows</code>, you can redeclare the window. 
This is useful when using a window model that has a pre-configured surface area,
glazing type, frame fraction and shading. 
The parameters 
<code>azi=aziA</code>,
<code>inc=IDEAS.Types.Tilt.Wall</code>,
<code>T_start=T_start</code>,
<code>linIntCon_a=linIntCon</code>,
<code>dT_nominal_a=dT_nominal_win</code>,
<code>linExtCon=linExtCon</code>,
<code>windowDynamicsType=windowDynamicsType</code>,
<code>linExtRad=linExtRadWin</code>,
<code>nWin=nWinA</code>,
are still computed from the zone model parameters but, the
other windows parameters are those configured in the
used window model, including the window surface area.
</p>
<h4>Dynamics</h4>
<p>
This model contains wall dynamics
and a state for the zone air temperature.
The zone temperature may be set to steady state using
parameter <code>energyDynamicsAir</code>, which should
in general not be done.
The mass dynamics of the air volume
may be set to steady state by overriding the default parameter
assignment in the <code>airModel</code> submodel.
This removes small time constants
when the zone model is connected to an air flow circuit. 
</p>
<h4>Shading</h4>
<p>
In order to choose the shading of the glazing,
instead of selecting one shading type from the
dropdown menu, click on the
button right of the dropdown menu (edit). 
A menu will appear where the type of 
shading and corresponding parameters
have to be defined.
Alternatively, the shading template can be extended.
</p>
<h4>Validation</h4>
<p>
This implementation is compared with a manual implementation
in <a href=modelica://IDEAS.Buildings.Validation.Tests.ZoneTemplateVerification2>
IDEAS.Buildings.Validation.Tests.ZoneTemplateVerification2</a>.
This gives identical results.
</p>
<h4>Example</h4>
<p>
An example of how this template may be used
can be found in 
<a href=modelica://IDEAS.Examples.PPD12>IDEAS.Examples.PPD12</a>.
</p>
<h4>Implementation</h4>
<p>
Shading types need to be declared using a record instead of
by redeclaring the shading components.
This is a workaround because redeclared 
components cannot be propagated.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 13, 2019, by Filip Jorissen:<br/>
Refactored the parameter definition of <code>inc</code> 
and <code>azi</code> by adding the option to use radio buttons.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1067\">
#1067</a>
</li>
<li>
February 5, 2019, by Damien Picard:<br/>
Correct typo in winB declaration (fraB should be fracB). 
</li>
<li>
October 26, 2018, by Filip Jorissen:<br/>
Removed use of non-existent parameter <code>aziCei</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/946\">#946</a>. 
</li>
<li>
August 26, 2018, by Damien Picard:<br/>
Move all equations except those of windows to 
<code>RectangularZoneTemplateInterface</code>
for LIDEAS.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/891\">#891</a>.
</li>
<li>
August 16, 2018, by Damien Picard:<br/>
Make windows replaceable.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/891\">#891</a>.
And correct wall surface computation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/890\">#890</a>. 
</li>
<li>
August 10, 2018, by Damien Picard:<br/>
Added parameters for scaling factors for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">#888</a>.
</li>
<li>
Adapted model to make it possible to remove walls from the template.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/880\">#880</a>.
</li>
<li>
June 13, 2018, by Filip Jorissen:<br/>
Added parameters for shade cast by external building.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/576\">#576</a>.
</li>
<li>
May 21, 2018, by Filip Jorissen:<br/>
Added parameters for air flow through cavity.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/822\">#822</a>.
</li>
<li>
April 30, 2018 by Iago Cupeiro:<br/>
Propagated boolean input connections for controlled shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/809\">#809</a>.
Shading documentation added.
</li>
<li>
July 26, 2017 by Filip Jorissen:<br/>
Added replaceable block that allows to define
the number of occupants.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
April 26, 2017, by Filip Jorissen:<br/>
Added asserts that check for illegal combinations of internal wall with exterior window.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/714>#714</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed bus parameters for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
Also removed obsolete each.
</li>
<li>
January 20, 2017 by Filip Jorissen:<br/>
Removed propagation of <code>nLay</code> and <code>nGain</code>
since this lead to warnings.
</li>
<li>
January 11, 2017 by Filip Jorissen:<br/>
Added documentation
</li>
<li>
January 10, 2017, by Filip Jorissen:<br/>
Added <code>linExtRadWin</code> for windows.
</li>
<li>
November 14, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>"));
      end RectangularZoneTemplate;

      model SlabOnGround "opaque floor on ground slab"
         extends IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface(
           final nWin=1,
           QTra_design=UEqui*A    *(273.15 + 21 - sim.Tdes),
              dT_nominal_a=-3,
              inc=IDEAS.Types.Tilt.Floor,
              azi=0,
          redeclare replaceable Data.Constructions.FloorOnGround constructionType,
          layMul(disableInitPortB=true));

        parameter Modelica.SIunits.Length PWall=4*sqrt(A)
          "Total floor slab perimeter";
        parameter Modelica.SIunits.Temperature TeAvg = 273.15+10.8
          "Annual average outdoor temperature";
        parameter Modelica.SIunits.Temperature TiAvg = 273.15+22
          "Annual average indoor temperature";
        parameter Modelica.SIunits.TemperatureDifference dTeAvg = 4
          "Amplitude of variation of monthly average outdoor temperature";
        parameter Modelica.SIunits.TemperatureDifference dTiAvg = 2
          "Amplitude of variation of monthly average indoor temperature";
        parameter Boolean linearise=sim.lineariseDymola
          "= true, if heat flow to ground should be linearized"
          annotation(Dialog(tab="Convection"));
        Modelica.SIunits.HeatFlowRate Qm = if not linearise then UEqui*A*(TiAvg - TeAvg) - Lpi*dTiAvg*cos(2*3.1415/12*(m- 1 + alfa)) + Lpe*dTeAvg*cos(2*3.1415/12*(m - 1 - beta)) else
          sum({UEqui*A*(TiAvg - TeAvg) - Lpi*dTiAvg*cos(2*3.1415/12*(i- 1 + alfa)) + Lpe*dTeAvg*cos(2*3.1415/12*(i - 1 - beta)) for i in 1:12})/12
          "Two-dimensional correction for edge flow";

      //Calculation of heat loss based on ISO 13370
    protected
        final parameter IDEAS.Buildings.Data.Materials.Ground ground1(final d=0.50);
        final parameter IDEAS.Buildings.Data.Materials.Ground ground2(final d=0.33);
        final parameter IDEAS.Buildings.Data.Materials.Ground ground3(final d=0.17);
        final parameter Real U_value=1/(1/6 + sum(constructionType.mats.R) + 0)
          "Floor theoretical U-value";

        final parameter Modelica.SIunits.Length B=A/(0.5*PWall + 1E-10)
          "Characteristic dimension of the slab on ground";
        final parameter Modelica.SIunits.Length dt=sum(constructionType.mats.d) + ground1.k*1/U_value
          "Equivalent thickness";//Thickness of basement walls assumed to be as the thickness of the slab
        final parameter Real UEqui=if (dt<B) then (2*ground1.k/(Modelica.Constants.pi*B+dt)*Modelica.Math.log(Modelica.Constants.pi*B/dt+1)) else (ground1.k/(0.457*B + dt))
          "Equivalent thermal transmittance coefficient";
        final parameter Real alfa=1.5 - 12/(2*3.14)*atan(dt/(dt + delta));
        final parameter Real beta=1.5 - 0.42*log(delta/(dt + 1));
        final parameter Real delta=sqrt(3.15*10^7*ground1.k/3.14/ground1.rho/ground1.c);
        final parameter Real Lpi=A    *ground1.k/dt*sqrt(1/((1 + delta/dt)^2 + 1));
        final parameter Real Lpe=0.37*PWall*ground1.k*log(delta/dt + 1);
        Real m = sim.solTim.y/3.1536e7*12 "time in months";

        BaseClasses.ConductiveHeatTransfer.MultiLayer layGro(
          final inc=incInt,
          final nLay=3,
          final mats={ground1,ground2,ground3},
          final T_start={TeAvg,TeAvg,TeAvg},
          monLay(each energyDynamics=energyDynamics),
          final A=A)
          "Declaration of array of resistances and capacitances for ground simulation"
          annotation (Placement(transformation(extent={{-20,-10},{-40,10}})));
        Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow periodicFlow(T_ref=284.15)
                      annotation (Placement(transformation(
              extent={{10,10},{-10,-10}},
              rotation=180,
              origin={-30,22})));
        Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow adiabaticBoundary(Q_flow=0,
            T_ref=285.15)
          annotation (Placement(transformation(extent={{-70,-10},{-50,10}})));
    public
        Modelica.Blocks.Math.Product product
          annotation (Placement(transformation(extent={{-30,36},{-38,44}})));
        Modelica.Blocks.Sources.RealExpression Qm_val(y=-Qm)
          annotation (Placement(transformation(extent={{0,50},{-20,70}})));
      equation

        connect(periodicFlow.port, layMul.port_b) annotation (Line(points={{-20,22},{
                -14,22},{-14,0},{-10,0}}, color={191,0,0}));
        connect(layGro.port_a, layMul.port_b)
          annotation (Line(points={{-20,0},{-15,0},{-10,0}}, color={191,0,0}));
        connect(layGro.port_b, adiabaticBoundary.port)
          annotation (Line(points={{-40,0},{-45,0},{-50,0}}, color={191,0,0}));
        connect(Qm_val.y, product.u1) annotation (Line(points={{-21,60},{-26,60},{-26,
                42.4},{-29.2,42.4}}, color={0,0,127}));
        connect(product.u2, propsBusInt.weaBus.dummy) annotation (Line(points={{-29.2,
                37.6},{56.09,37.6},{56.09,19.91}},
                                            color={0,0,127}));
        connect(product.y, periodicFlow.Q_flow) annotation (Line(points={{-38.4,40},{-50,
                40},{-50,22},{-40,22}}, color={0,0,127}));
        annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-60,-100},{60,100}}),
              graphics={
              Rectangle(
                extent={{-50,-70},{50,100}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-50,-90},{50,-70}},
                fillColor={175,175,175},
                fillPattern=FillPattern.Backward,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Line(
                points={{-50,-20},{-30,-20},{-30,-70},{-30,-70},{-30,-70}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,-20},{-50,-90},{-50,-90}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,60},{-30,60},{-30,80},{50,80}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,60},{-50,66},{-50,100},{50,100}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-44,60},{-44,-20}},
                color={175,175,175},
                smooth=Smooth.None),
              Line(
                points={{-50,-70},{50,-70}},
                color={0,0,0},
                thickness=0.5,
                smooth=Smooth.None)}),
          Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-60,-100},{60,100}})),
          Documentation(info="<html>
<p>
This is a floor model that should be used to
simulate floors on solid ground.
See <a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface>IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface</a> 
for equations, options, parameters, validation and dynamics that are common for all surfaces.
</p>
<h4>Typical use and important parameters</h4>
<p>
The model contains several parameters that are used
to set up a simplified model of the influence of the 
environment on the ground themperature.
The model assumes that the floor plate is connected to a (heated)
zone that is surrounded by air at the ambient temperature.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 13, 2019, by Filip Jorissen:<br/>
Refactored the parameter definition of <code>inc</code> 
and <code>azi</code> by adding the option to use radio buttons.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1067\">
#1067</a>
</li>
<li>
January 25, 2019, by Filip Jorissen:<br/>
Revised initial equation implementation.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
August 10, 2018 by Damien Picard:<br/>
Set nWin final to 1 as this should only be used for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>. 
</li>
<li>
May 14, 2018, by Filip Jorissen:<br/>
Revised value of <code>energyDynamics</code>
for ground layers such that unique initial conditions
can be defined.
</li>
<li>
January 2, 2017, by Filip Jorissen:<br/>
Added default values for parameters <code>inc</code> and 
<code>azi</code>.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
December 7, 2016 by Damien Picard:<br/>
Set placeCapacityAtSurf_b to false for the last layMul layer. 
This is necessary due to the initialization which is overspecified when two capacities are
connected to each other without resistances between. 
Using dynamicFreeInitial for both the first layer of layGro and 
the last one of LayMul did not solve the problem.
</li>
<li>
September 27, 2016 by Filip Jorissen:<br/>
Different initialisation for state between layMul 
and layGround for avoiding conflicting initial equations.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
</ul>
</html>"));
      end SlabOnGround;

      model Window "Multipane window"
        replaceable IDEAS.Buildings.Data.Interfaces.Glazing glazing
          constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type"
          annotation (__Dymola_choicesAllMatching=true, Dialog(group=
                "Construction details"));

        extends IDEAS.Buildings.Components.Interfaces.PartialSurface(
          dT_nominal_a=-3,
          intCon_a(final A=
                 A*(1 - frac),
                 linearise=linIntCon_a or sim.linearise,
                 dT_nominal=dT_nominal_a),
          QTra_design(fixed=false),
          Qgai(y=if sim.computeConservationOfEnergy then
                                                        (gain.propsBus_a.surfCon.Q_flow +
              gain.propsBus_a.surfRad.Q_flow + gain.propsBus_a.iSolDif.Q_flow + gain.propsBus_a.iSolDir.Q_flow) else 0),
          E(y=0),
          layMul(
            A=A*(1 - frac),
            nLay=glazing.nLay,
            mats=glazing.mats,
            energyDynamics=if windowDynamicsType == IDEAS.Buildings.Components.Interfaces.WindowDynamicsType.Normal then energyDynamics else Modelica.Fluid.Types.Dynamics.SteadyState,
            dT_nom_air=5,
            linIntCon=true,
            checkCoatings=glazing.checkLowPerformanceGlazing));
        parameter Boolean linExtCon=sim.linExtCon
          "= true, if exterior convective heat transfer should be linearised (uses average wind speed)"
          annotation(Dialog(tab="Convection"));
        parameter Boolean linExtRad=sim.linExtRadWin
          "= true, if exterior radiative heat transfer should be linearised"
          annotation(Dialog(tab="Radiation"));

        parameter Real frac(
          min=0,
          max=1) = 0.15 "Area fraction of the window frame";
        parameter IDEAS.Buildings.Components.Interfaces.WindowDynamicsType
          windowDynamicsType=IDEAS.Buildings.Components.Interfaces.WindowDynamicsType.Two
          "Type of dynamics for glazing and frame: using zero, one combined or two states"
          annotation (Dialog(tab="Dynamics", group="Equations", enable = not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState));
        parameter Real fraC = frac
          "Ratio of frame and glazing thermal masses"
          annotation(Dialog(tab="Dynamics", group="Equations", enable= not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState and windowDynamicsType == IDEAS.Buildings.Components.Interfaces.WindowDynamicsType.Two));
        parameter Boolean controlled = shaType.controlled
          " = true if shaType has a control input (see e.g. screen). Can be set to false manually to force removal of input icon."
          annotation(Dialog(tab="Advanced",group="Icon"));

        replaceable parameter IDEAS.Buildings.Data.Frames.None fraType
          constrainedby IDEAS.Buildings.Data.Interfaces.Frame "Window frame type"
          annotation (choicesAllMatching=true, Dialog(group=
                "Construction details"));
        replaceable IDEAS.Buildings.Components.Shading.None shaType constrainedby
        Shading.Interfaces.PartialShading(
                                  final azi=aziInt) "First shading type"  annotation (Placement(transformation(extent={{-70,-60},
                  {-60,-40}})),
            __Dymola_choicesAllMatching=true, Dialog(group="Construction details"));

        Modelica.Blocks.Interfaces.RealInput Ctrl if controlled
          "Control signal between 0 and 1, i.e. 1 is fully closed" annotation (
            Placement(transformation(
              extent={{20,-20},{-20,20}},
              rotation=-90,
              origin={-50,-110}), iconTransformation(
              extent={{10,-10},{-10,10}},
              rotation=-90,
              origin={-40,-100})));


    protected
        final parameter Real U_value=glazing.U_value*(1-frac)+fraType.U_value*frac
          "Average window U-value";
        final parameter Boolean addCapGla =  windowDynamicsType == IDEAS.Buildings.Components.Interfaces.WindowDynamicsType.Two and not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState
          "Add lumped thermal capacitor for window glazing";
        final parameter Boolean addCapFra =  fraType.present and not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState
          "Added lumped thermal capacitor for window frame";
        final parameter Modelica.SIunits.HeatCapacity Cgla = layMul.C
          "Heat capacity of glazing state";
        final parameter Modelica.SIunits.HeatCapacity Cfra = layMul.C*fraC
          "Heat capacity of frame state";

        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.ExteriorConvection
          eCon(
          final A=A*(1 - frac),
          linearise=linExtCon or sim.linearise,
          final inc=incInt,
          final azi=aziInt)
          "Convective surface heat transimission on the exterior side of the wall"
          annotation (Placement(transformation(extent={{-20,-38},{-40,-18}})));

        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ExteriorHeatRadiation
          skyRad(final A=A*(1 - frac), Tenv_nom=sim.Tenv_nom,
          linearise=linExtRad or sim.linearise)
          "determination of radiant heat exchange with the environment and sky"
          annotation (Placement(transformation(extent={{-20,-10},{-40,10}})));
        replaceable
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.SwWindowResponse
          solWin(
          final nLay=glazing.nLay,
          final SwAbs=glazing.SwAbs,
          final SwTrans=glazing.SwTrans,
          final SwTransDif=glazing.SwTransDif,
          final SwAbsDif=glazing.SwAbsDif)
          annotation (Placement(transformation(extent={{-10,-60},{10,-40}})));

        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.InteriorConvection
          iConFra(final A=A*frac, final inc=incInt,
          linearise=linIntCon_a or sim.linearise) if
                              fraType.present
          "convective surface heat transimission on the interior side of the wall"
          annotation (Placement(transformation(extent={{20,60},{40,80}})));
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ExteriorHeatRadiation
          skyRadFra(final A=A*frac, Tenv_nom=sim.Tenv_nom,
          linearise=linExtRad or sim.linearise) if
                               fraType.present
          "determination of radiant heat exchange with the environment and sky"
          annotation (Placement(transformation(extent={{-20,80},{-40,100}})));
        IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.ExteriorConvection
          eConFra(final A=A*frac, linearise=linExtCon or sim.linearise,
          inc=incInt,
          azi=aziInt) if
                       fraType.present
          "convective surface heat transimission on the exterior side of the wall"
          annotation (Placement(transformation(extent={{-20,60},{-40,80}})));
        Modelica.Thermal.HeatTransfer.Components.ThermalConductor layFra(final G=(if
              fraType.briTyp.present then fraType.briTyp.G else 0) + (fraType.U_value)
              *A*frac) if                fraType.present  annotation (Placement(transformation(extent={{10,60},
                  {-10,80}})));

        BoundaryConditions.SolarIrradiation.RadSolData radSolData(
          inc=incInt,
          azi=aziInt,
          lat=sim.lat,
          outputAngles=sim.outputAngles,
          incAndAziInBus=sim.incAndAziInBus,
          numIncAndAziInBus=sim.numIncAndAziInBus)
          annotation (Placement(transformation(extent={{-100,-60},{-80,-40}})));
        Modelica.Blocks.Math.Gain gainDir(k=A*(1 - frac))
          "Gain for direct solar irradiation"
          annotation (Placement(transformation(extent={{-42,-46},{-38,-42}})));
        Modelica.Blocks.Math.Gain gainDif(k=A*(1 - frac))
          "Gain for diffuse solar irradiation"
          annotation (Placement(transformation(extent={{-36,-50},{-32,-46}})));
        Modelica.Blocks.Routing.RealPassThrough Tdes
          "Design temperature passthrough since propsBus variables cannot be addressed directly";
        Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heaCapGlaInt(C=Cgla/2,
            T(fixed=energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial,
              start=T_start)) if                                                                             addCapGla
          "Heat capacitor for glazing at interior"
          annotation (Placement(transformation(extent={{6,-12},{26,-32}})));
        Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heaCapFraIn(C=Cfra/2,
            T(fixed=energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial,
              start=T_start)) if                                                                             addCapFra
          "Heat capacitor for frame at interior"
          annotation (Placement(transformation(extent={{4,100},{24,120}})));
        Modelica.Blocks.Sources.Constant constEpsSwFra(final k=fraType.mat.epsSw)
          "Shortwave emissivity of frame"
          annotation (Placement(transformation(extent={{4,46},{-6,56}})));
        Modelica.Blocks.Sources.Constant constEpsLwFra(final k=fraType.mat.epsLw)
          "Shortwave emissivity of frame"
          annotation (Placement(transformation(extent={{4,86},{-6,96}})));
        IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ExteriorSolarAbsorption
          solAbs(A=A*frac) if fraType.present
          "Solar absorption model for shortwave radiation"
          annotation (Placement(transformation(extent={{-20,40},{-40,60}})));
        Modelica.Blocks.Math.Add solDif(final k1=1, final k2=1)
          "Sum of ground and sky diffuse solar irradiation"
          annotation (Placement(transformation(extent={{-56,-50},{-50,-44}})));
        Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heaCapFraExt(C=Cfra/2,
            T(fixed=energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial,
              start=T_start)) if                                                                             addCapFra
          "Heat capacitor for frame at exterior"
          annotation (Placement(transformation(extent={{-20,100},{0,120}})));
        Modelica.Thermal.HeatTransfer.Components.HeatCapacitor heaCapGlaExt(C=Cgla/2,
            T(fixed=energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial,
              start=T_start)) if                                                                             addCapGla
          "Heat capacitor for glazing at exterior"
          annotation (Placement(transformation(extent={{-20,-12},{0,-32}})));
      initial equation
        QTra_design = (U_value*A + (if fraType.briTyp.present then fraType.briTyp.G else 0)) *(273.15 + 21 - Tdes.y);





      equation
        connect(eCon.port_a, layMul.port_b) annotation (Line(
            points={{-20,-28},{-14,-28},{-14,0},{-10,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(skyRad.port_a, layMul.port_b) annotation (Line(
            points={{-20,0},{-10,0}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(solWin.iSolDir, propsBusInt.iSolDir) annotation (Line(
            points={{-2,-60},{-2,-70},{56.09,-70},{56.09,19.91}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(solWin.iSolDif, propsBusInt.iSolDif) annotation (Line(
            points={{2,-60},{2,-70},{56.09,-70},{56.09,19.91}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(solWin.iSolAbs, layMul.port_gain) annotation (Line(
            points={{0,-40},{0,-10}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(layMul.iEpsLw_b, skyRad.epsLw) annotation (Line(
            points={{-10,8},{-14,8},{-14,3.4},{-20,3.4}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(shaType.Ctrl, Ctrl) annotation (Line(
            points={{-65,-60},{-50,-60},{-50,-110}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(iConFra.port_b, propsBusInt.surfCon) annotation (Line(
            points={{40,70},{46,70},{46,19.91},{56.09,19.91}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(layFra.port_a, iConFra.port_a) annotation (Line(
            points={{10,70},{20,70}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(skyRadFra.port_a, layFra.port_b) annotation (Line(
            points={{-20,90},{-16,90},{-16,70},{-10,70}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(eConFra.port_a, layFra.port_b) annotation (Line(
            points={{-20,70},{-10,70}},
            color={191,0,0},
            smooth=Smooth.None));
        connect(radSolData.angInc, shaType.angInc) annotation (Line(
            points={{-79.4,-54},{-76,-54},{-76,-54},{-70,-54}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.angAzi, shaType.angAzi) annotation (Line(
            points={{-79.4,-58},{-76,-58},{-76,-58},{-70,-58}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.angZen, shaType.angZen) annotation (Line(
            points={{-79.4,-56},{-76,-56},{-76,-56},{-70,-56}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(radSolData.weaBus, propsBusInt.weaBus) annotation (Line(
            points={{-80,-42},{-80,20},{0,20},{0,19.91},{56.09,19.91}},
            color={255,204,51},
            thickness=0.5,
            smooth=Smooth.None));
        connect(radSolData.Tenv, skyRad.Tenv) annotation (Line(
            points={{-79.4,-52},{-72,-52},{-72,10},{-20,10},{-20,6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(skyRadFra.Tenv, skyRad.Tenv) annotation (Line(
            points={{-20,96},{-12,96},{-12,6},{-20,6}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(eConFra.Te, eCon.Te) annotation (Line(
            points={{-20,65.2},{-20,66},{-16,66},{-16,-32.8},{-20,-32.8}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(eCon.hForcedConExt, eConFra.hForcedConExt) annotation (Line(
            points={{-20,-37},{-20,-36},{-14,-36},{-14,61},{-20,61}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(eCon.Te, propsBusInt.weaBus.Te) annotation (Line(
            points={{-20,-32.8},{56.09,-32.8},{56.09,19.91}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(Tdes.u, propsBusInt.weaBus.Tdes);
        connect(shaType.iAngInc, solWin.angInc) annotation (Line(points={{-60,-54},{
                -60,-54},{-10,-54}},           color={0,0,127}));
        connect(heaCapGlaInt.port, layMul.port_a)
          annotation (Line(points={{16,-12},{16,0},{10,0}}, color={191,0,0}));
        connect(heaCapFraIn.port, layFra.port_a)
          annotation (Line(points={{14,100},{14,70},{10,70}}, color={191,0,0}));
        connect(skyRadFra.epsLw, constEpsLwFra.y) annotation (Line(points={{-20,93.4},
                {-14,93.4},{-14,91},{-6.5,91}}, color={0,0,127}));
        connect(solAbs.port_a, layFra.port_b) annotation (Line(points={{-20,50},{-16,
                50},{-16,70},{-10,70}},
                                    color={191,0,0}));
        connect(solAbs.epsSw, constEpsSwFra.y) annotation (Line(points={{-20,56},{-10,
                56},{-10,51},{-6.5,51}}, color={0,0,127}));
        connect(gainDir.y, solWin.solDir)
          annotation (Line(points={{-37.8,-44},{-10,-44}}, color={0,0,127}));
        connect(gainDif.y, solWin.solDif) annotation (Line(points={{-31.8,-48},{-22,
                -48},{-10,-48}}, color={0,0,127}));
        connect(radSolData.HDirTil, shaType.HDirTil) annotation (Line(points={{-79.4,
                -46},{-78,-46},{-78,-44},{-70,-44}}, color={0,0,127}));
        connect(radSolData.HSkyDifTil, shaType.HSkyDifTil) annotation (Line(points={{-79.4,
                -48},{-76,-48},{-76,-46},{-70,-46}},       color={0,0,127}));
        connect(radSolData.HGroDifTil, shaType.HGroDifTil) annotation (Line(points={{-79.4,
                -50},{-74,-50},{-74,-48},{-70,-48}},       color={0,0,127}));
        connect(shaType.HShaGroDifTil, solDif.u2) annotation (Line(points={{-60,-48},
                {-56.6,-48},{-56.6,-48.8}}, color={0,0,127}));
        connect(solDif.u1, shaType.HShaSkyDifTil) annotation (Line(points={{-56.6,
                -45.2},{-56.3,-45.2},{-56.3,-46},{-60,-46}}, color={0,0,127}));
        connect(gainDif.u, solDif.y) annotation (Line(points={{-36.4,-48},{-49.7,-48},
                {-49.7,-47}}, color={0,0,127}));
        connect(solDif.y, solAbs.solDif) annotation (Line(points={{-49.7,-47},{-48,
                -47},{-48,52},{-40,52}}, color={0,0,127}));
        connect(shaType.HShaDirTil, solAbs.solDir) annotation (Line(points={{-60,-44},
                {-60,-44},{-60,56},{-40,56}}, color={0,0,127}));
        connect(gainDir.u, shaType.HShaDirTil) annotation (Line(points={{-42.4,-44},{
                -51.2,-44},{-60,-44}}, color={0,0,127}));
        connect(eCon.hForcedConExt, radSolData.hForcedConExt) annotation (Line(points=
               {{-20,-37},{-50,-37},{-50,-62.2},{-79.4,-62.2}}, color={0,0,127}));
        connect(layFra.port_b, heaCapFraExt.port)
          annotation (Line(points={{-10,70},{-10,100}}, color={191,0,0}));
        connect(heaCapGlaExt.port, layMul.port_b)
          annotation (Line(points={{-10,-12},{-10,0}}, color={191,0,0}));
          annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-60,-100},{60,100}}),
              graphics={
              Rectangle(
                extent={{-50,-90},{50,100}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-46,60},{50,24},{50,-50},{-30,-20},{-46,-20},{-46,60}},
                smooth=Smooth.None,
                pattern=LinePattern.None,
                fillColor={255,255,170},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Line(
                points={{-50,60},{-30,60},{-30,80},{50,80}},
                color={175,175,175}),
              Line(
                points={{-50,-20},{-30,-20},{-30,-70},{-30,-70},{52,-70}},
                color={175,175,175}),
              Line(
                points={{-50,60},{-50,66},{-50,100},{50,100}},
                color={175,175,175}),
              Line(
                points={{-50,-20},{-50,-90},{50,-90}},
                color={175,175,175}),
              Line(
                points={{-46,60},{-46,-20}},
                color={0,0,0},
                thickness=0.5,
                smooth=Smooth.None)}),
          Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},{100,
                  100}})),
          Documentation(info="<html>
<p>
This model should be used to model windows or other transparant surfaces.
See <a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialSurface>IDEAS.Buildings.Components.Interfaces.PartialSurface</a> 
for equations, options, parameters, validation and dynamics that are common for all surfaces and windows.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameter <code>A</code> is the total window surface area, i.e. the
sum of the frame surface area and the glazing surface area.
</p>
<p>
Parameter <code>frac</code> may be used to define the surface
area of the frame as a fraction of <code>A</code>. 
</p>
<p>
Parameter <code>glazing</code>  must be used to define the glass properties.
It contains information about the number of glass layers,
their thickness, thermal properties and emissivity.
</p>
<p>
Optional parameter <code>briType</code> may be used to compute additional line losses
along the edges of the glazing.
</p>
<p>
Optional parameter <code>fraType</code> may be used to define the frame thermal properties.
If <code>fraType = None</code> then the frame is assumed to be perfectly insulating.
</p>
<p>
Optional parameter <code>shaType</code> may be used to define the window shading properties.
</p>
<p>
The parameter <code>n</code> may be used to scale the window to <code>n</code> identical windows.
For example, if a wall has 10 identical windows with identical shading, this parameter
can be used to simulate 10 windows by scaling the model of a single window.
</p>
<h4>Validation</h4>
<p>
To verify the U-value of your glazing system implementation,
see <a href=\"modelica://IDEAS.Buildings.Components.Validations.WindowEN673\">
IDEAS.Buildings.Components.Validations.WindowEN673</a>
</p>
</html>",       revisions="<html>
<ul>
<li>
November 28, 2019, by Ian Beausoleil-Morrison:<br/>
<code>inc</code> and <code>azi</code> of surface now passed as parameters to ExteriorConvection.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1089\">
#1089</a>
</li>
<li>
December 2, 2019, by Filip Jorissen:<br/>
Split heat capacitor to interior and exterior part 
to avoid non-linear algebraic loops.
<a href=\"https://github.com/open-ideas/IDEAS/issues/1092\">#1092</a>.
</li>
<li>
October 13, 2019, by Filip Jorissen:<br/>
Refactored the parameter definition of <code>inc</code> 
and <code>azi</code> by adding the option to use radio buttons.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1067\">
#1067</a>
</li>
<li>
September 9, 2019, by Filip Jorissen:<br/>
Added <code>checkCoatings</code> for issue
<a href=\"https://github.com/open-ideas/IDEAS/issues/1038\">#1038</a>.
</li>
<li>
August 10, 2018 by Damien Picard:<br/>
Add scaling to propsBus_a to allow simulation of n windows instead of 1
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>.
</li>
<li>
January 21, 2018 by Filip Jorissen:<br/>
Changed implementation such that control input is visible.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/761\">
#761</a>.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
March 6, 2017, by Filip Jorissen:<br/>
Added option for using 'normal' dynamics for the window glazing.
Removed the option for having a combined state for 
window and frame this this is non-physical.
This is for 
<a href=https://github.com/open-ideas/IDEAS/issues/678>#678</a>.
</li>
<li>
January 10, 2017, by Filip Jorissen:<br/>
Removed declaration of 
<code>A</code> since this is now declared in 
<a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialSurface>
IDEAS.Buildings.Components.Interfaces.PartialSurface</a>.
This is for 
<a href=https://github.com/open-ideas/IDEAS/issues/609>#609</a>.
</li>
<li>
January 10, 2017 by Filip Jorissen:<br/>
Set <code>linExtRad = sim.linExtRadWin</code>.
See <a href=https://github.com/open-ideas/IDEAS/issues/615>#615</a>.
</li>
<li>
December 19, 2016, by Filip Jorissen:<br/>
Added solar irradiation on window frame.
</li>
<li>
December 19, 2016, by Filip Jorissen:<br/>
Removed briType, which had default value LineLoss.
briType is now part of the Frame model and has default
value None.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
December 17, 2015, Filip Jorissen:<br/>
Added thermal connection between frame and glazing state. 
This is required for decoupling steady state thermal dynamics
without adding a second state for the window.
</li>
<li>
July 14, 2015, Filip Jorissen:<br/>
Removed second shading device since a new partial was created
for handling this.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>"));
      end Window;

      model Zone "Building zone model"
        extends IDEAS.Buildings.Components.Interfaces.PartialZone;

        //this propsbus exposes all ports to the outside of the model
        IDEAS.Buildings.Components.Interfaces.ZoneBus[nSurf] propsBus(
          each final numIncAndAziInBus=sim.numIncAndAziInBus,
          each final outputAngles=sim.outputAngles)
                                annotation (Placement(transformation(
              extent={{-20,20},{20,-20}},
              rotation=-90,
              origin={-100,40}), iconTransformation(
              extent={{-20,20},{20,-20}},
              rotation=-90,
              origin={-100,40})));
      equation
        connect(propsBus, propsBusInt) annotation (Line(
            points={{-100,40},{-90,40},{-80,40}},
            color={255,204,51},
            thickness=0.5));

        annotation (
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
               graphics={Text(
                extent={{-64,68},{-28,18}},
                lineColor={255,215,136},
                textString="%nSurf")}),
          Documentation(info="<html>
<p>
This model is the main zone model. 
Surfaces such as windows and walls can be connectured using 
the <code>propsBus</code> connectors and HVAC can be connected
using <code>FluidPorts</code>.
The model contains models or options for radiative heat exchange,
internal heat gains, interzonal air exchange and
a zone air model.
</p>
<h4>Typical use and important parameters</h4>
<p>
Any number of surfaces can be connected to the 
<code>propsbus</code> of a zone.
The number of connected surfaces must be specified
using the parameter <code>nSurf</code> and 
each of the nSurf <code>propsbus</code> components 
has to be connected to exactly one surface.
</p>
<p>
Parameter <code>V</code> must be used to define the total
zone air volume.
</p>
<p>
Parameter <code>hZone</code> is the zone height,
which may be used to define the zone geometry.
</p>
<p>
Parameter <code>A</code> is the total
floor surface area of the zone.
</p>
<p>
Replaceable parameter <code>airModel</code> determines
the type of air model that is used.
</p>
<p>
Replaceable model <code>occNum</code> allows the user to choose a
way to define the number of occupants that are present in the zone.
This number of occupants is used to compute the
internal heat gains in the model.
Depending on the chosen model, 
an external input <code>yOcc</code> may be exposed
by the zone model.
</p>
<p>
Parameter <code>occTyp</code> determines
occupants properties.
These properties may be used to evaluate internal comfort,
or to determine internal gains.
</p>
<p>
Parameter <code>comfort</code> determines
how occupant comfort may be computed.
</p>
<h4>Options</h4>
<p>
Parameter <code>intGai</code> determines
internal gains model type. 
By default the internal gains model considers
a fixed sensible and latent heat load and CO2 production per person.
</p>
<p>
Parameter <code>simVieFac</code> may be set to false to simplify the 
view factor calculation. This leads to a less accurate computation
of view factors, but this approach is more robust.
It may be used when the initial equation that computes the view factors does not converge.
</p>
<p>
Replaceable model <code>interzonalAirFlow</code> allows to 
choose between multiple options for modelling air leakage and interzonal 
airflow. 
This model can have a strong influence on numerics and on model results
if used inappropliately, therefore only change the default value 
if you know what you are doing. 
</p>
<p>
The lighting options allow to compute the thermal heat gains originating in the 
zone lighting. We assume that electric power use is converted for 100 % into heat gains.
The record <code>rooType</code> determines the type of room, and the typical
illuminance that corresponds to such a room type.
The record <code>ligTyp</code> determines what kind of lighting device is used,
which contains the lighting efficacy of the device,
i.e. how much electric power is required per square meter of lighted zone.
We assume that the zone is lighted completely.
The model <code>ligCtr</code> determines how the lighting is controlled.
See <a href=\"modelica://IDEAS.Buildings.Components.LightingControl\">
IDEAS.Buildings.Components.LightingControl</a> for the available options.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 13, 2019 by Filip Jorissen:<br/>
Added number of surfaces in the zone icon.
for <a href=\"https://github.com/open-ideas/IDEAS/issues/1068\">#1068</a>.
</li>
<li>
March 28, 2019 by Filip Jorissen:<br/>
Revised documentation
for <a href=\"https://github.com/open-ideas/IDEAS/issues/998\">#998</a>.
</li>
<li>
July 26, 2018 by Filip Jorissen:<br/>
Added replaceable block that allows to define
the number of occupants.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
August 26, 2016 by Filip Jorissen:<br/>
Added support for conservation of energy of air model.
</li>
<li>
April 30, 2016, by Filip Jorissen:<br/>
Added replaceable air model implementation.
</li>
<li>
March, 2015, by Filip Jorissen:<br/>
Added view factor implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}})));
      end Zone;

      package Comfort "Package for computing thermal comfort "
      extends Modelica.Icons.Package;

        model None "No comfort is computed"
          extends BaseClasses.PartialComfort;
          annotation (Documentation(revisions="<html>
<ul>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>",         info="<html>
<p>
Use this if you do not need to know the thermal comfort of the occupants.
</p>
</html>"));
        end None;

        package BaseClasses
          extends Modelica.Icons.BasesPackage;

          partial model PartialComfort "Partial for comfort models"
            extends Modelica.Blocks.Icons.Block;
            parameter Boolean use_phi_in=true
              "Get the relative humidity from the input connector"
              annotation(Evaluate=true);
            parameter Real phi(min=0,max=1)=0.4
              "Default value of relative humidity"
              annotation(Dialog(enable=not use_phi_in));
            parameter IDEAS.Buildings.Components.OccupancyType.OfficeWork
              occupancyType
              annotation (Placement(transformation(extent={{-60,80},{-40,100}})));
            Modelica.Blocks.Interfaces.RealInput phi_in(min=0, max=1) if use_phi_in "Relative humidity"
              annotation (
                Placement(transformation(extent={{-120,10},{-100,30}}),
                  iconTransformation(extent={{-120,10},{-100,30}})));
            Modelica.Blocks.Interfaces.RealInput TRad(final quantity="ThermodynamicTemperature",
                                                    final unit = "K", displayUnit = "degC")
              "Radiation temperature"
              annotation (
                Placement(transformation(extent={{-120,50},{-100,70}}),
                  iconTransformation(extent={{-120,50},{-100,70}})));
            Modelica.Blocks.Interfaces.RealInput TAir(final quantity="ThermodynamicTemperature",
                                                    final unit = "K", displayUnit = "degC")
              "Air temperature"
              annotation (Placement(
                  transformation(extent={{-120,90},{-100,110}})));

        protected
            Modelica.Blocks.Interfaces.RealInput phi_in_internal
              "Needed to connect to conditional connector";
          equation
            connect(phi_in, phi_in_internal);
            if not use_phi_in then
              phi_in_internal = phi;
            end if;
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
April 11, 2019 by Filip Jorissen:<br/>
Revised implementation such that default value of relative humidity is
used when using a dry air medium.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1011\">#1011</a>.
</li>
<li>
January 26, 2018 by Filip Jorissen:<br/>
Changed replaceable record into parameter such that 
<code>IDEAS.Buildings.Components.OccupancyType.BaseClasses.PartialOccupancyType</code> 
can be a partial record.
This is for <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>"));
          end PartialComfort;
        end BaseClasses;
      end Comfort;

      package InternalGains "Package for occupant models"

        model Lighting
          "Computes heat gains due to lighting requirements"
          extends
          IDEAS.Buildings.Components.InternalGains.BaseClasses.PartialLightingGains;
          Modelica.Blocks.Math.Gain gaiHea(final k=PNom)
            "Gain for computing heat lighting gains based on zone lighting requirements"
            annotation (Placement(transformation(extent={{-52,-10},{-32,10}})));
      protected
          final parameter Modelica.SIunits.Power PNom = rooTyp.Ev*A/ligTyp.K
            "Nominal power, avoids parameter division";
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloCon(final
              alpha=0) "Prescribed heat flow rate for convective sensible heat"
            annotation (Placement(transformation(extent={{40,10},{60,30}})));
          Modelica.Blocks.Math.Gain gainRad(final k=ligTyp.radFra) "Radiative fraction"
            annotation (Placement(transformation(extent={{-8,-30},{12,-10}})));
          Modelica.Blocks.Math.Gain gainCon(final k=1 - ligTyp.radFra)
            "Convective fraction"
            annotation (Placement(transformation(extent={{-8,10},{12,30}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloRad(
            final alpha=0) "Prescribed heat flow rate for radiative sensible heat"
            annotation (Placement(transformation(extent={{40,-30},{60,-10}})));
        equation
          connect(preHeaFloCon.port, portCon)
            annotation (Line(points={{60,20},{100,20}},            color={191,0,0}));
          connect(preHeaFloRad.port, portRad)
            annotation (Line(points={{60,-20},{100,-20}},           color={191,0,0}));
          connect(gainRad.y, preHeaFloRad.Q_flow)
            annotation (Line(points={{13,-20},{40,-20}}, color={0,0,127}));
          connect(gainCon.y, preHeaFloCon.Q_flow) annotation (Line(points={{13,20},{40,20}},
                                           color={0,0,127}));
          connect(gainCon.u, gaiHea.y)
            annotation (Line(points={{-10,20},{-20,20},{-20,0},{-31,0}},
                                                                     color={0,0,127}));
          connect(gainRad.u, gaiHea.y) annotation (Line(points={{-10,-20},{-20,-20},{-20,
                  0},{-31,0}}, color={0,0,127}));
          connect(ctrl, gaiHea.u) annotation (Line(points=
                 {{-110,0},{-54,0}}, color={0,0,127}));
          annotation (Documentation(info="<html>
<p>
This lighting model uses a light control input signal, 
which should have a value between 0 and 1,
which is multiplied by the lighting requirements of the zone (<i>lx=lm/m<sup>2</sup></i>), 
the floor area (<i>m<sup>2</sup></i>) and the inverse of the luminous efficacy (<i>lm/W</i>). 
The total lighting gains are then split into a radiative and a convective part. 
</p>
</html>",       revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>"));
        end Lighting;

        model Occupants "Constant sensible, latent and CO2 heat production per person"
          extends BaseClasses.PartialOccupancyGains;
          parameter Modelica.SIunits.Power QlatPp = occupancyType.QlatPp
            "Latent heat production per person, default from Ashrae Fundamentals: 'Seated, very light work'";
          parameter Modelica.SIunits.Power QsenPp = occupancyType.QsenPp
            "Sensible heat production per person, default from Ashrae Fundamentals: 'Seated, very light work'";
          parameter Real radFra(min=0,max=1) = occupancyType.radFra
            "Radiant fraction of sensible heat exchange, default based on Ashrae fundamentals chap 18.4 for low air velocity";
      protected
          constant Modelica.SIunits.SpecificEnthalpy lambdaWater = 2418000
            "Latent heat of evaporation of water at 35 degrees Celsius";
          constant Modelica.SIunits.SpecificEnthalpy E_glu = 16e6
            "Calorific value of glucose";
          constant Real MM_glu = 180
            "Molar mass of glucose";
          constant Real MM_CO2 = 44
            "Molar mass of CO2";
          parameter Real m_flow_co2_pp = (QlatPp+QsenPp)/(E_glu*MM_glu/6/MM_CO2)
            "CO2 production per person, based on oxidation of suger with calorific value of 16 kJ/g";
          final parameter Modelica.SIunits.MassFlowRate m_flow_h2o_pp = QlatPp/lambdaWater
            "Vapor production per person";
          final parameter Real s_co2[max(Medium.nC,1)] = {if Modelica.Utilities.Strings.isEqual(string1=if Medium.nC>0 then Medium.extraPropertiesNames[i] else "",
                                                     string2="CO2",
                                                     caseSensitive=false)
                                                     then 1 else 0 for i in 1:max(Medium.nC,1)};
          Modelica.Blocks.Math.Gain gaiHea(k=QsenPp)
                        "Gain for computing heat flow rate"
            annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
          Modelica.Blocks.Math.Gain[max(Medium.nC,1)] gaiCO2(k=m_flow_co2_pp*s_co2)
            "Gain for computing CO2 mass flow rate"
            annotation (Placement(transformation(extent={{-8,10},{12,30}})));
          Modelica.Blocks.Math.Gain gaiWat(k=m_flow_h2o_pp)
            "Gain for computing water mass flow rate"
            annotation (Placement(transformation(extent={{-8,50},{12,70}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloCon(final
              alpha=0) "Prescribed heat flow rate for convective sensible heat"
            annotation (Placement(transformation(extent={{40,-30},{60,-10}})));

      public
          Modelica.Blocks.Math.Gain gain(final k=radFra)
            annotation (Placement(transformation(extent={{-8,-70},{12,-50}})));
          Modelica.Blocks.Math.Gain gainCon(final k=1 - radFra)
            annotation (Placement(transformation(extent={{-8,-30},{12,-10}})));
      protected
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloRad(final
              alpha=0) "Prescribed heat flow rate for radiative sensible heat"
            annotation (Placement(transformation(extent={{40,-70},{60,-50}})));
        equation
          connect(gaiWat.y, mWat_flow)
            annotation (Line(points={{13,60},{106,60},{106,60}}, color={0,0,127}));
          connect(gaiCO2.y, C_flow)
            annotation (Line(points={{13,20},{60,20},{106,20}}, color={0,0,127}));
          connect(preHeaFloCon.port, portCon)
            annotation (Line(points={{60,-20},{82,-20},{100,-20}}, color={191,0,0}));
          connect(gaiHea.u, nOcc)
            annotation (Line(points={{-62,-40},{-110,-40},{-110,0}}, color={0,0,127}));
          for i in 1:max(Medium.nC,1) loop
            connect(gaiCO2[i].u, nOcc)
              annotation (Line(points={{-10,20},{-60,20},{-60,0},{-110,0}},
                                                          color={0,0,127}));
          end for;
          connect(gaiWat.u, nOcc)
            annotation (Line(points={{-10,60},{-110,60},{-110,0}}, color={0,0,127}));
          connect(preHeaFloRad.port, portRad)
            annotation (Line(points={{60,-60},{100,-60},{100,-60}}, color={191,0,0}));
          connect(gain.y, preHeaFloRad.Q_flow)
            annotation (Line(points={{13,-60},{40,-60}},          color={0,0,127}));
          connect(gainCon.y, preHeaFloCon.Q_flow) annotation (Line(points={{13,-20},{26,
                  -20},{40,-20}},          color={0,0,127}));
          connect(gainCon.u, gaiHea.y)
            annotation (Line(points={{-10,-20},{-39,-20},{-39,-40}}, color={0,0,127}));
          connect(gain.u, gaiHea.y)
            annotation (Line(points={{-10,-60},{-39,-60},{-39,-40}}, color={0,0,127}));
          annotation (Documentation(info="<html>
<p>
This occupancy model assumes a constant latent and sensible load per person. 
We assume this heat gain is caused by the metabolic combustion of suger, 
resulting into a corresponding CO2 production. 
The CO2 mass flow rate is added only if the Medium contains CO2. 
Latent heat is only added if the Medium is a moist air medium. 
Sensible heat is emitted both as convective and radiant heat using a fixed weighing factor.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 26, 2018 by Filip Jorissen:<br/>
Revised implementation to add support for
<a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
January 18, 2017 by Filip Jorissen:<br/>
Changed latent heat of evaporation of water.
This is for issue
<a href=https://github.com/open-ideas/IDEAS/issues/635>#635</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>"));
        end Occupants;

        package BaseClasses
          extends Modelica.Icons.BasesPackage;

          partial model PartialLightingGains "Partial model for lighting internal gains"
            extends Modelica.Blocks.Icons.Block;
            outer IDEAS.BoundaryConditions.SimInfoManager sim
              "Simulation information manager";
            parameter IDEAS.Buildings.Components.LightingType.None ligTyp
              annotation (Placement(transformation(extent={{-60,80},{-40,100}})));
            parameter IDEAS.Buildings.Components.RoomType.Generic rooTyp
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            parameter  Modelica.SIunits.Area A "Area of the zone";
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a portCon
              "Port for convective sensible heat transfer due to occupants"
              annotation (Placement(transformation(extent={{90,10},{110,30}})));
            Modelica.Blocks.Interfaces.RealInput ctrl
              "Number of occupants"
              annotation (Placement(transformation(extent={{-130,-20},{-90,20}})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFlo(
              final alpha=0) if sim.computeConservationOfEnergy
              "Prescribed energy heat flow for conservation of energy check";
            Modelica.Blocks.Sources.RealExpression Qgai(y=-portCon.Q_flow-portRad.Q_flow) if
                 sim.computeConservationOfEnergy;
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a portRad
              "Port for radiative sensible heat transfer due to occupants"
              annotation (Placement(transformation(extent={{90,-30},{110,-10}})));
          equation
            connect(preHeaFlo.port, sim.Qgai);
            connect(Qgai.y, preHeaFlo.Q_flow);
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>"));
          end PartialLightingGains;

          partial model PartialOccupancyGains "Partial model for occupant internal gains"
            import IDEAS;
            extends Modelica.Blocks.Icons.Block;
            outer IDEAS.BoundaryConditions.SimInfoManager sim "Simulation information manager";
            replaceable package Medium =
              Modelica.Media.Interfaces.PartialMedium "Medium in the component"
                annotation (choicesAllMatching = true, Documentation(revisions="<html>
<ul>
<li>
January 26, 2018 by Filip Jorissen:<br/>
Changed replaceable record into parameter such that 
<code>IDEAS.Buildings.Components.OccupancyType.BaseClasses.PartialOccupancyType</code> 
can be a partial record.
This is for <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
</ul>
</html>"));
            parameter IDEAS.Buildings.Components.OccupancyType.OfficeWork occupancyType
              annotation (Placement(transformation(extent={{-60,80},{-40,100}})));
            Modelica.Blocks.Interfaces.RealOutput mWat_flow
              "Water vapor mass flow rate due to occupants"
              annotation (Placement(transformation(extent={{96,50},{116,70}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a portCon
              "Port for convective sensible heat transfer due to occupants"
              annotation (Placement(transformation(extent={{90,-30},{110,-10}})));
            Modelica.Blocks.Interfaces.RealOutput C_flow[max(Medium.nC,1)]
              "Trace substance mass flow rate due to occupants"
              annotation (Placement(transformation(extent={{96,10},{116,30}})));
            Modelica.Blocks.Interfaces.RealInput nOcc "Number of occupants"
              annotation (Placement(transformation(extent={{-130,-20},{-90,20}})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFlo(final
                alpha=0) if sim.computeConservationOfEnergy
              "Prescribed energy heat flow for conservation of energy check";
            Modelica.Blocks.Sources.RealExpression Qgai(y=-portCon.Q_flow-portRad.Q_flow) if sim.computeConservationOfEnergy;
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a portRad
              "Port for radiative sensible heat transfer due to occupants"
              annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
          equation
            connect(preHeaFlo.port, sim.Qgai);
            connect(Qgai.y, preHeaFlo.Q_flow);
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
July 26, 2018 by Filip Jorissen:<br/>
Revised implementation to add support for
<a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>"));
          end PartialOccupancyGains;
        end BaseClasses;
      end InternalGains;

      package InterzonalAirFlow "Package for interzonal air flow models"
      extends Modelica.Icons.Package;

        model n50FixedPressure
          "n50FixedPressure: fixed pressure boundary, n50 air leakage into zone"
          extends
          IDEAS.Buildings.Components.InterzonalAirFlow.BaseClasses.PartialInterzonalAirFlown50
          (   prescribesPressure=true,
              verifyBothPortsConnected=true);
        equation
          connect(bou.ports[2], ports[2]) annotation (Line(points={{2,0},{2,-50},{2,-100},
                  {22,-100}},color={0,127,255}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
January 25, 2019, Filip Jorissen:<br/>
Added constant <code>prescribesPressure</code> that indicates
whether this model prescribes the zone air pressure or not.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/971\">#971</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
First version.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents an non-air tight zone. 
I.e. the zone air volume is internally fixed to a constant pressure
and the sum of the air injected through the two fluid ports
is consequently injected in the environment (as if all windows are opened).
If a net mass flow rate leaves the zone, then air is extracted
from the environment with the ambient temperature and humidity.
</p>
<p>
In addition to these mass flow rates, a fixed mass flow rate, 
corresponding to air infiltration, is injected into the zone.
The mass flow rate is computed from the zone <code>n50</code> value.
</p>
</html>"),         Icon(graphics={
                Polygon(
                  points={{-11,10},{20,0},{-11,-10},{-11,10}},
                  lineColor={0,128,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid,
                  visible=not allowFlowReversal,
                  origin={-54,19},
                  rotation=360),
                Line(
                  points={{57.5,0},{-11,-0.5}},
                  color={0,128,255},
                  visible=not allowFlowReversal,
                  origin={-60.5,19},
                  rotation=180),
                Polygon(
                  points={{-11,10},{20,0},{-11,-10},{-11,10}},
                  lineColor={0,128,255},
                  fillColor={0,128,255},
                  fillPattern=FillPattern.Solid,
                  visible=not allowFlowReversal,
                  origin={-118,19},
                  rotation=180)}));
        end n50FixedPressure;

        model n50Tight
          "n50Tight: n50 air leakage into and from airtight zone"
          extends
          IDEAS.Buildings.Components.InterzonalAirFlow.BaseClasses.PartialInterzonalAirFlown50
          ( prescribesPressure=false);
          Fluid.Interfaces.IdealSource airExfiltration(
            redeclare package Medium = Medium,
            control_m_flow=true,
            allowFlowReversal=false,
            control_dp=false) "Fixed air exfiltration rate" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={10,-50})));
        equation
          connect(airExfiltration.m_flow_in, airInfiltration.m_flow_in)
            annotation (Line(points={{2,-56},{-18,-56},{-18,-44}},  color={0,0,127}));
          connect(airExfiltration.port_b, bou.ports[2])
            annotation (Line(points={{10,-40},{10,0},{2,0}},  color={0,127,255}));
          connect(airExfiltration.port_a, ports[2]) annotation (Line(points={{10,-60},{10,
                  -100},{22,-100},{22,-100}},
                                            color={0,127,255}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
January 25, 2019, Filip Jorissen:<br/>
Added constant <code>prescribesPressure</code> that indicates
whether this model prescribes the zone air pressure or not.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/971\">#971</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
First version.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
</ul>
</html>",         info="<html>
<p>
This model represents an air tight zone.  
A fixed mass flow rate, 
corresponding to air infiltration, is injected into and extracted from the zone.
The mass flow rate is computed from the zone <code>n50</code> value.
No other air leakage is modelled.
</p>
</html>"),         Icon(graphics={
                Rectangle(
                  extent={{-70,40},{-100,0}},
                  fillColor={192,192,192},
                  fillPattern=FillPattern.Backward,
                  pattern=LinePattern.None)}));
        end n50Tight;

        package BaseClasses "Base classes"
          extends Modelica.Icons.BasesPackage;

          partial model PartialInterzonalAirFlow "Partial for interzonal air flow"
            replaceable package Medium = IDEAS.Media.Air "Air medium";
            parameter Integer nPorts "Number of ports for connection to zone air volume";
            parameter Modelica.SIunits.Volume V "Zone air volume for n50 computation";
            parameter Real n50 "n50 value";
            parameter Real n50toAch = 20
              "Conversion fractor from n50 to Air Change Rate"
              annotation(Dialog(tab="Advanced"));
            constant Boolean prescribesPressure = false
              "Indication whether this model prescribes the air zone pressure or not";
            // = true to enable check in zone that verifies whether both FluidPorts
            //  or none of the are connected, to avoid incorrect use.
            parameter Boolean verifyBothPortsConnected = false
              "=true, to verify fluid port connections";
            parameter Modelica.SIunits.MassFlowRate m_flow_nominal_vent
              "Nominal mass flow rate of ventilation system"
              annotation(Dialog(tab="Advanced"));
            Modelica.Fluid.Interfaces.FluidPort_b port_b_interior(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal_vent),
              h_outflow(nominal=Medium.h_default))
              "Port a connection to zone air model ports"
              annotation (Placement(transformation(extent={{50,-110},{70,-90}})));
            Modelica.Fluid.Interfaces.FluidPort_a port_a_interior(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal_vent),
              h_outflow(nominal=Medium.h_default))
              "Port b connection to zone air model ports"
              annotation (Placement(transformation(extent={{-70,-110},{-50,-90}})));
            Modelica.Fluid.Interfaces.FluidPort_a port_a_exterior(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal_vent),
              h_outflow(nominal=Medium.h_default))
              "Port a connection to model exterior ports"
              annotation (Placement(transformation(extent={{10,90},{30,110}})));
            Modelica.Fluid.Interfaces.FluidPort_b port_b_exterior(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal_vent),
              h_outflow(nominal=Medium.h_default))
              "Port b connection to model exterior ports"
              annotation (Placement(transformation(extent={{-30,90},{-10,110}})));
            Modelica.Fluid.Interfaces.FluidPorts_a[nPorts] ports(
              redeclare each package Medium = Medium,
              each m_flow(nominal=m_flow_nominal_vent),
              each h_outflow(nominal=Medium.h_default))
              "Ports connector for multiple ports" annotation (Placement(
                  transformation(
                  extent={{-10,40},{10,-40}},
                  rotation=90,
                  origin={2,-100})));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(
                    extent={{-15,80},{15,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None,
                    origin={-19,86},
                    rotation=90),
                  Rectangle(
                    extent={{-70,100},{-100,40}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{57.5,0},{-11,-0.5}},
                    color={0,128,255},
                    visible=not allowFlowReversal,
                    origin={-20.5,31},
                    rotation=90),
                  Line(
                    points={{57.5,0},{-13,-0.5}},
                    color={0,128,255},
                    visible=not allowFlowReversal,
                    origin={19.5,33},
                    rotation=90),
                  Rectangle(
                    extent={{-70,0},{-100,-60}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Polygon(
                    points={{-11,10},{20,0},{-11,-10},{-11,10}},
                    lineColor={0,128,255},
                    fillColor={0,128,255},
                    fillPattern=FillPattern.Solid,
                    visible=not allowFlowReversal,
                    origin={20,41},
                    rotation=270),
                  Line(
                    points={{60,70},{-70,70},{-70,-60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Polygon(
                    points={{-11,10},{20,0},{-11,-10},{-11,10}},
                    lineColor={0,128,255},
                    fillColor={0,128,255},
                    fillPattern=FillPattern.Solid,
                    visible=not allowFlowReversal,
                    origin={-20,69},
                    rotation=90)}),                                        Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
January 25, 2019, Filip Jorissen:<br/>
Added constant <code>prescribesPressure</code> that indicates
whether this model prescribes the zone air pressure or not.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/971\">#971</a>.
</li>
<li>
July 11, 2018, Filip Jorissen:<br/>
Added <code>m_flow_nominal_vent</code> and set 
<code>h_outflow</code> and <code>m_flow</code>
in <code>FluidPorts</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/859\">#859</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
First version.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
</ul>
</html>"));
          end PartialInterzonalAirFlow;

          partial model PartialInterzonalAirFlowBoundary
            "Partial interzonal air flow model that includes a boundary"
            extends
            IDEAS.Buildings.Components.InterzonalAirFlow.BaseClasses.PartialInterzonalAirFlow;
            outer BoundaryConditions.SimInfoManager sim "Simulation information manager"
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));

            Fluid.Sources.OutsideAir bou(redeclare package Medium = Medium)
              "Boundary model" annotation (Placement(transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={0,10})));
        protected
            final parameter Real s_co2[max(Medium.nC,1)] = {if Modelica.Utilities.Strings.isEqual(string1=if Medium.nC>0 then Medium.extraPropertiesNames[i] else "",
                                                       string2="CO2",
                                                       caseSensitive=false)
                                                       then 1 else 0 for i in 1:max(Medium.nC,1)};
            IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(numSolBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles)
              annotation (Placement(transformation(extent={{-78,80},{-58,100}})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFlo(final
                alpha=0) if                                                                 sim.computeConservationOfEnergy
              "Prescribed heat flow rate for conservation of energy check" annotation (
                Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=270,
                  origin={-90,66})));
            Modelica.Blocks.Sources.RealExpression QGai(y=-actualStream(bou.ports.h_outflow)
                  *bou.ports.m_flow) "Net heat gain through n50 air leakage "
              annotation (Placement(transformation(extent={{-22,30},{-82,50}})));

          equation
            connect( sim.weaBus,weaBus);
            connect(port_a_interior, port_b_exterior) annotation (Line(points={{-60,-100},
                    {-60,0},{-20,0},{-20,100}}, color={0,127,255}));
            connect(port_a_exterior, port_b_interior) annotation (Line(points={{20,100},{20,
                    0},{60,0},{60,-100}}, color={0,127,255}));
            connect(preHeaFlo.port, sim.Qgai)
              annotation (Line(points={{-90,76},{-90,80}}, color={191,0,0}));
            connect(QGai.y, preHeaFlo.Q_flow)
              annotation (Line(points={{-85,40},{-90,40},{-90,56}}, color={0,0,127}));


            if Medium.nX == 2 then
            end if;
            if Medium.nC > 0 then
            end if;


            annotation (Documentation(revisions="<html>
<ul>
<li>
September 21, 2019 by Filip Jorissen:<br/>
Using OutsideAir.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1052\">#1052</a>.
</li>
<li>
September 24, 2018 by Filip Jorissen:<br/>
Fix for supporting multiple trace substances.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/920\">#920</a>.
</li>
<li>
August 24, 2018 by Damien Picard:<br/>
Use weaDatBus.Te instead of sim.Te such that the variable is correctly 
used when linearizing with LIDEAS.
</li>
<li>
June 11, 2018 by Filip Jorissen:<br/>
Using <code>Xi_in</code> instead of <code>X_in</code> since this
requires fewer inputs and it avoids an input variable consistency check.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
First version.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
</ul>
</html>"));
          end PartialInterzonalAirFlowBoundary;

          partial model PartialInterzonalAirFlown50
            "Model representing idealised n50 air leakage"
            extends
            IDEAS.Buildings.Components.InterzonalAirFlow.BaseClasses.PartialInterzonalAirFlowBoundary(
                nPorts=2, bou(nPorts=2));
            parameter Modelica.SIunits.MassFlowRate m_flow_nominal_airLea=
              V*rho_default/3600*n50/n50toAch
              "Nominal mass flow of air leakage"
              annotation(Dialog(tab="Advanced"));
            Modelica.Blocks.Sources.RealExpression reaExpMflo(y=m_flow_nominal_airLea)
              annotation (Placement(transformation(extent={{-52,-54},{-30,-34}})));
            Fluid.Interfaces.IdealSource airInfiltration(
              redeclare package Medium = Medium,
              control_m_flow=true,
              allowFlowReversal=false,
              control_dp=false) "Fixed air infiltration rate" annotation (Placement(
                  transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=90,
                  origin={-10,-50})));
        protected
            final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
                T=Medium.T_default,
                p=Medium.p_default,
                X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
            final parameter Modelica.SIunits.Density rho_default = Medium.density(
              state=state_default) "Medium default density";
          equation
            connect(reaExpMflo.y, airInfiltration.m_flow_in) annotation (Line(points={{-28.9,
                    -44},{-18,-44}},                 color={0,0,127}));
            connect(airInfiltration.port_a, bou.ports[1]) annotation (Line(points={{-10,-40},
                    {-10,0},{-2,0}},                                          color={0,127,
                    255}));
            connect(airInfiltration.port_b, ports[1]) annotation (Line(points={{-10,-60},{
                    -10,-100},{-18,-100}},          color={0,127,255}));
            annotation (Documentation(revisions="<html>
<ul>
<li>
April 27, 2018 by Filip Jorissen:<br/>
First version.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
</ul>
</html>"),           Icon(graphics={Text(
                    extent={{18,-38},{66,-60}},
                    lineColor={28,108,200},
                    textString="n50")}));
          end PartialInterzonalAirFlown50;
        end BaseClasses;
      end InterzonalAirFlow;

      package LightingControl
      "Models for defining the lighting control that is present"
      extends Modelica.Icons.Package;

        block Fixed "Fixed lighting"
          extends BaseClasses.PartialLightingControl(
            final useCtrInput=false,
            final useOccInput=false);
          parameter Real ctrFix(min=0)=0
            "Fixed control signal";
          outer BoundaryConditions.SimInfoManager       sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          Modelica.Blocks.Math.Product product "For LIDEAS"
            annotation (Placement(transformation(extent={{40,10},{60,-10}})));
          Modelica.Blocks.Sources.Constant constCtrl(final k=ctrFix)
            "Constant block for lighting control"
            annotation (Placement(transformation(extent={{
                    -12,-10},{8,10}})));
      protected
          IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(
            final numSolBus=sim.numIncAndAziInBus,
            final outputAngles=sim.outputAngles)
            annotation (Placement(transformation(extent={{-74,82},{-54,102}})));
        equation
          connect(product.u2,weaBus. dummy) annotation (Line(points={{38,6},{24,6},{24,
                  92.05},{-63.95,92.05}},
                                   color={0,0,127}));
          connect(sim.weaBus,weaBus)  annotation (Line(
              points={{-81,93},{-74,93},{-74,92},{-64,92}},
              color={255,204,51},
              thickness=0.5));
          connect(constCtrl.y, product.u1)
            annotation (Line(points={{9,0},{20,0},{20,-6},{38,-6}}, color={0,0,127}));
          connect(product.y, ctrl)
            annotation (Line(points={{61,0},{120,0}}, color={0,0,127}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
August 28, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",         info="<html>
<p>
This block implements a fixed lighting control signal.
</p>
</html>"));
        end Fixed;

        block OccupancyBased
          "Lighting control from zone when nOcc > 0"
          extends
          IDEAS.Buildings.Components.LightingControl.BaseClasses.PartialLightingControl(
            final useOccInput=true);
          Modelica.Blocks.Logical.GreaterThreshold      greEquThr(threshold=0)
            "Greater or equal than threshold"
            annotation (Placement(transformation(extent={{-40,-10},{-20,10}})));
          Modelica.Blocks.Math.BooleanToReal booToRea(realTrue=1, realFalse=0)
            "Boolean to real conversion"
            annotation (Placement(transformation(extent={{0,-10},{20,10}})));
        equation
          connect(booToRea.y, ctrl)
            annotation (Line(points={{21,0},{120,0}}, color={0,0,127}));
          connect(booToRea.u, greEquThr.y)
            annotation (Line(points={{-2,0},{-19,0}}, color={255,0,255}));
          connect(greEquThr.u, nOcc) annotation (Line(points={{-42,0},{-60,0},{-60,20},{
                  -120,20}}, color={0,0,127}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
August 28, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",         info="<html>
<p>
This block enables the lighting when the number 
of occupants in the zone exceeds zero.
</p>
</html>"));
        end OccupancyBased;

        package BaseClasses "Base classes"
        extends Modelica.Icons.BasesPackage;

          partial block PartialLightingControl
            "Partial for defining the lighting control"
            extends Modelica.Blocks.Icons.Block;
            parameter Boolean useCtrInput= false
              "=true to use external control input";
            parameter Boolean useOccInput= false
              "=true to use occupancy input";
            parameter Boolean linearise
              "For linearisation checks";
            Modelica.Blocks.Interfaces.RealOutput ctrl "Lighting control signal"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));
            Modelica.Blocks.Interfaces.RealInput ligCtr if useCtrInput
              "External lighting control input"
              annotation (Placement(transformation(extent={{-140,-40},{-100,0}})));
            Modelica.Blocks.Interfaces.RealInput nOcc if   useOccInput
              "Number of occupants"
              annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
August 28, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",           info="<html>
<p>
Partial for defining the lighting control.
</p>
</html>"));
          end PartialLightingControl;
        end BaseClasses;
      annotation (Documentation(revisions="<html>
<ul>
<li>
August 28, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>"));
      end LightingControl;

      package LightingType
      "Records for defining the properties of the lighting"

        record LED "Properties for generic LED lighting"
          extends Modelica.Icons.Record;
          extends
          IDEAS.Buildings.Components.LightingType.BaseClasses.PartialLighting(
              K = 150,
              radFra = 0.35);
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",         info="<html>
<p>
Record for lighting properties of LED lighting. 
Based on <a href=\"https://en.wikipedia.org/wiki/Luminous_efficacy\">
https://en.wikipedia.org/wiki/Luminous_efficacy</a>.
</p>
</html>"));
        end LED;

        record None "No lighting installed in the zone"
          extends Modelica.Icons.Record;
          extends
          IDEAS.Buildings.Components.LightingType.BaseClasses.PartialLighting(
              K = Modelica.Constants.inf,
              radFra = 0);                   //infinite to force 0 lighting gains in the lighting model
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",         info="<html>
<p>
Model in case no lighting heat gains should be modelled.
</p>
</html>"));
        end None;

        package BaseClasses "Base classes"
        extends Modelica.Icons.BasesPackage;

          partial record PartialLighting
            "Record for defining the lighting type"
            extends Modelica.Icons.Record;
            parameter Real radFra(min=0,max=1)
              "Radiant fraction of lighting heat exchange";
            parameter Modelica.SIunits.LuminousEfficacy K
              "Luminous efficacy, specifies the lm/W (lumen per watt) of the installed lighting";
        protected
            parameter Real conFra(min=0, max=1) = 1-radFra
              "Convective fraction of lighting heat exchange";
            annotation (Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",           info="<html>
<p>This record may be used to describe the relevant parameters of the lighting installation of a determined zone, i.e. the luminous efficacy (in<i> lm/W</i>) and the fraction between the convective and radiative heat gains.</p>
</html>"));
          end PartialLighting;
        end BaseClasses;
      end LightingType;

      package OccupancyType
      "Records for defining the properties of the zone occupants"

        record OfficeWork
          "Properties for typical office work."
          extends
          IDEAS.Buildings.Components.OccupancyType.BaseClasses.PartialOccupancyType(
            QlatPp=45,
            QsenPp=73,
            radFra=0.6,
            ICl=0.7);
          annotation (Documentation(revisions="<html>
<ul>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>",         info="<html>
<p>
See documentation in IDEAS.Buildings.Components.OccupancyType.PartialOccupancyType.
This model is based on Fanger and Ashrae Fundamentals (2009).
</p>
<h4>References</h4>
<ul>
<li>
ASHRAE Handbook, Fundamentals.
 American Society of Heating, Refrigerating and Air-Conditioning Engineers,
Chapter 18, Internal Heat Gains; pages 18.4; Atlanta, USA, 2009.
</li>
</ul>
</html>"));
        end OfficeWork;

        package BaseClasses "Base classes"
        extends Modelica.Icons.BasesPackage;

          partial record PartialOccupancyType
            "Record for defining the type (i.e. properties) of the occupants, used in InternalGains and Comfort models"
            extends Modelica.Icons.Record;

            parameter Modelica.SIunits.Power QlatPp(min=0)
              "Latent heat production per person";
            parameter Modelica.SIunits.Power QsenPp(min=0)
              "Sensible heat production per person";
            parameter Real radFra(min=0,max=1) = 0.6
              "Radiant fraction of sensible heat exchange, default based on Ashrae fundamentals chap 18.4 for low air velocity, used for computing radiative and convective sensible heat flow rate fractions";
            parameter Real ICl(min=0) = 0.7
              "Fixed value for clothing insulation in units of clo (summer=0.5; winter=0.9), used to compute thermal comfort";
            annotation (Documentation(revisions="<html>
<ul>
<li>
October 15, 2019 by Iago Cupeiro:<br/>
Corrected typo in description.
</li>
<li>
January 26, 2018 by Filip Jorissen:<br/>
Revised default values. 
Record is now partial.
This is for <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>",           info="<html>
<p>
This record may be used to describe the thermally relevant characteristics of the occupants. 
Following tables may be used as a guide to choose the numeric values.
Some tables and part of this documentation was copied from Buildings.Utilities.Comfort.Fanger.
</p>

<h4>Latent/sensible heat load fraction</h4>
<p>
Human heat production is dissipated through a latent (sweat secretion) and 
sensible heat load, respectively QlatPp and QsenPp in this record.
The table below provides some typical values (W per person) from ASHRAE (2009) page 18.4.
The table also provides typical values for radFra for low and high air velocities.
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Activity</th><th>QsenPp</th><th>QlatPp</th><th>radFra low</th><th>radFra high</th></tr>
<tr><td>Seated at theatre</td><td>66</td><td>31</td><td>0.6</td><td>0.27</td></tr>
<tr><td>Seated, very light work</td><td>72</td><td>45</td><td>0.6</td><td>0.27</td></tr>
<tr><td>Moderately active office work</td><td>73</td><td>59</td><td>0.58</td><td>0.38</td></tr>
<tr><td>Standing, light work, walking</td><td>73</td><td>59</td><td>0.58</td><td>0.38</td></tr>
<tr><td>Walking, standing</td><td>73</td><td>73</td><td>0.58</td><td>0.38</td></tr>
<tr><td>Light bench work (factory)</td><td>81</td><td>140</td><td>0.49</td><td>0.35</td></tr>
</table>
<br/>

<h4>Insulation for clothing ensembles</h4>
<p>
Clothing (parameter ICl) is defined in terms of clo units.  Clo is a unit used to express the thermal insulation provided by garments and clothing ensembles,
where <i>1</i> clo = <i>0.155</i> (m^2*K/W) (ASHRAE 55-92).
</p>
<p>
The following table is obtained from ASHRAE page 8.8
</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Clothing ensemble</th><th>clo</th></tr>
<tr><td>ASHRAE Standard 55 Winter</td><td>0.90</td></tr>
<tr><td>ASHRAE Standard 55 Summer</td><td>0.50</td></tr>
<tr><td>Walking shorts, short-sleeve shirt</td><td>  0.36</td></tr>
<tr><td>Trousers, long-sleeve shirt</td><td> 0.61</td></tr>
<tr><td>Trousers, long-sleeve shirt, suit jacket</td><td> 0.96</td></tr>
<tr><td>Trousers, long-sleeve shirt, suit jacket, T-shirt</td><td> 1.14</td></tr>
<tr><td>Trousers, long-sleeve shirt, long-sleeve sweater, T-shirt</td><td> 1.01</td></tr>
<tr><td>Same as above + suit jacket, long underwear bottoms</td><td> 1.30</td></tr>
<tr><td>Sweat pants, sweat shirt</td><td> 0.74</td></tr>
<tr><td>Knee-length skirt, short-sleeve shirt, panty hose, sandals</td><td> 0.54</td></tr>
<tr><td>Knee-length skirt, long-sleeve shirt, full slip, panty hose</td><td> 0.67</td></tr>
<tr><td>Knee-length skirt, long-sleeve shirt, half slip, panty hose, long sleeve sweater</td><td> 1.10</td></tr>
<tr><td>Long-sleeve coveralls, T-shirt</td><td>   0.72</td></tr>
<tr><td>Insulated coveralls, long-sleeve, thermal underwear, long underwear bottoms</td><td> 1.37</td></tr>
</table>
<br/>

<h4> Metabolic rates</h4>
<p>
One met is defined as <i>58.2</i> Watts per square meter which is equal to the energy produced
per unit surface area of a seated person at rest.</p>
<p>The following table is obtained from ASHRAE (1997) page 8.6.</p>
<table summary=\"summary\" border=\"1\">
<tr><th>Activity</th><th>W/m2 body surface area</th></tr>
<tr><td>ASHRAE Standard 55</td><td>58.2</td></tr>
<tr><td> reclining  </td><td>45</td></tr>
<tr><td> seated and quiet </td><td>60</td></tr>
<tr><td> sedentary activity (reading, writing) </td><td>60</td></tr>
<tr><td> standing, relaxed </td><td>70</td></tr>
<tr><td> office (filling while standing)</td><td>80</td></tr>
<tr><td> office (walking)</td><td>100</td></tr>
<tr><td>Sleeping</td><td>         40     </td></tr>
<tr><td>Seated quiet</td><td>   60 </td></tr>
<tr><td>Standing Relaxed</td><td>  70  </td></tr>
<tr><td>Walking 3.2 - 6.4km/h</td><td> 115-220   </td></tr>
<tr><td>Reading</td><td> 55</td></tr>
<tr><td>Writing</td><td> 60</td></tr>
<tr><td>Typing</td><td> 65</td></tr>
<tr><td>Lifting/packing</td><td>  120</td></tr>
<tr><td>Driving Car</td><td> 60-115</td></tr>
<tr><td>Driving Heavy vehicle</td><td> 185</td></tr>
<tr><td>Cooking</td><td> 95-115</td></tr>
<tr><td>Housecleaning</td><td> 115-200</td></tr>
<tr><td>Machine work</td><td> 105-235</td></tr>
<tr><td>Pick and shovel work</td><td> 235-280</td></tr>
<tr><td>Dancing-Social</td><td> 140-225</td></tr>
<tr><td>Calisthenics</td><td>  175-235</td></tr>
<tr><td>Basketball</td><td>  290-440</td></tr>
<tr><td>Wrestling</td><td>  410-505</td></tr>
</table>
<br/>
<h4>References</h4>

<ul><li>
ASHRAE Handbook, Fundamentals (SI Edition).
 American Society of Heating, Refrigerating and Air-Conditioning Engineers,
Chapter 8, Thermal Comfort; pages 8.1-8.26; Atlanta, USA, 1997.
</li>
<li>
ASHRAE Handbook, Fundamentals.
 American Society of Heating, Refrigerating and Air-Conditioning Engineers,
Chapter 18, Internal Heat Gains; pages 18.4; Atlanta, USA, 2009.
</li>
<li>
International Standards Organization (ISO).
Moderate Thermal Environments: Determination of the PMV and PPD Indices
and Specification of the Conditions for Thermal Comfort (ISO 7730).
Geneva, Switzerland: ISO. 1994.
</li>
<li>
Charles, K.E. Fanger Thermal Comfort and Draught Models. Institute for Research in Construction
National Research Council of Canada, Ottawa, K1A 0R6, Canada.
IRC Research Report RR-162. October 2003.
<a href=\"http://irc.nrc-cnrc.gc.ca/ircpubs\">http://irc.nrc-cnrc.gc.ca/ircpubs</a>.
</li>
<li>
Data, References and Links at: Thermal Comfort; Dr. Sam C M Hui
Department of Mechanical Engineering
The University of Hong Kong MEBS6006 Environmental Services I;
<a href=\"http://me.hku.hk/msc-courses/MEBS6006/index.html\">
http://me.hku.hk/msc-courses/MEBS6006/index.html</a>
</li>
</ul>

</html>"));
          end PartialOccupancyType;
        end BaseClasses;
      end OccupancyType;

      package Occupants
      "Models for defining the number of occupants that are present"
      extends Modelica.Icons.Package;

        block Fixed "Fixed number of occupants"
          extends BaseClasses.PartialOccupants(final useInput=false);
          outer BoundaryConditions.SimInfoManager       sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          parameter Real nOccFix(min=0)=0
            "Fixed number of occupants";
          Modelica.Blocks.Sources.Constant constOcc(final k=nOccFix)
            "Constant block for number of occupants"
            annotation (Placement(transformation(extent={{-10,-16},{10,4}})));
          Modelica.Blocks.Math.Product product "For LIDEAS"
            annotation (Placement(transformation(extent={{40,10},{60,-10}})));
      protected
          Interfaces.WeaBus weaBus(numSolBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles)
            annotation (Placement(transformation(extent={{-74,82},{-54,102}})));
        equation
          connect(sim.weaBus, weaBus) annotation (Line(
              points={{-81,93},{-74,93},{-74,92},{-64,92}},
              color={255,204,51},
              thickness=0.5));
          connect(product.u1, constOcc.y)
            annotation (Line(points={{38,-6},{11,-6}},color={0,0,127}));
          connect(product.y, nOcc)
            annotation (Line(points={{61,0},{120,0}}, color={0,0,127}));
          connect(product.u2, weaBus.dummy) annotation (Line(points={{38,6},{24,6},{24,
                  92.05},{-63.95,92.05}},
                                   color={0,0,127}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
August 21, 2018 by Damien Picard: <br/> 
Multiplied the occupant number with the dummy variable to 
avoid the suppression of it while linearizing in LIDEAS.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/812\">#812</a>.
</li>
<li>
July 26, 2018 by Filip Jorissen:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
</ul>
</html>"));
        end Fixed;

        block Input "Number of occupants equals zone input yOcc"
          extends BaseClasses.PartialOccupants(final useInput=true);

          Modelica.Blocks.Math.Gain gain(k=1) "Optional gain for scaling input"
            annotation (Placement(transformation(extent={{-8,-10},{12,10}})));
        equation
          assert(not linearise, "Linearising the model when using an occupancy control input. 
    Make sure to add the occupancy control input as an input for the linearisation to work correctly.",
            level=AssertionLevel.warning);
          connect(nOcc, gain.y)
            annotation (Line(points={{120,0},{13,0}}, color={0,0,127}));
          connect(gain.u, yOcc)
            annotation (Line(points={{-10,0},{-120,0}}, color={0,0,127}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
March 28, 2019 by Filip Jorissen:<br/>
Revised implementation
for <a href=\"https://github.com/open-ideas/IDEAS/issues/998\">#998</a>.
</li>
<li>
July 26, 2018 by Filip Jorissen:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
</ul>
</html>",         info="<html>
<p>
This block allows defining the occupancy externally, by using the zone model input <code>yOcc</code>.
</p>
</html>"));
        end Input;

        package BaseClasses "Base classes"
        extends Modelica.Icons.BasesPackage;

          partial block PartialOccupants "Partial for defining the number of occupants"
            extends Modelica.Blocks.Icons.Block;
            parameter Boolean useInput= false
              "=true to use external input";
            parameter Boolean linearise
              "For linearisation checks";
            parameter Modelica.SIunits.Area A
              "Zone surface area";
            Modelica.Blocks.Interfaces.RealOutput nOcc "Number of occupants"
              annotation (Placement(transformation(extent={{100,-20},{140,20}})));
            Modelica.Blocks.Interfaces.RealInput yOcc if   useInput
              "Input for number of occupants"
              annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
March 28, 2019 by Filip Jorissen:<br/>
Added parameter <code>A</code> 
for <a href=\"https://github.com/open-ideas/IDEAS/issues/998\">#998</a>.
</li>
<li>
July 26, 2018 by Filip Jorissen:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
</ul>
</html>"));
          end PartialOccupants;
        end BaseClasses;
      end Occupants;

      package RoomType "package for room type specifications"
      extends Modelica.Icons.Package;

        record Generic "Generic room type"
          extends
          IDEAS.Buildings.Components.RoomType.BaseClasses.PartialRoomType(
            Ev = 300);
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",         info="<html>
<p>Record for lighting requirements for a generic zone.
Based on standard EN 12464-1, Table 5.31 (5.31.1)</p>
</html>"));
        end Generic;

        record Office "Office room type"
          extends
          IDEAS.Buildings.Components.RoomType.BaseClasses.PartialRoomType(
            Ev = 500);
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",         info="<html>
<p>Record for lighting requirements for office typical work
(writing, typing, reading, data processing...). Based on
standard EN 12464-1, Table 5.26 (5.26.2)</p>
</html>"));
        end Office;

        package BaseClasses
        extends Modelica.Icons.BasesPackage;

          partial record PartialRoomType
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.Illuminance Ev
              "Illuminance requirement of the zone";
            annotation (Documentation(revisions="<html>
<ul>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
First implementation
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
</ul>
</html>",           info="<html>
<p>
This record describes the function of the zone.
</p>
<p>
At this point, this record only contains the illuminance requirements of the zone.
In the future, other functionality may be added.
</p>
</html>"));
          end PartialRoomType;
        end BaseClasses;
      end RoomType;

      package Shading "Shadeing devices for windows"
      extends Modelica.Icons.Package;

        model Box "Both side fins and overhang"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
                                                                     final controlled=false);
          parameter Modelica.SIunits.Length hWin(min=0) "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin(min=0) "Window width"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wLeft(min=0)
            "Left overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length wRight(min=0)
            "Right overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length ovDep(min=0)
            "Overhang depth perpendicular to the wall plane"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length ovGap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length hFin(min=0)
            "Height of side fin above window"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length finDep(min=0)
            "Side fin depth perpendicular to the wall plane"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length finGap(min=0)
            "Vertical distance between side fin and window"
            annotation(Dialog(group="Side fin properties"));
          Real fraSunDir(
            final min=0,
            final max=1,
            final unit="1")
            "Fraction of window area exposed to the sun";
          Real fraSunDifSky(
            final min=0,
            final max=1,
            final unit="1")
            "Fraction of window area exposed to diffuse sun light";
          IDEAS.Buildings.Components.Shading.Overhang overhang(
            final azi=azi,
            final hWin=hWin,
            final wWin=wWin,
            final wLeft=wLeft,
            final wRight=wRight,
            final dep=ovDep,
            final gap=ovGap)
            annotation (Placement(transformation(extent={{-2,60},{8,80}})));
          IDEAS.Buildings.Components.Shading.SideFins sideFins(
            final azi=azi,
            final hWin=hWin,
            final wWin=wWin,
            final hFin=hFin,
            final dep=finDep,
            final gap=finGap)
            annotation (Placement(transformation(extent={{-4,20},{6,40}})));
      protected
            final parameter Modelica.SIunits.Area aWin = hWin*wWin "Window area";
        initial equation
            assert(ovDep > 0, "The depth of the overhang must be larger than zero. If this is not the case, just use Shading.SideFins");
            assert(finDep > 0, "The depth of the side fins must be larger than zero. If this is not the case, just use Shading.Overhang");
        equation
          fraSunDir = overhang.fraSunDir*sideFins.fraSunDir;
          fraSunDifSky = overhang.fraSunDifSky*sideFins.fraSunDif;
          HShaDirTil = HDirTil * fraSunDir;
          HShaSkyDifTil = HSkyDifTil * fraSunDifSky;
          HShaGroDifTil = HGroDifTil * sideFins.fraSunDif;
          connect(angInc, iAngInc) annotation (Line(
              points={{-60,-50},{-16,-50},{-16,-50},{40,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(overhang.angZen, angZen) annotation (Line(
              points={{-2,64},{-30,64},{-30,-70},{-60,-70}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sideFins.angInc, angInc) annotation (Line(
              points={{-4,26},{-32,26},{-32,-50},{-60,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sideFins.angZen, angZen) annotation (Line(
              points={{-4,24},{-30,24},{-30,-70},{-60,-70}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(sideFins.angAzi, angAzi) annotation (Line(
              points={{-4,22},{-28,22},{-28,-90},{-60,-90}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(overhang.angAzi, angAzi) annotation (Line(
              points={{-2,62},{-28,62},{-28,-90},{-60,-90}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(overhang.angInc, angInc) annotation (Line(
              points={{-2,66},{-32,66},{-32,-50},{-60,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirTil, overhang.HDirTil) annotation (Line(points={{-60,50},{-40,50},
                  {-40,76},{-2,76}}, color={0,0,127}));
          connect(HDirTil, sideFins.HDirTil) annotation (Line(points={{-60,50},{-40,50},
                  {-40,36},{-4,36}}, color={0,0,127}));
          connect(HSkyDifTil, overhang.HSkyDifTil) annotation (Line(points={{-60,30},{-38,
                  30},{-38,74},{-2,74}}, color={0,0,127}));
          connect(HSkyDifTil, sideFins.HSkyDifTil) annotation (Line(points={{-60,30},{-38,
                  30},{-38,34},{-4,34}}, color={0,0,127}));
          connect(HGroDifTil, overhang.HGroDifTil) annotation (Line(points={{-60,10},{-36,
                  10},{-36,72},{-2,72}}, color={0,0,127}));
          connect(HGroDifTil, sideFins.HGroDifTil) annotation (Line(points={{-60,10},{-36,
                  10},{-36,32},{-4,32}}, color={0,0,127}));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),  Documentation(info="<html>
<p>
Shading model that simulates a combination of both side fins and a overhang. 
The implementation is a combination of both IDEAS.Buildings.Components.Shading.Overhang 
and IDEAS.Buildings.Components.Shading.SideFins.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
        end Box;

        model BoxAndScreen "Box and screen shading"
          parameter Modelica.SIunits.Length hWin(min=0) "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin(min=0) "Window width"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wLeft(min=0)
            "Left overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length wRight(min=0)
            "Right overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length ovDep(min=0)
            "Overhang depth perpendicular to the wall plane"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length ovGap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length hFin(min=0)
            "Height of side fin above window"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length finDep(min=0)
            "Side fin depth perpendicular to the wall plane"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length finGap(min=0)
            "Vertical distance between side fin and window"
            annotation(Dialog(group="Side fin properties"));
          parameter Real shaCorr=0.24 "Shortwave transmittance of shortwave radiation";
          extends IDEAS.Buildings.Components.Shading.Interfaces.DoubleShading(
              redeclare IDEAS.Buildings.Components.Shading.Screen stateShading1(
                azi=azi,
                shaCorr=shaCorr),
              redeclare IDEAS.Buildings.Components.Shading.Box stateShading2(
                azi=azi,
                hWin=hWin,
                wWin=wWin,
                wLeft=wLeft,
                wRight=wRight,
                ovDep=ovDep,
                ovGap=ovGap,
                hFin=hFin,
                finDep=finDep,
                finGap=finGap));
        initial equation
            assert(ovDep > 0, "The depth of the overhang must be larger than zero, if this is not the case: just use Shading.Screen.");
            assert(finDep > 0, "The depth of the side fins must be larger than zero, if this is not the case: just use Shading.OverhangAndScreen.");
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),  Documentation(info="<html>
<p>This model describes the transient behaviour of solar irradiance on a window below a non-fixed horizontal or vertical overhang combined with a controllable screen.</p>
</html>",         revisions="<html>
<ul>
<li>
July 2015, by Filip Jorissenr:<br/>
Now extending from IDEAS.Buildings.Components.Interfaces.DoubleShading.
</li>
<li>
December 2014, by Filip Jorissenr:<br/>
First implementation.
</li>
</ul>
</html>"));
        end BoxAndScreen;

        model BuildingShade
          "Component for modeling shade cast by distant objects such as buildings and treelines"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
            final controlled=false);

          parameter Modelica.SIunits.Length L(min=0)
            "Distance to object perpendicular to window"
            annotation(Dialog(group="Dimensions (see illustration in documentation)"));
          parameter Modelica.SIunits.Length dh
            "Height difference between top of object and top of window glazing"
            annotation(Dialog(group="Dimensions (see illustration in documentation)"));
          parameter Modelica.SIunits.Length hWin(min=0) = 1
            "Window height: distance between top and bottom of window glazing"
            annotation(Dialog(group="Dimensions (see illustration in documentation)"));
          parameter Real fraSha(min=0,max=1) = 1
            "Fraction of the light that is shaded, e.g. smaller than 1 for shading cast by tree lines.";
          final parameter Real fraSunDifSky(final min=0,final max=1, final unit="1") = 1-vieAngObj/(Modelica.Constants.pi/2)
            "Fraction of window area exposed to diffuse sun light";

          Real fraSunDir(final min=0,final max=1, final unit="1")
            "Fraction of window area exposed to direct sun light";

          // Computation assumes that window base is at ground level.
          // Viewing angle computed from center of glazing.
      protected
          parameter Modelica.SIunits.Angle vieAngObj = atan((hWin/2+dh)/L) "Viewing angle of opposite object";
          final parameter Modelica.SIunits.Angle rot = 0
            "Rotation angle of opposite building. Zero when parallel, positive when rotated clockwise"
            annotation(Evaluate=true);
          final parameter Real coeff = 1-fraSha "More efficient implementation";
          final parameter Real hWinInv = 1/hWin "More efficient implementation";
          Real tanZen = tan(min(angZen, Modelica.Constants.pi/2.01));
          Modelica.SIunits.Length L1 "Horizontal distance to object when following vertical plane through sun ray";
          Modelica.SIunits.Length L2 "Distance to object, taking into account sun position";
          Modelica.SIunits.Angle alt = (Modelica.Constants.pi/2) - angZen;
          Modelica.SIunits.Angle verAzi
            "Angle between downward projection of sun's rays and normal to vertical surface";
        initial equation
          assert(fraSunDifSky>=0 and fraSunDifSky<=1, "In " + getInstanceName() +
            ": The parameter fraSunDifSky has the value " +String(fraSunDifSky) + " and 
    should be within [0,1]. Please contact the IDEAS developers.");

        equation

          verAzi = Modelica.Math.acos(cos(angInc)/cos(alt));
          L1 = max(0,L/cos(verAzi));
          L2 = L1*tan(alt);
          if noEvent(L2<dh) then
            fraSunDir=coeff;
          elseif noEvent(L2<dh+hWin) then
            fraSunDir=coeff + (L2-dh)*fraSha*hWinInv;
          else
            fraSunDir=1;
          end if;

          HShaDirTil=fraSunDir*HDirTil;
          HShaSkyDifTil = fraSunDifSky*HSkyDifTil;
          connect(angInc, iAngInc) annotation (Line(points={{-60,-50},{-14,-50},{-14,-50},
                  {40,-50}}, color={0,0,127}));

          connect(HGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-60,10},{40,10},{40,10}}, color={0,0,127}));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-50,-100},{50,100}}),
                graphics),
            Documentation(info="<html>
<p>
This model computes the shading cast by a building (or other object) at 
distance <code>L</code> and relative height <code>dh</code> 
on a window (or wall) with height <code>hWin</code>.
For a window this height corresponds to the window glazing height,
excluding the window frame.
Diffuse sky solar radiation is reduced
by computing a simplified view factor of the building,
which blocks the sky view.
Diffuse ground solar radiation is unaffected by this model. 
</p>
<p><img alt=\"illustration\" src=\"modelica://IDEAS/Resources/Images/Buildings/Components/Shading/BuildingShade.png\"/></p>
<h4>Assumption and limitations</h4>
<p>
This model assumes that the obstructing object is very wide (infinite) 
compared to the window/wall
and that it is parallel to the window. 
This model is inaccurate when this is not the case.
</p>
<p>
We assume that the opposite building is shaded or that its reflectivity is zero,
such that it does not reflect solar irradiation towards
the window.
Partial shading, e.g. when modelling treelines, 
can be modelled by changing the value of parameter <code>fraSha</code> accordingly.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 22, 2019 by Filip Jorissen:<br/>
Added assert that checks validity of parameter <code>fraSunDifSky</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/843\">
#843</a>.
</li>
<li>
April 10, 2019 by Filip Jorissen:<br/>
Revised computation of <code>fraSunDifSky</code> to avoid
negative shading fractions.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1007\">
#1007</a>.
</li>
<li>
February 21, 2019 by Filip Jorissen:<br/>
Added parameter <code>shaFra</code> for lowering shading
fraction of the model.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/912\">
#912</a>.
</li>
<li>
September 25, 2018 by Filip Jorissen:<br/>
Clarified meaning of <code>hWin</code>
and grouped parameters with reference to documentation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/909\">
#909</a>.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Added computation of diffuse solar shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
May 25, 2017, by Filip Jorissen:<br/>
Fixed implementation for non-south oriented windows.
</li>
<li>
December 9, 2016, by Filip Jorissen:<br/>
Fixed implementation for non-circular type building.
</li>
<li>
July 14, 2015, by Filip Jorissen:<br/>
Added documentation.
</li>
<li>
June 12, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end BuildingShade;

        model HorizontalFins "Horizontal fin shading with 2 control input options"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(final controlled=use_betaInput or use_displacementInput);

          parameter Modelica.SIunits.Length s(min=0)
            "Vertical spacing between fins";
          parameter Modelica.SIunits.Length w(min=0)
            "Fin width";
          parameter Modelica.SIunits.Length t(min=0)
            "Fin thickness";
          parameter Boolean use_displacementInput = false
            "=true, to use input for controlling the horizontal fin displacement. Set Ctrl=1 for fully closed shading."
            annotation(Evaluate=true);
          parameter Boolean use_betaInput = false
            "=true, to use input for fin inclination angle"
            annotation(Evaluate=true);
          parameter Modelica.SIunits.Angle beta(min=0)=0
            "Fin inclination angle: 0 for horizontal inclination, see documentation"
            annotation(Dialog(enable=not use_betaInput));

          Real shaFrac "Shaded fraction of the glazing for direct solar irradiation";
          Real shaFracDif "Shaded fraction of the glazing for diffuse solar irradiation";


      protected
          Modelica.SIunits.Length dy1 = s-sin(beta_internal)*w-cos(beta_internal)*t;
          Modelica.SIunits.Length dx = cos(beta_internal)*w-sin(beta_internal)*t;
          Modelica.SIunits.Length dz = dx/cos(angInc) "Horizontal ray displacement along the ray direction";
          Modelica.SIunits.Length dy3 = max(0,min(dz*tan(angAlt),s));

          Real dispLim=min(1,max(0,disp_internal));

          Modelica.Blocks.Interfaces.RealInput beta_internal
            "Internal variable for inclination angle";
          Modelica.Blocks.Interfaces.RealInput disp_internal
            "Internal variable for displacement fraction";
          Modelica.SIunits.Angle angAlt = Modelica.Constants.pi/2 - angZen
            "Altitude angle";

          // assuming diffuse radiation impedes perpendicular in azimuth direction
          // and under 30 degrees with the horizontal plane
          parameter Modelica.SIunits.Angle angAltDif = Modelica.Constants.pi/2/3
            "Assumed average altitude angle of diffuse shading";
          Modelica.SIunits.Length dy3Dif = max(0,min(dzDif*tan(angAltDif),s));
          Modelica.SIunits.Length dzDif = dx/cos(angAltDif);

        initial equation
          if not use_betaInput then
            assert(beta >= 0 and beta < acos(t/s), "In " + getInstanceName() + ": Beta must be within the feasible range.");
          end if;
          assert(s > 0 and w > 0 and t >= 0,
           "The fin spacing, width and thickness should be positive");
          assert(not use_betaInput or not use_displacementInput,
            "In " + getInstanceName() + ": Either use_betaInput or use_displacementInput should be false.");

        equation

          if not use_betaInput then
            beta_internal = beta;
          else
            connect(beta_internal,Ctrl);
          end if;
          if not use_displacementInput then
            disp_internal=1;
          else
            connect(disp_internal,Ctrl);
          end if;

          if dy3 > dy1 then
            shaFrac = dispLim;
          else
            // The shaded part equals 100% minus the unshaded part due to displacement (1-dispLim),
            // minus the shaded fraction (disp) that is unshaded by the fins (dy1-min(dy1,dy3))/s.
            // i.e. 1 - (1-dispLim) - dispLim*(dy1-min(dy1,dy3))/s
            // after collecting terms this results in:
            shaFrac = dispLim*(1 - (dy1-min(dy1,dy3))/s);
          end if;

          // same reasoning as for direct solar irradiation
          if dy3Dif > dy1 then
            shaFracDif = dispLim;
          else
            shaFracDif = dispLim*(1 - (dy1-min(dy1,dy3Dif))/s);
          end if;

          HShaDirTil = (1-shaFrac)*HDirTil;
          HShaSkyDifTil = (1-shaFracDif)*HSkyDifTil;

          angInc = iAngInc;
          connect(HGroDifTil, HShaGroDifTil);

            annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-50,-100},{50,100}})),
            Documentation(info="<html>
<p>
Shading model for exterior horizontal fins in front of a window,
in function of the fin angle. The control input <code>Ctrl</code>
can either be used for controlling the fin angle, or its horizontal displacement.
The horizontal displacement option assumes that the fins can be displaced
horizontally at the exterior of the window such that they are either in front or
next to the window.
</p>
<h4>Assumption and limitations</h4>
<p>
We assume that the fins fully cover the window unless the horizontal
displacement option is used.
The fin angle <code>beta</code> should be positive.
We compute the shaded fraction of the direct solar irradiation and assume
that indirect reflect effects are negligible.
The diffuse solar irradiation is correct by assuming that the diffuse
solar irradation originates from a solar altitude angle of 30 degrees,
which is an approximation to reality.
The ground diffuse solar irradation is not modified.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameter <code>t</code> is the fin thickness,
<code>s</code> is the vertical spacing between the fins and
<code>w</code> is the fin width.
If <code>use_betaInput=true</code>, 
the input <code>Ctrl</code> is used to control the angle beta,
such that <code>beta</code> in the figure equals <code>Ctrl</code>.
Note that <code>beta</code> must have radians as a unit.
If <code>use_displacementInput=true</code>,
the input <code>0 &lt; Ctrl &lt; 1</code> is used to control the horizontal
displacement of the fins.
For <code>Ctrl=0</code>, the fins are moved away from the window, 
into the plane of the figure below,
such that no sun light is blocked.
Either <code>use_displacementInput</code> or <code>use_betaInput</code>
should be false.
See the figure below for an illustration.
</p>
<h4>Dynamics</h4>
<p>
This model has no dynamics.
</p>
<h4>Implementation</h4>
<p>
The implementation is illustrated using this figure: 
<br/><img alt=\"illustration\" src=\"modelica://IDEAS/Resources/Images/Buildings/Components/Shading/HorizontalFins.PNG\"/>
</p>
</html>",         revisions="<html>
<ul>
<li>
November 10, 2019 by Filip Jorissen:<br/>
Added simplified computation for diffuse solar shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/874\">#874</a>.
</li>
<li>
March 18, 2019 by Filip Jorissen:<br/>
Added control option for horizontal displacement.
Fixed bug in the implementation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/992\">#992</a>.
</li>
<li>
April, 2017 by Iago Cupeiro:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
        end HorizontalFins;

        model None "No solar shading"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
                                                                     final controlled=false);
        equation
          connect(angInc, iAngInc) annotation (Line(
              points={{-60,-50},{-16,-50},{-16,-50},{40,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HDirTil, HShaDirTil)
            annotation (Line(points={{-60,50},{40,50},{40,50}}, color={0,0,127}));
          connect(HSkyDifTil, HShaSkyDifTil) annotation (Line(points={{-60,30},{-17,30},
                  {-17,30},{40,30}}, color={0,0,127}));
          connect(HGroDifTil, HShaGroDifTil) annotation (Line(points={{-60,10},{-14,10},
                  {-14,10},{40,10}}, color={0,0,127}));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})), Documentation(revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>",         info="<html>
<p>Use this model if you want no solar shading to be computed.</p>
</html>"));
        end None;

        model Overhang "Roof overhangs"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
                                                                     final controlled=false);
          parameter Modelica.SIunits.Length hWin(min=0) "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin(min=0) "Window width"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wLeft(min=0)
            "Left overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length wRight(min=0)
            "Right overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length dep(min=0)
            "Overhang depth perpendicular to the wall plane"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length gap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(group="Overhang properties"));
          final parameter Real fraSunDifSky(final min=0,final max=1, final unit="1") = 1-vieAngOverhang/(0.5*Modelica.Constants.pi)
            "Fraction of window area exposed to diffuse sun light";
          Real fraSunDir(final min=0,final max=1, final unit="1")
            "Fraction of window area exposed to direct sun light";
      protected
          final parameter Modelica.SIunits.Area AWin= hWin*wWin "Window area";
          parameter Modelica.SIunits.Length tmpH[4](fixed=false)
            "Height rectangular sections used for superposition";
          final parameter Modelica.SIunits.Angle vieAngOverhang = atan(dep/(gap+hWin/2)) "Viewing angle of overhang";
          Modelica.SIunits.Length w
            "Either wL or wR, depending on the sun relative to the wall azimuth";
          Modelica.SIunits.Length tmpW[4]
            "Width of rectangular sections used for superpositions";
          Modelica.SIunits.Length del_L = wWin/100
            "Fraction of window dimension over which min-max functions are smoothened";
          Modelica.SIunits.Length x1
            "Horizontal distance between window side edge and shadow corner";
          Modelica.SIunits.Length x2[4]
            "Horizontal distance between window side edge and point where shadow line and window lower edge intersects";
          Modelica.SIunits.Length y1
            "Vertical distance between overhang and shadow lower edge";
          Modelica.SIunits.Length y2[4]
            "Window height (vertical distance corresponding to x2)";
          Real shdwTrnglRtio "ratio of y1 and x1";
          Modelica.SIunits.Area area[4]
            "Shaded areas of the sections used in superposition";
          Modelica.SIunits.Area shdArea "Shaded area calculated from equations";
          Modelica.SIunits.Area crShdArea "Final value for shaded area";
          Modelica.SIunits.Area crShdArea1
            "Corrected for the sun behind the surface/wall";
          Modelica.SIunits.Area crShdArea2 "Corrected for the sun below horizon";
          Modelica.SIunits.Angle alt = (Modelica.Constants.pi/2) - angZen;
          Modelica.SIunits.Angle verAzi
            "Angle between projection of sun's rays and normal to vertical surface";
        initial equation
            assert(dep > 0, "The depth of the overhang must be larger than zero.");
        initial algorithm
          for i in 1:4 loop
            tmpH[i] := gap + mod((i - 1), 2)*hWin;
          end for;
        equation
          verAzi = Modelica.Math.acos(cos(angInc)/cos(alt));
          w = Modelica.Media.Air.MoistAir.Utilities.spliceFunction(pos=wLeft, neg=wRight, x=angAzi-azi, deltax=0.005);
          tmpW = {w+wWin,w,w,w+wWin};
          y1*Modelica.Math.cos(verAzi) = dep*Modelica.Math.tan(alt);
          x1 = dep*Modelica.Math.tan(verAzi);
          shdwTrnglRtio*x1 = y1;
          for i in 1:4 loop
            y2[i] = tmpH[i];
            x2[i]*y1 = x1*tmpH[i];
            area[i] = IDEAS.Utilities.Math.Functions.smoothMin(x1=y1,x2=y2[i],deltaX=del_L)*tmpW[i]
              -(IDEAS.Utilities.Math.Functions.smoothMin(y1,tmpH[i],del_L)*IDEAS.Utilities.Math.Functions.smoothMin(x1=x2[i],x2=y1,deltaX=del_L)/2)
              + IDEAS.Utilities.Math.Functions.smoothMax(x1=shdwTrnglRtio*(IDEAS.Utilities.Math.Functions.smoothMin(x1=x1,x2=x2[i],deltaX=del_L) - tmpW[i]),x2=0,deltaX=del_L)*IDEAS.Utilities.Math.Functions.smoothMax(x1=(IDEAS.Utilities.Math.Functions.smoothMin(x1=x1,x2=x2[i],deltaX=del_L) - tmpW[i]),x2=0,deltaX=del_L)/2;
          end for;
          shdArea = area[4] + area[3] - area[2] - area[1];
          // correction case: Sun not in front of the wall
          crShdArea1 = Modelica.Media.Air.MoistAir.Utilities.spliceFunction(pos=shdArea,neg=AWin,x=(Modelica.Constants.pi/2)-verAzi,deltax=0.01);
          // correction case: Sun not above horizon
          crShdArea2 = Modelica.Media.Air.MoistAir.Utilities.spliceFunction(pos=shdArea,neg=AWin,x=alt,deltax=0.01);
          crShdArea=IDEAS.Utilities.Math.Functions.smoothMax(x1=crShdArea1,x2=crShdArea2,deltaX=0.01);
          fraSunDir = IDEAS.Utilities.Math.Functions.smoothMin( x1=IDEAS.Utilities.Math.Functions.smoothMax(x1=1-crShdArea/AWin,x2=0,deltaX=0.01),x2=1.0,deltaX=0.01);
          HShaDirTil = fraSunDir*HDirTil;
          HShaSkyDifTil=fraSunDifSky*HSkyDifTil;
          connect(angInc, iAngInc) annotation (Line(
              points={{-60,-50},{-14,-50},{-14,-50},{40,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(HGroDifTil, HShaGroDifTil) annotation (Line(points={{-60,10},{-14,10},
                  {-14,10},{40,10}}, color={0,0,127}));
          annotation (                   Documentation(info="<html>
<p>
Shading model of an overhang above a window where
hWin is the window height,
wWin is the window width,
gap is the vertical distance between the window upper edge and the overhang,
dep is the horizontal distance between the window glazing and the overhang
and wLeft and wRight are respectively the horizontal overhang widths.
</p>
<p><img alt=\"illustration\" src=\"modelica://IDEAS/Resources/Images/Buildings/Components/Shading/Overhang.png\"/></p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Added computation of diffuse solar shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
        end Overhang;

        model OverhangAndHorizontalFins "Roof overhang and horizontal fins"
          parameter Modelica.SIunits.Length hWin(min=0) "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin(min=0) "Window width"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wLeft(min=0)
            "Left overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length wRight(min=0)
            "Right overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length dep(min=0)
            "Overhang depth perpendicular to the wall plane"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length gap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length s(min=0)
            "Vertical spacing between fins"
            annotation(Dialog(group="Horizontal fin properties"));
          parameter Modelica.SIunits.Length w(min=0)
            "Fin width"
            annotation(Dialog(group="Horizontal fin properties"));
          parameter Modelica.SIunits.Length t(min=0)
            "Fin thickness"
            annotation(Dialog(group="Horizontal fin properties"));
          parameter Boolean use_betaInput = false
            "=true, to use input for fin inclination angle"
            annotation(Evaluate=true,Dialog(group="Horizontal fin properties"));
          parameter Modelica.SIunits.Angle beta(min=0)=0
            "Fin inclination angle: 0 for horizontal inclination, see documentation"
            annotation(Dialog(enable=not use_betaInput,group="Horizontal fin properties"));
          extends IDEAS.Buildings.Components.Shading.Interfaces.DoubleShading(
              redeclare HorizontalFins stateShading1(
                azi=azi,
              s=s,
              w=w,
              t=t,
              use_betaInput=use_betaInput,
              beta=beta),
              redeclare IDEAS.Buildings.Components.Shading.Overhang stateShading2(
                azi=azi,
                hWin=hWin,
                wWin=wWin,
                wLeft=wLeft,
                wRight=wRight,
                dep=dep,
                gap=gap));
        initial equation
            assert(dep > 0, "The depth of the overhang must be larger than zero, if this is not the case: just use Shading.Screen.");
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),  Documentation(info="<html>
<p>
Shading model for a combination of overhang and horizontal fins.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 23 2018, by Filip Jorissenr:<br/>
First implementation.
</li>
</ul>
</html>"));
        end OverhangAndHorizontalFins;

        model OverhangAndScreen "Roof overhangs and screen shading"
          parameter Modelica.SIunits.Length hWin(min=0) "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin(min=0) "Window width"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wLeft(min=0)
            "Left overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length wRight(min=0)
            "Right overhang width measured from the window corner"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length dep(min=0)
            "Overhang depth perpendicular to the wall plane"
            annotation(Dialog(group="Overhang properties"));
          parameter Modelica.SIunits.Length gap(min=0)
            "Distance between window upper edge and overhang lower edge"
            annotation(Dialog(group="Overhang properties"));
          parameter Real shaCorr=0.24 "Shortwave transmittance of shortwave radiation";
          extends IDEAS.Buildings.Components.Shading.Interfaces.DoubleShading(
              redeclare IDEAS.Buildings.Components.Shading.Screen stateShading1(
                azi=azi,
                shaCorr=shaCorr),
              redeclare IDEAS.Buildings.Components.Shading.Overhang stateShading2(
                azi=azi,
                hWin=hWin,
                wWin=wWin,
                wLeft=wLeft,
                wRight=wRight,
                dep=dep,
                gap=gap));
        initial equation
            assert(dep > 0, "The depth of the overhang must be larger than zero, if this is not the case: just use Shading.Screen.");
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),  Documentation(info="<html>
<p>This model describes the transient behaviour of solar irradiance on a window below a non-fixed horizontal or vertical overhang combined with a controllable screen.</p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 2015, by Filip Jorissenr:<br/>
Now extending from IDEAS.Buildings.Components.Interfaces.DoubleShading.
</li>
<li>
December 2014, by Filip Jorissenr:<br/>
First implementation.
</li>
</ul>
</html>"));
        end OverhangAndScreen;

        model Screen "Controllable exterior screen"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
                                                                     final controlled=true);

          parameter Real shaCorr=0.24 "Shortwave transmittance of shortwave radiation";

      protected
          Modelica.Blocks.Nonlinear.Limiter limiter(
            uMax=1,
            uMin=0,
            limitsAtInit=true);

        equation
          HShaDirTil = HDirTil*(1 - limiter.y);
          HShaSkyDifTil = HSkyDifTil*(1 - limiter.y) + HSkyDifTil*limiter.y*shaCorr + HDirTil*limiter.y*shaCorr;
          HShaGroDifTil = HGroDifTil*(1 - limiter.y) + HGroDifTil*limiter.y*shaCorr;

          connect(limiter.u, Ctrl);
          connect(angInc, iAngInc) annotation (Line(points={{-60,-50},{-14,-50},{-14,
                  -50},{40,-50}}, color={0,0,127}));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-50,-100},{50,100}})),
            Documentation(info="<html>
<p>
Shading model of a controllable screen. 
The transmitted direct solar irradiance varies linearly between [0, 1] with the control input. 
A fraction <code>shaCorr</code> is converted into diffuse light that enters the building.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
        end Screen;

        model Shading
          "Model that allows to select any shading option based on record"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(controlled=shaPro.controlled);
          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaPro
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading properties"
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
      protected
          IDEAS.Buildings.Components.Shading.Box box(
            azi=azi,
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            wLeft=shaPro.wLeft,
            wRight=shaPro.wRight,
            ovDep=shaPro.ovDep,
            ovGap=shaPro.ovGap,
            hFin=shaPro.hFin,
            finDep=shaPro.finDep,
            finGap=shaPro.finGap) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box
            "Box shading model"                                                           annotation (Placement(transformation(extent={{-16,80},{-6,100}})));
          IDEAS.Buildings.Components.Shading.BuildingShade buildingShade(
            L=shaPro.L,
            dh=shaPro.dh,
            hWin=shaPro.hWin,
            azi=azi) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.BuildingShade
            "Building shade model"
            annotation (Placement(transformation(extent={{-16,60},{-6,80}})));
          IDEAS.Buildings.Components.Shading.Overhang overhang(
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            wLeft=shaPro.wLeft,
            wRight=shaPro.wRight,
            dep=shaPro.ovDep,
            gap=shaPro.ovGap,
            azi=azi) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Overhang
            "Overhang model"
            annotation (Placement(transformation(extent={{-16,40},{-6,60}})));
          IDEAS.Buildings.Components.Shading.OverhangAndScreen overhangAndScreen(
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            wLeft=shaPro.wLeft,
            wRight=shaPro.wRight,
            dep=shaPro.ovDep,
            gap=shaPro.ovGap,
            shaCorr=shaPro.shaCorr,
            azi=azi) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen
            "Overhang and screen model"
            annotation (Placement(transformation(extent={{-16,20},{-6,40}})));
          IDEAS.Buildings.Components.Shading.Screen screen(
            azi=azi,
            shaCorr=shaPro.shaCorr) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Screen
            "Screen model"                                 annotation (Placement(transformation(extent={{-16,0},{-6,20}})));
          IDEAS.Buildings.Components.Shading.SideFins sideFins(
            azi=azi,
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            hFin=shaPro.hFin,
            dep=shaPro.finDep,
            gap=shaPro.finGap) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.SideFins
            "Side fin model"
            annotation (Placement(transformation(extent={{-16,-20},{-6,0}})));
          IDEAS.Buildings.Components.Shading.None none(azi=azi) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.None
            "No shading model"
            annotation (Placement(transformation(extent={{-16,-40},{-6,-20}})));
          IDEAS.Buildings.Components.Shading.BoxAndScreen boxAndScreen(
            azi=azi,
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            wLeft=shaPro.wLeft,
            wRight=shaPro.wRight,
            ovDep=shaPro.ovDep,
            ovGap=shaPro.ovGap,
            hFin=shaPro.hFin,
            finDep=shaPro.finDep,
            finGap=shaPro.finGap,
            shaCorr=shaPro.shaCorr) if shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.BoxAndScreen "Box and screen model"
                annotation (Placement(transformation(extent={{-16,-62},{-6,-42}})));
          IDEAS.Buildings.Components.Shading.HorizontalFins horizontalFins(
            azi=azi,
            s=shaPro.s,
            w=shaPro.w,
            t=shaPro.t,
            beta = shaPro.beta,
            use_betaInput=shaPro.use_betaInput) if shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins "Horizontal fins model"
            annotation (Placement(transformation(extent={{-16,100},{-6,120}})));
          IDEAS.Buildings.Components.Shading.OverhangAndHorizontalFins overhangAndHorizontalFins(
            s=shaPro.s,
            w=shaPro.w,
            t=shaPro.t,
            beta = shaPro.beta,
            use_betaInput=shaPro.use_betaInput,
            hWin=shaPro.hWin,
            wWin=shaPro.wWin,
            wLeft=shaPro.wLeft,
            wRight=shaPro.wRight,
            dep=shaPro.ovDep,
            gap=shaPro.ovGap,
            azi=azi) if
            shaPro.shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins
            "Overhang and horizontal fins model"
            annotation (Placement(transformation(extent={{-16,120},{-6,140}})));
        equation
          connect(screen.Ctrl, Ctrl) annotation (Line(
              points={{-11,0},{-10,0},{-10,-110}},
              color={0,0,127},
              visible=false));
          connect(Ctrl, overhangAndScreen.Ctrl) annotation (Line(
              points={{-10,-110},{-10,20},{-11,20}},
              color={0,0,127},
              visible=false));
          connect(box.HDirTil, HDirTil)
            annotation (Line(points={{-16,96},{-60,96},{-60,50}}, color={0,0,127}));
          connect(buildingShade.HDirTil, HDirTil)
            annotation (Line(points={{-16,76},{-60,76},{-60,50}}, color={0,0,127}));
          connect(overhang.HDirTil, HDirTil)
            annotation (Line(points={{-16,56},{-60,56},{-60,50}}, color={0,0,127}));
          connect(overhangAndScreen.HDirTil, HDirTil)
            annotation (Line(points={{-16,36},{-60,36},{-60,50}}, color={0,0,127}));
          connect(screen.HDirTil, HDirTil)
            annotation (Line(points={{-16,16},{-60,16},{-60,50}}, color={0,0,127}));
          connect(sideFins.HDirTil, HDirTil)
            annotation (Line(points={{-16,-4},{-60,-4},{-60,50}}, color={0,0,127}));
          connect(box.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,94},{-60,94},{-60,30}}, color={0,0,127}));
          connect(buildingShade.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,74},{-60,74},{-60,30}}, color={0,0,127}));
          connect(overhang.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,54},{-60,54},{-60,30}}, color={0,0,127}));
          connect(overhangAndScreen.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,34},{-60,34},{-60,30}}, color={0,0,127}));
          connect(screen.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,14},{-60,14},{-60,30}}, color={0,0,127}));
          connect(sideFins.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,-6},{-60,-6},{-60,30}}, color={0,0,127}));
          connect(box.angInc, angInc)
            annotation (Line(points={{-16,86},{-60,86},{-60,-50}}, color={0,0,127}));
          connect(buildingShade.angInc, angInc)
            annotation (Line(points={{-16,66},{-60,66},{-60,-50}}, color={0,0,127}));
          connect(overhang.angInc, angInc)
            annotation (Line(points={{-16,46},{-60,46},{-60,-50}}, color={0,0,127}));
          connect(overhangAndScreen.angInc, angInc)
            annotation (Line(points={{-16,26},{-60,26},{-60,-50}}, color={0,0,127}));
          connect(screen.angInc, angInc)
            annotation (Line(points={{-16,6},{-60,6},{-60,-50}}, color={0,0,127}));
          connect(sideFins.angInc, angInc)
            annotation (Line(points={{-16,-14},{-60,-14},{-60,-50}}, color={0,0,127}));
          connect(box.angZen, angZen) annotation (Line(points={{-16,84},{-24,84},{-60,84},
                  {-60,-70}},          color={0,0,127}));
          connect(buildingShade.angZen, angZen) annotation (Line(points={{-16,64},{-24,64},
                  {-60,64},{-60,-70}},          color={0,0,127}));
          connect(overhang.angZen, angZen) annotation (Line(points={{-16,44},{-26,44},{-60,
                  44},{-60,-70}},          color={0,0,127}));
          connect(overhangAndScreen.angZen, angZen)
            annotation (Line(points={{-16,24},{-60,24},{-60,-70}}, color={0,0,127}));
          connect(screen.angZen, angAzi) annotation (Line(points={{-16,4},{-24,4},{-60,4},
                  {-60,-90}},         color={0,0,127}));
          connect(sideFins.angZen, angZen) annotation (Line(points={{-16,-16},{-24,-16},
                  {-60,-16},{-60,-70}},           color={0,0,127}));
          connect(box.angAzi, angAzi)
            annotation (Line(points={{-16,82},{-60,82},{-60,-90}}, color={0,0,127}));
          connect(buildingShade.angAzi, angAzi)
            annotation (Line(points={{-16,62},{-60,62},{-60,-90}}, color={0,0,127}));
          connect(overhang.angAzi, angAzi)
            annotation (Line(points={{-16,42},{-60,42},{-60,-90}}, color={0,0,127}));
          connect(overhangAndScreen.angAzi, angAzi)
            annotation (Line(points={{-16,22},{-60,22},{-60,-90}}, color={0,0,127}));
          connect(screen.angAzi, angAzi)
            annotation (Line(points={{-16,2},{-60,2},{-60,-90}}, color={0,0,127}));
          connect(sideFins.angAzi, angAzi)
            annotation (Line(points={{-16,-18},{-60,-18},{-60,-90}}, color={0,0,127}));
          connect(box.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,96},{40,96},{40,50}}, color={0,0,127}));
          connect(buildingShade.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,76},{40,76},{40,50}}, color={0,0,127}));
          connect(overhang.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,56},{40,56},{40,50}}, color={0,0,127}));
          connect(overhangAndScreen.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,36},{40,36},{40,50}}, color={0,0,127}));
          connect(screen.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,16},{40,16},{40,50}}, color={0,0,127}));
          connect(sideFins.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,-4},{40,-4},{40,50}}, color={0,0,127}));
          connect(box.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,94},{40,94},{40,30}}, color={0,0,127}));
          connect(buildingShade.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,74},{40,74},{40,30}}, color={0,0,127}));
          connect(overhang.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,54},{40,54},{40,30}}, color={0,0,127}));
          connect(overhangAndScreen.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,34},{40,34},{40,30}}, color={0,0,127}));
          connect(screen.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,14},{40,14},{40,30}}, color={0,0,127}));
          connect(sideFins.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,-6},{40,-6},{40,30}}, color={0,0,127}));
          connect(sideFins.iAngInc, iAngInc)
            annotation (Line(points={{-6,-14},{40,-14},{40,-50}}, color={0,0,127}));
          connect(screen.iAngInc, iAngInc)
            annotation (Line(points={{-6,6},{40,6},{40,-50}}, color={0,0,127}));
          connect(overhangAndScreen.iAngInc, iAngInc)
            annotation (Line(points={{-6,26},{40,26},{40,-50}}, color={0,0,127}));
          connect(overhang.iAngInc, iAngInc)
            annotation (Line(points={{-6,46},{40,46},{40,-50}}, color={0,0,127}));
          connect(buildingShade.iAngInc, iAngInc)
            annotation (Line(points={{-6,66},{40,66},{40,-50}}, color={0,0,127}));
          connect(box.iAngInc, iAngInc)
            annotation (Line(points={{-6,86},{40,86},{40,-50}}, color={0,0,127}));
          connect(none.HDirTil, HDirTil)
            annotation (Line(points={{-16,-24},{-60,-24},{-60,50}}, color={0,0,127}));
          connect(none.HSkyDifTil, HSkyDifTil)
            annotation (Line(points={{-16,-26},{-60,-26},{-60,30}}, color={0,0,127}));
          connect(none.angInc, angInc)
            annotation (Line(points={{-16,-34},{-60,-34},{-60,-50}}, color={0,0,127}));
          connect(none.angAzi, angAzi) annotation (Line(points={{-16,-38},{-24,-38},{-60,
                  -38},{-60,-90}}, color={0,0,127}));
          connect(none.angZen, angZen) annotation (Line(points={{-16,-36},{-28,-36},{-60,
                  -36},{-60,-70}}, color={0,0,127}));
          connect(none.iAngInc, iAngInc)
            annotation (Line(points={{-6,-34},{40,-34},{40,-50}}, color={0,0,127}));
          connect(none.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,-26},{40,-26},{40,30}}, color={0,0,127}));
          connect(none.HShaDirTil, HShaDirTil)
            annotation (Line(points={{-6,-24},{40,-24},{40,50}}, color={0,0,127}));
          connect(boxAndScreen.HDirTil, HDirTil) annotation (Line(points={{-16,-46},{-36,-46},
                  {-36,50},{-60,50}}, color={0,0,127}));
          connect(boxAndScreen.HSkyDifTil, HSkyDifTil) annotation (Line(points={{-16,-48},
                  {-36,-48},{-36,30},{-60,30}},
                                      color={0,0,127}));
          connect(boxAndScreen.angInc, angInc) annotation (Line(points={{-16,-56},{-36,-56},
                  {-36,-50},{-60,-50}}, color={0,0,127}));
          connect(boxAndScreen.angZen, angZen) annotation (Line(points={{-16,-58},{-32,-58},
                  {-32,-70},{-60,-70}}, color={0,0,127}));
          connect(boxAndScreen.angAzi, angAzi) annotation (Line(points={{-16,-60},{-34,-60},
                  {-34,-90},{-60,-90}}, color={0,0,127}));
          connect(boxAndScreen.HShaDirTil, HShaDirTil) annotation (Line(points={{-6,-46},
                  {40,-46},{40,50}},color={0,0,127}));
          connect(boxAndScreen.HShaSkyDifTil, HShaSkyDifTil) annotation (Line(points={{-6,-48},
                  {40,-48},{40,30}},color={0,0,127}));
          connect(boxAndScreen.iAngInc, iAngInc) annotation (Line(points={{-6,-56},{40,-56},
                  {40,-50}},          color={0,0,127}));
          connect(Ctrl, boxAndScreen.Ctrl) annotation (Line(points={{-10,-110},{-10,-62},
                  {-11,-62}}, color={0,0,127}));
          connect(box.HGroDifTil, HGroDifTil)
            annotation (Line(points={{-16,92},{-60,92},{-60,10}}, color={0,0,127}));
          connect(buildingShade.HGroDifTil, HGroDifTil)
            annotation (Line(points={{-16,72},{-60,72},{-60,10}}, color={0,0,127}));
          connect(overhang.HGroDifTil, HGroDifTil) annotation (Line(points={{-16,52},{
                  -22,52},{-60,52},{-60,10}}, color={0,0,127}));
          connect(overhangAndScreen.HGroDifTil, HGroDifTil)
            annotation (Line(points={{-16,32},{-60,32},{-60,10}}, color={0,0,127}));
          connect(screen.HGroDifTil, HGroDifTil)
            annotation (Line(points={{-16,12},{-60,12},{-60,10}}, color={0,0,127}));
          connect(sideFins.HGroDifTil, HGroDifTil) annotation (Line(points={{-16,-8},{
                  -30,-8},{-60,-8},{-60,10}}, color={0,0,127}));
          connect(none.HGroDifTil, HGroDifTil) annotation (Line(points={{-16,-28},{-32,
                  -28},{-60,-28},{-60,10}}, color={0,0,127}));
          connect(boxAndScreen.HGroDifTil, HGroDifTil)
            annotation (Line(points={{-16,-50},{-60,-50},{-60,10}}, color={0,0,127}));
          connect(box.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,92},{40,92},{40,10}}, color={0,0,127}));
          connect(buildingShade.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,72},{40,72},{40,10}}, color={0,0,127}));
          connect(overhang.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,52},{40,52},{40,10}}, color={0,0,127}));
          connect(overhangAndScreen.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,32},{40,32},{40,10}}, color={0,0,127}));
          connect(screen.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,12},{40,12},{40,10}}, color={0,0,127}));
          connect(sideFins.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,-8},{40,-8},{40,10}}, color={0,0,127}));
          connect(none.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,-28},{40,-28},{40,10}}, color={0,0,127}));
          connect(boxAndScreen.HShaGroDifTil, HShaGroDifTil)
            annotation (Line(points={{-6,-50},{40,-50},{40,10}}, color={0,0,127}));
          connect(horizontalFins.Ctrl, Ctrl) annotation (Line(points={{-11,100},{-10,100},
                  {-10,-110}}, color={0,0,127}, visible=false));
          connect(horizontalFins.iAngInc, iAngInc)
            annotation (Line(points={{-6,106},{40,106},{40,-50}}, color={0,0,127}));
          connect(horizontalFins.HShaGroDifTil, HShaGroDifTil) annotation (Line(points={
                  {-6,112},{14,112},{40,112},{40,10}}, color={0,0,127}));
          connect(horizontalFins.HShaSkyDifTil, HShaSkyDifTil)
            annotation (Line(points={{-6,114},{40,114},{40,30}}, color={0,0,127}));
          connect(horizontalFins.HShaDirTil, HShaDirTil) annotation (Line(points={{-6,116},
                  {16,116},{40,116},{40,50}},      color={0,0,127}));
          connect(HDirTil, horizontalFins.HDirTil) annotation (Line(points={{-60,50},{-60,
                  50},{-60,116},{-16,116},{-16,116}}, color={0,0,127}));
          connect(HSkyDifTil, horizontalFins.HSkyDifTil) annotation (Line(points={{-60,30},
                  {-60,30},{-60,114},{-16,114}}, color={0,0,127}));
          connect(HGroDifTil, horizontalFins.HGroDifTil) annotation (Line(points={{-60,10},
                  {-60,10},{-60,112},{-16,112}}, color={0,0,127}));
          connect(angInc, horizontalFins.angInc) annotation (Line(points={{-60,-50},{-60,
                  -50},{-60,106},{-16,106}}, color={0,0,127}));
          connect(horizontalFins.angAzi, angAzi)
            annotation (Line(points={{-16,102},{-60,102},{-60,-90}}, color={0,0,127}));
          connect(horizontalFins.angZen, angZen)
            annotation (Line(points={{-16,104},{-60,104},{-60,-70}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.Ctrl, Ctrl) annotation (Line(points={{-11,120},
                  {-10,120},{-10,-110}},            color={0,0,127}, visible=false));
          connect(overhangAndHorizontalFins.iAngInc, iAngInc)
            annotation (Line(points={{-6,126},{40,126},{40,-50}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HShaGroDifTil, HShaGroDifTil) annotation (
              Line(points={{-6,132},{16,132},{40,132},{40,10}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HShaSkyDifTil, HShaSkyDifTil) annotation (
              Line(points={{-6,134},{18,134},{40,134},{40,30}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HShaDirTil, HShaDirTil) annotation (Line(
                points={{-6,136},{38,136},{40,136},{40,50}},          color={0,0,127}));
          connect(overhangAndHorizontalFins.angAzi, angAzi)
            annotation (Line(points={{-16,122},{-60,122},{-60,-90}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.angInc, angInc) annotation (Line(points={{-16,
                  126},{-34,126},{-60,126},{-60,-50}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HGroDifTil, HGroDifTil) annotation (Line(
                points={{-16,132},{-40,132},{-60,132},{-60,10}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HSkyDifTil, HSkyDifTil) annotation (Line(
                points={{-16,134},{-36,134},{-60,134},{-60,30}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.HDirTil, HDirTil) annotation (Line(points={{
                  -16,136},{-38,136},{-60,136},{-60,50}}, color={0,0,127}));
          connect(overhangAndHorizontalFins.angZen, angZen)
            annotation (Line(points={{-16,124},{-60,124},{-60,-70}}, color={0,0,127}));
          annotation (Documentation(revisions="<html>
<ul>
<li>
Aug 2 2018, by Iago Cupeiro:<br/>
Added missing beta parameter.
</li>
<li>
May 4 2018, by Iago Cupeiro:<br/>
Extended with HorizontalFins and OverhangAndHorizontalFins models.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
</ul>
</html>",         info="<html>
<ul>
<li>
August 22, 2018 by Filip Jorissen:<br/>
Fixed bug in implementation due to missing <code>irr</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/pull/818\">
#818</a>.
</li>
</ul>
</html>"),  Diagram(coordinateSystem(extent={{-100,-100},{100,140}})),
            Icon(coordinateSystem(extent={{-100,-100},{100,140}})));
        end Shading;

        model SideFins "Vertical side fins next to windows"
          extends IDEAS.Buildings.Components.Shading.Interfaces.PartialShading(
                                                                     final controlled=false);
          // Window properties
          parameter Modelica.SIunits.Length hWin
            "Window height"
            annotation(Dialog(group="Window properties"));
          parameter Modelica.SIunits.Length wWin
            "Window width"
            annotation(Dialog(group="Window properties"));
          // Sidefin properties
          parameter Modelica.SIunits.Length hFin
            "Height of side fin above window"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length dep
            "Side fin depth perpendicular to the wall plane"
            annotation(Dialog(group="Side fin properties"));
          parameter Modelica.SIunits.Length gap
            "Vertical distance between side fin and window"
            annotation(Dialog(group="Side fin properties"));
          final parameter Real fraSunDif(final min=0,final max=1, final unit="1") = 1-2*vieAngFin/Modelica.Constants.pi
            "Fraction of window area exposed to diffuse sun light";
          Real fraSunDir(final min=0,final max=1, final unit="1")
            "Fraction of window area exposed to the sun";
      protected
          final parameter Modelica.SIunits.Angle vieAngFin = atan(dep/(gap+wWin/2)) "Viewing angle of overhang";
          final parameter Modelica.SIunits.Area AWin= hWin*wWin "Window area";
          final parameter Modelica.SIunits.Length tmpH[4] = {hFin+hWin,hFin,hFin+hWin,hFin}
            "Height rectangular sections used for superposition";
          final parameter Modelica.SIunits.Length tmpW[4] = {gap+wWin,gap+wWin,gap,gap}
            "Width rectangular sections used for superposition";
          Modelica.SIunits.Length x1[4]
            "Horizontal distance between side fin and point where shadow line and window lower edge intersects";
          Modelica.SIunits.Length x2
            "Horizontal distance between side fin and shadow corner";
          Modelica.SIunits.Length x3[4] "Window width";
          Modelica.SIunits.Length y1[4] "Window height";
          Modelica.SIunits.Length y2
            "Vertical distance between window upper edge and shadow corner";
          Modelica.SIunits.Length y3[4]
            "Vertical distance between window upper edge and point where shadow line and window side edge intersects";
          Modelica.SIunits.Area area[4]
            "Shaded areas of the sections used in superposition";
          Modelica.SIunits.Area shdArea "Shaded area";
          Modelica.SIunits.Area crShdArea "Final value of shaded area";
          Modelica.SIunits.Area crShdArea1
            "Shaded area, corrected for the sun behind the surface/wall";
          Modelica.SIunits.Area crShdArea2
            "Shaded area, corrected for the sun below horizon";
          Modelica.SIunits.Length minX[4];
          Modelica.SIunits.Length minY[4];
          Modelica.SIunits.Length minX2X3[4];
          Modelica.SIunits.Length minY2Y3[4];
          Real deltaL=1e-6 "Small number to avoid division by zero";
          Modelica.SIunits.Angle alt = (Modelica.Constants.pi/2) - angZen;
          Real verAzi;
          Real lambda;
        initial equation
            assert(dep > 0, "The depth of the sidefins must be larger than zero.");
        equation
          lambda = tan(alt) / cos(verAzi);
          verAzi = Modelica.Math.acos(cos(angInc)/cos(alt));
          y2*Modelica.Math.cos(verAzi) = dep*Modelica.Math.tan(alt);
          x2 = dep*Modelica.Math.tan(verAzi);
          for i in 1:4 loop
            x1[i] = tmpH[i]/lambda;
            x3[i] = tmpW[i];
            y1[i] = tmpH[i];
            y3[i] = tmpW[i]*lambda;
            minX2X3[i] = IDEAS.Utilities.Math.Functions.smoothMin(x1=x2,x2=x3[i],deltaX=deltaL);
            minX[i] = IDEAS.Utilities.Math.Functions.smoothMin(x1=x1[i],x2=minX2X3[i],deltaX=deltaL);
            minY2Y3[i] = IDEAS.Utilities.Math.Functions.smoothMin(x1=y2,x2=y3[i],deltaX=deltaL);
            minY[i] = IDEAS.Utilities.Math.Functions.smoothMin(x1=y1[i],x2=minY2Y3[i],deltaX=deltaL);
            area[i] = tmpH[i]*minX[i] - minX[i]*minY[i]/2;
          end for;
          shdArea = area[4] - area[3] - area[2] + area[1];
          // correction case: Sun not in front of the wall
          crShdArea1 = Modelica.Media.Air.MoistAir.Utilities.spliceFunction(pos=shdArea,neg=AWin,x=(Modelica.Constants.pi/2)-verAzi,deltax=0.01);
          // correction case: Sun not above horizon
          crShdArea2 = Modelica.Media.Air.MoistAir.Utilities.spliceFunction(pos=shdArea,neg=AWin,x=alt,deltax=0.01);
          crShdArea=IDEAS.Utilities.Math.Functions.smoothMax(x1=crShdArea1,x2=crShdArea2,deltaX=0.01);
          fraSunDir = IDEAS.Utilities.Math.Functions.smoothMin( x1=IDEAS.Utilities.Math.Functions.smoothMax(x1=1-crShdArea/AWin,x2=0,deltaX=0.01),x2=1.0,deltaX=0.01);
          HShaDirTil = HDirTil * fraSunDir;
          HShaSkyDifTil = fraSunDif * HSkyDifTil;
          HShaGroDifTil = fraSunDif * HGroDifTil;
          connect(angInc, iAngInc) annotation (Line(
              points={{-60,-50},{-14,-50},{-14,-50},{40,-50}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (                   Documentation(info="<html>
<p>
Shading model of side fins (or similar objects) 
next to a window where
hWin is the window height,
wWin is the window width,
gap equals the horizontal distances between the window edges and the side fins,
dep fin length in the direction normal to the window.
</p>
<h4>Assumption and limitations</h4>
<p>
This model computes a simplified view factor of the side fins.
The view factor determines how much diffuse light 
is blocked by the fins.
We assume that the fins do not reflect light
towards the window.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Added computation of diffuse solar shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
        end SideFins;

        package Interfaces
        extends Modelica.Icons.InterfacesPackage;

          model DoubleShading "Two shading components in series"
            extends PartialShading(
              final controlled=stateShading1.controlled or
                  stateShading2.controlled);
            replaceable PartialShading stateShading1 constrainedby
            PartialShading(                                                       azi=azi)
              "First shading device"
              annotation (Placement(transformation(extent={{-28,-18},{-18,2}})));
            replaceable PartialShading stateShading2 constrainedby
            PartialShading(                                                       azi=azi)
              "Second shading device"
              annotation (Placement(transformation(extent={{-4,-18},{6,2}})));
          equation
            connect(stateShading1.angInc, angInc) annotation (Line(points={{-28,-12},{-34,
                    -12},{-34,-50},{-60,-50}}, color={0,0,127}));
            connect(stateShading1.angAzi, angAzi) annotation (Line(points={{-28,-16},{-30,
                    -16},{-30,-90},{-60,-90}}, color={0,0,127}));
            connect(stateShading1.angZen, angZen) annotation (Line(points={{-28,-14},{-32,
                    -14},{-32,-16},{-32,-70},{-60,-70}}, color={0,0,127}));
            connect(Ctrl, stateShading1.Ctrl) annotation (Line(points={{-10,-110},{-10,-80},
                    {-23,-80},{-23,-18}}, color={0,0,127}));
            connect(Ctrl,stateShading2. Ctrl) annotation (Line(points={{-10,-110},{-10,-80},
                    {1,-80},{1,-18}}, color={0,0,127}));
            connect(stateShading1.angAzi, stateShading2.angAzi)
              annotation (Line(points={{-28,-16},{-4,-16}}, color={0,0,127}));
            connect(stateShading1.angZen, stateShading2.angZen)
              annotation (Line(points={{-28,-14},{-16,-14},{-4,-14}}, color={0,0,127}));
            connect(stateShading1.iAngInc, stateShading2.angInc)
              annotation (Line(points={{-18,-12},{-11,-12},{-4,-12}}, color={0,0,127}));
            connect(stateShading2.iAngInc, iAngInc) annotation (Line(points={{6,-12},{14,-12},
                    {14,-50},{40,-50}}, color={0,0,127}));
            connect(HSkyDifTil, stateShading1.HSkyDifTil) annotation (Line(points={{-60,
                    30},{-34,30},{-34,-4},{-28,-4}}, color={0,0,127}));
            connect(HGroDifTil, stateShading1.HGroDifTil) annotation (Line(points={{-60,
                    10},{-36,10},{-36,-6},{-28,-6}}, color={0,0,127}));
            connect(stateShading2.HShaGroDifTil, HShaGroDifTil) annotation (Line(points={
                    {6,-6},{16,-6},{16,10},{40,10}}, color={0,0,127}));
            connect(stateShading2.HShaDirTil, HShaDirTil) annotation (Line(points={{6,-2},
                    {12,-2},{12,0},{12,52},{12,50},{40,50}}, color={0,0,127}));
            connect(stateShading2.HShaSkyDifTil, HShaSkyDifTil) annotation (Line(points={
                    {6,-4},{14,-4},{14,30},{40,30}}, color={0,0,127}));
            connect(stateShading1.HShaDirTil, stateShading2.HDirTil)
              annotation (Line(points={{-18,-2},{-11,-2},{-4,-2}}, color={0,0,127}));
            connect(stateShading1.HShaSkyDifTil, stateShading2.HSkyDifTil)
              annotation (Line(points={{-18,-4},{-11,-4},{-4,-4}}, color={0,0,127}));
            connect(stateShading1.HShaGroDifTil, stateShading2.HGroDifTil)
              annotation (Line(points={{-18,-6},{-12,-6},{-4,-6}}, color={0,0,127}));
            connect(HDirTil, stateShading1.HDirTil) annotation (Line(points={{-60,50},{
                    -32,50},{-32,-2},{-28,-2}}, color={0,0,127}));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}})), Documentation(revisions="<html>
<ul>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
<li>
December 2014, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>This model can be extended or used if two shading models need to be combined.</p>
</html>"));
          end DoubleShading;

          partial model PartialShading "Window shading partial"
            parameter Boolean controlled=true
              "if true, shading has a control input"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.Angle azi
              "Window azimuth angle"
              annotation(Dialog(group="Window properties"));
            Modelica.Blocks.Interfaces.RealInput HDirTil
              "Direct solar illuminance on surface" annotation (Placement(
                  transformation(extent={{-80,30},{-40,70}}), iconTransformation(extent={
                      {-60,50},{-40,70}})));
            Modelica.Blocks.Interfaces.RealInput HSkyDifTil
              "Diffuse sky solar illuminance on tilted surface" annotation (Placement(
                  transformation(extent={{-80,10},{-40,50}}),  iconTransformation(extent={{-60,30},
                      {-40,50}})));
            Modelica.Blocks.Interfaces.RealInput HGroDifTil
              "Diffuse ground solar illuminance on tilted surface" annotation (Placement(
                  transformation(extent={{-80,-10},{-40,30}}), iconTransformation(extent={{-60,10},
                      {-40,30}})));
            Modelica.Blocks.Interfaces.RealInput angZen
              "Angle of incidence" annotation (
                Placement(transformation(extent={{-80,-90},{-40,-50}}),
                  iconTransformation(extent={{-60,-70},{-40,-50}})));
            Modelica.Blocks.Interfaces.RealOutput HShaDirTil
              "Shaded direct solar illuminance on surface" annotation (Placement(
                  transformation(extent={{20,30},{60,70}}), iconTransformation(extent={{
                      40,50},{60,70}})));
            Modelica.Blocks.Interfaces.RealOutput HShaSkyDifTil
              "Shaded diffuse sky solar illuminance on tilted surface" annotation (Placement(
                  transformation(extent={{20,10},{60,50}}),  iconTransformation(extent={{40,30},
                      {60,50}})));
            Modelica.Blocks.Interfaces.RealOutput HShaGroDifTil
              "Shaded diffuse ground solar illuminance on tilted surface" annotation (Placement(
                  transformation(extent={{20,-10},{60,30}}), iconTransformation(extent={{40,10},
                      {60,30}})));
            Modelica.Blocks.Interfaces.RealOutput iAngInc
              "Angle of incidence after transmittance through (possible) shading"
              annotation (Placement(transformation(extent={{20,-70},{60,-30}}),
                  iconTransformation(extent={{40,-50},{60,-30}})));
            Modelica.Blocks.Interfaces.RealInput angInc "Inclination angle" annotation (
                Placement(transformation(extent={{-80,-70},{-40,-30}}),
                  iconTransformation(extent={{-60,-50},{-40,-30}})));
            Modelica.Blocks.Interfaces.RealInput angAzi "Azimuth angle" annotation (
                Placement(transformation(extent={{-80,-110},{-40,-70}}),
                  iconTransformation(extent={{-60,-90},{-40,-70}})));
            Modelica.Blocks.Interfaces.RealInput Ctrl(min=0, max=1) if controlled
              "Control signal between 0 and 1, i.e. 1 is fully closed" annotation (
                Placement(transformation(
                  extent={{20,-20},{-20,20}},
                  rotation=-90,
                  origin={-10,-110}), iconTransformation(
                  extent={{10,-10},{-10,10}},
                  rotation=-90,
                  origin={0,-100})));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,
                      -100},{100,100}})),           Icon(coordinateSystem(
                    preserveAspectRatio=true, extent={{-50,-100},{50,100}}), graphics={
                  Polygon(
                    points={{-50,80},{0,60},{4,60},{4,-20},{-50,0},{-50,80}},
                    smooth=Smooth.None,
                    pattern=LinePattern.None,
                    fillColor={255,255,170},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Polygon(
                    points={{4,40},{50,20},{50,-32},{20,-20},{4,-20},{4,40}},
                    smooth=Smooth.None,
                    pattern=LinePattern.None,
                    fillColor={179,179,179},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0}),
                  Line(
                    points={{0,60},{20,60},{20,80},{50,80}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-20},{20,-20},{20,-70},{20,-70},{50,-70}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{0,60},{0,66},{0,100},{50,100}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-20},{0,-90},{50,-90}},
                    color={95,95,95},
                    smooth=Smooth.None),
                  Line(
                    points={{4,60},{4,-20}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None)}),
              Documentation(revisions="<html>
<ul>
<li>
July 18, 2016 by Filip Jorissen:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>",           info="<html>
<p>Partial model for shading computations.</p>
</html>"));
          end PartialShading;

          type ShadingType = enumeration(
            None "None",
            BuildingShade "Buildings shade",
            Overhang "Overhang",
            SideFins "Side fins",
            Box "Box: overhang and side fins",
            Screen "Screen",
            OverhangAndScreen "Overhang and screen",
            BoxAndScreen
                    "Box and screen",
            HorizontalFins
                    "Horizontal fins",
            OverhangAndHorizontalFins
                    "Overhang and horizontal fins",
            Shading "Shading") annotation (Documentation(revisions="<html>
<ul>
<li>
May 4 2018, by Iago Cupeiro:<br/>
Extended with HorizontalFins and OverhangAndHorizontalFins models.
</li>
</ul>
</html>"));

          record ShadingProperties
            "Default: no shading"
            extends Modelica.Icons.Record;
            parameter Boolean controlled = false
              "if true, shading has a control input"
              annotation(Evaluate=true,
                         Dialog(enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Screen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.BoxAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingType shaType=
                IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.None
              "Window shading type";
            parameter Modelica.SIunits.Length hWin(min=0, start=0)=0.01 "Window height"
              annotation(Dialog(group="Window properties"));
            parameter Modelica.SIunits.Length wWin(min=0, start=0)=0.01 "Window width"
              annotation(Dialog(group="Window properties"));
            parameter Modelica.SIunits.Length wLeft(min=0, start=0)=0.01
              "Left overhang width measured from the window corner"
              annotation(Dialog(group="Overhang properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Overhang or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length wRight(min=0, start=0)=0.01
              "Right overhang width measured from the window corner"
              annotation(Dialog(group="Overhang properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Overhang or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length ovDep(min=0, start=0)=0.01
              "Overhang depth perpendicular to the wall plane"
              annotation(Dialog(group="Overhang properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Overhang or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length ovGap(min=0, start=0)=0.01
              "Distance between window upper edge and overhang lower edge"
              annotation(Dialog(group="Overhang properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Overhang or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length hFin(min=0, start=0)=0.01
              "Height of side fin above window"
              annotation(Dialog(group="Side fin properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.SideFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box)));
            parameter Modelica.SIunits.Length finDep(min=0, start=0)=0.01
              "Side fin depth perpendicular to the wall plane"
              annotation(Dialog(group="Side fin properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.SideFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box)));
            parameter Modelica.SIunits.Length finGap(min=0, start=0)=0.01
              "Vertical distance between side fin and window"
              annotation(Dialog(group="Side fin properties",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.SideFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Box)));
            parameter Modelica.SIunits.Length L(min=0, start=0)=0.01
              "Horizontal distance to object"
              annotation(Dialog(group="Building shade",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.BuildingShade)));
            parameter Modelica.SIunits.Length dh(min=0, start=0)=0.01
              "Height difference between top of object and top of window"
              annotation(Dialog(group="Building shade",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.BuildingShade)));
            parameter Real shaCorr(min=0)=0.24
              "Shortwave transmittance of shortwave radiation"
              annotation(Dialog(group="Screen",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.Screen or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndScreen)));
            parameter Modelica.SIunits.Length s(min=0)=0.1
              "Vertical spacing between fins"
              annotation(Dialog(group="Horizontal fins",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length w(min=0)=0.1
              "Fin width"
                  annotation(Dialog(group="Horizontal fins",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Modelica.SIunits.Length t(min=0)=0.01
              "Fin thickness"
                  annotation(Dialog(group="Horizontal fins",
                                enable= (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            parameter Boolean use_betaInput = controlled
              "=true, to use input for fin inclination angle"
                  annotation(Dialog(group="Horizontal fins",
                                Evaluate = true,
                                enable= false));
            parameter Modelica.SIunits.Angle beta(min=0) = 0.01
              "Fin inclination angle: 0 for horizontal inclination, see documentation"
              annotation(Dialog(group="Horizontal fins",
                                enable= not controlled and (shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.HorizontalFins or
                                         shaType==IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins)));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
Aug 2 2018, by Iago Cupeiro:<br/>
Corrected initialization bug in assert
</li>
<li>
May 4 2018, by Iago Cupeiro:<br/>
Extended with HorizontalFins and OverhangAndHorizontalFins models.
</li>
</ul>
</html>"));
          end ShadingProperties;
        end Interfaces;
      end Shading;

      package ThermalBridges "Thermal bridge models"
      extends Modelica.Icons.Package;

        record None "No thermal bridge included"
          extends
          IDEAS.Buildings.Components.ThermalBridges.BaseClasses.ThermalBridge(
            final G=0,
            final present=false);
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)));
        end None;

        package BaseClasses
        extends Modelica.Icons.BasesPackage;

          record ThermalBridge "Record data for thermal bridges"
            parameter Modelica.SIunits.ThermalConductance G "Effective thermal loss";
            parameter Boolean present = true
              annotation(Evaluate=true);
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)));
          end ThermalBridge;
        end BaseClasses;
      end ThermalBridges;

      package ZoneAirModels "Package containing zone air models"

        model WellMixedAir "Zone air model assuming perfectly mixed air"
          // We assume an initial CO2 concentration of 400 ppm, if the medium contains CO2
          extends
          IDEAS.Buildings.Components.ZoneAirModels.BaseClasses.PartialAirModel(
            C_start=400*s*MMFraction/1e6,
            final nSeg=1,
            mSenFac(min=0)=5);

            parameter StateSelect stateSelectTVol = if sim.linearise then StateSelect.prefer else StateSelect.default
              "Set to .prefer to use temperature as a state in mixing volume";


      protected
          final parameter Modelica.SIunits.MolarMass MM=
            Modelica.Media.IdealGases.Common.SingleGasesData.CO2.MM
            "Molar mass of the trace substance";
          final parameter Modelica.SIunits.MolarMass MMBul=Medium.molarMass(
            Medium.setState_phX(
              p=Medium.p_default,
              h=Medium.h_default,
              X=Medium.X_default)) "Molar mass of bulk medium";
          final parameter Real MMFraction=MM/MMBul
            "Molar mass of CO2 divided by the molar mass of the medium";

          constant Modelica.SIunits.SpecificEnthalpy lambdaWater = IDEAS.Media.Air.enthalpyOfCondensingGas(T=273.15+35)
            "Latent heat of evaporation water";
          constant Boolean hasVap = Medium.nXi>0
            "Medium has water vapour";
          constant Boolean hasPpm = sum(s)>0
            "Medium has trace substance";
          MixingVolumeNominal       vol(
            redeclare package Medium = Medium,
            energyDynamics=energyDynamics,
            massDynamics=massDynamics,
            p_start=p_start,
            T_start=T_start,
            X_start=X_start,
            C_start=C_start,
            C_nominal=C_nominal,
            allowFlowReversal=allowFlowReversal,
            V=Vtot,
            mSenFac=mSenFac,
            U_nominal=mSenFac*10*Vtot*1.2*1000,
            use_C_flow=true,
            nPorts=(2 + (if hasVap then 1 else 0) + (if hasPpm then 1 else 0))+nPorts,
            m_flow_nominal=0.1,
            T(stateSelect=stateSelectTVol))  annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=180,
                origin={0,0})));

          Modelica.Thermal.HeatTransfer.Sensors.TemperatureSensor senTem
            annotation (Placement(transformation(extent={{10,-50},{30,-70}})));
          Modelica.Blocks.Math.Gain gaiLat(k=lambdaWater)
            "Gain for computing latent heat flow rate based on water vapor mass flow rate"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={64,58})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow preHeaFloLat(final
              alpha=0)
            "Prescribed heat flow rate for latent heat gain corresponding to water vapor mass flow rate"
            annotation (Placement(transformation(extent={{-10,-10},{10,10}},
                rotation=270,
                origin={64,22})));
      protected
          constant Real s[:]= {
            if ( Modelica.Utilities.Strings.isEqual(string1=Medium.extraPropertiesNames[i],
                                                    string2="CO2",
                                                    caseSensitive=false))
            then 1 else 0 for i in 1:Medium.nC}
            "Vector with zero everywhere except where species is";

          IDEAS.Fluid.Sensors.RelativeHumidity senRelHum(
            redeclare package Medium = Medium) if hasVap
            "Relative humidity of the zone air"
            annotation (Placement(transformation(extent={{30,-30},{50,-50}})));
            model MixingVolumeNominal
              "To avoid warning when modifying parameters of protected submodel dynBal of MixingVolumeMoistAir"
              parameter Modelica.SIunits.Energy U_nominal = mSenFac*10*m_nominal*1000 "Nominal value of internal energy";
              parameter Modelica.SIunits.Mass m_nominal = V*1.2 "Nominal value of internal energy";
              parameter Real[Medium.nXi] mXi_nominal = m_nominal*Medium.X_default[1:Medium.nXi] "Nominal value of internal energy";
              parameter Real[Medium.nC] mC_nominal = m_nominal*0.0015*ones(Medium.nC) "Nominal value of internal energy";
              extends IDEAS.Fluid.MixingVolumes.MixingVolumeMoistAir(
                mSenFac(min=0),
                dynBal(
                  U(nominal=U_nominal),
                  mC(nominal=mC_nominal),
                  mXi(nominal=mXi_nominal),
                  m(nominal=m_nominal)));
            end MixingVolumeNominal;
          IDEAS.Fluid.Sensors.PPM senPPM(
            redeclare package Medium = Medium) if hasPpm
            "CO2 sensor"
            annotation (Placement(transformation(extent={{50,-10},{70,-30}})));

        equation
          if hasVap then
            assert(vol.ports[1].Xi_outflow[1] <= 0.1,
                   "The water content of the zone air model is very high. 
           Possibly you are simulating occupants (that generates a latent heat load), 
           but air is not being refreshed (for instance using ventilation or air leakage models)?",
                   level=AssertionLevel.warning);
          else
            phi=0;
          end if;
          if not hasPpm then
            ppm=0;
          end if;

          E=vol.U;
          QGai=preHeaFloLat.Q_flow;
          for i in 1:nSurf loop
            connect(vol.heatPort, ports_surf[i]) annotation (Line(points={{10,
                    -1.33227e-15},{10,-20},{-40,-20},{-40,0},{-100,0}},
                                                       color={191,0,0}));
          end for;
          for i in 1:nSeg loop
            connect(ports_air[i], vol.heatPort) annotation (Line(points={{100,0},{20,0},
                    {20,-20},{10,-20},{10,0}},
                                           color={191,0,0}));
          end for;
          connect(senTem.port, vol.heatPort) annotation (Line(points={{10,-60},{10,0}},
                                      color={191,0,0}));
          connect(senTem.T,TAir)
            annotation (Line(points={{30,-60},{110,-60}},          color={0,0,127}));
          connect(vol.mWat_flow, mWat_flow) annotation (Line(points={{12,-8},{16,-8},{
                  16,80},{108,80}},
                                 color={0,0,127}));
          connect(vol.C_flow[1:Medium.nC], C_flow[1:Medium.nC]) annotation (Line(points={{12,6},{
                  18,6},{18,40},{108,40}},
                        color={0,0,127}));
          connect(gaiLat.y, preHeaFloLat.Q_flow)
            annotation (Line(points={{64,47},{64,32}}, color={0,0,127}));
          connect(gaiLat.u, mWat_flow)
            annotation (Line(points={{64,70},{64,80},{108,80}}, color={0,0,127}));
          connect(preHeaFloLat.port, vol.heatPort) annotation (Line(points={{64,12},{64,
                  0},{20,0},{20,-20},{10,-20},{10,0}},
                                         color={191,0,0}));
          connect(senRelHum.phi, phi)
            annotation (Line(points={{51,-40},{110,-40}},          color={0,0,127}));
          connect(port_b, vol.ports[2]) annotation (Line(points={{-60,100},{-60,10},{
                  1.33227e-15,10}},
                        color={0,127,255}));
          connect(port_a, vol.ports[1]) annotation (Line(points={{60,100},{60,10},{8.88178e-16,
                  10}}, color={0,127,255}));
          connect(senRelHum.port, vol.ports[nPorts+3]) annotation (Line(points={{40,-30},
                  {40,10},{1.33227e-15,10}},
                                  color={0,127,255}));
          connect(senPPM.port, vol.ports[nPorts+3+(if hasVap then 1 else 0)]) annotation (Line(points={{60,-10},
                  {60,10},{1.33227e-15,10}},
                                  color={0,127,255}));
          connect(ports[1:nPorts], vol.ports[3:nPorts+2]) annotation (Line(points={{0,100},
                  {0,10},{1.33227e-15,10}},
                                  color={0,127,255}));
          connect(senPPM.ppm, ppm)
            annotation (Line(points={{71,-20},{110,-20}}, color={0,0,127}));
           annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})), Documentation(revisions="<html>
<ul>
<li>
December 13, 2019 by Filip Jorissen:<br/>
Directly referencing <code>IDEAS.Media.Air</code> instead of <code>Medium</code>
to avoid warnings in Dymola and errors in OpenModelica.
<a href=\"https://github.com/open-ideas/IDEAS/issues/1097\">#1097</a>.
</li>
<li>
March 29, 2019 by Filip Jorissen:<br/>
Added start value for CO2 concentration for
<a href=\"https://github.com/open-ideas/IDEAS/issues/1004\">#1004</a>.
</li>
<li>
February 14, 2019 by Filip Jorissen:<br/>
Changed default value of <code>stateSelectTVol</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/982\">#982</a>.
</li>
<li>
December 11, 2018 by Filip Jorissen:<br/>
Revised mixing volume connection order to avoid triggering flow reversal warnings.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/964\">#964</a>.
</li>
<li>
August 30, 2018 by Damien Picard:<br/>
Added constant StateSelectTVol to be able to select preferred state
of mixing volume.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/905\">#905</a>.
</li>
<li>
July 27, 2018 by Filip Jorissen:<br/>
Added nominal values for <code>m</code>, <code>mXi</code> and <code>mC</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/864\">#864</a>.
</li>
<li>
Added output for the CO2 concentration.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/868\">#868</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
Created <code>MixingVolumeNominalU</code> such that 
<code>MixingVolume</code> can be used without generating a warning.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
Added nominal value for internal energy of mixing volume.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/797\">#797</a>.
</li>
<li>
Modified model for supporting new interzonal air flow models.
Air leakage model and its parameters have been removed.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
<li>
August 5, 2017 by Filip Jorissen:<br/>
Added support for dry air.
</li>
<li>
November 15, 2016 by Filip Jorissen:<br/>
Revised documentation.
</li>
<li>
August 26, 2016 by Filip Jorissen:<br/>
Added support for conservation of energy.
</li>
<li>
April 30, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Perfectly mixed air model.
</p>
<h4>Main equations</h4>
<p>
This model computes a single air temperature that is used to 
evaluate convective heat transfer of all surfaces,
components connected to gainCon (e.g. radiators), etc.
The air outlet temperature equals the well mixed air temperature.
</p>
<h4>Assumption and limitations</h4>
<p>
This model is not valid for buildings where stratification occurs, 
e.g. when using floor cooling
or ceiling heating.
</p>
<p>
When dry air is used, then the relative humidity output is set to zero.
</p>
<h4>Typical use and important parameters</h4>
<p>
The zone air volume <code>Vto</code> determines the thermal mass of the air.
This mass may be artificially increased using <code>mSenFac</code> if desired, 
e.g. to take into account the thermal mass of furniture.
</p>
<h4>Dynamics</h4>
This model only contains states to represent the energy and mass dynamics, 
typically using a temperature and pressure variable.
Parameters <code>energyDynamics</code> and <code>massDynamics</code>
may be used to change the model dynamics.
<h4>Validation</h4>
<p>
See BESTEST.
</p>
</html>"));
        end WellMixedAir;

        package BaseClasses
          extends Modelica.Icons.BasesPackage;

          partial model PartialAirModel "Partial for air models"
            extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations(
              energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
              redeclare replaceable package Medium = IDEAS.Media.Air);
            outer IDEAS.BoundaryConditions.SimInfoManager sim
              "Simulation information manager for climate data"
              annotation (Placement(transformation(extent={{80,-100},{100,-80}})));
            parameter Integer nSurf "Number of connected surfaces";
            parameter Integer nSeg(min=1)=1 "Number of air segments";
            parameter Integer nPorts "Number of fluid port connections to zone air volume";
            parameter Modelica.SIunits.Volume Vtot "Total zone air volume";
            parameter Boolean allowFlowReversal=true
               "= false to simplify equations, assuming, but not enforcing, no flow reversal"
              annotation(Dialog(tab="Advanced"));
            parameter Modelica.SIunits.MassFlowRate m_flow_nominal
              "Nominal flow rate of the ventilation system";
            Modelica.Blocks.Interfaces.RealOutput E(unit="J") "Model internal energy";
            Modelica.Blocks.Interfaces.RealOutput QGai(unit="J/s") "Model internal energy";
            Modelica.Blocks.Interfaces.RealOutput TAir "Zone air temperature"
              annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nSurf] ports_surf
              "Heat convection ports for surfaces"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] inc
              "Inclination angle of surface"
              annotation (Placement(transformation(extent={{-128,60},{-88,100}})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] A
              "Surface area of surfaces"
              annotation (Placement(transformation(extent={{-126,-80},{-86,-40}})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] azi
              "Azimuth of surface"
              annotation (Placement(transformation(extent={{-128,20},{-88,60}})));
            Modelica.Fluid.Interfaces.FluidPort_a port_a(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal),
              h_outflow(nominal=Medium.h_default))
              annotation (Placement(transformation(extent={{50,90},{70,110}})));
            Modelica.Fluid.Interfaces.FluidPort_b port_b(
              redeclare package Medium = Medium,
              m_flow(nominal=m_flow_nominal),
              h_outflow(nominal=Medium.h_default))
              annotation (Placement(transformation(extent={{-70,90},{-50,110}})));
            Modelica.Fluid.Interfaces.FluidPorts_a[nPorts] ports(
              redeclare each package Medium = Medium,
              each m_flow(nominal=m_flow_nominal),
              each h_outflow(nominal=Medium.h_default))
              "Ports connector for multiple ports" annotation (Placement(
                  transformation(
                  extent={{-10,-40},{10,40}},
                  rotation=90,
                  origin={0,100})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nSeg] ports_air
              "Heat convection ports for air volumes"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Blocks.Interfaces.RealInput mWat_flow
              "Moisture mass flow rate being added to the zone air"
              annotation (Placement(transformation(extent={{128,60},{88,100}})));
            Modelica.Blocks.Interfaces.RealInput C_flow[max(Medium.nC,1)]
              "Trace substance mass flow rate being added to the zone air"
              annotation (Placement(transformation(extent={{128,20},{88,60}})));
            Modelica.Blocks.Interfaces.RealOutput phi(unit="1")
              "Relative humidity in the zone"
              annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
            Modelica.Blocks.Interfaces.RealOutput ppm(unit="1")
              "CO2 concentration in the zone" annotation (Placement(transformation(extent=
                     {{100,-30},{120,-10}})));
        protected
            final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
                T=Medium.T_default,
                p=Medium.p_default,
                X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
            final parameter Modelica.SIunits.Density rho_default = Medium.density(
              state=state_default) "Medium default density";
            final parameter Modelica.SIunits.SpecificHeatCapacity cp_default = Medium.specificHeatCapacityCp(state=state_default);
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}})), Documentation(revisions="<html>
<ul>
<li>
July 27, 2018 by Filip Jorissen:<br/>
Added output for the CO2 concentration.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/868\">#868</a>.
</li>
<li>
July 11, 2018, Filip Jorissen:<br/>
Added <code>m_flow_nominal</code> for setting nominal values 
of <code>h_outflow</code> and <code>m_flow</code>
in <code>FluidPorts</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/859\">#859</a>.
</li>
<li>
May 29, 2018, Filip Jorissen:<br/>
Removed conditional fluid ports for JModelica compatibility.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/834\">#834</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
Modified model for supporting new interzonal air flow models.
Air leakage model and its parameters have been removed.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
<li>
November 15, 2016 by Filip Jorissen:<br/>
Revised documentation.
</li>
<li>
August 26, 2016 by Filip Jorissen:<br/>
Added support for conservation of energy.
</li>
<li>
April 30, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",           info="<html>
<p>
Zone air model partial containing main parameters and connectors.
</p>
</html>"),    Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{90,-80}},
                    pattern=LinePattern.None,
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Backward,
                    lineColor={0,0,0}),
                  Line(
                    points={{-68,60},{68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{68,60},{68,-60},{-68,-60},{-68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Rectangle(
                    extent={{68,60},{-68,-60}},
                    pattern=LinePattern.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    lineThickness=0.5),
                  Line(points={{-30,42},{38,42},{38,-12},{28,-2},{38,-12},{46,-2}}, color=
                       {28,108,200}),
                  Line(points={{40,-32},{-30,-32},{-30,22},{-20,12},{-30,22},{-38,12}},
                      color={238,46,47})}));
          end PartialAirModel;
        end BaseClasses;
      end ZoneAirModels;

      package Interfaces "Building component interfaces"
      extends Modelica.Icons.InterfacesPackage;

        type BoundaryType = enumeration(
          BoundaryWall   "Boundary wall",
          InternalWall   "Internal wall",
          OuterWall   "Outer wall",
          SlabOnGround   "Slab on ground",
          External   "External connection using propsbus",
          None   "No wall for this orientation") "Type of zone boundary conditions that should be considered";

        partial model PartialOpaqueSurface
          "Partial component for the opaque surfaces of the building envelope"

          replaceable parameter IDEAS.Buildings.Data.Interfaces.Construction constructionType
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Building component material structure" annotation (
            __Dymola_choicesAllMatching=true,
            Placement(transformation(extent={{-34,78},{-30,82}})),
            Dialog(group="Construction details"));
          extends IDEAS.Buildings.Components.Interfaces.PartialSurface(
            E(y=if sim.computeConservationOfEnergy then layMul.E else 0),
            Qgai(y=layMul.port_b.Q_flow + (if sim.openSystemConservationOfEnergy or not sim.computeConservationOfEnergy
                 then 0 else sum(port_emb.Q_flow))),
            layMul(
              final nLay=constructionType.nLay,
              final mats=constructionType.mats,
              T_start=ones(constructionType.nLay)*T_start,
              nGain=constructionType.nGain));


          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_emb[constructionType.nGain]
            "Port for gains by embedded active layers"
            annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
      protected
          Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow iSolDir(final Q_flow=0);
          Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow iSolDif(final Q_flow=0);

        initial equation
          assert(not energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState,
            "In " + getInstanceName() + ": Using SteadyState energyDynamics for a wall
    is not allowed since this causes large algebraic loops, which significantly affects computation time.");
          assert(IDEAS.Utilities.Math.Functions.isAngle(constructionType.incLastLay, IDEAS.Types.Tilt.Other) or
            constructionType.incLastLay >= incInt - Modelica.Constants.pi/3 - Modelica.Constants.eps and
            constructionType.incLastLay <= incInt + Modelica.Constants.pi/3 + Modelica.Constants.eps,
            "The inclination of a wall, a floor or a ceiling does not correspond to its record.");

        equation
          connect(iSolDif.port, propsBus_a.iSolDif);
          connect(iSolDir.port, propsBus_a.iSolDir);

          for i in 1:constructionType.nGain loop
            connect(layMul.port_gain[constructionType.locGain[i]], port_emb[i])
            annotation (Line(points={{0,-10},{0,-10},{0,-100}}, color={191,0,0}));
          end for;

            annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-60,-100},{60,100}})),
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-50,-100},{50,100}}),
                graphics),
            Documentation(revisions="<html>
<ul>
<li>
June 27, 2018, by Filip Jorissen:<br/>
Added check to avoid <code>energyDynamics=SteadyState</code>. 
See issue <a href=https://github.com/open-ideas/IDEAS/issues/856>#856</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed conservation of energy implementation for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
January 10, 2017, by Filip Jorissen:<br/>
Removed
<code>AWall</code>  and declared <code>A</code> in 
<a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialSurface>
IDEAS.Buildings.Components.Interfaces.PartialSurface</a>.
This is for 
<a href=https://github.com/open-ideas/IDEAS/issues/609>#609</a>.
</li>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
February 6, 2016 by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
This model extends 
<a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialSurface>IDEAS.Buildings.Components.Interfaces.PartialSurface</a>
with parameters that are typical for opaque surfaces, i.e. all surfaces except windows.
</p>
</html>"));
        end PartialOpaqueSurface;

        partial model PartialSurface "Partial model for building envelope component"

          outer IDEAS.BoundaryConditions.SimInfoManager sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{30,-100},{50,-80}})));

          parameter Integer incOpt = 4
            "Tilt angle option from simInfoManager, or custom using inc"
            annotation(choices(__Dymola_radioButtons=true, choice=1 "Wall", choice=2 "Floor", choice=3 "Ceiling", choice=4 "Custom"));
          parameter Modelica.SIunits.Angle inc = sim.incOpts[incOpt]
            "Custom inclination (tilt) angle of the wall, default wall"
            annotation(Dialog(enable=incOpt==4));
          parameter Integer aziOpt = 5
            "Azimuth angle option from simInfoManager, or custom using azi"
            annotation(choices(__Dymola_radioButtons=true, choice=1 "South", choice=2 "West", choice=3 "North", choice=4 "East", choice=5 "Custom"));
          parameter Modelica.SIunits.Angle azi=sim.aziOpts[aziOpt]
            "Custom azimuth angle of the wall, default south"
            annotation(Dialog(enable=aziOpt==5));
          parameter Modelica.SIunits.Area A
            "Component surface area";
          parameter Real nWin = 1 "Use this factor to scale the component to nWin identical components";
          parameter Modelica.SIunits.Power QTra_design
            "Design heat losses at reference temperature of the boundary space"
            annotation (Dialog(group="Design power",tab="Advanced"));
          parameter Modelica.SIunits.Temperature T_start=293.15
            "Start temperature for each of the layers"
            annotation(Dialog(tab="Dynamics", group="Initial condition"));

          parameter Modelica.SIunits.Temperature TRef_a=291.15
            "Reference temperature of zone on side of propsBus_a, for calculation of design heat loss"
            annotation (Dialog(group="Design power",tab="Advanced"));
          parameter Boolean linIntCon_a=sim.linIntCon
            "= true, if convective heat transfer should be linearised"
            annotation (Dialog(tab="Convection"));
          parameter Modelica.SIunits.TemperatureDifference dT_nominal_a=1
            "Nominal temperature difference used for linearisation, negative temperatures indicate the solid is colder"
            annotation (Dialog(tab="Convection"));
          parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial
            "Static (steady state) or transient (dynamic) thermal conduction model"
            annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

          IDEAS.Buildings.Components.Interfaces.ZoneBus propsBus_a(
            numIncAndAziInBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles)
                                                     "If inc = Floor, then propsbus_a should be connected to the zone above this floor.
    If inc = ceiling, then propsbus_a should be connected to the zone below this ceiling.
    If component is an outerWall, porpsBus_a should be connect to the zone."
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={100,20}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={50,20})));

          IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.InteriorConvection intCon_a(
            linearise=linIntCon_a or sim.linearise,
            dT_nominal=dT_nominal_a,
            final inc=incInt,
            A=A)
            "Convective heat transfer correlation for port_a"
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));

          IDEAS.Buildings.Components.BaseClasses.ConductiveHeatTransfer.MultiLayer
            layMul(
            energyDynamics=energyDynamics,
            linIntCon=linIntCon_a or sim.linearise,
            A=A,
            final inc=incInt)
            "Multilayer component for simulating walls, windows and other surfaces"
            annotation (Placement(transformation(extent={{10,-10},{-10,10}})));

      protected
          final parameter Modelica.SIunits.Angle aziInt=
            if aziOpt==5
            then azi
            else sim.aziOpts[aziOpt]
              "Azimuth angle";
          final parameter Modelica.SIunits.Angle incInt=
            if incOpt==4
            then inc
            else sim.incOpts[incOpt]
              "Inclination angle";
          Modelica.Blocks.Sources.RealExpression QDesign(y=QTra_design);

          Modelica.Blocks.Sources.RealExpression aziExp(y=aziInt)
            "Azimuth angle expression";
          Modelica.Blocks.Sources.RealExpression incExp(y=incInt)
            "Inclination angle expression";
          Modelica.Blocks.Sources.RealExpression E
            "Model internal energy";
          IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.PrescribedEnergy prescribedHeatFlowE
            "Component for computing conservation of energy";
          Modelica.Blocks.Sources.RealExpression Qgai
            "Heat gains across model boundary";
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow prescribedHeatFlowQgai
            "Component for computing conservation of energy";

          IDEAS.Buildings.Components.Interfaces.ZoneBusVarMultiplicator gain(k=nWin)
            "Gain for all propsBus variable to represent nWin surfaces instead of 1"
            annotation (Placement(transformation(extent={{70,6},{88,36}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus propsBusInt(
            numIncAndAziInBus=sim.numIncAndAziInBus,
            outputAngles=sim.outputAngles)
            annotation (Placement(transformation(
                extent={{-18,-18},{18,18}},
                rotation=-90,
                origin={56,20}),  iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={50,20})));
        equation
          connect(prescribedHeatFlowE.port, propsBusInt.E);
          connect(Qgai.y,prescribedHeatFlowQgai. Q_flow);
          connect(prescribedHeatFlowQgai.port, propsBusInt.Qgai);
          connect(E.y,prescribedHeatFlowE. E);
          connect(QDesign.y, propsBusInt.QTra_design);
          connect(propsBusInt.surfCon, intCon_a.port_b) annotation (Line(
              points={{56.09,19.91},{46,19.91},{46,0},{40,0}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(layMul.port_a, propsBusInt.surfRad) annotation (Line(
              points={{10,0},{16,0},{16,19.91},{56.09,19.91}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(layMul.port_a, intCon_a.port_a) annotation (Line(
              points={{10,0},{20,0}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(layMul.iEpsSw_a, propsBusInt.epsSw) annotation (Line(
              points={{10,4},{20,4},{20,19.91},{56.09,19.91}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(layMul.iEpsLw_a, propsBusInt.epsLw) annotation (Line(
              points={{10,8},{18,8},{18,19.91},{56.09,19.91}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(layMul.area, propsBusInt.area) annotation (Line(
              points={{0,10},{0,19.91},{56.09,19.91}},
              color={0,0,127},
              smooth=Smooth.None), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(incExp.y, propsBusInt.inc);
          connect(aziExp.y, propsBusInt.azi);
          connect(propsBus_a, gain.propsBus_b) annotation (Line(
              points={{100,20},{94,20},{94,20.2105},{88,20.2105}},
              color={255,204,51},
              thickness=0.5));
          connect(gain.propsBus_a, propsBusInt) annotation (Line(
              points={{70,20.2105},{60,20.2105},{60,20},{56,20}},
              color={255,204,51},
              thickness=0.5));
          annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                    100,100}})),
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-50,-100},{50,100}})),
            Documentation(revisions="<html>
<ul>
<li>
October 13, 2019, by Filip Jorissen:<br/>
Refactored the parameter definition of <code>inc</code> 
and <code>azi</code> by adding the option to use radio buttons.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1067\">
#1067</a>
</li>
<li>
August 10, 2018 by Damien Picard:<br/>
Add scaling to propsBus_a to allow simulation of nWin windows instead of 1
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">
#888</a>. This factor is not useful for wall and it is set final to 1 
for them.
</li>
<li>
January 26, 2018, by Filip Jorissen:<br/>
Extended documentation.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed bus declarations for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
January 10, 2017, by Filip Jorissen:<br/>
Declared parameter <code>A</code> instead of using
<code>AWall</code> in 
<a href=modelica://IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface>
IDEAS.Buildings.Components.Interfaces.PartialOpaqueSurface</a>.
This is for 
<a href=https://github.com/open-ideas/IDEAS/issues/609>#609</a>.
</li>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
March 8, 2016, by Filip Jorissen:<br/>
Added energyDynamics parameter.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: cleaned up connections and partials.
</li>
<li>
February 6, 2016 by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Partial model for all surfaces and windows that contains common building blocks such as material layers and parameters.
</p>
<h4>Main equations</h4>
<p>
Submodel <code>layMul</code> contains equations
for simulating conductive (and sometimes radiative) heat transfer
inside material layers.
</p>
<h4>Assumption and limitations</h4>
<p>
This model assumes 1D heat transfer, i.e. edge effects are neglected.
Mass exchange (moisture) is not modelled.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameters <code>inc</code> and <code>azi</code> may be
used to specify the inclination and azimuth/tilt angle of the surface.
Variables in <a href=modelica://IDEAS.Types.Azimuth>IDEAS.Types.Azimuth</a>
and <a href=modelica://IDEAS.Types.Tilt>IDEAS.Types.Tilt</a>
may be used for this purpose or custom variables may be defined.
Numerical values can be used directly. 
Azimuth angles should be in radians relative to the south orientation, clockwise.
Tilt angles should be in radians where an angle of 0 is the ceiling (upward) orientation
and an angle of Pi is the floor (downward) orientation.
Preferably the azimuth angle is set to zero for horizontal tilt angles, 
since this leads to more efficient code, 
although the model results will not change.
</p>
<p>
The parameter <code>nWin</code> is used in the window model to scale
the window to <code>nWin</code> identical window using the single window
model.
</p>
<h4>Options</h4>
<p>
Convection equations may be simplified (linearised) by setting <code>linIntCon_a = true</code>.
</p>
<h4>Dynamics</h4>
<p>
This model contains multiple state variables for describing the temperature state of the component.
</p>
</html>"));
        end PartialSurface;

        model PartialZone "Building zone model"
          extends IDEAS.Buildings.Components.Interfaces.ZoneInterface(
            Qgai(y=(if not sim.computeConservationOfEnergy then 0 elseif sim.openSystemConservationOfEnergy
                   then airModel.QGai else gainCon.Q_flow + gainRad.Q_flow + airModel.QGai)),
            Eexpr(y=if sim.computeConservationOfEnergy then E else 0),
            useOccNumInput=occNum.useInput,
            useLigCtrInput=ligCtr.useCtrInput);

            replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choicesAllMatching = true);

          parameter Modelica.SIunits.Length hZone = 2.8
            "Zone height: distance between floor and ceiling"
            annotation(Dialog(group="Building physics"));
          parameter Modelica.SIunits.Area A = V/hZone "Total conditioned floor area"
            annotation(Dialog(group="Building physics"));
          parameter Real n50(min=0.01)= 0.4
            "n50 value cfr airtightness, i.e. the ACH at a pressure diffence of 50 Pa"
            annotation(Dialog(group="Building physics"));
          parameter Boolean allowFlowReversal=true
            "= true to allow flow reversal in zone, false restricts to design direction (port_a -> port_b)."
            annotation(Dialog(tab="Advanced", group="Air model"));
          parameter Real n50toAch=20 "Conversion fractor from n50 to Air Change Rate"
           annotation(Dialog(tab="Advanced", group="Air model"));
          parameter Modelica.Fluid.Types.Dynamics energyDynamicsAir=Modelica.Fluid.Types.Dynamics.FixedInitial
            "Type of energy balance for air model: dynamic (3 initialization options) or steady state";
          parameter Real mSenFac = 5 "Correction factor for thermal capacity of zone air."
            annotation(Dialog(tab="Advanced",group="Air model"));

          parameter Boolean linIntRad=sim.linIntRad
            "Linearized computation of long wave radiation"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange"));
          parameter Boolean calculateViewFactor = false
            "Explicit calculation of view factors: works well only for rectangular zones!"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange"));
          final parameter Modelica.SIunits.Power QInf_design=1012*1.204*V/3600*n50/n50toAch*(273.15
               + 21 - sim.Tdes)
            "Design heat losses from infiltration at reference outdoor temperature";
          final parameter Modelica.SIunits.Power QRH_design=A*fRH
            "Additional power required to compensate for the effects of intermittent heating";
          final parameter Modelica.SIunits.Power Q_design(fixed=false)
            "Total design heat losses for the zone";
          parameter Medium.Temperature T_start=Medium.T_default
            "Start value of temperature"
            annotation(Dialog(tab = "Initialization"));
          parameter Real fRH=11
            "Reheat factor for calculation of design heat load, (EN 12831, table D.10 Annex D)" annotation(Dialog(tab="Advanced",group="Design heat load"));
          parameter Modelica.SIunits.Temperature Tzone_nom = 295.15
            "Nominal zone temperature, used for linearising radiative heat exchange"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange", enable=linIntRad));
          parameter Modelica.SIunits.TemperatureDifference dT_nom = -2
            "Nominal temperature difference between zone walls, used for linearising radiative heat exchange"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange", enable=linIntRad));
          parameter Boolean simVieFac=false "Simplify view factor computation"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange"));

          replaceable ZoneAirModels.WellMixedAir airModel(
            redeclare package Medium = Medium,
            nSurf=nSurf,
            Vtot=V,
            energyDynamics=energyDynamicsAir,
            allowFlowReversal=allowFlowReversal)
          constrainedby
          IDEAS.Buildings.Components.ZoneAirModels.BaseClasses.PartialAirModel(
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            nSurf=nSurf,
            Vtot=V,
            final T_start=T_start,
            allowFlowReversal=allowFlowReversal,
            energyDynamics=energyDynamicsAir,
            massDynamics=if interzonalAirFlow.prescribesPressure
                         then Modelica.Fluid.Types.Dynamics.SteadyState
                         else energyDynamicsAir,
            nPorts=interzonalAirFlow.nPorts,
            m_flow_nominal=m_flow_nominal)
            "Zone air model"
            annotation (choicesAllMatching=true,
            Placement(transformation(extent={{-40,20},{-20,40}})),
            Dialog(tab="Advanced",group="Air model"));
          replaceable IDEAS.Buildings.Components.InterzonalAirFlow.n50Tight interzonalAirFlow
          constrainedby
          IDEAS.Buildings.Components.InterzonalAirFlow.BaseClasses.PartialInterzonalAirFlow(
              redeclare package Medium = Medium,
              V=V,
              n50=n50,
              n50toAch=n50toAch,
              m_flow_nominal_vent=m_flow_nominal)
              "Interzonal air flow model"
            annotation (choicesAllMatching = true,Dialog(tab="Advanced", group="Air model"),
              Placement(transformation(extent={{-40,60},{-20,80}})),
            choicesAllMatching=true,
            Dialog(group="Building physics"));
          replaceable IDEAS.Buildings.Components.Occupants.Fixed occNum
            constrainedby Occupants.BaseClasses.PartialOccupants(
              final A=A,
              final linearise = sim.lineariseDymola)
            "Number of occupants that are present" annotation (
            choicesAllMatching=true,
            Dialog(group="Occupants (optional)"),
            Placement(transformation(extent={{80,22},{60,42}})));

          replaceable parameter IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp
            constrainedby
          IDEAS.Buildings.Components.OccupancyType.BaseClasses.PartialOccupancyType
            "Occupancy type, only used for evaluating occupancy model and comfort model"
            annotation (
            choicesAllMatching=true,
            Dialog(group="Occupants (optional)"),
            Placement(transformation(extent={{80,82},{100,102}})));
          replaceable parameter IDEAS.Buildings.Components.RoomType.Generic rooTyp
            constrainedby
          IDEAS.Buildings.Components.RoomType.BaseClasses.PartialRoomType
            "Room type or function, currently only determines the desired lighting intensity"
            annotation (choicesAllMatching=true,
            Dialog(group="Lighting (optional)"),
            Placement(transformation(extent={{32,82},{52,102}})));
          replaceable parameter IDEAS.Buildings.Components.LightingType.None ligTyp
            constrainedby
          IDEAS.Buildings.Components.LightingType.BaseClasses.PartialLighting
            "Lighting type, determines the lighting efficacy/efficiency" annotation (
            choicesAllMatching=true,
            Dialog(group="Lighting (optional)"),
            Placement(transformation(extent={{56,82},{76,102}})));
          replaceable IDEAS.Buildings.Components.Comfort.None comfort
            constrainedby
          IDEAS.Buildings.Components.Comfort.BaseClasses.PartialComfort(
              occupancyType=occTyp,
              use_phi_in=Medium.nX > 1) "Comfort model" annotation (
            choicesAllMatching=true,
            Dialog(group="Occupants (optional)"),
            Placement(transformation(extent={{20,-20},{40,0}})));
          replaceable IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ZoneLwGainDistribution
            radDistr(nSurf=nSurf, lineariseJModelica=sim.lineariseJModelica,
            T_start=T_start)
            "Distribution of radiative internal gains"
            annotation (choicesAllMatching=true,Dialog(tab="Advanced",group="Building physics"),Placement(transformation(
                extent={{10,10},{-10,-10}},
                rotation=-90,
                origin={-50,-50})));
          replaceable IDEAS.Buildings.Components.InternalGains.Occupants intGaiOcc
            constrainedby
          IDEAS.Buildings.Components.InternalGains.BaseClasses.PartialOccupancyGains(
              occupancyType=occTyp,
              redeclare final package Medium = Medium)
            "Internal gains model" annotation (
            choicesAllMatching=true,
            Dialog(tab="Advanced", group="Occupants"),
            Placement(transformation(extent={{40,22},{20,42}})));

          replaceable IDEAS.Buildings.Components.InternalGains.Lighting intGaiLig
            constrainedby
          IDEAS.Buildings.Components.InternalGains.BaseClasses.PartialLightingGains(
              A=A,
              ligTyp=ligTyp,
              rooTyp=rooTyp) "Lighting model" annotation (
            choicesAllMatching=true,
            Dialog(tab="Advanced", group="Lighting"),
            Placement(transformation(extent={{40,52},{20,72}})));

          Modelica.SIunits.Power QTra_design=sum(propsBusInt.QTra_design)
            "Total design transmission heat losses for the zone";
          Modelica.Blocks.Interfaces.RealOutput TAir(unit="K") = airModel.TAir;
          Modelica.Blocks.Interfaces.RealOutput TRad(unit="K") = radDistr.TRad;
          Modelica.SIunits.Energy E = airModel.E;

          replaceable IDEAS.Buildings.Components.LightingControl.Fixed ligCtr
            constrainedby
          IDEAS.Buildings.Components.LightingControl.BaseClasses.PartialLightingControl(
              final linearise = sim.lineariseDymola)
            "Lighting control type" annotation (
            choicesAllMatching=true,
            Dialog(group="Lighting (optional)"),
            Placement(transformation(extent={{80,52},{60,72}})));



      protected
          IDEAS.Buildings.Components.Interfaces.ZoneBus[nSurf] propsBusInt(
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles)
            "Dummy propsbus for partial" annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-80,40}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-80,40})));

          IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ZoneLwDistribution
            radDistrLw(nSurf=nSurf, final linearise=linIntRad or sim.linearise,
            Tzone_nom=Tzone_nom,
            dT_nom=dT_nom,
            final simVieFac=simVieFac) if                not calculateViewFactor
            "internal longwave radiative heat exchange" annotation (Placement(
                transformation(
                extent={{10,-10},{-10,10}},
                rotation=90,
                origin={-50,-10})));
          Modelica.Blocks.Math.Sum add(nin=2, k={0.5,0.5}) "Operative temperature"
            annotation (Placement(transformation(extent={{84,14},{96,26}})));

          IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.ZoneLwDistributionViewFactor
            zoneLwDistributionViewFactor(
              nSurf=nSurf,
              final hZone=hZone,
            linearise=linIntRad or sim.linearise,
            Tzone_nom=Tzone_nom,
            dT_nom=dT_nom) if       calculateViewFactor annotation (Placement(
                transformation(
                extent={{-10,10},{10,-10}},
                rotation=270,
                origin={-30,-10})));



        initial equation
          Q_design=QInf_design+QRH_design+QTra_design; //Total design load for zone (additional ventilation losses are calculated in the ventilation system)

        equation
          if interzonalAirFlow.verifyBothPortsConnected then
            assert(cardinality(port_a)>1 and cardinality(port_b)>1 or cardinality(port_a) == 1 and cardinality(port_b) == 1,
              "WARNING: Only one of the FluidPorts of " + getInstanceName() + " is 
      connected and an 'open' interzonalAirFlow model is used, 
      which means that all injected/extracted air will flow
      through the zone to/from the surroundings, at ambient temperature. 
      This may be unintended.",         AssertionLevel.warning);
          end if;
          for i in 1:nSurf loop
            connect(sim.weaBus, propsBusInt[i].weaBus) annotation (Line(
                points={{-81,93},{-81,92},{-80,92},{-80,66},{-80.1,66},{-80.1,39.9}},
                color={255,204,51},
                thickness=0.5,
                smooth=Smooth.None));
            connect(dummy1, propsBusInt[i].Qgai);
            connect(dummy2, propsBusInt[i].E);
        end for;
          connect(radDistr.radGain, gainRad) annotation (Line(
              points={{-46.2,-60},{100,-60}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(radDistr.TRad, add.u[1]) annotation (Line(
              points={{-40,-50},{-6,-50},{-6,19.4},{82.8,19.4}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(propsBusInt[1:nSurf].area, radDistr.area[1:nSurf]) annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-58},{-60,-58}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].area, radDistrLw.A[1:nSurf]) annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-14},{-60,-14}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].epsLw, radDistrLw.epsLw[1:nSurf]) annotation (
              Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-10},{-60,-10}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].epsLw, zoneLwDistributionViewFactor.epsLw[1:
            nSurf]) annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-10},{-40,-10}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].area, zoneLwDistributionViewFactor.A[1:nSurf])
            annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-14},{-40,-14}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].epsLw, radDistr.epsLw[1:nSurf]) annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-50},{-60,-50}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(propsBusInt[1:nSurf].epsSw, radDistr.epsSw[1:nSurf]) annotation (Line(
              points={{-80.1,39.9},{-80,39.9},{-80,-54},{-60,-54}},
              color={127,0,0},
              smooth=Smooth.None), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          for i in 1:nSurf loop
            connect(radDistr.iSolDir, propsBusInt[i].iSolDir) annotation (Line(
                points={{-54,-60},{-80.1,-60},{-80.1,39.9}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(radDistr.iSolDif, propsBusInt[i].iSolDif) annotation (Line(
                points={{-50,-60},{-50,-64},{-80.1,-64},{-80.1,39.9}},
                color={191,0,0},
                smooth=Smooth.None));
          end for;
          connect(radDistr.radSurfTot, radDistrLw.port_a) annotation (Line(
              points={{-50,-40},{-50,-20}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(zoneLwDistributionViewFactor.inc[1:nSurf], propsBusInt[1:nSurf].inc)
            annotation (Line(
              points={{-34,-1.77636e-15},{-34,4},{-80,4},{-80,39.9},{-80.1,39.9}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(zoneLwDistributionViewFactor.azi[1:nSurf], propsBusInt[1:nSurf].azi)
            annotation (Line(
              points={{-26,-1.77636e-15},{-26,8},{-80,8},{-80,39.9},{-80.1,39.9}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(zoneLwDistributionViewFactor.port_a, radDistr.radSurfTot) annotation (
             Line(
              points={{-30,-20},{-30,-30},{-50,-30},{-50,-40}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(add.y, TSensor) annotation (Line(points={{96.6,20},{110,20}},
                           color={0,0,127}));
          connect(radDistr.radSurfTot[1:nSurf], propsBusInt[1:nSurf].surfRad)
            annotation (Line(points={{-50,-40},{-50,-30},{-80,-30},{-80,39.9},{-80.1,
                  39.9}}, color={191,0,0}));
          connect(airModel.ports_surf[1:nSurf], propsBusInt[1:nSurf].surfCon)
            annotation (Line(points={{-40,30},{-80,30},{-80,40},{-80.1,40},{-80.1,39.9}},
                color={191,0,0}));
          connect(airModel.inc[1:nSurf], propsBusInt[1:nSurf].inc) annotation (Line(
                points={{-40.8,38},{-80,38},{-80,40},{-82,40},{-80.1,40},{-80.1,39.9}},
                color={0,0,127}));
          connect(airModel.azi[1:nSurf], propsBusInt[1:nSurf].azi) annotation (Line(
                points={{-40.8,34},{-80,34},{-80,40},{-80.1,40},{-80.1,39.9}}, color={0,
                  0,127}));
          connect(airModel.A[1:nSurf], propsBusInt[1:nSurf].area) annotation (Line(
                points={{-40.6,24},{-80,24},{-80,40},{-80.1,40},{-80.1,39.9}}, color={0,
                  0,127}));
          connect(airModel.ports_air[1], gainCon) annotation (Line(points={{-20,30},{2,30},
                  {2,-30},{100,-30}}, color={191,0,0}));
          connect(airModel.TAir, add.u[2]) annotation (Line(points={{-19,24},{-10,24},{-10,
                  20.6},{82.8,20.6}},  color={0,0,127}));
          connect(radDistr.azi[1:nSurf], propsBusInt[1:nSurf].azi) annotation (Line(
                points={{-60,-42},{-70,-42},{-80,-42},{-80,39.9},{-80.1,39.9}}, color={
                  0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(radDistr.inc[1:nSurf], propsBusInt[1:nSurf].inc) annotation (Line(
                points={{-60,-46},{-80,-46},{-80,39.9},{-80.1,39.9}}, color={0,0,127}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(intGaiOcc.portCon, airModel.ports_air[1])
            annotation (Line(points={{20,30},{-20,30}}, color={191,0,0}));
          connect(intGaiOcc.portRad, radDistr.radGain) annotation (Line(points={{20,26},
                  {4,26},{4,-60},{-46.2,-60}}, color={191,0,0}));
          connect(intGaiOcc.mWat_flow, airModel.mWat_flow)
            annotation (Line(points={{19.4,38},{-19.2,38}}, color={0,0,127}));
          connect(intGaiOcc.C_flow, airModel.C_flow)
            annotation (Line(points={{19.4,34},{-19.2,34}}, color={0,0,127}));
          connect(comfort.TAir, airModel.TAir) annotation (Line(points={{19,0},{-10,0},{
                  -10,24},{-19,24}},   color={0,0,127}));
          connect(comfort.TRad, radDistr.TRad) annotation (Line(points={{19,-4},{-6,-4},
                  {-6,-50},{-40,-50}}, color={0,0,127}));
          connect(comfort.phi_in, airModel.phi) annotation (Line(points={{19,-8},{-12,-8},{
                  -12,26},{-19,26}},   color={0,0,127}));
          connect(occNum.nOcc, intGaiOcc.nOcc)
            annotation (Line(points={{58,32},{41,32}}, color={0,0,127}));
          connect(yOcc, occNum.yOcc) annotation (Line(points={{120,40},{96,40},{96,32},{
                  82,32}}, color={0,0,127}));
          connect(uLig, ligCtr.ligCtr) annotation (Line(points={{120,70},{96,70},{96,60},
                  {82,60}},color={0,0,127}));
          connect(occNum.nOcc, ligCtr.nOcc) annotation (Line(points={{58,32},{96,32},{96,
                  64},{82,64}},
                           color={0,0,127}));
          connect(airModel.port_b, interzonalAirFlow.port_a_interior)
            annotation (Line(points={{-36,40},{-36,60}}, color={0,127,255}));
          connect(airModel.port_a, interzonalAirFlow.port_b_interior)
            annotation (Line(points={{-24,40},{-24,60}}, color={0,127,255}));
          connect(interzonalAirFlow.ports, airModel.ports) annotation (Line(points={{
                  -29.8,60},{-30,60},{-30,40}}, color={0,127,255}));
          connect(interzonalAirFlow.port_b_exterior, port_b) annotation (Line(points={{
                  -32,80},{-32,92},{-20,92},{-20,100}}, color={0,127,255}));
          connect(interzonalAirFlow.port_a_exterior, port_a) annotation (Line(points={{
                  -28,80},{-28,84},{20,84},{20,100}}, color={0,127,255}));
          connect(ppm, airModel.ppm) annotation (Line(points={{110,0},{52,0},{52,16},{-8,
                  16},{-8,28},{-19,28}}, color={0,0,127}));
          connect(intGaiLig.portRad, gainRad) annotation (Line(points={{20,60},{4,60},{4,
                  -60},{100,-60}}, color={191,0,0}));
          connect(intGaiLig.portCon, gainCon) annotation (Line(points={{20,64},{2,64},{2,
                  -30},{100,-30}}, color={191,0,0}));
          connect(ligCtr.ctrl, intGaiLig.ctrl)
            annotation (Line(points={{58,62},{41,62}}, color={0,0,127}));
         annotation (Placement(transformation(extent={{
                    140,48},{100,88}})),
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                 graphics),
            Documentation(info="<html>
<p>See extending models.</p>
</html>",         revisions="<html>
<ul>
<li>
April 26, 2019 by Filip Jorissen:<br/>
Set <code>massDynamics=if interzonalAirFlow.prescribesPressure then Modelica.Fluid.Types.Dynamics.SteadyState</code>
such that the state is removed when the pressure is prescribed.
See <a href=https://github.com/open-ideas/IDEAS/issues/1021>#1021</a>.
</li>
<li>
April 11, 2019 by Filip Jorissen:<br/>
Revised implementation such that default value of relative humidity is
used when using a dry air medium.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1011\">#1011</a>.
</li>
<li>
January 25, 2019 by Filip Jorissen:<br/>
Avoided redundant consistent initial equation for pressure in <code>airModel</code>.
See <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
November 5, 2018 by Filip Jorissen:<br/>
Propagated <code>T_start</code> into <code>radDistr</code>.
</li>
<li>
September 26, 2018 by Iago Cupeiro:<br/>
Implementation of the lighting model
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
<li>
September 24, 2018 by Filip Jorissen:<br/>
Fixed duplicate declaration of <code>V</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/917\">#917</a>.
</li>
<li>
July 27, 2018 by Filip Jorissen:<br/>
Added output for the CO2 concentration.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/868\">#868</a>.
</li>
<li>
July 11, 2018, Filip Jorissen:<br/>
Propagated <code>m_flow_nominal</code> for setting nominal values 
of <code>h_outflow</code> and <code>m_flow</code>
in <code>FluidPorts</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/859\">#859</a>.
</li>
<li>
May 29, 2018, Filip Jorissen:<br/>
Removed conditional fluid ports for JModelica compatibility.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/834\">#834</a>.
</li>
<li>
April 27, 2018 by Filip Jorissen:<br/>
Modified interfaces for supporting new interzonal air flow models.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/796\">#796</a>.
</li>
<li>
April 12, 2018 by Filip Jorissen:<br/>
Propagated <code>energyDynamicsAir</code>.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/800>#800</a>.
</li>
<li>
March 29, 2018 by Filip Jorissen:<br/>
Propagated <code>mSenFac</code> to <code>airModel</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/792\">#792</a>.
</li>
<li>
March 28, 2018 by Filip Jorissen:<br/>
Added option for introducing state for
radiative temperature.
</li>
<li>
July 26, 2018 by Filip Jorissen:<br/>
Added replaceable block that allows to define
the number of occupants.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed linearisation and conservation of energy implementations for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
February 1, 2017 by Filip Jorissen:<br/>
Added option for disabling new view factor computation.
See issue
<a href=https://github.com/open-ideas/IDEAS/issues/663>#663</a>.
</li>
<li>
January 24, 2017 by Filip Jorissen:<br/>
Made <code>radDistr</code> replaceable
such that it can be redeclared in experimental models.
</li>
<li>
January 19, 2017 by Filip Jorissen:<br/>
Propagated linearisation parameters for interior radiative heat exchange.
</li>
<li>
August 26, 2016 by Filip Jorissen:<br/>
Added support for conservation of energy of air model.
</li>
<li>
April 30, 2016, by Filip Jorissen:<br/>
Added replaceable air model implementation.
</li>
<li>
March, 2015, by Filip Jorissen:<br/>
Added view factor implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Partial model that defines the main variables and connectors of a zone model.
</p>
</html>"));
        end PartialZone;

        connector RealConnector =
                            Real "Real connector without input/output specifier"
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)));

        partial model RectangularZoneTemplateInterface
          "Rectangular zone including walls, floor and ceiling"
          extends IDEAS.Buildings.Components.Interfaces.PartialZone(
            calculateViewFactor=false,
            final nSurf=indWinCei+nSurfExt,
            final V=A*h,
            final A=AZone,
            final hZone=h,
            final fRH=11);

          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypA
            "Modelled boundary for face A of the zone"
            annotation(Dialog(tab="Face A", group="Construction details"));
          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypB
            "Modelled boundary for face B of the zone"
            annotation(Dialog(tab="Face B", group="Construction details"));
          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypC
            "Modelled boundary for face C of the zone"
            annotation(Dialog(tab="Face C", group="Construction details"));
          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypD
            "Modelled boundary for face D of the zone"
            annotation(Dialog(tab="Face D", group="Construction details"));
          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypFlo
            "Modelled boundary for the zone floor"
            annotation(Dialog(tab="Floor", group="Construction details"));
          parameter IDEAS.Buildings.Components.Interfaces.BoundaryType bouTypCei
            "Modelled boundary for the zone ceiling"
            annotation(Dialog(tab="Ceiling", group="Construction details"));
          parameter Integer nExtA(min=0) = 1 "Number of external surfaces connected to face A"
            annotation(Dialog(tab="Face A", group="Construction details",
                       enable=bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));
          parameter Integer nExtB(min=0) = 1 "Number of external surfaces connected to face B"
            annotation(Dialog(tab="Face B", group="Construction details",
                       enable=bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));
          parameter Integer nExtC(min=0) = 1 "Number of external surfaces connected to face C"
            annotation(Dialog(tab="Face C", group="Construction details",
                       enable=bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));
          parameter Integer nExtD(min=0) = 1 "Number of external surfaces connected to face D"
            annotation(Dialog(tab="Face D", group="Construction details",
                       enable=bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));
          parameter Integer nExtFlo(min=0) = 1 "Number of external surfaces connected to floor"
            annotation(Dialog(tab="Floor", group="Construction details",
                       enable=bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));
          parameter Integer nExtCei(min=0) = 1 "Number of external surfaces connected to ceiling"
            annotation(Dialog(tab="Ceiling", group="Construction details",
                       enable=bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.External));

          parameter Boolean hasWinA = false
            "Modelling window for face A if true"
            annotation(Dialog(tab="Face A", group="Window details", enable=not (bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.None)));
          parameter Boolean hasWinB = false
            "Modelling window for face B if true"
            annotation(Dialog(tab="Face B", group="Window details", enable=not (bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.None)));
          parameter Boolean hasWinC = false
            "Modelling window for face C if true"
            annotation(Dialog(tab="Face C", group="Window details", enable=not (bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.None)));
          parameter Boolean hasWinD = false
            "Modelling window for face D if true"
            annotation(Dialog(tab="Face D", group="Window details", enable=not (bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.None)));
          parameter Boolean hasWinCei = false
            "Modelling window for ceiling if true"
            annotation(Dialog(tab="Ceiling", group="Window details", enable=not (bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.None)));
          parameter Boolean hasInt = false
            "If true, the zone contains an internal wall with both faces connected to the zone"
            annotation(Dialog(tab="Internal wall"));
          parameter Integer nSurfExt = 0
            "Number of additional connected external surfaces";
          parameter Integer aziOpt = 5
            "Azimuth angle option from simInfoManager, or custom using aziA"
            annotation(choices(__Dymola_radioButtons=true, choice=1 "South", choice=2 "West", choice=3 "North", choice=4 "East", choice=5 "Custom"));
          parameter Modelica.SIunits.Angle aziA=sim.aziOpts[aziOpt]
            "Azimuth angle of face A"
            annotation(Dialog(enable=aziOpt==5));
          parameter Modelica.SIunits.Length l
            "Horizontal length of faces A and C. This parameter can be overwritten per surface";
          parameter Modelica.SIunits.Length w
            "Horizontal length of faces B and D. This parameter can be overwritten per surface";
          parameter Modelica.SIunits.Length lA = l
            "Horizontal length of face A" annotation(Dialog(tab="Face A", group="Overwrite"));
          parameter Modelica.SIunits.Length lB = w
            "Horizontal length of face B" annotation(Dialog(tab="Face B", group="Overwrite"));
          parameter Modelica.SIunits.Length lC = l
            "Horizontal length of face C" annotation(Dialog(tab="Face C", group="Overwrite"));
          parameter Modelica.SIunits.Length lD = w
            "Horizontal length of face D" annotation(Dialog(tab="Face D", group="Overwrite"));
          parameter Modelica.SIunits.Length lInt = lA
            "Horizontal length of internal wall contained within the zone" annotation(Dialog(tab="Internal wall", group="Construction details", enable=hasInt));
          parameter Modelica.SIunits.Area AZone = w*l
            "Parameter to overwrite the zone surface area"
                                          annotation(Dialog(tab="Advanced", group="Overwrite"));
          parameter Modelica.SIunits.Area ACei = w*l "Surface of roof or ceiling (including potential windows)"
            annotation(Dialog(tab="Ceiling", group="Overwrite"));

          parameter Modelica.SIunits.Length h
            "Height between top of floor and bottom of ceiling";
          parameter Modelica.SIunits.Area A_winA=0
            "Surface area of window of face A"
            annotation(Dialog(tab="Face A", group="Window details",
            enable=hasWinA));
          parameter Modelica.SIunits.Area A_winB=0
            "Surface area of window of face B"
            annotation(Dialog(tab="Face B", group="Window details",
            enable=hasWinB));
          parameter Modelica.SIunits.Area A_winC=0
            "Surface area of window of face C"
            annotation(Dialog(tab="Face C", group="Window details",
            enable=hasWinC));
          parameter Modelica.SIunits.Area A_winD=0
            "Surface area of window of face D"
            annotation(Dialog(tab="Face D", group="Window details",
            enable=hasWinD));
          parameter Modelica.SIunits.Area A_winCei=0
            "Surface area of window of ceiling"
            annotation(Dialog(tab="Ceiling", group="Window details",
            enable=hasWinCei));

          parameter Real fracA=0.15
            "Area fraction of the window frame of face A"
            annotation(Dialog(tab="Face A", group="Window details",
            enable=hasWinA));
          parameter Real fracB=0.15
            "Area fraction of the window frame of face B"
            annotation(Dialog(tab="Face B", group="Window details",
            enable=hasWinB));
          parameter Real fracC=0.15
            "Area fraction of the window frame of face C"
            annotation(Dialog(tab="Face C", group="Window details",
            enable=hasWinC));
          parameter Real fracD=0.15
            "Area fraction of the window frame of face D"
            annotation(Dialog(tab="Face D", group="Window details",
            enable=hasWinD));
          parameter Real fracCei=0.15
            "Area fraction of the window frame of the ceiling"
            annotation(Dialog(tab="Ceiling", group="Window details",
            enable=hasWinCei));
          parameter Real nWinA=1
            "Scaling factor to model nWinA identical windows in facade A"
            annotation(Dialog(tab="Face A", group="Window details",
            enable=hasWinA));
          parameter Real nWinB=1
            "Scaling factor to model nWinB identical windows in facade B"
            annotation(Dialog(tab="Face B", group="Window details",
            enable=hasWinB));
          parameter Real nWinC=1
            "Scaling factor to model nWinC identical windows in facade C"
            annotation(Dialog(tab="Face C", group="Window details",
            enable=hasWinC));
          parameter Real nWinD=1
            "Scaling factor to model nWinD identical windows in facade D"
            annotation(Dialog(tab="Face D", group="Window details",
            enable=hasWinD));
          parameter Real nWinCei=1
            "Scaling factor to model nWinCei identical windows in the ceiling"
            annotation(Dialog(tab="Ceiling", group="Window details",
            enable=hasWinCei));

          parameter Boolean linIntCon=sim.linIntCon
            "= true, if convective heat transfer should be linearised"
            annotation(Dialog(tab="Advanced", group="Convective heat exchange"));
          parameter Interfaces.WindowDynamicsType windowDynamicsType=IDEAS.Buildings.Components.Interfaces.WindowDynamicsType.Two
            "Type of dynamics for glazings and frames: using zero, one combined or two states"
            annotation(Dialog(group="Windows", tab="Advanced"));
          parameter SI.TemperatureDifference dT_nominal_win=-3
            "Nominal temperature difference used for linearisation, negative temperatures indicate the solid is colder"
            annotation(Dialog(group="Convective heat transfer", tab="Advanced"));
          parameter Boolean linExtCon=sim.linExtCon
            "= true, if exterior convective heat transfer should be linearised (uses average wind speed)"
            annotation(Dialog(tab="Advanced", group="Convective heat exchange"));
          parameter Boolean linExtRad=sim.linExtRad
            "= true, if exterior radiative heat transfer for walls should be linearised"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange"));
          parameter Boolean linExtRadWin=sim.linExtRadWin
            "= true, if exterior radiative heat transfer for windows should be linearised"
            annotation(Dialog(tab="Advanced", group="Radiative heat exchange"));

          parameter Real mSenFac(min=0.1)=5
            "Factor for scaling the sensible thermal mass of the zone air"
            annotation(Dialog(tab="Advanced",group="Air model"));
          parameter SI.TemperatureDifference dT_nominal_bou=-1
            "Nominal temperature difference for boundary walls, used for linearisation, negative temperatures indicate the solid is colder"
            annotation(Dialog(tab="Advanced", group="Convective heat transfer"));
          parameter SI.TemperatureDifference dT_nominal_out=-3
            "Nominal temperature difference for outer walls, used for linearisation, negative temperatures indicate the solid is colder"
            annotation(Dialog(tab="Advanced", group="Convective heat transfer"));
          parameter SI.TemperatureDifference dT_nominal_sla=-3
            "Nominal temperature difference of slab on ground, used for linearisation, negative temperatures indicate the solid is colder"
            annotation(Dialog(tab="Advanced", group="Convective heat transfer"));
          parameter SI.Temperature TeAvg=273.15 + 10.8
            "Annual average outdoor temperature"
            annotation(Dialog(tab="Floor", group="Slab on ground", enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));
          parameter SI.Temperature TiAvg=273.15 + 22
            "Annual average indoor temperature"
            annotation(Dialog(tab="Floor", group="Slab on ground", enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));
          parameter SI.TemperatureDifference dTeAvg=4
            "Amplitude of variation of monthly average outdoor temperature"
            annotation(Dialog(tab="Floor", group="Slab on ground", enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));
          parameter SI.TemperatureDifference dTiAvg=2
            "Amplitude of variation of monthly average indoor temperature"
            annotation(Dialog(tab="Floor", group="Slab on ground", enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));
          parameter SI.TemperatureDifference dT_nominal_intA=1
            "Nominal temperature difference between zone air and interior walls, used for linearisation"
            annotation(Dialog(tab="Advanced", group="Convective heat transfer"));
          parameter SI.TemperatureDifference dT_nominal_intB=1
            "Nominal temperature difference between interior walls exterior connection, used for linearisation"
            annotation(Dialog(tab="Advanced", group="Convective heat transfer"));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypA
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of face A" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,8},{-224,12}})),
            Dialog(tab="Face A",group="Construction details",
                   enable=not (bouTypA==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypA==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypB
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of face B" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-12},{-224,-8}})),
            Dialog(tab="Face B",group="Construction details",
                   enable=not (bouTypB==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypB==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypC
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of face C" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-32},{-224,-28}})),
            Dialog(tab="Face C",group="Construction details",
                   enable=not (bouTypC==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypC==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypD
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of face D" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-52},{-224,-48}})),
            Dialog(tab="Face D",group="Construction details",
                   enable=not (bouTypD==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypD==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypCei
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of ceiling" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-92},{-224,-88}})),
            Dialog(tab="Ceiling",group="Construction details",
                   enable=not (bouTypCei==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypCei==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypFlo
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of floor" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-72},{-224,-68}})),
            Dialog(tab="Floor",group="Construction details",
                   enable=not (bouTypFlo==IDEAS.Buildings.Components.Interfaces.BoundaryType.None) and not
                         (bouTypFlo==IDEAS.Buildings.Components.Interfaces.BoundaryType.External)));
          replaceable parameter IDEAS.Buildings.Data.Constructions.CavityWall conTypInt
            constrainedby IDEAS.Buildings.Data.Interfaces.Construction
            "Material structure of internal wall" annotation (
            choicesAllMatching=true,
            Placement(transformation(extent={{-228,-72},{-224,-68}})),
            Dialog(tab="Internal wall",group="Construction details", enable=hasInt));
          replaceable IDEAS.Buildings.Data.Glazing.Ins2 glazingA
            constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type of window of face A"
            annotation (choicesAllMatching=true,
            Dialog(tab="Face A", group="Window details",
                   enable = hasWinA));
          replaceable IDEAS.Buildings.Data.Glazing.Ins2 glazingB
            constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type of window of face B"
            annotation (choicesAllMatching=true,
            Dialog(tab="Face B", group="Window details",
                   enable = hasWinB));
          replaceable IDEAS.Buildings.Data.Glazing.Ins2 glazingC
            constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type of window of face C"
            annotation (choicesAllMatching=true,
            Dialog(tab="Face C", group="Window details",
                   enable = hasWinC));
          replaceable IDEAS.Buildings.Data.Glazing.Ins2 glazingD
            constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type of window of face D"
            annotation (choicesAllMatching=true,
            Dialog(tab="Face D", group="Window details",
                   enable = hasWinD));
          replaceable IDEAS.Buildings.Data.Glazing.Ins2 glazingCei
            constrainedby IDEAS.Buildings.Data.Interfaces.Glazing "Glazing type of window of ceiling"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Ceiling", group="Window details",
                   enable = hasWinCei));

          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaTypA
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading type and properties of window of face A"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Face A", group="Window details",
                   enable = hasWinA));
          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaTypB
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading type and properties of window of face B"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Face B", group="Window details",
                   enable = hasWinB));
          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaTypC
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading type and properties of window of face C"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Face C", group="Window details",
                   enable = hasWinC));
          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaTypD
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading type and properties of window of face D"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Face D", group="Window details",
                   enable = hasWinD));
          replaceable parameter IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties shaTypCei
            constrainedby
          IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
            "Shading type and properties of window of ceiling"
            annotation (
                   choicesAllMatching=true,
                   Dialog(tab="Ceiling", group="Window details",
                   enable = hasWinCei));
          replaceable parameter IDEAS.Buildings.Data.Frames.None fraTypA
            constrainedby IDEAS.Buildings.Data.Interfaces.Frame
            "Window frame type for surface A"
            annotation (choicesAllMatching=true,
                        Dialog(tab="Face A", group="Window details", enable=hasWinA));
          replaceable parameter IDEAS.Buildings.Data.Frames.None fraTypB
            constrainedby IDEAS.Buildings.Data.Interfaces.Frame
            "Window frame type for surface B"
            annotation (choicesAllMatching=true,
                        Dialog(tab="Face B", group="Window details", enable=hasWinB));
          replaceable parameter IDEAS.Buildings.Data.Frames.None fraTypC
            constrainedby IDEAS.Buildings.Data.Interfaces.Frame
            "Window frame type for surface C"
            annotation (choicesAllMatching=true,
                        Dialog(tab="Face C", group="Window details", enable=hasWinC));
          replaceable parameter IDEAS.Buildings.Data.Frames.None fraTypD
            constrainedby IDEAS.Buildings.Data.Interfaces.Frame
            "Window frame type for surface D"
            annotation (choicesAllMatching=true,
                        Dialog(tab="Face D", group="Window details", enable=hasWinD));
          replaceable parameter IDEAS.Buildings.Data.Frames.None fraTypCei
            constrainedby IDEAS.Buildings.Data.Interfaces.Frame
            "Window frame type for surface Cei"
            annotation (choicesAllMatching=true,
                        Dialog(tab="Ceiling", group="Window details", enable=hasWinCei));

          // open door modelling
          parameter Boolean hasCavityA = false
            "=true, to model open door or cavity in internal wall"
            annotation(Dialog(tab="Face A", group="Cavity or open door", enable=(bouTypeA==IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall)));
          parameter Modelica.SIunits.Length hA(min=0) = 2
            "Height of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityA,tab="Face A", group="Cavity or open door"));
          parameter Modelica.SIunits.Length wA(min=0) = 1
            "Width of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityA,tab="Face A", group="Cavity or open door"));
          parameter Boolean hasCavityB = false
            "=true, to model open door or cavity in internal wall"
            annotation(Dialog(tab="Face B", group="Cavity or open door", enable=(bouTypeB==IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall)));
          parameter Modelica.SIunits.Length hB(min=0) = 2
            "Height of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityB,tab="Face B", group="Cavity or open door"));
          parameter Modelica.SIunits.Length wB(min=0) = 1
            "Width of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityB,tab="Face B", group="Cavity or open door"));
          parameter Boolean hasCavityC = false
            "=true, to model open door or cavity in internal wall"
            annotation(Dialog(tab="Face C", group="Cavity or open door", enable=(bouTypeC==IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall)));
          parameter Modelica.SIunits.Length hC(min=0) = 2
            "Height of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityC,tab="Face C", group="Cavity or open door"));
          parameter Modelica.SIunits.Length wC(min=0) = 1
            "Width of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityC,tab="Face C", group="Cavity or open door"));
          parameter Boolean hasCavityD = false
            "=true, to model open door or cavity in internal wall"
            annotation(Dialog(tab="Face D", group="Cavity or open door", enable=(bouTypeD==IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall)));
          parameter Modelica.SIunits.Length hD(min=0) = 2
            "Height of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityD,tab="Face D", group="Cavity or open door"));
          parameter Modelica.SIunits.Length wD(min=0) = 1
            "Width of (rectangular) cavity in internal wall"
             annotation(Dialog(enable=hasCavityD,tab="Face D", group="Cavity or open door"));
          parameter Modelica.SIunits.Acceleration g = Modelica.Constants.g_n
            "Gravity, for computation of buoyancy"
            annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
          parameter Modelica.SIunits.Pressure p = 101300
            "Absolute pressure for computation of buoyancy"
            annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
          parameter Modelica.SIunits.Density rho = p/r/T
            "Nominal density for computation of buoyancy mass flow rate"
            annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
          parameter Modelica.SIunits.SpecificHeatCapacity c_p = 1013
           "Nominal heat capacity for computation of buoyancy heat flow rate"
           annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
          parameter Modelica.SIunits.Temperature T = 293.15
           "Nominal temperature for linearising heat flow rate"
           annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));
          parameter Modelica.SIunits.TemperatureDifference dT = 1
           "Nominal temperature difference when linearising heat flow rate"
           annotation(Dialog(enable=hasCavity,group="Cavity or open door",tab="Advanced"));

          parameter Boolean hasBuildingShadeA=false
            "=true, to enable computation of shade cast by opposite building or object on OuterWall"
            annotation(Dialog(tab="Face A", group="Building shade", enable=(bouTypA==IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall)));
          parameter SI.Length LShaA=0
            "Distance between shading object and wall, perpendicular to wall"
            annotation(Dialog(enable=hasBuildingShadeA,tab="Face A", group="Building shade"));
          parameter SI.Length dhShaA=0
            "Height difference between top of shading object and top of wall A"
            annotation(Dialog(enable=hasBuildingShadeA,tab="Face A", group="Building shade"));
          parameter Boolean hasBuildingShadeB=false
            "=true, to enable computation of shade cast by opposite building or object on OuterWall"
            annotation(Dialog(tab="Face B", group="Building shade", enable=(bouTypB==IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall)));
          parameter SI.Length LShaB=0
            "Distance between shading object and wall, perpendicular to wall"
            annotation(Dialog(enable=hasBuildingShadeB,tab="Face B", group="Building shade"));
          parameter SI.Length dhShaB=0
            "Height difference between top of shading object and top of wall B"
            annotation(Dialog(enable=hasBuildingShadeB,tab="Face B", group="Building shade"));
          parameter Boolean hasBuildingShadeC=false
            "=true, to enable computation of shade cast by opposite building or object on OuterWall"
            annotation(Dialog(tab="Face C", group="Building shade", enable=(bouTypC==IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall)));
          parameter SI.Length LShaC=0
            "Distance between shading object and wall, perpendicular to wall"
            annotation(Dialog(enable=hasBuildingShadeC,tab="Face C", group="Building shade"));
          parameter SI.Length dhShaC=0
            "Height difference between top of shading object and top of wall C"
            annotation(Dialog(enable=hasBuildingShadeC,tab="Face C", group="Building shade"));
          parameter Boolean hasBuildingShadeD=false
            "=true, to enable computation of shade cast by opposite building or object on OuterWall"
            annotation(Dialog(tab="Face D", group="Building shade", enable=(bouTypD==IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall)));
          parameter SI.Length LShaD=0
            "Distance between shading object and wall, perpendicular to wall"
            annotation(Dialog(enable=hasBuildingShadeD,tab="Face D", group="Building shade"));
          parameter SI.Length dhShaD=0
            "Height difference between top of shading object and top of wall D"
            annotation(Dialog(enable=hasBuildingShadeD,tab="Face D", group="Building shade"));
          parameter SI.Length PWall = (if hasOutA then lA else 0) + (if hasOutB then lB else 0) + (if hasOutC then lC else 0) + (if hasOutD then lD else 0)
            "Total floor slab perimeter length" annotation(Dialog(tab="Advanced", group="SlabOnGround", enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));

          parameter Boolean hasEmb = false
            "Set to true if floor is equipped with floor heating or concrete core activation"
          annotation(Dialog(tab="Floor", group="Floor heating / CCA",
                    enable=(bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
                            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall or
                            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround)));
          final parameter Modelica.SIunits.Angle aziB = aziAInt + Modelica.Constants.pi/2
            "Azimuth angle of face B";
          final parameter Modelica.SIunits.Angle aziC = aziAInt + Modelica.Constants.pi
            "Azimuth angle of face C";
          final parameter Modelica.SIunits.Angle aziD = aziAInt + 3*Modelica.Constants.pi/2
            "Azimuth angle of face D";

          IDEAS.Buildings.Components.Interfaces.ZoneBus[nSurfExt] proBusExt(
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if nSurfExt>0
            "Propsbus for connecting additional external surfaces" annotation (
              Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-210,50}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=180,
                origin={-120,100})));

      protected
          constant Real r = 287 "Gas constant";
          final parameter Modelica.SIunits.Angle aziAInt=
             if aziOpt==5
             then aziA
             else sim.aziOpts[aziOpt]
             "Internal azimuth angle";
          final parameter Integer nGainEmb = conTypFlo.nGain "Number of planes in which CCA or FH pipes are located"
            annotation(Dialog(tab="Floor", group="Floor heating / CCA"));
          IDEAS.Buildings.Components.BoundaryWall bouA(azi=aziAInt, inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypA.locGain,
              incLastLay=conTypA.incLastLay,
              mats=conTypA.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou,
            A=AWallANet) if
               hasBouA
            "Boundary wall for face A of this zone"
            annotation (Placement(transformation(extent={{-120,0},{-110,20}})));
          IDEAS.Buildings.Components.BoundaryWall bouB(
                   inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypB.locGain,
              incLastLay=conTypB.incLastLay,
              mats=conTypB.mats),
            azi=aziB,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou,
            A=AWallBNet) if
               hasBouB
            "Boundary wall for face A of this zone"
            annotation (Placement(transformation(extent={{-120,-20},{-110,0}})));
          IDEAS.Buildings.Components.BoundaryWall bouC(inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypC.locGain,
              incLastLay=conTypC.incLastLay,
              mats=conTypC.mats),
            azi=aziC,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou,
            A=AWallCNet) if
               hasBouC
            "Boundary wall for face C of this zone"
            annotation (Placement(transformation(extent={{-120,-40},{-110,-20}})));
          IDEAS.Buildings.Components.BoundaryWall bouD(inc=IDEAS.Types.Tilt.Wall, azi=aziD,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypD.locGain,
              incLastLay=conTypD.incLastLay,
              mats=conTypD.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou,
            A=AWallDNet) if
               hasBouD
            "Boundary wall for face D of this zone"
            annotation (Placement(transformation(extent={{-120,-60},{-110,-40}})));
          IDEAS.Buildings.Components.BoundaryWall bouFlo(inc=IDEAS.Types.Tilt.Floor, azi=aziAInt,
            A=A,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypFlo.locGain,
              incLastLay=conTypFlo.incLastLay,
              mats=conTypFlo.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou) if
               hasBouFlo
            "Boundary wall for zone floor"
            annotation (Placement(transformation(extent={{-120,-80},{-110,-60}})));
          IDEAS.Buildings.Components.BoundaryWall bouCei(inc=IDEAS.Types.Tilt.Ceiling, azi=aziAInt,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypCei.locGain,
              incLastLay=conTypCei.incLastLay,
              mats=conTypCei.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_bou,
            A=ACeiNet) if
               hasBouCei
            "Boundary wall for zone ceiling"
            annotation (Placement(transformation(extent={{-120,-100},{-110,-80}})));
          IDEAS.Buildings.Components.OuterWall outA(azi=aziAInt, inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypA.locGain,
              incLastLay=conTypA.incLastLay,
              mats=conTypA.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_out,
            linExtCon=linExtCon,
            linExtRad=linExtRad,
            A=max(0,AWallANet),
            final hWal=h,
            final hasBuildingShade=hasBuildingShadeA,
            final L=LShaA,
            final dh=dhShaA) if
               hasOutA
            "Outer wall for face A of this zone"
            annotation (Placement(transformation(extent={{-140,0},{-130,20}})));
          IDEAS.Buildings.Components.OuterWall outB(
              inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypB.locGain,
              incLastLay=conTypB.incLastLay,
              mats=conTypB.mats),
            azi=aziB,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_out,
            linExtCon=linExtCon,
            linExtRad=linExtRad,
            A=max(0,AWallBNet),
            final hasBuildingShade=hasBuildingShadeB,
            final L=LShaB,
            final dh=dhShaB,
            final hWal=h) if
               hasOutB
            "Outer wall for face B of this zone"
            annotation (Placement(transformation(extent={{-140,-20},{-130,0}})));
          IDEAS.Buildings.Components.OuterWall outC(inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypC.locGain,
              incLastLay=conTypC.incLastLay,
              mats=conTypC.mats),
            azi=aziC,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_out,
            linExtCon=linExtCon,
            linExtRad=linExtRad,
            A=max(0,AWallCNet),
            final hasBuildingShade=hasBuildingShadeC,
            final L=LShaC,
            final dh=dhShaC,
            final hWal=h) if
               hasOutC
            "Outer wall for face C of this zone"
            annotation (Placement(transformation(extent={{-140,-40},{-130,-20}})));
          IDEAS.Buildings.Components.OuterWall outD(inc=IDEAS.Types.Tilt.Wall, azi=aziD,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypD.locGain,
              incLastLay=conTypD.incLastLay,
              mats=conTypD.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_out,
            linExtCon=linExtCon,
            linExtRad=linExtRad,
            A=max(0,AWallDNet),
            final hasBuildingShade=hasBuildingShadeD,
            final L=LShaD,
            final dh=dhShaD,
            final hWal=h) if
               hasOutD
            "Outer wall for face D of this zone"
            annotation (Placement(transformation(extent={{-140,-60},{-130,-40}})));
          IDEAS.Buildings.Components.OuterWall outCei(
            inc=IDEAS.Types.Tilt.Ceiling,
            azi=aziAInt,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypCei.locGain,
              incLastLay=conTypCei.incLastLay,
              mats=conTypCei.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_out,
            linExtCon=linExtCon,
            linExtRad=linExtRad,
            A=max(0,ACeiNet)) if
               hasOutCei
            "Outer wall for zone ceiling"
            annotation (Placement(transformation(extent={{-140,-100},{-130,-80}})));
          IDEAS.Buildings.Components.SlabOnGround slaOnGro(
            inc=IDEAS.Types.Tilt.Floor,
            azi=aziAInt,
            A=A,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypFlo.locGain,
              incLastLay=conTypFlo.incLastLay,
              mats=conTypFlo.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            TeAvg=TeAvg,
            TiAvg=TiAvg,
            dTeAvg=dTeAvg,
            dTiAvg=dTiAvg,
            dT_nominal_a=dT_nominal_sla,
            PWall=PWall) if
             bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround
            "Slab on ground model for zone floor."
            annotation (Placement(transformation(extent={{-160,-80},{-150,-60}})));
          IDEAS.Buildings.Components.InternalWall intA(azi=aziAInt, inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypA.locGain,
              mats=conTypA.mats,
              incLastLay=conTypA.incLastLay),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intB,
            hasCavity=hasCavityA,
            h=hA,
            w=wA,
            g=g,
            p=p,
            rho=rho,
            c_p=c_p,
            T=T,
            dT=dT,
            A=lA*h - (if hasCavityA then hA*wA else 0)) if
            hasIntA
            "Internal wall for face A of this zone"
            annotation (Placement(transformation(extent={{-176,0},{-164,20}})));
          IDEAS.Buildings.Components.InternalWall intB(
                   inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypB.locGain,
              incLastLay=conTypB.incLastLay,
              mats=conTypB.mats),
            azi=aziB,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intB,
            g=g,
            p=p,
            rho=rho,
            c_p=c_p,
            T=T,
            dT=dT,
            hasCavity=hasCavityB,
            h=hB,
            w=wB,
            A=lB*h - (if hasCavityB then hB*wB else 0)) if
            hasIntB
            "Internal wall for face B of this zone"
            annotation (Placement(transformation(extent={{-176,-20},{-164,0}})));
          IDEAS.Buildings.Components.InternalWall intC(inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypC.locGain,
              incLastLay=conTypC.incLastLay,
              mats=conTypC.mats),
            azi=aziC,
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intB,
            g=g,
            p=p,
            rho=rho,
            c_p=c_p,
            T=T,
            dT=dT,
            hasCavity=hasCavityC,
            h=hC,
            w=wC,
            A=lC*h - (if hasCavityC then hC*wC else 0)) if
            hasIntC
            "Internal wall for face C of this zone"
            annotation (Placement(transformation(extent={{-176,-40},{-164,-20}})));
          IDEAS.Buildings.Components.InternalWall intD(inc=IDEAS.Types.Tilt.Wall, azi=aziD,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypD.locGain,
              incLastLay=conTypD.incLastLay,
              mats=conTypD.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intB,
            g=g,
            p=p,
            rho=rho,
            c_p=c_p,
            T=T,
            dT=dT,
            hasCavity=hasCavityD,
            h=hD,
            w=wD,
            A=lD*h - (if hasCavityD then hD*wD else 0)) if
            hasIntD
            "Internal wall for face D of this zone"
            annotation (Placement(transformation(extent={{-176,-60},{-164,-40}})));
          IDEAS.Buildings.Components.InternalWall intFlo(
            inc=IDEAS.Types.Tilt.Floor,
            azi=aziAInt,
            A=A,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypFlo.locGain,
              incLastLay=conTypFlo.incLastLay,
              mats=conTypFlo.mats),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intB) if
            hasIntFlo
            "Internal wall for zone floor"
            annotation (Placement(transformation(extent={{-176,-80},{-164,-60}})));

          IDEAS.Buildings.Components.InternalWall int(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall constructionType(
              locGain=conTypInt.locGain,
              mats=conTypInt.mats,
              incLastLay=conTypInt.incLastLay),
            T_start=T_start,
            linIntCon_a=linIntCon,
            dT_nominal_a=dT_nominal_intA,
            linIntCon_b=linIntCon,
            dT_nominal_b=dT_nominal_intA,
            azi=0,
            A=lInt*h,
            final hasCavity=false) if
            hasInt "Internal wall contained within the zone"
            annotation (Placement(transformation(extent={{-176,20},{-164,40}})));
      public
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusA[nExtA](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface or internalWall of face A"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,10}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=180,
                origin={-60,90})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusB[nExtB](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface or internalWall of face B"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,-10}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=90,
                origin={90,60})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusC[nExtC](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface or internalWall of face C"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,-30}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=0,
                origin={68,-98})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusD[nExtD](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface or internalWall of face D"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,-50}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-96,-70})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusFlo[nExtFlo](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface or internalWall of floor"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,-70}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=180,
                origin={0,-60})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus proBusCei[nExtCei](
            each final numIncAndAziInBus=sim.numIncAndAziInBus,
            each final outputAngles=sim.outputAngles) if
            bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
            "Propsbus connector for connecting to external surface of ceiling: internal walls should be modelled as the floor of the zone above"
            annotation (Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={-188,-90}), iconTransformation(
                extent={{-20,20},{20,-20}},
                rotation=180,
                origin={-2,60})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b gainEmb[nGainEmb] if
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall or
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround
            "Floor node for embedded heat gain if case of floor heating or CCA."
            annotation (Placement(transformation(extent={{90,-100},{110,-80}})));
      protected
          final parameter Boolean hasBouA=
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasBouB=
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasBouC=
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasBouD=
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasBouFlo=
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasBouCei=
            bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall;
          final parameter Boolean hasOutA=
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall;
          final parameter Boolean hasOutB=
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall;
          final parameter Boolean hasOutC=
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall;
          final parameter Boolean hasOutD=
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall;
          final parameter Boolean hasOutCei=
            bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall;
          final parameter Boolean hasIntA=
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall;
          final parameter Boolean hasIntB=
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall;
          final parameter Boolean hasIntC=
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall;
          final parameter Boolean hasIntD=
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall;
          final parameter Boolean hasIntFlo=
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall;
          final parameter Boolean hasExtA=
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasExtB=
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasExtC=
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasExtD=
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasExtFlo=
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasExtCei=
            bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.External;
          final parameter Boolean hasNoA=
            bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;
          final parameter Boolean hasNoB=
            bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;
          final parameter Boolean hasNoC=
            bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;
          final parameter Boolean hasNoD=
            bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;
          final parameter Boolean hasNoFlo=
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;
          final parameter Boolean hasNoCei=
            bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.None;

          parameter Modelica.SIunits.Area AWallANet(fixed=false);
          parameter Modelica.SIunits.Area AWallBNet(fixed=false);
          parameter Modelica.SIunits.Area AWallCNet(fixed=false);
          parameter Modelica.SIunits.Area AWallDNet(fixed=false);
          parameter Modelica.SIunits.Area ACeiNet(fixed=false);

          final parameter Integer indWalA = if hasNoA then 0 else 1;
          final parameter Integer indWalA_end = indWalA + (if bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtA - 1  else 0);
          final parameter Integer indWalB = indWalA_end + (if hasNoB then 0 else 1);
          final parameter Integer indWalB_end = indWalB+ (if bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtB - 1  else 0);
          final parameter Integer indWalC = indWalB_end  + (if hasNoC then 0 else 1);
          final parameter Integer indWalC_end = indWalC + (if bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtC - 1  else 0);
          final parameter Integer indWalD = indWalC_end  + (if hasNoD then 0 else 1);
          final parameter Integer indWalD_end = indWalD + (if bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtD - 1  else 0);
          final parameter Integer indFlo = indWalD_end + (if hasNoFlo then 0 else 1);
          final parameter Integer indFlo_end = indFlo + (if bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtFlo - 1  else 0);
          final parameter Integer indCei = indFlo_end  + (if hasNoCei then 0 else 1);
          final parameter Integer indCei_end = indCei + (if bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.External
                                            then nExtCei - 1  else 0);
          final parameter Integer indIntZone_a = indCei_end + (if hasInt then 1 else 0);
          final parameter Integer indIntZone_b = indIntZone_a + (if hasInt then 1 else 0);
          final parameter Integer indWinA = indIntZone_b + (if hasWinA then 1 else 0);
          final parameter Integer indWinB = indWinA + (if hasWinB then 1 else 0);
          final parameter Integer indWinC = indWinB + (if hasWinC then 1 else 0);
          final parameter Integer indWinD = indWinC + (if hasWinD then 1 else 0);
          final parameter Integer indWinCei = indWinD + (if hasWinCei then 1 else 0);

        initial equation
          assert(not bouTypA==IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
            "The value for bouTypA is not supported");
          assert(not bouTypB==IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
            "The value for bouTypB is not supported");
          assert(not bouTypC==IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
            "The value for bouTypC is not supported");
          assert(not bouTypD==IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
            "The value for bouTypD is not supported");
          assert(not bouTypCei==IDEAS.Buildings.Components.Interfaces.BoundaryType.SlabOnGround,
            "The value for bouTypCei is not supported");
          assert(not (bouTypCei==IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
                      "Using internal walls for the ceiling is not allowed because it is considered bad practice. 
              Use instead the 'External'  connection to connect the the floor of the surface above, 
              or use this option to connect and internal wall externally.");
          assert(not (hasWinA and bouTypA == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
            "Combining an internal wall with an (exterior) window is not allowed since this is non-physical.");
          assert(not (hasWinB and bouTypB == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
            "Combining an internal wall with an (exterior) window is not allowed since this is non-physical.");
          assert(not (hasWinC and bouTypC == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
            "Combining an internal wall with an (exterior) window is not allowed since this is non-physical.");
          assert(not (hasWinD and bouTypD == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
            "Combining an internal wall with an (exterior) window is not allowed since this is non-physical.");
          assert(not (hasWinCei and bouTypCei == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall),
            "Combining an internal wall with an (exterior) window is not allowed since this is non-physical.");

          //assert that the cavity is not larger than the wall
          assert(not hasCavityA or (hA <= h and wA <=lA),
            "In " + getInstanceName() + ": The cavity dimensions of surface A exceed the zone dimensions. This is non-physical");
          assert(not hasCavityB or (hB <= h and wB <=lB),
            "In " + getInstanceName() + ": The cavity dimensions of surface B exceed the zone dimensions. This is non-physical");
          assert(not hasCavityC or (hC <= h and wC <=lC),
            "In " + getInstanceName() + ": The cavity dimensions of surface C exceed the zone dimensions. This is non-physical");
          assert(not hasCavityD or (hD <= h and wD <=lD),
            "In " + getInstanceName() + ": The cavity dimensions of surface D exceed the zone dimensions. This is non-physical");

          AWallANet = lA*h - (if hasWinA then  propsBusInt[indWinA].area else 0);
          AWallBNet = lB*h - (if hasWinB then  propsBusInt[indWinB].area else 0);
          AWallCNet = lC*h - (if hasWinC then  propsBusInt[indWinC].area else 0);
          AWallDNet = lD*h - (if hasWinD then  propsBusInt[indWinD].area else 0);
          ACeiNet = ACei - (if hasWinCei then  propsBusInt[indWinCei].area else 0);

          // assert that the windows are not bigger than the wall
          assert(AWallANet >= 0, "The net surface area of wall A is negative. This is not allowed.");
          assert(AWallBNet >= 0, "The net surface area of wall B is negative. This is not allowed.");
          assert(AWallDNet >= 0, "The net surface area of wall C is negative. This is not allowed.");
          assert(AWallDNet >= 0, "The net surface area of wall D is negative. This is not allowed.");
          assert(ACeiNet >= 0, "The net surface area of the ceiling is negative. This is not allowed.");

          if hasIntA then
            assert(nExtA == 1, "The parameter nExtA should be = 1 when internalWall type is chosen for surface A");
          end if;
          if hasIntB then
            assert(nExtB == 1, "The parameter nExtB should be = 1 when internalWall type is chosen for surface B");
          end if;
          if hasIntC then
            assert(nExtC == 1, "The parameter nExtC should be = 1 when internalWall type is chosen for surface C");
          end if;
          if hasIntD then
            assert(nExtD == 1, "The parameter nExtD should be = 1 when internalWall type is chosen for surface D");
          end if;
          if hasIntFlo then
            assert(nExtFlo == 1, "The parameter nExtFlo should be = 1 when internalWall type is chosen for Floor");
          end if;

          if hasWinCei then
            // note that w*l is the default value of ACei
            assert(abs(ACei-w*l) < 1e-6, "The overwrite parameter ACei should not be used when the roof has a window
                                  since then the window surface area cannot be factored in correctly.");
          end if;
        equation
          connect(intA.propsBus_a, propsBusInt[indWalA]) annotation (Line(
              points={{-165,12},{-152,12},{-152,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(intB.propsBus_a, propsBusInt[indWalB]) annotation (Line(
              points={{-165,-8},{-152,-8},{-152,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(intC.propsBus_a, propsBusInt[indWalC]) annotation (Line(
              points={{-165,-28},{-152,-28},{-152,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(intD.propsBus_a, propsBusInt[indWalD]) annotation (Line(
              points={{-165,-48},{-152,-48},{-152,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(intFlo.propsBus_a, propsBusInt[indFlo]) annotation (Line(
              points={{-165,-68},{-152,-68},{-152,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(int.propsBus_a, propsBusInt[indIntZone_a]) annotation (Line(
              points={{-165,32},{-80,32},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(int.propsBus_b, propsBusInt[indIntZone_b]) annotation (Line(
              points={{-175,32},{-180,32},{-180,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(outA.propsBus_a, propsBusInt[indWalA]) annotation (Line(
              points={{-130.833,12},{-130.833,12},{-124,12},{-124,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(outB.propsBus_a, propsBusInt[indWalB]) annotation (Line(
              points={{-130.833,-8},{-124,-8},{-124,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(outC.propsBus_a, propsBusInt[indWalC]) annotation (Line(
              points={{-130.833,-28},{-124,-28},{-124,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(outD.propsBus_a, propsBusInt[indWalD]) annotation (Line(
              points={{-130.833,-48},{-124,-48},{-124,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(slaOnGro.propsBus_a, propsBusInt[indFlo]) annotation (Line(
              points={{-150.833,-68},{-150.833,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(outCei.propsBus_a, propsBusInt[indCei]) annotation (Line(
              points={{-130.833,-88},{-124,-88},{-124,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouA.propsBus_a, propsBusInt[indWalA]) annotation (Line(
              points={{-110.833,12},{-110.833,12},{-106,12},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouB.propsBus_a, propsBusInt[indWalB]) annotation (Line(
              points={{-110.833,-8},{-106,-8},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouC.propsBus_a, propsBusInt[indWalC]) annotation (Line(
              points={{-110.833,-28},{-106,-28},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouD.propsBus_a, propsBusInt[indWalD]) annotation (Line(
              points={{-110.833,-48},{-106,-48},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouFlo.propsBus_a, propsBusInt[indFlo]) annotation (Line(
              points={{-110.833,-68},{-106,-68},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(bouCei.propsBus_a, propsBusInt[indCei]) annotation (Line(
              points={{-110.833,-88},{-106,-88},{-106,-76},{-106,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
          connect(intA.propsBus_b, proBusA[1]) annotation (Line(
              points={{-175,12},{-188,12},{-188,10}},
              color={255,204,51},
              thickness=0.5));
          connect(intB.propsBus_b, proBusB[1]) annotation (Line(
              points={{-175,-8},{-188,-8},{-188,-10}},
              color={255,204,51},
              thickness=0.5));
          connect(intC.propsBus_b, proBusC[1]) annotation (Line(
              points={{-175,-28},{-188,-28},{-188,-30}},
              color={255,204,51},
              thickness=0.5));
          connect(intD.propsBus_b, proBusD[1]) annotation (Line(
              points={{-175,-48},{-188,-48},{-188,-50}},
              color={255,204,51},
              thickness=0.5));
          connect(intFlo.propsBus_b, proBusFlo[1]) annotation (Line(
              points={{-175,-68},{-188,-68},{-188,-70}},
              color={255,204,51},
              thickness=0.5));
          if hasExtA then
            for i in indWalA:indWalA_end loop
            connect(proBusA[i-indWalA+1], propsBusInt[i]) annotation (Line(
              points={{-188,10},{-188,10},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;
          if hasExtB then
            for i in indWalB:indWalB_end loop
            connect(proBusB[i-indWalB+1], propsBusInt[i]) annotation (Line(
              points={{-188,-10},{-188,-10},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;
          if hasExtC then
            for i in indWalC:indWalC_end loop
            connect(proBusC[i-indWalC+1], propsBusInt[i]) annotation (Line(
              points={{-188,-30},{-188,-30},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;
          if hasExtD then
            for i in indWalD:indWalD_end loop
            connect(proBusD[i-indWalD+1], propsBusInt[i]) annotation (Line(
              points={{-188,-50},{-188,-50},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;
          if hasExtFlo then
            for i in indFlo:indFlo_end loop
            connect(proBusFlo[i-indFlo+1], propsBusInt[i]) annotation (Line(
              points={{-188,-70},{-188,-70},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;
          if hasExtCei then
            for i in indCei:indCei_end loop
            connect(proBusCei[i-indCei+1], propsBusInt[i]) annotation (Line(
              points={{-188,-90},{-188,-90},{-188,40},{-80,40}},
              color={255,204,51},
              thickness=0.5));
            end for;
          end if;

          connect(propsBusInt[(indWinCei+1):(indWinCei+nSurfExt)], proBusExt[1:nSurfExt]) annotation (Line(
              points={{-80,40},{-82,40},{-82,54},{-82,50},{-210,50}},
              color={255,204,51},
              thickness=0.5));
          connect(intFlo.port_emb, gainEmb) annotation (Line(points={{-170,-80},{-170,-104},
                  {100,-104},{100,-90}}, color={191,0,0}));
          connect(bouFlo.port_emb, gainEmb) annotation (Line(points={{-115,-80},{-88,-80},
                  {-88,-104},{100,-104},{100,-90}}, color={191,0,0}));
          connect(slaOnGro.port_emb, gainEmb) annotation (Line(points={{-155,-80},{-156,
                  -80},{-156,-104},{100,-104},{100,-90}}, color={191,0,0}));
            annotation(Dialog(tab="Floor", group="Floor heating / CCA", enable=
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall or
            bouTypFlo == IDEAS.Buildings.Components.Interfaces.BoundaryType.BoundaryWall),
                          Icon(coordinateSystem(preserveAspectRatio=false, initialScale=0.1),
                graphics={
                Text(
                  extent={{-60,-72},{-30,-38}},
                  lineColor={28,108,200},
                  textString="Flo"),
                Text(
                  extent={{120,-14},{140,20}},
                  lineColor={28,108,200},
                  textString="B"),
                Text(
                  extent={{-10,-122},{10,-94}},
                  lineColor={28,108,200},
                  textString="C"),
                Text(
                  extent={{-122,-14},{-102,20}},
                  lineColor={28,108,200},
                  textString="D"),
                Text(
                  extent={{18,44},{46,80}},
                  lineColor={28,108,200},
                  textString="Cei"),
                Text(
                  extent={{-10,114},{10,148}},
                  lineColor={28,108,200},
                  textString="A")}),                                     Diagram(
                coordinateSystem(preserveAspectRatio=false, extent={{-220,-100},{100,100}}),
                            graphics={
                Text(
                  extent={{-220,-60},{-200,-80}},
                  lineColor={28,108,200},
                  textString="Floor"),
                Text(
                  extent={{-220,-80},{-200,-100}},
                  lineColor={28,108,200},
                  textString="Ceiling"),
                Text(
                  extent={{-220,-40},{-200,-60}},
                  lineColor={28,108,200},
                  textString="D"),
                Text(
                  extent={{-220,-20},{-200,-40}},
                  lineColor={28,108,200},
                  textString="C"),
                Text(
                  extent={{-220,0},{-200,-20}},
                  lineColor={28,108,200},
                  textString="B"),
                Text(
                  extent={{-220,20},{-200,0}},
                  lineColor={28,108,200},
                  textString="A")}),
            Documentation(info="<html>
<p>
This model can be used to set up
zones with a rectangular geometry more quickly.
This template consists of a zone, four walls, a horizontal roof and a floor
and five optional windows.
Additional surfaces may also be connected through external bus connector.
For the documentation of the zone parameters, see the documentation of 
<a href=\"modelica://IDEAS.Buildings.Components.Zone\">Zone</a>.
</p>
<h4>Main equations</h4>
<p>
This model incorporates IDEAS components such as
<a href=modelica://IDEAS.Buildings.Components.OuterWall>
IDEAS.Buildings.Components.OuterWall</a> and reproduces
the same results as a model that would be constructed without 
the use of this template.
</p>
<h4>Assumption and limitations</h4>
<p>
This model assumes that the zone has a rectangular
geometry with width <code>w</code>, length <code>l</code>
and height <code>h</code>.
All walls are vertical and perpendicular to each other and both the roof and
the floor are horizontal.
</p>
<p>
The surface area of each wall is calculated by default using
the parameters <code>h, w</code> and <code>l</code>. If you want to split a wall
and add external walls using the external bus connector, use the overwrite
length parameters <code>lA, lB, lC, lD</code> from the <code>Face</code> tabs
such that the surface area of the wall is correct. Also the ceiling or roof
surface area can be overwritten using the parameter <code>ACei</code>
from the <code>Ceiling</code> tab.
This way the user can overwrite the default ceiling surface area, 
e.g. to better approximate an inclinated roof.
Be also aware that the model
<code>slabOnGround</code> has a parameter <code>PWall</code> which specifies the
perimeter of slab on ground. The model cannot detect external walls connected
using the external bus connector. When splitting outer walls by using the external bus connector
you should update this parameter
manually using the parameter <code>PWall</code> from the <code>Advanced</code> tab.
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameters width <code>w</code>, length <code>l</code>
and height <code>h</code> need to be defined
and are used to compute the dimensions of each of the surfaces.
Parameter <code>aziA</code> represents the azimuth angle
of surface A (see icon). Other surfaces are rotated (clockwise) by multiples
of ninety degrees with respect to <code>aziA</code>.
Parameter <code>nSurfExt</code> may be used
to connect additional surfaces to the template. 
When doing this, you may need to change the surface areas of
the surfaces in the template as these are not updated automatically.
</p>
<p>
Seven parameter tabs allow to specify further parameters
that are specific for each of the seven surfaces: six surfaces 
for the walls, floor and ceiling and one for an internal wall 
contained within the zone.
For each surface the surface type may be specified
using parameters <code>bouTyp*</code>.
The construction type should be defined
using <code>conTyp*</code>.
Parameter <code>hasWin*</code> may be used
for all orientations except for the floor to add
a window.
In this case the window surface area, shading and glazing 
types need to be provided.
For non-default shading a record needs to be created that specifies
the shading properties.
The surface area of the window is deducted from the surface area
of the wall such that the total surface areas add up.
</p>
<p>
The zone template also has a heat port for embedded heat gains
in the floor. This can be used when the floor has a floor heating
system or a concrete core activation system. Set then 
<code>hasEmb</code> from the tab Floor to <code>true</code> 
to get the <code>gaiEmb</code> heat port on the zone template.
Notice that the zone template does not have a heat port for embedded
gains in the ceiling. To model concrete core activation in the ceiling,
use an external surface.
</p>
<h4>Options</h4>
<p>
Advanced options are found under the <code>Advanced</code> 
parameter tab. 
The model may also be adapted further by
overriding the default parameter assignments in the template.
</p>
<p>
You can also use this model for non-rectangular zones by, for example,
using the <code>None</code> type for a wall and by adding additional walls
corresponding to a different geometry through
the external bus connector. 
This model however then does not guarantee that all parameters are consistent.
Therefore, some internal parameters of this model will need to be
updated manually.
</p>
<p>
In the parameter group <code>Windows</code>, you can redeclare the window. 
This is useful when using a window model that has a pre-configured surface area,
glazing type, frame fraction and shading. 
The parameters 
<code>azi=aziA</code>,
<code>inc=IDEAS.Types.Tilt.Wall</code>,
<code>T_start=T_start</code>,
<code>linIntCon_a=linIntCon</code>,
<code>dT_nominal_a=dT_nominal_win</code>,
<code>linExtCon=linExtCon</code>,
<code>windowDynamicsType=windowDynamicsType</code>,
<code>linExtRad=linExtRadWin</code>,
<code>nWin=nWinA</code>,
are still computed from the zone model parameters but, the
other windows parameters are those configured in the
used window model, including the window surface area.
</p>
<h4>Dynamics</h4>
<p>
This model contains wall dynamics
and a state for the zone air temperature.
The zone temperature may be set to steady state using
parameter <code>energyDynamicsAir</code>, which should
in general not be done.
The mass dynamics of the air volume
may be set to steady state by overriding the default parameter
assignment in the <code>airModel</code> submodel.
This removes small time constants
when the zone model is connected to an air flow circuit. 
</p>
<h4>Shading</h4>
<p>
In order to choose the shading of the glazing,
instead of selecting one shading type from the
dropdown menu, click on the
button right of the dropdown menu (edit). 
A menu will appear where the type of 
shading and corresponding parameters
have to be defined.
Alternatively, the shading template can be extended.
</p>
<h4>Validation</h4>
<p>
This implementation is compared with a manual implementation
in <a href=modelica://IDEAS.Buildings.Validation.Tests.ZoneTemplateVerification2>
IDEAS.Buildings.Validation.Tests.ZoneTemplateVerification2</a>.
This gives identical results.
</p>
<h4>Example</h4>
<p>
An example of how this template may be used
can be found in 
<a href=modelica://IDEAS.Examples.PPD12>IDEAS.Examples.PPD12</a>.
</p>
<h4>Implementation</h4>
<p>
Shading types need to be declared using a record instead of
by redeclaring the shading components.
This is a workaround because redeclared 
components cannot be propagated.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 13, 2019, by Filip Jorissen:<br/>
Refactored the parameter definition of <code>inc</code> 
and <code>azi</code> by adding the option to use radio buttons.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1067\">
#1067</a>
</li>
<li>
April 10, 2019, by Filip Jorissen:<br/>
Removed obsolete redeclaration.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1009\">#1009</a>.
</li>
<li>
August 29, 2018, by Damien Picard:<br/>
Add embedded heat port for floor heating or CCA.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/903\">#903</a>.
</li>
<li>
August 28, 2018, by Damien Picard:<br/>
Changes to allow multiple external surfaces connection per faces.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/901\">#901</a>.
</li>
<li>
August 26, 2018, by Damien Picard:<br/>
Move all equations except windows equations of
RectangularZoneTemplate to this interface model.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/891\">#891</a>.
</li>
<li>
August 16, 2018, by Damien Picard:<br/>
Make windows replaceable.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/891\">#891</a>.
And correct wall surface computation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/890\">#890</a>. 
</li>
<li>
August 10, 2018, by Damien Picard:<br/>
Added parameters for scaling factors for windows.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/888\">#888</a>.
</li>
<li>
Adapted model to make it possible to remove walls from the template.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/880\">#880</a>.
</li>
<li>
June 13, 2018, by Filip Jorissen:<br/>
Added parameters for shade cast by external building.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/576\">#576</a>.
</li>
<li>
May 21, 2018, by Filip Jorissen:<br/>
Added parameters for air flow through cavity.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/822\">#822</a>.
</li>
<li>
April 30, 2018 by Iago Cupeiro:<br/>
Propagated boolean input connections for controlled shading.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/809\">#809</a>.
Shading documentation added.
</li>
<li>
July 26, 2017 by Filip Jorissen:<br/>
Added replaceable block that allows to define
the number of occupants.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/760\">#760</a>.
</li>
<li>
April 26, 2017, by Filip Jorissen:<br/>
Added asserts that check for illegal combinations of internal wall with exterior window.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/714>#714</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed bus parameters for JModelica compatibility.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
Also removed obsolete each.
</li>
<li>
January 20, 2017 by Filip Jorissen:<br/>
Removed propagation of <code>nLay</code> and <code>nGain</code>
since this lead to warnings.
</li>
<li>
January 11, 2017 by Filip Jorissen:<br/>
Added documentation
</li>
<li>
January 10, 2017, by Filip Jorissen:<br/>
Added <code>linExtRadWin</code> for windows.
</li>
<li>
November 14, 2016 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>"));
        end RectangularZoneTemplateInterface;

        connector SolBus
          "Bus containing solar radiation for various incidence angles as well as external convection coefficients"
          extends Modelica.Icons.SignalBus;
          parameter Boolean outputAngles = true "Set to false when linearising in Dymola only";
          IDEAS.Buildings.Components.Interfaces.RealConnector HDirTil(unit="W/(m2)",start=100) annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector HSkyDifTil(unit="W/(m2)",start=100) annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector HGroDifTil(unit="W/(m2)",start=100) annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector hForcedConExt(unit="W/(m2.K)",start=10) "Coefficient for forced convection at exterior surface" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector angInc(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg",
            start=1) if outputAngles;
          IDEAS.Buildings.Components.Interfaces.RealConnector angZen(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg",
            start=1) if outputAngles;
          IDEAS.Buildings.Components.Interfaces.RealConnector angAzi(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg",
            start=1) if outputAngles;
          IDEAS.Buildings.Components.Interfaces.RealConnector Tenv(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min = 0.0,
            start = 293.15,
            nominal = 300,
            displayUnit="degC") "Equivalent radiant temperature" annotation ();


          annotation (Documentation(info="<html>
<p>
Connector that contains all solar irridiation information for one inclination and tilt angle.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 28, 2019 by Ian Beausoleil-Morrison:<br/>
Add RealConnector for coefficient for forced convection at exterior surface.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1089\">
#1089</a>
</li>
<li>
August 24, 2018, by Damien Picard:<br/>
Add start value for linearisation.
</li>
<li>
May 26, 2017 by Filip Jorissen:<br/>
Revised implementation for renamed
ports <code>HDirTil</code> etc.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/735\">
#735</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed Reals into connectors for JModelica compatibility.
Other compatibility changes. 
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
        end SolBus;

        connector WeaBus "Data bus that stores weather data"
          extends Modelica.Icons.SignalBus;
          parameter Integer numSolBus;
          parameter Boolean outputAngles = true "Set to false when linearising in Dymola only";

          IDEAS.Buildings.Components.Interfaces.RealConnector solTim(
            final unit="s",
            final quantity="Time",
            start=1) "Solar time";
          IDEAS.Buildings.Components.Interfaces.SolBus[numSolBus] solBus(each outputAngles=outputAngles) annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector Te(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min = 0.0,
            start = 293.15,
            nominal = 300,
            displayUnit="degC") "Ambient sensible temperature" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector Tdes(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min = 0.0,
            start = -8 + 273.15,
            nominal = 300,
            displayUnit="degC") "Design temperature?" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector TGroundDes(
            final quantity="ThermodynamicTemperature",
            final unit="K",
            min = 0.0,
            start = 283.15,
            nominal = 300,
            displayUnit="degC")
            "Design ground temperature" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector Va(unit="m/s", start=0) "Wind speed" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector Vdir(unit="rad", start=0) "Wind direction" annotation ();

          IDEAS.Buildings.Components.Interfaces.RealConnector X_wEnv(start=0.01) "Environment air water mass fraction"
                                        annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector CEnv(start=1e-6) "Environment air trace substance mass fraction"
                                        annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector dummy(start=1)
            "Dummy variable of value 1 to include constant term in linearization (see SlabOnGround)"
            annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector TskyPow4(start=273^4),TePow4(start=273^4), solGloHor(start=100), solDifHor(start=100), F1(start=0.1), F2(start=-0.1), angZen(start=1), angHou(start=1), angDec(start=1), solDirPer(start=1), phi(start=1);
          annotation (
            defaultComponentName="weaBus",
            Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-20,2},{22,-2}},
                  lineColor={255,204,51},
                  lineThickness=0.5)}),
            Diagram(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                    100}})),
            Documentation(info="<html>
<p>
Connector that contains all environment information for many inclinations and tilt angles.
</p>
</html>",  revisions="<html>
<ul>
<li>
November 28, 2019, by Ian Beausoleil-Morrison:<br/>
Removed hConExt from weather bus because it is not calculated in ExtConvForcedCoeff.mo and ExteriorConvection.mo.<br/>
Added wind speed and direction to weather bus.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1089\">
#1089</a>
</li>
<li>
March 27, 2018, by Filip Jorissen:<br/>
Added relative humidity to weather bus.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/780>#780</a>
</li>
<li>
January 25, 2018 by Filip Jorissen:<br/>
Added <code>solTim</code> connections for revised azimuth computations.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/753\">
#753</a>.
</li>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed Reals into connectors for JModelica compatibility.
Other compatibility changes. 
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
        end WeaBus;

        connector WindowBus
          "Bus containing inputs/outputs for linear window model"
          extends Modelica.Icons.SignalBus;
          parameter Integer nLay = 3 "Number of window layers";
          RealConnector[nLay] AbsQFlow(start=fill(100,nLay)) annotation ();
          RealConnector iSolDir(start=100) annotation ();
          RealConnector iSolDif(start=100) annotation ();
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
March, 2015 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>",         info="<html>
<p>
Specialized connector
</p>
</html>"));
        end WindowBus;

        type WindowDynamicsType = enumeration(
          Two   "One state for the glazing and one for the frame",
          Normal   "States in each glass sheet and one state for the frame") "Type of dynamics that are used for window models" annotation (
            Documentation(revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>",         info="<html>
<p>
Type variable for defining how many states should be used to represent the window dynamics.
Zero, one or two states may be used to represent the dynamics of the frame and glazing of a window.
Fewer states are used than for opaque surfaces since the time constants of glazing are relatively fast,
which may slow down simulations. 
Therefore the dynamics are lumped into one or two states.
</p>
</html>"));

        connector ZoneBus
          extends Modelica.Icons.SignalBus;
          parameter Integer numIncAndAziInBus
            "Number of calculated azimuth angles, set to sim.numIncAndAziInBus";
          parameter Boolean outputAngles = true "Set to false when linearising in Dymola only";
          IDEAS.Buildings.Components.Interfaces.RealConnector QTra_design(
            final quantity="Power",
            final unit="W") annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector area(
            final quantity="Area",
            final unit="m2") annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector epsLw(
            final quantity="Emissivity",
            final unit="1") annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector epsSw(
            final quantity="Emissivity",
            final unit="1") annotation ();
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a surfCon annotation ();
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b surfRad annotation ();
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a iSolDir annotation ();
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b iSolDif annotation ();
          IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(numSolBus=numIncAndAziInBus, outputAngles=outputAngles)
            annotation(HideResult=true);
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b Qgai
            "Heat gains in model" annotation ();
          IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.EnergyPort E
            "Internal energy in model" annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector inc(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") annotation ();
          IDEAS.Buildings.Components.Interfaces.RealConnector azi(
            final quantity="Angle",
            final unit="rad",
            displayUnit="deg") annotation ();
          annotation (Documentation(info="<html>
<p>
Connector that contains a weather bus and further
contains variables and connectors for exchanging 
heat and information between a zone and a surface.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 21, 2017, by Filip Jorissen:<br/>
Changed Reals into connectors for JModelica compatibility.
Other compatibility changes. 
See issue <a href=https://github.com/open-ideas/IDEAS/issues/559>#559</a>.
</li>
<li>
October 22, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
        end ZoneBus;

        model ZoneBusVarMultiplicator "Component to scale all flows from the zone propsBus. This can be used to scale the surface to n identical surfaces"
          parameter Real k = 1 "Scaling factor";
          ZoneBus propsBus_a(
            numIncAndAziInBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles)
            "Unscaled port"                                                         annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-100,0})));
          ZoneBus propsBus_b(
            numIncAndAziInBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles)
            "Scaled port"                                                           annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={100,0})));
          outer BoundaryConditions.SimInfoManager       sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{72,122},{92,142}})));
      protected
          Modelica.Blocks.Math.Gain QTra_desgin(k=k) "Design heat flow rate"
            annotation (Placement(transformation(extent={{-10,178},{10,198}})));
          Modelica.Blocks.Math.Gain area(k=k) "Heat exchange surface area"
            annotation (Placement(transformation(extent={{-10,150},{10,170}})));
          BaseClasses.Varia.HeatFlowMultiplicator surfCon(k=k)
            "Block for scaling convective heat transfer"
            annotation (Placement(transformation(extent={{-10,62},{10,82}})));
          BaseClasses.Varia.HeatFlowMultiplicator surfRad(k=k)
            "Block for scaling radiative heat transfer"
            annotation (Placement(transformation(extent={{-10,34},{10,54}})));
          BaseClasses.Varia.HeatFlowMultiplicator iSolDir(k=k)
            "Block for scaling direct solar irradiation"
            annotation (Placement(transformation(extent={{-10,2},{10,22}})));
          BaseClasses.Varia.HeatFlowMultiplicator iSolDif(k=k)
            "Black for scaling diffuse solar irradiation"
            annotation (Placement(transformation(extent={{-10,-26},{10,-6}})));
          BaseClasses.Varia.HeatFlowMultiplicator QGai(k=k)
            "Block for scaling internal gains"
            annotation (Placement(transformation(extent={{-10,-86},{10,-66}})));
          BaseClasses.Varia.EnergyFlowMultiplicator E(k=k)
            "Block for scaling internal energy"
            annotation (Placement(transformation(extent={{-10,-116},{10,-96}})));
          WeaBus weaBus(numSolBus=sim.numIncAndAziInBus, outputAngles=sim.outputAngles) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={0,-48})));
          Modelica.Blocks.Routing.RealPassThrough inc "Inclination angle"
            annotation (Placement(transformation(extent={{-10,-148},{10,-128}})));
          Modelica.Blocks.Routing.RealPassThrough azi "Azimuth angle"
            annotation (Placement(transformation(extent={{-10,-178},{10,-158}})));
          Modelica.Blocks.Routing.RealPassThrough epsLw "Longwave emissivity"
            annotation (Placement(transformation(extent={{-10,118},{10,138}})));
          Modelica.Blocks.Routing.RealPassThrough epsSw "Shortwave emissivity"
            annotation (Placement(transformation(extent={{-10,88},{10,108}})));
        equation
          connect(QTra_desgin.u, propsBus_a.QTra_design) annotation (Line(points={{-12,188},
                  {-100.1,188},{-100.1,0.1}},         color={0,0,127}));
          connect(QTra_desgin.y, propsBus_b.QTra_design) annotation (Line(points={{11,188},
                  {100.1,188},{100.1,-0.1}},color={0,0,127}));
          connect(area.u, propsBus_a.area) annotation (Line(points={{-12,160},{-100.1,
                  160},{-100.1,0.1}},color={0,0,127}));
          connect(area.y, propsBus_b.area) annotation (Line(points={{11,160},{100.1,160},
                  {100.1,-0.1}},     color={0,0,127}));
          connect(surfCon.port_a, propsBus_a.surfCon) annotation (Line(points={{-10,72},
                  {-100.1,72},{-100.1,0.1}},          color={191,0,0}));
          connect(surfRad.port_a, propsBus_a.surfRad) annotation (Line(points={{-10,44},
                  {-100.1,44},{-100.1,0.1}},          color={191,0,0}));
          connect(iSolDif.port_a, propsBus_a.iSolDif) annotation (Line(points={{-10,-16},
                  {-100.1,-16},{-100.1,0.1}},
                                           color={191,0,0}));
          connect(iSolDir.port_a, propsBus_a.iSolDir) annotation (Line(points={{-10,12},
                  {-100.1,12},{-100.1,0.1}},          color={191,0,0}));
          connect(weaBus, propsBus_a.weaBus) annotation (Line(
              points={{0,-48},{-100.1,-48},{-100.1,0.1}},
              color={255,204,51},
              thickness=0.5));
          connect(weaBus, propsBus_b.weaBus) annotation (Line(
              points={{0,-48},{100.1,-48},{100.1,-0.1}},
              color={255,204,51},
              thickness=0.5));
          connect(surfCon.port_b, propsBus_b.surfCon) annotation (Line(points={{10,72},
                  {100.1,72},{100.1,-0.1}},        color={191,0,0}));
          connect(surfRad.port_b, propsBus_b.surfRad) annotation (Line(points={{10,44},
                  {100.1,44},{100.1,-0.1}},        color={191,0,0}));
          connect(iSolDir.port_b, propsBus_b.iSolDir) annotation (Line(points={{10,12},
                  {100.1,12},{100.1,-0.1}},        color={191,0,0}));
          connect(iSolDif.port_b, propsBus_b.iSolDif)
            annotation (Line(points={{10,-16},{100.1,-16},{100.1,-0.1}},
                                                                     color={191,0,0}));
          connect(QGai.port_b, propsBus_b.Qgai) annotation (Line(points={{10,-76},{
                  100.1,-76},{100.1,-0.1}},
                                      color={191,0,0}));
          connect(E.E_b, propsBus_b.E) annotation (Line(points={{10,-106},{100.1,-106},
                  {100.1,-0.1}},
                          color={0,0,0}));
          connect(inc.y, propsBus_b.inc) annotation (Line(points={{11,-138},{100.1,-138},
                  {100.1,-0.1}}, color={0,0,127}));
          connect(azi.y, propsBus_b.azi) annotation (Line(points={{11,-168},{100.1,-168},
                  {100.1,-0.1}}, color={0,0,127}));
          connect(azi.u, propsBus_a.azi) annotation (Line(points={{-12,-168},{-100.1,
                  -168},{-100.1,0.1}},
                                 color={0,0,127}));
          connect(inc.u, propsBus_a.inc) annotation (Line(points={{-12,-138},{-100.1,
                  -138},{-100.1,0.1}},
                                 color={0,0,127}));
          connect(E.E_a, propsBus_a.E) annotation (Line(points={{-9.8,-106},{-100.1,
                  -106},{-100.1,0.1}},
                                 color={0,0,0}));
          connect(QGai.port_a, propsBus_a.Qgai) annotation (Line(points={{-10,-76},{
                  -100.1,-76},{-100.1,0.1}},       color={191,0,0}));
          connect(epsLw.u, propsBus_a.epsLw) annotation (Line(points={{-12,128},{-100.1,
                  128},{-100.1,0.1}}, color={0,0,127}));
          connect(epsSw.u, propsBus_a.epsSw) annotation (Line(points={{-12,98},{-100.1,
                  98},{-100.1,0.1}},         color={0,0,127}));
          connect(epsLw.y, propsBus_b.epsLw) annotation (Line(points={{11,128},{100.1,
                  128},{100.1,-0.1}},        color={0,0,127}));
          connect(epsSw.y, propsBus_b.epsSw) annotation (Line(points={{11,98},{100.1,98},
                  {100.1,-0.1}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-180},
                    {100,200}}), graphics={
                Polygon(
                  points={{-100,120},{102,-2},{-100,-120},{-100,120}},
                  lineColor={255,215,136},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Text(
                  extent={{-76,-110},{72,-160}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="k = %k"),
                Text(
                  extent={{-100,158},{100,98}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="%name")}),                                 Diagram(
                coordinateSystem(preserveAspectRatio=false, extent={{-100,-180},{100,200}})),
            Documentation(revisions="<html>
<ul>
<li>
August 10, 2018 by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ZoneBusVarMultiplicator;

        partial model ZoneInterface "Partial model for thermal building zones"
          replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choicesAllMatching = true);
          outer IDEAS.BoundaryConditions.SimInfoManager sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));

          parameter Integer nSurf(min=2)
            "Number of surfaces adjacent to and heat exchangeing with the zone";
          parameter Modelica.SIunits.Volume V "Total zone air volume"
            annotation(Dialog(group="Building physics"));
          parameter Modelica.SIunits.Length hZone = 2.8
            "Zone height: distance between floor and ceiling"
            annotation(Dialog(group="Building physics"));
          parameter Modelica.SIunits.Area A = V/hZone "Total conditioned floor area"
            annotation(Dialog(group="Building physics"));
          parameter Boolean useOccNumInput
            "=false, to remove icon of nOcc"
            annotation(Dialog(tab="Advanced",group="Occupants"));
          parameter Boolean useLigCtrInput
            "=false, to remove icon of lightCtrl"
            annotation(Dialog(tab="Advanced",group="Lighting"));
          //default ACH=2 for ventilation
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal = V * 1.2*2/3600
            "Nominal flow rate of the air flow system fluid ports"
            annotation(Dialog(tab="Advanced",group="Air model"));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b gainRad
            "Internal zone node for radiative heat gains"
            annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a gainCon
            "Internal zone node for convective heat gains"
            annotation (Placement(transformation(extent={{90,-40},{110,-20}})));
          Modelica.Blocks.Interfaces.RealOutput TSensor(unit="K", displayUnit="degC")
            "Sensor temperature of the zone, i.e. operative temeprature" annotation (
              Placement(transformation(extent={{100,10},{120,30}}), iconTransformation(
                  extent={{100,10},{120,30}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b(
            redeclare package Medium = Medium,
            m_flow(nominal=m_flow_nominal),
            h_outflow(nominal=Medium.h_default))
            annotation (Placement(transformation(extent={{-30,90},{-10,110}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_a(
            redeclare package Medium = Medium,
            m_flow(nominal=m_flow_nominal),
            h_outflow(nominal=Medium.h_default))
            annotation (Placement(transformation(extent={{10,90},{30,110}})));
          Modelica.Blocks.Interfaces.RealInput yOcc if useOccNumInput
            "Control input for number of occupants, used by Occupants.Input and Occupants.AreaWeightedInput"
            annotation (Placement(transformation(extent={{140,20},{100,60}})));
          Modelica.Blocks.Interfaces.RealInput uLig if useLigCtrInput
            "Lighting control input (1 corresponds to 100%), only used when using LightingControl.Input"
            annotation (Placement(transformation(extent={{140,50},{100,90}})));
          Modelica.Blocks.Interfaces.RealOutput ppm(unit="1")
            "CO2 concentration in the zone" annotation (Placement(transformation(extent={{100,-10},
                    {120,10}}),           iconTransformation(extent={{100,-10},{120,10}})));
      protected
          Modelica.Blocks.Sources.RealExpression Eexpr "Internal energy model";
          BaseClasses.ConservationOfEnergy.PrescribedEnergy prescribedHeatFlowE
            "Dummy that allows computing total internal energy";
          Modelica.Blocks.Sources.RealExpression Qgai(
            y=(if sim.openSystemConservationOfEnergy or not sim.computeConservationOfEnergy
               then 0
            else gainCon.Q_flow + gainRad.Q_flow)) "Heat gains in model";
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow prescribedHeatFlowQgai
            "Component for computing conservation of energy";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a dummy1
            "Dummy heat port for avoiding error by dymola translator";
          IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.EnergyPort dummy2
            "Dummy emergy port for avoiding error by dymola translator";
        initial equation
          assert(nSurf>1, "In " + getInstanceName() +
            ": A minimum of 2 surfaces must be connected to the zone.");

        equation
          connect(sim.Qgai, dummy1);
          connect(sim.E, dummy2);
          connect(Eexpr.y,prescribedHeatFlowE.E);
          connect(prescribedHeatFlowE.port, sim.E);
          connect(Qgai.y,prescribedHeatFlowQgai. Q_flow);
          connect(prescribedHeatFlowQgai.port, sim.Qgai);

          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),           Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-90,90},{90,-90}},
                  pattern=LinePattern.None,
                  fillColor={175,175,175},
                  fillPattern=FillPattern.Backward,
                  lineColor={0,0,0}),
                Rectangle(
                  extent={{68,70},{-68,-70}},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineColor={0,0,0},
                  lineThickness=0.5),
                Line(
                  points={{-68,70},{68,70}},
                  color={0,0,0},
                  thickness=0.5,
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-40,-70},{40,-90}},
                  lineThickness=0.5,
                  pattern=LinePattern.None,
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-40,-90},{68,22},{68,-42},{40,-70},{40,-90},{-40,-90},{-40,-90}},
                  lineThickness=0.5,
                  smooth=Smooth.None,
                  fillColor={255,255,170},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Line(
                  points={{-68,70},{-68,-70},{-40,-70},{-40,-80},{40,-80},{40,-70},{68,
                      -70},{68,70}},
                  color={0,0,0},
                  smooth=Smooth.None,
                  thickness=0.5),
                Text(
                  extent={{-39,40},{39,-40}},
                  lineColor={0,0,0},
                  fontName="Calibri",
                  origin={-2,3},
                  rotation=0,
                  textString="%name")}),
            Documentation(revisions="<html>
<ul>
<li>
May 2, 2019 by Filip Jorissen:<br/>
Moved location of <code>ppm</code> in the icon layer such that it
does not overlap with <code>TSensor</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1026\">#1026</a>.
</li>
<li>
March 28, 2019 by Filip Jorissen:<br/>
Renamed <code>nOcc</code> to <code>yOcc</code>
See <a href=\"https://github.com/open-ideas/IDEAS/issues/998\">#998</a>.
</li>
<li>
September 5, 2018 by Iago Cupeiro:<br/>
Added uLig input for controlling lighting
See <a href=\"https://github.com/open-ideas/IDEAS/issues/879\">#879</a>.
</li>
<li>
July 27, 2018 by Filip Jorissen:<br/>
Added output for the CO2 concentration.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/868\">#868</a>.
</li>
<li>
July 11, 2018, Filip Jorissen:<br/>
Added nominal values for <code>h_outflow</code> and <code>m_flow</code>
in <code>FluidPorts</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/859\">#859</a>.
</li>
<li>
May 29, 2018, Filip Jorissen:<br/>
Removed conditional fluid ports for JModelica compatibility.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/834\">#834</a>.
</li>
<li>
April 28, 2016, Filip Jorissen:<br/>
Added assert for checking nSurf larger than 1.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
Adjusted implementation for computing conservation of energy.
</li>
<li>
February 10, 2015 by Filip Jorissen:<br/>
Adjusted implementation for grouping of solar calculations.
</li>
</ul>
</html>"));
        end ZoneInterface;
      end Interfaces;

      package BaseClasses
      extends Modelica.Icons.BasesPackage;

        package ConductiveHeatTransfer

          model MonoLayer "single material layer"

            parameter Modelica.SIunits.Area A "Layer surface area";
            parameter IDEAS.Buildings.Data.Interfaces.Material mat
              "Layer material properties";
            parameter Modelica.SIunits.Angle inc
              "Inclinination angle of the layer at port_a";
            parameter Modelica.SIunits.Emissivity epsLw_a
              "Longwave emissivity of material connected at port_a";
            parameter Modelica.SIunits.Emissivity epsLw_b
              "Longwave emissivity on material connected at port_b";

            parameter Boolean linIntCon=false
              "Linearise interior convection inside air layers / cavities in walls";
            parameter Modelica.Fluid.Types.Dynamics energyDynamics=if mat.glass then Modelica.Fluid.Types.Dynamics.SteadyState else Modelica.Fluid.Types.Dynamics.FixedInitial
              "Static (steady state) or transient (dynamic) thermal conduction model"
              annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
            parameter Modelica.SIunits.Temperature T_start=293.15
              "Start temperature for each of the states";
            parameter Boolean checkCoating = false
              "Throw if an air cavity does not have a coating";
            final parameter Modelica.SIunits.ThermalInsulance R = mat.R
              "Total specific thermal resistance";
            final parameter Boolean isDynamic = dynamicLayer and realLayer and not airLayer;

            Modelica.SIunits.Energy E = E_internal;

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              "Port for connections between layers"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              "Port for connections between layers"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_gain
              "Port for heat gains in layers"
              annotation (Placement(transformation(extent={{-10,90},{10,110}})));
            IDEAS.Buildings.Components.BaseClasses.ConductiveHeatTransfer.MonoLayerDynamic
              monLayDyn(
              A=A,
              mat=mat,
              T_start=T_start,
              energyDynamics=energyDynamics) if isDynamic
              "Dynamic monolayer for solid"
              annotation (Placement(transformation(extent={{-10,-42},{10,-22}})));

            IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.MonoLayerAir
              monLayAir(
              A=A,
              inc=inc,
              d=mat.d,
              k=mat.k,
              epsLw_a=epsLw_a,
              epsLw_b=epsLw_b,
              linearise=linIntCon,
              dT_nominal=dT_nom_air,
              checkCoating=checkCoating) if                 realLayer and airLayer
              annotation (Placement(transformation(extent={{-20,30},{0,50}})));
            IDEAS.Buildings.Components.BaseClasses.ConductiveHeatTransfer.MonoLayerStatic
              monLaySta(R=R/A) if
                 realLayer and not dynamicLayer and not airLayer
              annotation (Placement(transformation(extent={{0,70},{20,90}})));

        protected
            Modelica.Blocks.Interfaces.RealInput E_internal;
            final parameter Boolean dynamicLayer= not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState
              "True when modelling thermal dynamics"
              annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
            final parameter Boolean realLayer = mat.d > Modelica.Constants.small
              "True when the layer has a non-zero thickness";

            final parameter Boolean airLayer = mat.gas
              "True when a convection + radiation equation should be used to model the layer instead of conduction";

        public
            parameter SI.TemperatureDifference dT_nom_air=1
              "Nominal temperature difference for air layers, used for linearising Rayleigh number";
          equation
            connect(E_internal, monLayDyn.E);
            if not realLayer or airLayer or not dynamicLayer then
              E_internal=0;
            end if;

            // Connections for fictive layers
            if not realLayer then
              connect(port_a, port_b) annotation (Line(
                points={{-100,0},{100,0}},
                color={191,0,0},
                smooth=Smooth.None));
            end if;

            // Connections for dynamic layers
            connect(port_a, monLayDyn.port_a) annotation (Line(
                points={{-100,0},{-100,-32},{-10,-32}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(monLayDyn.port_b, port_b) annotation (Line(
                points={{10,-32},{100,-32},{100,0}},
                color={191,0,0},
                smooth=Smooth.None));

            // Connections for air layers
            connect(monLayAir.port_a, port_a) annotation (Line(points={{-20,40},{-100,40},
                    {-100,0}},         color={191,0,0}));
            connect(monLayAir.port_b, port_b) annotation (Line(points={{0,40},{100,40},{100,
                    0}},            color={191,0,0}));

            // Connections for static layers
            connect(port_a, monLaySta.port_a) annotation (Line(points={{-100,0},{-100,0},{
                    -100,78},{-100,80},{0,80}},   color={191,0,0}));
            connect(monLaySta.port_b, port_b) annotation (Line(points={{20,80},{20,80},{100,
                    80},{100,0}}, color={191,0,0}));

            // For static monolayers or air monolayer, connect port_gain in the middle of the layer.
            connect(monLayAir.port_emb, port_gain)
              annotation (Line(points={{-10,50},{-10,50},{-10,100},{0,100}},
                                               color={191,0,0}));
            connect(port_gain, monLaySta.port_gain)
              annotation (Line(points={{0,100},{8,100},{10,100},{10,90}},
                                                        color={191,0,0}));
            // For dynamic monolayers or fictive monolayers, connect port_gain at port_b of the layer.
            if not realLayer or realLayer and dynamicLayer and not airLayer then
              connect(port_a, port_gain) annotation (Line(points={{-100,0},{-100,0},{-100,
                      100},{0,100}},
                              color={191,0,0}));
            end if;

            annotation (
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})),
              Icon(graphics={Rectangle(
                    extent={{-90,80},{90,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),Text(
                    extent={{-150,113},{150,73}},
                    textString="%name",
                    lineColor={0,0,255}),Ellipse(
                    extent={{-40,-42},{40,38}},
                    lineColor={127,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),Text(
                    extent={{-39,40},{39,-40}},
                    lineColor={127,0,0},
                    fontName="Calibri",
                    origin={0,-1},
                    rotation=90,
                    textString="S")}),
              Documentation(info="<html>
</html>",           revisions="<html>
<ul>
<li>
September 9, 2019, by Kristoff Six:<br/>
Updated with <code>checkCoating</code> for issue
<a href=\"https://github.com/open-ideas/IDEAS/issues/1038\">#1038</a>.
</li>
<li>
January 25, 2019, by Filip Jorissen:<br/>
Revised initial equation implementation.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
March 8, 2016, by Filip Jorissen:<br/>
Fixed bug in connection of internal gains. 
Now connecting to port_a instead of port_b.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: now only one MonoLayer component exists.
</li>
</ul>
</html>"));
          end MonoLayer;

          model MonoLayerDynamic "Dynamic layer for uniform solid."

            parameter Modelica.SIunits.Area A "Layer area";
            parameter IDEAS.Buildings.Data.Interfaces.Material mat "Layer material";
            parameter Modelica.SIunits.Temperature T_start=293.15
              "Start temperature for each of the states";
            parameter Integer nStaMin(min=1) = 2 "Minimum number of states";

            parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial
              "Static (steady state) or transient (dynamic) thermal conduction model"
              annotation (Evaluate=true, Dialog(tab="Dynamics", group="Equations"));
            final parameter Boolean present=mat.d > Modelica.Constants.small;
            final parameter Integer nSta=max(nStaMin, mat.nSta) "Number of states";
            final parameter Real R=mat.R "Total specific thermal resistance";
            final parameter Modelica.SIunits.HeatCapacity Ctot=A*mat.rho*mat.c*mat.d
              "Total heat capacity";
            // This option is for solving problems when connecting a
            // fixed temperature boundary to a state when linearising a model.
            parameter Boolean addRes_b=false
              "Set to true to add a resistor at port b.";
            Modelica.Blocks.Interfaces.RealOutput E(unit="J") = sum(T .* C);

        protected
            final parameter Integer nRes=if addRes_b then nSta
                 else max(nSta - 1, 1) "Number of thermal resistances";
            final parameter Modelica.SIunits.ThermalConductance[nRes] G=fill(nRes*A/R,
                nRes);
            final parameter Modelica.SIunits.HeatCapacity[nSta] C=Ctot*(if nSta <= 2 or
                addRes_b then ones(nSta)/nSta else cat(
                1,
                {0.5},
                ones(nSta - 2),
                {0.5})/(nSta - 1));
            final parameter Real[nSta] Cinv(unit="K/J") = ones(nSta) ./ C
              "Dummy parameter for efficiently handling check for division by zero";
            Modelica.SIunits.Temperature[nSta] T(each start=T_start) "Temperature at the states";
            Modelica.SIunits.HeatFlowRate[nRes] Q_flow
              "Heat flow rate from state i to i-1";

        public
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));

          initial equation
            // We define initial conditions only for the inner states to avoid
            // redundant initial equations.
            // Initial equations for the outer states are defined at the MultiLayer level.
            if energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
              if addRes_b then
                T[nSta]=T_start;
              end if;
              for i in 2:nSta-1 loop
                T[i] = T_start;
              end for;
            elseif energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
              if addRes_b then
                der(T[nSta])=0;
              end if;
              for i in 2:nSta-1 loop
                der(T[i]) = 0;
              end for;
            end if;
            assert(nSta >= 1, "Number of states needs to be higher than zero.");
            assert(abs(sum(C) - A*mat.rho*mat.c*mat.d) < 1e-6, "Verification error in MonLayerDynamic");
            assert(abs(sum(ones(size(G, 1)) ./ G) - R/A) < 1e-6, "Verification error in MonLayerDynamic");
            assert(not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState, "MonoLayerDynamic is configured to steady state, which is not the scope of this model!");
          equation
            port_a.T = T[1];

            if nSta > 1 then
              der(T[1]) = (port_a.Q_flow - Q_flow[1])*Cinv[1];
              // Q_flow[i] is heat flowing from (i-1) to (i)
              for i in 1:nSta - 1 loop
                (T[i] - T[i + 1])*G[i] = Q_flow[i];
              end for;
              for i in 2:nRes loop
                der(T[i]) = (Q_flow[i - 1] - Q_flow[i])*Cinv[i];
              end for;

              if not addRes_b then
                der(T[nSta]) = (Q_flow[nSta - 1] + port_b.Q_flow)*Cinv[nSta];
                port_b.T = T[nSta];
              else
                (T[end] - port_b.T)*G[end] = Q_flow[end];
                port_b.Q_flow = -Q_flow[end];
              end if;
            else
              der(port_a.T) = (port_a.Q_flow + port_b.Q_flow)*Cinv[1];
              Q_flow[1] = -port_b.Q_flow;
              Q_flow[1] = (port_a.T - port_b.T)*G[1];
            end if;

            annotation (
              Diagram(graphics),
              Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{90,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-150,113},{150,73}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Ellipse(
                    extent={{-40,-42},{40,38}},
                    lineColor={127,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-39,40},{39,-40}},
                    lineColor={127,0,0},
                    fontName="Calibri",
                    origin={0,-1},
                    rotation=90,
                    textString="S")}),
              Documentation(info="<html>
<p>For the purpose of dynamic building simulation, the partial differential equation of the continuous 
time and space model of heat transport through a solid is most often simplified into ordinary differential 
equations with a finite number of parameters representing only one-dimensional heat transport through a construction layer. 
Within this context, the wall is modeled with lumped elements, i.e. a model where temperatures and heat 
fluxes are determined from a system composed of a sequence of discrete resistances and capacitances R_{n+1}, C_{n}. 
The number of capacitive elements $n$ used in modeling the transient thermal response of the wall denotes the order of the lumped capacitance model.
</p>
<p align=\"center\"><img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-pqp0E04K.png\"/></p>
<p>where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-I7KXJhSH.png\"/> is the added energy to the lumped capacity, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-B0HPmGTu.png\"/> is the temperature of the lumped capacity, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-t7aqbnLB.png\"/> is the thermal capacity of the lumped capacity equal to
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-JieDs0oi.png\"/> for which rho denotes the density and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-ml5CM4zK.png\"/> is the specific heat capacity of the material and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-hOGNA6h5.png\"/> the equivalent thickness of the lumped element, where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-1pDREAb7.png\"/> the heat flux through the lumped resistance and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-XYf3O3hw.png\"/> is the total thermal resistance of the lumped resistance and where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-dgS5sGAN.png\"/> are internal thermal source.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 25, 2019, by Filip Jorissen:<br/>
Revised initial equation implementation.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
January 25, 2018, by Filip Jorissen:<br/>
Propagated <code>T_start</code> in the declaration of <code>T</code>.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/692>#692</a>.
</li>
<li>
December 8, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation of placeCapacityAtSurf_b, which has been renamed to addRes_b.
This is for solving problems when linearising a model.
See issue 591.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation.
</li>
</ul>
</html>"));
          end MonoLayerDynamic;

          model MonoLayerStatic "Static layer for uniform solid."
            parameter Modelica.SIunits.ThermalResistance R
              "Total specific thermal resistance";
            Modelica.Thermal.HeatTransfer.Components.ThermalConductor theCon_a(G=G2)
              "Static monolayer for solid"
              annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
             Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_gain
              "port for gains by embedded active layers"
              annotation (Placement(transformation(extent={{-10,90},{10,110}})));
            Modelica.Thermal.HeatTransfer.Components.ThermalConductor theCon_b(G=G2)
              "Static monolayer for solid"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        protected
            final parameter Modelica.SIunits.ThermalConductance G2 = 2/R;
          equation
            connect(theCon_a.port_b, theCon_b.port_a)
              annotation (Line(points={{-40,0},{40,0}}, color={191,0,0}));
            connect(port_gain, theCon_b.port_a) annotation (Line(points={{0,100},{0,100},{
                    0,16},{0,0},{40,0}}, color={191,0,0}));
            connect(theCon_a.port_a, port_a)
              annotation (Line(points={{-60,0},{-100,0}}, color={191,0,0}));
            connect(theCon_b.port_b, port_b)
              annotation (Line(points={{60,0},{100,0}}, color={191,0,0}));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}})), Icon(graphics={
                  Rectangle(
                    extent={{-86,80},{24,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-150,-69},{150,-109}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{24,80},{44,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Forward,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{44,80},{84,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{24,80},{24,-80}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{44,80},{44,-80}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Ellipse(
                    extent={{-36,-42},{44,38}},
                    lineColor={127,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-39,40},{39,-40}},
                    lineColor={127,0,0},
                    fontName="Calibri",
                    origin={4,-1},
                    rotation=90,
                    textString="S")}),
              Documentation(revisions="<html>
<ul>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
          end MonoLayerStatic;

          model MultiLayer "multiple material layers in series"

            parameter Modelica.SIunits.Area A "total multilayer area";
            parameter Modelica.SIunits.Angle inc
              "Inclinination angle of the multilayer at port_a";
            parameter Integer nLay(min=1) "number of layers";
            parameter IDEAS.Buildings.Data.Interfaces.Material[nLay] mats
              "array of layer materials";
            parameter Integer nGain = 0 "Number of gains";
            parameter Boolean linIntCon=false
              "Linearise interior convection inside air layers / cavities in walls";
            final parameter Modelica.SIunits.ThermalInsulance R=sum(monLay.R)
              "total specific thermal resistance";
            final parameter Modelica.SIunits.HeatCapacity C = sum(mats.d.*mats.rho.*mats.c*A)
              "Total heat capacity of the layers"
              annotation(Evaluate=true);

            parameter Modelica.SIunits.Temperature T_start[nLay]=ones(nLay)*293.15
              "Start temperature from port_b to port_a"
              annotation(Evaluate=true, Dialog(group="Dynamics"));
            parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial
              "Static (steady state) or transient (dynamic) thermal conduction model"
              annotation(Evaluate=true, Dialog(group="Dynamics"));
            parameter Boolean disableInitPortA= false
              "Remove initial equation at port a"
              annotation(Evaluate=true, Dialog(group="Dynamics"));
            parameter Boolean disableInitPortB= false
              "Remove initial equation at port b"
              annotation(Evaluate=true, Dialog(group="Dynamics"));
            parameter SI.TemperatureDifference dT_nom_air=1
              "Nominal temperature difference for air layers, used for linearising Rayleigh number"
              annotation(Dialog(enable=linIntCon));
            parameter Boolean checkCoatings = false
              "Check whether air layers have a coating";
            Modelica.SIunits.Energy E = sum(monLay.E);

            IDEAS.Buildings.Components.BaseClasses.ConductiveHeatTransfer.MonoLayer[nLay]
              monLay(
              each final A=A,
              each final inc=inc,
              final T_start=T_start,
              final mat=mats,
              each linIntCon=linIntCon,
              epsLw_a=cat(
                  1,
                  mats[2:nLay].epsLw_b,
                  {0.85}),
              epsLw_b=cat(
                  1,
                  {0.85},
                  mats[1:nLay - 1].epsLw_a),
              each energyDynamics=energyDynamics,
              each checkCoating = checkCoatings,
              each dT_nom_air=dT_nom_air) "Individual layers"
              annotation (Placement(transformation(extent={{-10,10},{10,-10}})));

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_gain[nLay]
              "port for gains by embedded active layers"
              annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a(T(start=289.15))
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b(T(start=289.15))
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Blocks.Interfaces.RealOutput iEpsLw_b
              "output of the interior emissivity for radiative heat losses"
              annotation (Placement(transformation(extent={{90,70},{110,90}})));
            Modelica.Blocks.Interfaces.RealOutput iEpsSw_b
              "output of the interior emissivity for radiative heat losses"
              annotation (Placement(transformation(extent={{90,30},{110,50}})));
            Modelica.Blocks.Interfaces.RealOutput iEpsLw_a
              "output of the interior emissivity for radiative heat losses"
              annotation (Placement(transformation(extent={{-90,70},{-110,90}})));
            Modelica.Blocks.Interfaces.RealOutput iEpsSw_a
              "output of the interior emissivity for radiative heat losses"
              annotation (Placement(transformation(extent={{-90,30},{-110,50}})));
            Modelica.Blocks.Interfaces.RealOutput area=A
              "output of the interior emissivity for radiative heat losses" annotation (
                Placement(transformation(
                  extent={{10,-10},{-10,10}},
                  rotation=-90,
                  origin={0,100})));
          initial equation
            // This code sets initial equations for the outer states of each monolayer.
            // These initial equations are not added at the monoLayer level
            // since then two adjacent monolayers may set an initial equation for the
            // same port, which causes warnings when the initial equations are consistent
            // and errors otherwise.
            // Moreover, multiple multiLayers may be connected to each other, such as in
            // the SlabOnGround model. For this case the parameter disableInitPortB is added.
            for i in 1:nLay loop
              if monLay[i].isDynamic then
                if i>1 or not disableInitPortB then
                  monLay[i].port_b.T=T_start[i];
                end if;
              end if;
              if monLay[i].isDynamic and (if i==nLay then not disableInitPortA else not monLay[i+1].isDynamic) then
                monLay[i].port_a.T=T_start[i];
              end if;
            end for;

          equation
            // Last layer of monLay is connected to port_a
            connect(port_a, monLay[nLay].port_a)
              annotation (Line(points={{-100,0},{-100,0},{-10,0}}, color={191,0,0}));
            for j in 1:nLay - 1 loop
              connect(monLay[nLay - j + 1].port_b, monLay[nLay - j].port_a);
            end for;
            connect(port_b, monLay[1].port_b)
              annotation (Line(points={{100,0},{10,0}}, color={191,0,0}));

            connect(monLay.port_gain, port_gain) annotation (Line(points={{0,-10},{0,-10},
                    {0,-60},{0,-100}}, color={191,0,0}));

            iEpsLw_a = mats[nLay].epsLw_a;
            iEpsSw_a = mats[nLay].epsSw_a;
            iEpsLw_b = mats[1].epsLw_b;
            iEpsSw_b = mats[1].epsSw_b;

            annotation (
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})),
              Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{20,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Text(
                    extent={{-150,113},{150,73}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Rectangle(
                    extent={{20,80},{40,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Forward,
                    pattern=LinePattern.None,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{40,80},{80,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{20,80},{20,-80}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Line(
                    points={{40,80},{40,-80}},
                    pattern=LinePattern.None,
                    smooth=Smooth.None),
                  Ellipse(
                    extent={{-40,-42},{40,38}},
                    lineColor={127,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-39,40},{39,-40}},
                    lineColor={127,0,0},
                    fontName="Calibri",
                    origin={0,-1},
                    rotation=90,
                    textString="S")}),
              Documentation(info="<html>
</html>",           revisions="<html>
<ul>
<li>
September 9, 2019, by Kristoff Six:<br/>
Updated with <code>checkCoatings</code> for issue
<a href=\"https://github.com/open-ideas/IDEAS/issues/1038\">#1038</a>.
</li>
<li>
January 25, 2019, by Filip Jorissen:<br/>
Revised initial equation implementation.
See issue <a href=https://github.com/open-ideas/IDEAS/issues/971>#971</a>.
</li>
<li>
March 8, 2016, by Filip Jorissen:<br/>
Fixed bug in output of iEpsLw and iEpsSw for issue 464.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation: now only one MultiLayer component exists.
</li>
</ul>
</html>"));
          end MultiLayer;
        end ConductiveHeatTransfer;

        package ConservationOfEnergy

          connector EnergyPort "Port for adding up energy"
            flow Modelica.SIunits.Energy E "Energy port";
            Modelica.SIunits.Energy Etot "Energy port";
            annotation (Documentation(info="<html>
<p>
This connector is used to add up all internal energy terms of the model in the SimInfoManager.
</p>
</html>",           revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
June 14, 2015, Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
          end EnergyPort;

          model PrescribedEnergy "Prescribed energy component"
            Modelica.Blocks.Interfaces.RealInput E(unit="J") annotation (Placement(
                  transformation(
                  origin={-100,0},
                  extent={{20,-20},{-20,20}},
                  rotation=180)));
            IDEAS.Buildings.Components.BaseClasses.ConservationOfEnergy.EnergyPort port
              annotation (Placement(transformation(extent={{90,-10},{110,10}}, rotation=0)));
          equation
            port.E = -E;
            annotation (
              Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{
                      100,100}}), graphics={
                  Line(
                    points={{-60,-20},{40,-20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-60,20},{40,20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-80,0},{-60,-20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-80,0},{-60,20}},
                    color={191,0,0},
                    thickness=0.5),
                  Polygon(
                    points={{40,0},{40,40},{70,20},{40,0}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{40,-40},{40,0},{70,-20},{40,-40}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{70,40},{90,-40}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{-150,100},{150,60}},
                    textString="%name",
                    lineColor={0,0,255})}),
              Documentation(info="<html>
<p>
This model allows a specified amount of heat flow rate to be \"injected\"
into a thermal system at a given port.  The amount of heat
is given by the input signal Q_flow into the model. The heat flows into the
component to which the component PrescribedHeatFlow is connected,
if the input signal is positive.
</p>
<p>
If parameter alpha is &lt;&gt; 0, the heat flow is multiplied by (1 + alpha*(port.T - T_ref))
in order to simulate temperature dependent losses (which are given with respect to reference temperature T_ref).
</p>
</html>",           revisions="<html>
<ul>
<li>
June 14, 2015, Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"),           Diagram(coordinateSystem(preserveAspectRatio=false,extent={{-100,-100},
                      {100,100}}), graphics={
                  Line(
                    points={{-60,-20},{68,-20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-60,20},{68,20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-80,0},{-60,-20}},
                    color={191,0,0},
                    thickness=0.5),
                  Line(
                    points={{-80,0},{-60,20}},
                    color={191,0,0},
                    thickness=0.5),
                  Polygon(
                    points={{60,0},{60,40},{90,20},{60,0}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{60,-40},{60,0},{90,-20},{60,-40}},
                    lineColor={191,0,0},
                    fillColor={191,0,0},
                    fillPattern=FillPattern.Solid)}));
          end PrescribedEnergy;
        end ConservationOfEnergy;

        package ConvectiveHeatTransfer

          model CavityAirflow "Model for air flow through a cavity"
            parameter Boolean linearise = false
              "=true, to linearise the relation between heat flow rate and temperature difference";
            parameter Real CD=0.65 "Discharge coefficient";
            parameter Modelica.SIunits.Length h = 2
              "Height of (rectangular) cavity in wall";
            parameter Modelica.SIunits.Length w = 1
              "Width of (rectangular) cavity in wall";
            parameter Modelica.SIunits.Acceleration g = Modelica.Constants.g_n
              "Gravity, for computation of buoyancy";
            parameter Modelica.SIunits.Pressure p = 101300
              "Absolute pressure for computation of buoyancy";
            parameter Modelica.SIunits.Density rho = p/r/T
              "Nominal density for computation of buoyancy mass flow rate";
            parameter Modelica.SIunits.SpecificHeatCapacity c_p = 1013
             "Nominal heat capacity for computation of buoyancy heat flow rate";
            parameter Modelica.SIunits.Temperature T = 293
             "Nominal temperature for linearising heat flow rate";
            parameter Modelica.SIunits.TemperatureDifference dT = 1
             "Nominal temperature difference when linearising heat flow rate"
             annotation(Dialog(enable=linearise));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              "Port for connections between layers"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              "Port for connections between layers"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        protected
            constant Real r = 287 "Gas constant";
            // Assuming the same entering and leaving flow rate
            // between .bottom and top half of the cavity
            // Assuming uniform flow through both parts.
            // dp= rho * g * h/4 * (1-T1/T2) - buoyancy: horizontal pressure differences
            // factor 4: distance between door center and center of top/bottom door half
            // v = sqrt(2 * dp/rho) - Bernoulli
            // dotm = v*h/2*w*rho*cp  - Mass flow rate
            // G = dotm * c_p
            final parameter Real coeff1 = CD*c_p*rho*w*h/2*sqrt(0.5*g*h) "Bernoulli-based thermal conductance";
            final parameter Real coeff2 = sqrt(abs(1-T/(T+dT)));
            Modelica.SIunits.ThermalConductance G=
              coeff1*(if linearise
                     then coeff2
           else
              sqrt(abs(1-port_a.T/port_b.T)));
              // We don't need a regularisation for the square root since this
              // equation should not end up in an algebraic loop
              // when used correctly in IDEAS.
              // However, laminar flow could be approximated better.
          equation
            port_a.Q_flow+port_b.Q_flow=0;
            port_a.Q_flow=(port_a.T-port_b.T)*G;
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(
                    extent={{-60,80},{60,-84}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={85,75,55},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-54,72},{56,-84}},
                    lineColor={0,0,0},
                    fillColor={215,215,215},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{56,72},{-36,66},{-36,-90},{56,-84},{56,72}},
                    lineColor={0,0,0},
                    fillColor={95,95,95},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-30,-10},{-16,-8},{-16,-14},{-30,-16},{-30,-10}},
                    lineColor={0,0,255},
                    pattern=LinePattern.None,
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid)}),                      Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
June 5, 2018 by Filip Jorissen:<br/>
First implementation
</li>
</ul>
</html>",           info="<html>
<h4>Assumptions and limitations</h4>
<p>
The cavity model assumes that the temperature difference between both zones is constant
along the zone heights and that this causes a pressure difference between the zones
due to buoyancy. 
We assume that the pressure at the height of the center of the opening is 
equal in both zones.
Based on this pressure difference, the mass flow rate is computed using Bernoulli,
from which a heat flow rate is computed.
This model deals with stratification in a very simplified way. 
Very large openings can lead to small time constants, which can cause problems
for the time integrator.
Only thermal effects are modelled: there is no mass transport of air or moisture.
The influence of the cavity on the radiative heat exchange is not modelled.
</p>
</html>"));
          end CavityAirflow;

          model ExteriorConvection "exterior surface convection"

            parameter Modelica.SIunits.Area A "surface area";
            parameter Boolean linearise = false "Use constant convection coefficient"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.CoefficientOfHeatTransfer hConExtLin = 18.3
              "Fixed exterior convection coefficient used when linearising equations"
               annotation(Dialog(enable=linearize));
            parameter Modelica.SIunits.Angle inc "Surface inclination";
            parameter Modelica.SIunits.Angle azi "Surface azimuth";

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              "Connector for solid part"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));

            Modelica.Blocks.Interfaces.RealInput Te(unit="K",displayUnit="degC")
              "Ambient temperature"
              annotation (Placement(transformation(extent={{-120,-68},{-80,-28}})));
            Modelica.Blocks.Interfaces.RealInput hForcedConExt(unit="W/(m2.K)")
              "Exterior convective heat transfer coefficient"
              annotation (Placement(transformation(extent={{-120,-110},{-80,-70}})));

        protected
            Modelica.SIunits.CoefficientOfHeatTransfer hNatConvExt
              "Heat transfer coefficient for natural convection" annotation ();
            Modelica.SIunits.CoefficientOfHeatTransfer hSmooth
              "Heat transfer coefficient for a smooth (glass) surface" annotation ();
            Modelica.SIunits.CoefficientOfHeatTransfer hConExt
              "Heat transfer coefficient for combined forced and natural convection"
              annotation ();

            final parameter Boolean isCeiling=abs(sin(inc)) < 10E-5 and cos(inc) > 0
              "true if ceiling" annotation (Evaluate=true);
            final parameter Boolean isFloor=abs(sin(inc)) < 10E-5 and cos(inc) < 0
              "true if floor" annotation (Evaluate=true);


            constant Real C_vertical=1.31 "TARP coeff";
            constant Real C_horz_buoyant=1.509 "TARP coeff";
            constant Real C_horz_stable=0.76 "TARP coeff";
            constant Real n=1/3 "TARP coeff";
            constant Real R=1 "Roughness factor (value of 1 recommended)";

            Real C "TARP coeff";
            Modelica.SIunits.TemperatureDifference dT
              "Surface temperature minus outdoor air temperature" annotation ();



          equation

            // Assign empirical coefficient according to flow regime.
            if isCeiling then
              if dT > 0 then
                C = C_horz_buoyant;
              else
                C = C_horz_stable;
              end if;
            elseif isFloor then
              if dT < 0 then
                C = C_horz_buoyant;
              else
                C = C_horz_stable;
              end if;
            else
              C = C_vertical;
            end if;

            // Calculate coefficient for natural convection.
            hNatConvExt = C * abs(dT)^n;

            // Evaluate combined coefficient for natural and forced convection, or use fixed values.
            if linearise then
              hSmooth = 0;
              hConExt = hConExtLin;
            else
              hSmooth = (hNatConvExt^2 + hForcedConExt^2)^0.5;
              hConExt = (1-R)*hNatConvExt + R*hSmooth;
            end if;

            // Apply Newton's law at exterior surface.
            dT = port_a.T - Te;
            port_a.Q_flow = A * hConExt * dT;

            annotation (
              Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{-60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(points={{-60,20},{76,20}}, color={191,0,0}),
                  Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                  Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                  Line(points={{56,30},{76,20}}, color={191,0,0}),
                  Line(points={{56,10},{76,20}}, color={191,0,0}),
                  Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                  Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                  Line(points={{6,80},{6,-80}}, color={0,127,255}),
                  Line(points={{40,80},{40,-80}}, color={0,127,255}),
                  Line(points={{76,80},{76,-80}}, color={0,127,255}),
                  Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                  Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                  Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                  Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                  Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                  Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                  Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                  Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                  Text(
                    extent={{-150,-90},{150,-130}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-60,80},{-60,-80}},
                    color={0,0,0},
                    thickness=0.5)}),
              Documentation(info="<html>
<p>
The exterior convective heat transfer is computed using 
Newton's Law of Cooling. The convection coefficient considers the combined 
effects of natural (buoyancy driven) and forced (wind-driven) flow.
</p>
<p>
The coefficient for forced convection is calculated in ExtConvForcedCoeff.mo, 
whereas the current model calculates the coefficient for natural 
convection and combines the two together to determine the 
coefficient used in Newton&apos;s Law of Cooling.
</p>
<p>
The &quot;TARP&quot; correlation is used to calculate the coefficient for natural convection. 
The parameters for the correlation at sourced from the EnergyPlus Engineering 
manual (Equations 3.75 to 3.77, Page 94). 
Horizontal surfaces are treated as either a ceiling or a floor, 
and can be either stably stratified or buoyant, depending 
upon the surface-to-air temperature difference. 
Any non-horizontal surface is treated as vertical.
</p>
<p>
This implementation includes a &quot;roughness factor&quot; that can be used to 
augment the combined convection coefficient calculated by the correlations.  
This is used in the so-called &quot;DOE-2 model&quot; that is EnergyPlus'; 
default approach.  However, the use of roughness factors other 
than 1 are discouraged as there appears to be little physical basis for this factor.
</p>
</html>",           revisions="<html>
<ul>
<li>
November 28, 2019, by Ian Beausoleil-Morrison:<br/>
Major rewrite.  Convection coefficients now calculated by surface to consider 
combined natural and forced effects, and wind direction.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1089\">
#1089</a>
</li>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"),    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})));
          end ExteriorConvection;

          model InteriorConvection "interior surface convection"
            parameter Modelica.SIunits.Area A "surface area";
            parameter Modelica.SIunits.Angle inc "inclination";
            parameter Boolean linearise = false
              "= true, if convective heat transfer should be linearised"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.TemperatureDifference dT_nominal = -2
              "Nominal temperature difference used for linearisation, negative temperatures indicate the solid is colder"
              annotation(Evaluate=true, enable = linearise);
            parameter Modelica.SIunits.Length hZone = 2.7
              "Zone height, for calculation of hydraulic diameter"
              annotation(Dialog(tab="Advanced"));
            parameter Modelica.SIunits.Length DhWall = 4*A/(2*A/hZone+2*hZone)
              "Hydraulic diameter for walls"
              annotation(Dialog(tab="Advanced"));
            parameter Modelica.SIunits.Length DhFloor = sqrt(A)
              "Hydraulic diameter for ceiling/floor"
              annotation(Dialog(tab="Advanced"));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        protected
            Modelica.SIunits.TemperatureDifference dT(start=0);
            final parameter Real coeffWall = A*1.823/DhWall^0.121
              "For avoiding calculation of power at every time step";
            final parameter Real coeffFloor = A*2.175/DhFloor^0.076
              "For avoiding calculations at every time step";
            final parameter Real coeffCeiling = A*0.704/DhFloor^0.601
              "For avoiding calculations at every time step";
            final parameter Boolean isCeiling=abs(sin(inc)) < 10E-5 and cos(inc) > 0
              "true if ceiling"
              annotation(Evaluate=true);
            final parameter Boolean isFloor=abs(sin(inc)) < 10E-5 and cos(inc) < 0
              "true if floor"
              annotation(Evaluate=true);
            final parameter Real ceilingSign = if isCeiling then 1 else -1
              "Coefficient for buoyancy direction"
              annotation(Evaluate=true);
          equation
              if isCeiling or isFloor then
                if linearise then
                  port_a.Q_flow = if ceilingSign*dT_nominal > 0 then
                        dT*coeffCeiling*abs(dT_nominal)^0.133
                        else
                        dT*coeffFloor*abs(dT_nominal)^0.308;
                else
                  port_a.Q_flow = IDEAS.Utilities.Math.Functions.spliceFunction(
                        x=ceilingSign*dT,
                        pos=sign(dT)*coeffCeiling*abs(dT)^1.133,
                        neg=sign(dT)*coeffFloor*abs(dT)^1.308,
                        deltax = 0.1);
                end if;
              else
                if linearise then
                  port_a.Q_flow = dT*coeffWall*abs(dT_nominal)^0.293;
                else
                  port_a.Q_flow = sign(dT)*coeffWall*abs(dT)^1.293;
                end if;
              end if;
            port_a.Q_flow + port_b.Q_flow = 0;
            dT = port_a.T - port_b.T;
            annotation (Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{-60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(points={{-60,20},{76,20}}, color={191,0,0}),
                  Line(points={{-34,80},{-34,-80}}, color={0,127,255}),
                  Line(points={{-60,-20},{76,-20}}, color={191,0,0}),
                  Line(points={{56,30},{76,20}}, color={191,0,0}),
                  Line(points={{56,10},{76,20}}, color={191,0,0}),
                  Line(points={{56,-10},{76,-20}}, color={191,0,0}),
                  Line(points={{56,-30},{76,-20}}, color={191,0,0}),
                  Line(points={{6,80},{6,-80}}, color={0,127,255}),
                  Line(points={{40,80},{40,-80}}, color={0,127,255}),
                  Line(points={{76,80},{76,-80}}, color={0,127,255}),
                  Line(points={{-34,-80},{-44,-60}}, color={0,127,255}),
                  Line(points={{-34,-80},{-24,-60}}, color={0,127,255}),
                  Line(points={{6,-80},{-4,-60}}, color={0,127,255}),
                  Line(points={{6,-80},{16,-60}}, color={0,127,255}),
                  Line(points={{40,-80},{30,-60}}, color={0,127,255}),
                  Line(points={{40,-80},{50,-60}}, color={0,127,255}),
                  Line(points={{76,-80},{66,-60}}, color={0,127,255}),
                  Line(points={{76,-80},{86,-60}}, color={0,127,255}),
                  Text(
                    extent={{-150,-90},{150,-130}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-60,80},{-60,-80}},
                    color={0,0,0},
                    thickness=0.5)}), Documentation(info="<html>
<p>
The interior natural convective heat transfer coefficient 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-eZGZlJrg.png\"/> 
is computed for each interior surface as 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-KNBSKUDK.png\"/>where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-W5kvS3SS.png\"/> is the characteristic length of the surface, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-jhC1rqax.png\"/> is the indoor air temperature and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-sbXAgHuQ.png\"/> are correlation coefficients. These parameters {
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-nHmmePq5.png\"/>,
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-zJZmNUzp.png\"/>,
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-7nwXbcLp.png\"/>} are identical to {1.823,-0.121,0.293} for vertical surfaces [Awbi 1999], 
{2.175,-0.076,0.308} for horizontal surfaces wherefore the heat flux is in the same direction as the buoyancy force <a href=\"IDEAS.Buildings.UsersGuide.References\">[Khalifa 2001]</a>, 
and {2.72,-,0.13} for horizontal surfaces wherefore the heat flux is in the opposite direction as the buoyancy force <a href=\"IDEAS.Buildings.UsersGuide.References\">[Awbi 1999]</a>. 
The interior natural convective heat transfer coefficient is only described as function 
of the temperature difference. Similar to the thermal model for heat transfer through a wall, 
a thermal circuit formulation for the direct radiant exchange between surfaces can be derived 
<a href=\"IDEAS.Buildings.UsersGuide.References\">[ Buchberg 1955, Oppenheim 1956]</a>.
</p>
<p>
[Awbi 1999]: H.B. Awbi, A. Hatton, Natural convection from heated room surfaces, Energy and Buildings 30 (1999) 233&ndash;244.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 11, 2016 by Filip Jorissen:<br/>
Adjusted formulation of correlation such that the Jacobian computation of 
non-linear algebraic loops do not lead to negative exponents.
</li>
</ul>
</html>"));
          end InteriorConvection;

          model MonoLayerAir
            "Heat transfer correlations (convection and radiation) for air cavities"

            parameter Modelica.SIunits.Area A "Surface area";
            parameter Modelica.SIunits.Angle inc "Inclination of surface at port a";
            parameter Modelica.SIunits.Length d "Cavity width";

            parameter Modelica.SIunits.Emissivity epsLw_a
              "Longwave emissivity of material connected at port_a";
            parameter Modelica.SIunits.Emissivity epsLw_b
              "Longwave emissivity on material connected at port_b";
            parameter Modelica.SIunits.TemperatureDifference dT_nominal = 1
              "Nominal temperature difference, used for linearising Rayleigh number"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.ThermalConductivity k = 0.026
              "Thermal conductivity of medium, default for air, T=20C";

            parameter Modelica.Media.Interfaces.Types.IsobaricExpansionCoefficient beta=
                3.43e-3
              "Thermal expansion coefficient of medium, default for air, T=20C"
              annotation(Dialog(group="Advanced"));
            parameter Modelica.SIunits.KinematicViscosity nu = 15e-6
              "Kinematic viscosity of medium, default for air, T=20C"
              annotation(Dialog(group="Advanced"));
            parameter Modelica.SIunits.ThermalDiffusivity alpha = 22e-6
              "Thermal diffusivity of medium, default for air, T=300K"
              annotation(Dialog(group="Advanced"));
            parameter Boolean linearise = true
              "Linearise Grashoff number around expected nominal temperature difference"
              annotation(Evaluate=true);
            parameter Boolean checkCoating = true
              "Throws an error if the cavity does not have a coating";

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));

            Modelica.SIunits.ThermalConductance G=
               h*A + A*5.86*(1/((1/epsLw_a) + (1/epsLw_b) - 1));
            //when linearising we assume that Nu is the average Nu for positive and
            //negative temperature differences
            //Eqn 5 from Hollands
            Real Nu=
              if ceiling or floor then
                (if linearise then
                  (1 + (1.44*(1-1708/Ra)+((Ra/5830)^(1/3)-1)))/2
                else
                  if ceiling then
                    IDEAS.Utilities.Math.Functions.spliceFunction(
                      pos=1 + (1.44*max(1-1708/Ra,0)+max((Ra/5830)^(1/3)-1,0)),
                      neg=1,
                      x=sign(port_a.T-port_b.T)*Ra-500,  deltax=100)
                  else
                    IDEAS.Utilities.Math.Functions.spliceFunction(
                      pos=1 + (1.44*max(1-1708/Ra,0)+max((Ra/5830)^(1/3)-1,0)),
                      neg=1,
                      x=sign(port_b.T-port_a.T)*Ra-500,  deltax=100))
              elseif vertical then
                (if Ra>5e4
                  then 0.0673838*Ra^(1/3)
                elseif Ra>1e4
                  then 0.028154*Ra^0.41399
                else 1+1.75967e-10*Ra^2.2984755)
              else 1 "Correlations from Hollands et al. and Wright et al.";

        protected
            final parameter Boolean ceiling=
               IDEAS.Utilities.Math.Functions.isAngle(inc,IDEAS.Types.Tilt.Ceiling)
              "true if ceiling"
              annotation(Evaluate=true);
            final parameter Boolean floor=
               IDEAS.Utilities.Math.Functions.isAngle(inc,IDEAS.Types.Tilt.Floor)
              "true if floor"
              annotation(Evaluate=true);
            final parameter Boolean vertical=
               IDEAS.Utilities.Math.Functions.isAngle(inc,IDEAS.Types.Tilt.Wall)
              annotation(Evaluate=true);
            final parameter Real coeffRa=Modelica.Constants.g_n*beta*d^3/nu/alpha
            "Coefficient for evaluating less operations at run time";
            Real Ra = max(1,(if linearise then abs(dT_nominal) else
              abs(port_a.T-port_b.T))*coeffRa);
            Modelica.SIunits.CoefficientOfHeatTransfer h = Nu*k/d;

        public
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_emb "Internal port"
              annotation (Placement(transformation(extent={{-10,90},{10,110}})));

          equation
            if not (ceiling or floor or vertical) then
              assert(false, "Could not find suitable correlation for air cavity! Please 
      change the inclination to wall, ceiling or floor or remove the air layer.",
                level=AssertionLevel.warning);
            end if;

            if checkCoating then
              assert(abs(epsLw_a - IDEAS.Buildings.Data.Constants.epsLw_glass) > 1e-5
                or abs(epsLw_b - IDEAS.Buildings.Data.Constants.epsLw_glass) > 1e-5,
                "In " + getInstanceName() + ": You are probably unintentionally simulating low 
      performance glazing by not including a coating in the glazing record, 
      to correct it, modify the longwave emissivity within the glazing system.
      This check can be disabled using the parameter checkLowPerformanceGlazing.",
                level=AssertionLevel.error);
            end if;

            port_a.Q_flow + port_b.Q_flow + port_emb.Q_flow=0;
            port_a.Q_flow = G*(port_a.T - port_b.T);
            port_emb.T=(port_a.T+port_b.T)/2;
            annotation (Icon(graphics={
                  Rectangle(
                    extent={{-70,80},{-100,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(points={{-70,20},{66,20}}, color={191,0,0}),
                  Line(points={{-50,80},{-50,-80}}, color={0,127,255}),
                  Line(points={{-70,-20},{66,-20}}, color={191,0,0}),
                  Line(points={{46,30},{66,20}}, color={191,0,0}),
                  Line(points={{46,10},{66,20}}, color={191,0,0}),
                  Line(points={{46,-10},{66,-20}}, color={191,0,0}),
                  Line(points={{46,-30},{66,-20}}, color={191,0,0}),
                  Line(points={{-20,80},{-20,-80}},
                                                color={0,127,255}),
                  Line(points={{20,80},{20,-80}}, color={0,127,255}),
                  Line(points={{50,80},{50,-80}}, color={0,127,255}),
                  Line(points={{-50,80},{-60,60}},   color={0,127,255}),
                  Line(points={{-50,80},{-40,60}},   color={0,127,255}),
                  Line(points={{-20,80},{-30,60}},color={0,127,255}),
                  Line(points={{-20,80},{-10,60}},color={0,127,255}),
                  Line(points={{20,-80},{10,-60}}, color={0,127,255}),
                  Line(points={{20,-80},{30,-60}}, color={0,127,255}),
                  Line(points={{50,-80},{40,-60}}, color={0,127,255}),
                  Line(points={{50,-80},{60,-60}}, color={0,127,255}),
                  Text(
                    extent={{-148,-88},{152,-128}},
                    textString="%name",
                    lineColor={0,0,255}),
                  Line(
                    points={{-70,80},{-70,-80}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(points={{-50,64},{-60,44}},   color={0,127,255}),
                  Line(points={{-50,64},{-40,44}},   color={0,127,255}),
                  Line(points={{50,-60},{60,-40}},color={0,127,255}),
                  Line(points={{50,-60},{40,-40}},color={0,127,255}),
                  Rectangle(
                    extent={{100,80},{70,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{70,80},{70,-80}},
                    color={0,0,0},
                    thickness=0.5)}), Documentation(info="<html>
<p>
Model for computing convective/radiative heat transfer inside air cavities.
</p>
<p>
Optional error which can be enabled/disabled with parameter <code>checkLowPerformanceGlazing</code> checks 
if the user unintentionally is simulating low performance glazing with default emissivities.
</p>
<h4>Assumption and limitations</h4>
<p>
Only valid for horizontal or vertical surfaces.
</p>
<h4>References</h4>
<pre><span style=\"font-family: Courier New,courier;\">Horizontal:</span>
<span style=\"font-family: Courier New,courier;\">K.G.T. Hollands, G.D. Raithby, L. Konicek, Correlation equations for free convection heat transfer in horizontal layers of air and water, International Journal of Heat and Mass Transfer, Volume 18, Issues 7&ndash;8, July&ndash;August 1975, Pages 879-884, ISSN 0017-9310, http://dx.doi.org/10.1016/0017-9310(75)90179-9.</span>
<span style=\"font-family: Courier New,courier;\">(http://www.sciencedirect.com/science/article/pii/0017931075901799)</span>

<span style=\"font-family: Courier New,courier;\">Vertical:</span>
<span style=\"font-family: Courier New,courier;\">Wright, J. 1996. A correlation to quantify convective heat transfer between vertical window glazings, ASHRAE Transactions, 102(1): 940-946.</span></pre>
</html>",           revisions="<html>
<ul>
<li>
September 9, 2019, by Kristoff Six:<br/>
Updated with <code>checkCoating</code> for issue
<a href=\"https://github.com/open-ideas/IDEAS/issues/1038\">#1038</a>.
</li>
<li>
November 10, 2016, by Filip Jorissen:<br/>
Revised implementation for horizontal surfaces such that
less state events are generated.
</li>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
<li>
February 10, 2016, by Filip Jorissen and Damien Picard:<br/>
Revised implementation.
</li>
<li>
November 15, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
          end MonoLayerAir;

          model ExtConvForcedCoeff
            "Calculates convection coefficient for forced flow at an 
  exterior surface as a function of wind speed and direction"
            extends Modelica.Blocks.Icons.Block;

            parameter Modelica.SIunits.Angle inc "Surface inclination";
            parameter Modelica.SIunits.Angle azi "Surface azimuth";

            Modelica.Blocks.Interfaces.RealOutput hForcedConExt
              "Forced flow convective heat transfer coefficient at exterior surface" annotation (Placement(transformation(
                    extent={{100,-10},{120,10}}), iconTransformation(extent={{100,-10},{120,
                      10}})));
            Modelica.Blocks.Interfaces.RealInput winSpe(unit="m/s")
              "Wind speed" annotation (Placement(transformation(extent={{-140,20},{-100,
                      60}})));
            Modelica.Blocks.Interfaces.RealInput winDir(unit="rad")
              "Wind direction" annotation (Placement(transformation(extent={{-140,-60},{
                      -100,-20}})));

        protected
            final parameter Boolean isCeiling=abs(sin(inc)) < 10E-5 and cos(inc) > 0
              "=true, if ceiling"
              annotation(Evaluate=true);
            final parameter Boolean isFloor=abs(sin(inc)) < 10E-5 and cos(inc) < 0
              "=true, if floor"
              annotation(Evaluate=true);

            constant Real a_windward=3.26 "MoWiTT coeff for windward conditions";
            constant Real b_windward=0.89 "MoWiTT coeff for windward conditions";
            constant Real a_leeward=3.55 "MoWiTT coeff for leeward conditions";
            constant Real b_leeward=0.617 "MoWiTT coeff for leeward conditions";

            constant Modelica.SIunits.Angle WindwardVsLeeward=Modelica.SIunits.Conversions.from_deg(100)
              "Angle at which windward vs leeward transition occurs in MoWiTT model";
            constant Real cosWindwardVsLeeward=Modelica.Math.cos(WindwardVsLeeward)
              "Cosine of transition angle";

            Real a "MoWiTT coeff used for current wind direction";
            Real b "MoWiTT coeff used for current wind direction";
          equation

            if isCeiling then
              a = a_windward;
              b = b_windward;
            elseif isFloor then
              a = a_leeward;
              b = b_leeward;
            else // Treat as a vertical surface
              a = IDEAS.Utilities.Math.Functions.spliceFunction(
                pos=a_leeward,
                neg=a_windward,
                x=cosWindwardVsLeeward - Modelica.Math.cos(azi + Modelica.Constants.pi -
                  winDir),
                deltax=0.05);
              b = IDEAS.Utilities.Math.Functions.spliceFunction(
                pos=b_leeward,
                neg=b_windward,
                x=cosWindwardVsLeeward - Modelica.Math.cos(azi + Modelica.Constants.pi -
                  winDir),
                deltax=0.05);
            end if;

            hForcedConExt = a * winSpe^b;

            annotation (Documentation(revisions="<html>
<ul>
<li>
November 28, 2019, by Ian Beausoleil-Morrison:<br/>
First implementation.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1089\">
#1089</a>
</li>
</ul>
</html>",           info="<html>
<p>
This model calculates the convection coefficient at an exterior surface for pure forced flow conditions
for low-rise buildings. 
The forced flow coefficient resulting from this model is combined in 
<a href=\"IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.ExteriorConvection\">
IDEAS.Buildings.Components.BaseClasses.ConvectiveHeatTransfer.ExteriorConvection</a> 
with a coefficient 
for purely natural convection conditions to produce a coefficient for combined natural and forced flow.
</p>
<p>
It applies the &quot;MoWitt&quot; correlation for forced flow, 
which is empirically derived from a Window test facility. 
The correlation&apos;s coefficients are taken from the 
EnergyPlus v8.9 Engineering manual (Table 3.9, Page 95). 
Different coefficients are used in the correlation depending 
on whether the surface is &quot;windward&quot; or &quot;leeward&quot;. 
In this implementation a vertical surface is considered leeward if the 
wind angle is more than 100 degrees from normal incidence. 
Ceilings are always treated as windward, while floors are always treated as leeward.
</p>
<p>
Horizontal&nbsp;surfaces are treated as either a ceiling or a floor. 
Any non-horizontal surface is treated as vertical.
</p>
<p>
The wind speed from the weather file is used in the MoWiTT correlation: 
no adjustments are made for building height or local wind sheltering.
The MoWiTT correlation assumes that the wind speed is measured at the weather
station.
</p>
</html>"));
          end ExtConvForcedCoeff;
        end ConvectiveHeatTransfer;

        package RadiativeHeatTransfer

          model ExteriorHeatRadiation
            "longwave radiative heat exchange of an exterior surface with the environment"
            parameter Modelica.SIunits.Area A "Surface area of heat exchange surface";
            parameter Modelica.SIunits.Temperature Tenv_nom = 280
              "Nominal temperature of environment"
              annotation(Dialog(group="Linearisation", enable=linearise));
            parameter Boolean linearise=true "If true, linearise radiative heat transfer";
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Blocks.Interfaces.RealInput Tenv
              "Radiative temperature of the environment"
              annotation (Placement(transformation(extent={{-120,40},{-80,80}})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature preTem
              "Prescribed temperature block"
              annotation (Placement(transformation(extent={{-10,50},{10,70}})));
            Modelica.Blocks.Interfaces.RealInput epsLw
              "Longwave emissivity of the surface"
              annotation (Placement(transformation(extent={{-120,14},{-80,54}})));
            IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.HeatRadiation
              heaRad(
              final R=R,
              final Tzone_nom=Tenv_nom,
              dT_nom=5,
              final linearise=linearise) "Component for computing radiative heat "
              annotation (Placement(transformation(extent={{-10,-10},{10,10}})));
        protected
            parameter Real R(fixed=false);
          initial equation
            R=1/(Modelica.Constants.sigma*A*epsLw);
          equation
            connect(preTem.port, heaRad.port_b)
              annotation (Line(points={{10,60},{10,0}}, color={191,0,0}));
            connect(heaRad.port_a, port_a)
              annotation (Line(points={{-10,0},{-100,0}}, color={191,0,0}));
            connect(preTem.T, Tenv)
              annotation (Line(points={{-12,60},{-56,60},{-100,60}}, color={0,0,127}));
            annotation (Icon(graphics={
                  Line(points={{-40,10},{40,10}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,16}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,4}}, color={191,0,0}),
                  Line(points={{-40,-10},{40,-10}}, color={191,0,0}),
                  Line(points={{30,-16},{40,-10}}, color={191,0,0}),
                  Line(points={{30,-4},{40,-10}}, color={191,0,0}),
                  Line(points={{-40,-30},{40,-30}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-24}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-36}}, color={191,0,0}),
                  Line(points={{-40,30},{40,30}}, color={191,0,0}),
                  Line(points={{30,24},{40,30}}, color={191,0,0}),
                  Line(points={{30,36},{40,30}}, color={191,0,0}),
                  Rectangle(
                    extent={{-90,80},{-60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{-60,80},{-60,-80}},
                    color={0,0,0},
                    thickness=0.5),
                  Rectangle(
                    extent={{90,80},{60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{60,80},{60,-80}},
                    color={0,0,0},
                    thickness=0.5)}), Documentation(info="<html>
<p>
Longwave radiation between the surface and environment 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-AMjoTx5S.png\"/> is determined as
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-nt0agyic.png\"/>as derived from the Stefan-Boltzmann law wherefore 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-C6ZFvd5P.png\"/> the Stefan-Boltzmann constant 
<a href=\"IDEAS.Buildings.UsersGuide.References\">[Mohr 2008]</a>, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-sLNH0zgx.png\"/> the longwave emissivity of the exterior surface, 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-Q5X4Yht9.png\"/> the radiant-interchange configuration factor between the surface and sky 
<a href=\"IDEAS.Buildings.UsersGuide.References\">[Hamilton 1952]</a>, and the surface and the environment respectively and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-k2V39u5g.png\"/> and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-GuSnzLxW.png\"/> are the exterior surface and sky temperature respectively. 
Shortwave solar irradiation absorbed by the exterior surface is determined as 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-cISf3Itz.png\"/>where 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-IKuIUMef.png\"/> is the shortwave absorption of the surface and 
<img alt=\"equation\" src=\"modelica://IDEAS/Images/equations/equation-Vuo4fgcb.png\"/> the total irradiation on the depicted surface.
</p>
</html>"),    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                      100,100}})));
          end ExteriorHeatRadiation;

          model ExteriorSolarAbsorption
            "Shortwave radiation absorption on an exterior surface"
            parameter Modelica.SIunits.Area A "Surface area";

            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              "Port for heat exchange"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Blocks.Interfaces.RealInput solDir(unit="W/m2")
              "Direct solar irradiation on surface"
              annotation (Placement(transformation(extent={{120,40},{80,80}})));
            Modelica.Blocks.Interfaces.RealInput solDif(unit="W/m2")
              "Diffuse solar irradiation on surface"
              annotation (Placement(transformation(extent={{120,0},{80,40}})));
            Modelica.Blocks.Interfaces.RealInput epsSw
              "Shortwave emissivity of the surface"
              annotation (Placement(transformation(extent={{-120,40},{-80,80}})));

        protected
            parameter Modelica.SIunits.Area ASw(fixed=false)
              "Dummy for converting continuous variable into parameter";

          initial equation
            ASw=-A*epsSw;

          equation
            port_a.Q_flow = ASw*(solDir + solDif);

            annotation (Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{-60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{-60,80},{-60,-80}},
                    color={0,0,0},
                    thickness=0.5),
                  Line(points={{-40,10},{40,10}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,16}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,4}}, color={191,0,0}),
                  Line(points={{-40,-10},{40,-10}}, color={191,0,0}),
                  Line(points={{-40,-30},{40,-30}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-24}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-36}}, color={191,0,0}),
                  Line(points={{-40,30},{40,30}}, color={191,0,0}),
                  Line(points={{-40,30},{-30,36}}, color={191,0,0}),
                  Line(points={{-40,30},{-30,24}},color={191,0,0}),
                  Line(points={{-40,-10},{-30,-4}},color={191,0,0}),
                  Line(points={{-40,-10},{-30,-16}}, color={191,0,0})}), Documentation(
                  info="<html>
<p>Transmitted shortwave solar radiation is distributed over all surfaces in the zone in a prescribed scale. This scale is an input value which may be dependent on the shape of the zone and the location of the windows, but literature <a href=\"IDEAS.Buildings.UsersGuide.References\">[Liesen 1997]</a> shows that the overall model is not significantly sensitive to this assumption.</p>
</html>",           revisions="<html>
<ul>
<li>
October 29, 2018 by Filip Jorissen:<br/>
Improved documentation for
<a href=\"https://github.com/open-ideas/IDEAS/issues/950\">#950</a>.
</li>
<li>
Refactored solar absorption to include parameter for A.
</li>
</ul>
</html>"),    Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})));
          end ExteriorSolarAbsorption;

          model HeatRadiation "radiative heat exchange between two temperatures"
            parameter Real R(unit="K4/W")
              "Heat resistance for longwave radiative heat exchange";
            parameter Boolean linearise = true
              "If true, linearise radiative heat transfer"
              annotation(Evaluate=true, Dialog(group="Linearisation"));
            parameter Modelica.SIunits.Temperature Tzone_nom = 295.15
              "Nominal temperature of environment, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            parameter Modelica.SIunits.TemperatureDifference dT_nom = -2
              "Nominal temperature difference between solid and air, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        protected
            parameter Modelica.SIunits.ThermalConductance coeffLin = 1/R*(2*Tzone_nom+dT_nom)*(Tzone_nom^2+(Tzone_nom+dT_nom)^2)
              "Coefficient allowing less overhead for evaluation functions. This implementation is an approximation of the real linearization f(u)_lin = df/du|(u=u_bar) * (u-u_bar) + f|u_bar. The accuracy of it has been checked.";
            parameter Real coeffNonLin(unit="W/K4") = 1/R
              "Coefficient allowing less overhead for evaluation functions.";
          equation
            port_a.Q_flow+port_b.Q_flow=0;
            if linearise then
              port_a.Q_flow = coeffLin*(port_a.T - port_b.T);
            else
              port_a.Q_flow = coeffNonLin*(port_a.T^4 - port_b.T^4);
            end if;
            annotation (Icon(graphics={Line(points={{-40,10},{40,10}}, color={191,0,0}),
                    Line(points={{-40,10},{-30,16}}, color={191,0,0}),Line(points={{-40,
                    10},{-30,4}}, color={191,0,0}),Line(points={{-40,-10},{40,-10}},
                    color={191,0,0}),Line(points={{30,-16},{40,-10}}, color={191,0,0}),
                    Line(points={{30,-4},{40,-10}}, color={191,0,0}),Line(points={{-40,-30},
                    {40,-30}}, color={191,0,0}),Line(points={{-40,-30},{-30,-24}}, color=
                    {191,0,0}),Line(points={{-40,-30},{-30,-36}}, color={191,0,0}),Line(
                    points={{-40,30},{40,30}}, color={191,0,0}),Line(points={{30,24},{40,
                    30}}, color={191,0,0}),Line(points={{30,36},{40,30}}, color={191,0,0}),
                    Rectangle(
                    extent={{-90,80},{-60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),Line(
                    points={{-60,80},{-60,-80}},
                    color={0,0,0},
                    thickness=0.5),Rectangle(
                    extent={{90,80},{60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),Line(
                    points={{60,80},{60,-80}},
                    color={0,0,0},
                    thickness=0.5)}), Documentation(info="<html>
<p>
Basic implementation of Stefan Boltzmanns law for radiation.
Heat exchange is linearised by default.
</p>
</html>",           revisions="<html>
<ul>
<li>
July 12, 2016 by Filip Jorissen:<br/>
Changed implementation to be more intuitive.
Added units to variables.
</li>
</ul>
</html>"));
          end HeatRadiation;

          model SwWindowResponse "shortwave window respones"
            parameter Integer nLay(min=1) "number of layers of the wall";
            parameter Real[:, nLay + 1] SwAbs
              "absorbed solar radiation for each layer for look-up table as function of angle of incidence";
            parameter Real[:, 2] SwTrans
              "transmitted solar radiation for look-up table as function of angle of incidence";
            parameter Real[nLay] SwAbsDif
              "absorbed solar radiation for each layer for look-up table as function of angle of incidence";
            parameter Real SwTransDif
              "transmitted solar radiation for look-up table as function of angle of incidence";
            final parameter Integer[nLay] columns=if (nLay == 1) then {2} else integer(
                linspace(
                2,
                nLay + 1,
                nLay));
            Modelica.Blocks.Interfaces.RealInput solDir
              "direct solar illuminance on surface se"
              annotation (Placement(transformation(extent={{-120,40},{-80,80}})));
            Modelica.Blocks.Interfaces.RealInput solDif
              "diffuse solar illuminance on surface s"
              annotation (Placement(transformation(extent={{-120,0},{-80,40}})));
            Modelica.Blocks.Interfaces.RealInput angInc "angle of incidence"
              annotation (Placement(transformation(extent={{-120,-60},{-80,-20}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nLay] iSolAbs
              "solar absorptance in the panes"
              annotation (Placement(transformation(extent={{-10,90},{10,110}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a iSolDir
              "transmitted direct solar radiation"
              annotation (Placement(transformation(extent={{-30,-110},{-10,-90}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a iSolDif
              "transmitted difuse solar radiation"
              annotation (Placement(transformation(extent={{10,-110},{30,-90}})));
            Modelica.Blocks.Math.Gain radToDeg(final k=180/Modelica.Constants.pi)
              "Conversion of radians to degrees"
              annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
            Modelica.Blocks.Tables.CombiTable1Ds SwAbsDir(
              final table=SwAbs,
              final smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
              final columns=columns) "lookup table for AOI dependent absorptance"
              annotation (Placement(transformation(
                  extent={{-9,-9},{9,9}},
                  rotation=90,
                  origin={-29,-11})));
            Modelica.Blocks.Tables.CombiTable1Ds SwTransDir(
              final table=SwTrans,
              final smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments,
              final columns={2}) "lookup table for AOI dependent transmittance"
              annotation (Placement(transformation(
                  extent={{-9,-9},{9,9}},
                  rotation=90,
                  origin={-3,-11})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow[nLay] Abs_flow
              "solar absorptance in the panes source" annotation (Placement(
                  transformation(
                  extent={{-8,-8},{8,8}},
                  rotation=90,
                  origin={-8.88178e-016,78})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow Dir_flow
              "transmitted direct solar radiation source" annotation (Placement(
                  transformation(
                  extent={{-8,-8},{8,8}},
                  rotation=-90,
                  origin={-20,-78})));
            Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow Dif_flow
              "transmitted difuse solar radiation source" annotation (Placement(
                  transformation(
                  extent={{-8,-8},{8,8}},
                  rotation=-90,
                  origin={20,-78})));
            Modelica.Blocks.Math.Product[nLay] SwAbsDirProd annotation (Placement(
                  transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=90,
                  origin={-33,19})));
            Modelica.Blocks.Math.Product SwTransDirProd annotation (Placement(
                  transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=90,
                  origin={-7,19})));
            Modelica.Blocks.Math.Add[nLay] add annotation (Placement(transformation(
                  extent={{8,-8},{-8,8}},
                  rotation=-90,
                  origin={-32,48})));
            Modelica.Blocks.Math.Gain[   nLay] SwAbsDifProd(k=SwAbsDif)  annotation (Placement(
                  transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=90,
                  origin={25,21})));
            Modelica.Blocks.Math.Gain    SwTransDifProd(k=SwTransDif)  annotation (Placement(
                  transformation(
                  extent={{-7,-7},{7,7}},
                  rotation=90,
                  origin={51,21})));
          equation
            connect(Abs_flow.port, iSolAbs) annotation (Line(
                points={{4.89859e-016,86},{0,86},{0,100}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(Dir_flow.port, iSolDir) annotation (Line(
                points={{-20,-86},{-20,-100}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(Dif_flow.port, iSolDif) annotation (Line(
                points={{20,-86},{20,-100}},
                color={191,0,0},
                smooth=Smooth.None));
            connect(solDir, SwTransDirProd.u1) annotation (Line(
                points={{-100,60},{-60,60},{-60,4},{-11.2,4},{-11.2,10.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(SwAbsDir.y, SwAbsDirProd.u2) annotation (Line(
                points={{-29,-1.1},{-29,13.45},{-28.8,13.45},{-28.8,10.6}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(SwTransDir.y[1], SwTransDirProd.u2) annotation (Line(
                points={{-3,-1.1},{-3,13.45},{-2.8,13.45},{-2.8,10.6}},
                color={0,0,127},
                smooth=Smooth.None));
            for i in 1:nLay loop
              connect(solDir, SwAbsDirProd[i].u1) annotation (Line(
                  points={{-100,60},{-60,60},{-60,4},{-37.2,4},{-37.2,10.6}},
                  color={0,0,127},
                  smooth=Smooth.None));
              connect(SwAbsDifProd[i].u, solDif) annotation (Line(points={{25,12.6},{25,2},{
                    -64,2},{-64,20},{-100,20}}, color={0,0,127}));
            end for;
            connect(SwTransDirProd.y, Dir_flow.Q_flow) annotation (Line(
                points={{-7,26.7},{-7,50},{80,50},{80,-54},{-20,-54},{-20,-70}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(SwAbsDirProd.y, add.u2) annotation (Line(
                points={{-33,26.7},{-33,31.35},{-36.8,31.35},{-36.8,38.4}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(add.y, Abs_flow.Q_flow) annotation (Line(
                points={{-32,56.8},{-32,62},{-4.89859e-016,62},{-4.89859e-016,70}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(radToDeg.u, angInc) annotation (Line(points={{-62,-40},{-76,-40},{
                    -100,-40}},           color={0,0,127}));
            connect(radToDeg.y, SwAbsDir.u) annotation (Line(points={{-39,-40},{-29,-40},
                    {-29,-21.8}}, color={0,0,127}));
            connect(radToDeg.y, SwTransDir.u) annotation (Line(points={{-39,-40},{-3,-40},
                    {-3,-21.8}},      color={0,0,127}));
            connect(SwAbsDifProd.y, add.u1) annotation (Line(points={{25,28.7},{25,34},{-27.2,
                    34},{-27.2,38.4}}, color={0,0,127}));
            connect(SwTransDifProd.y, Dif_flow.Q_flow) annotation (Line(points={{51,28.7},
                    {51,34},{38,34},{38,-60},{20,-60},{20,-70}}, color={0,0,127}));
             connect(SwTransDifProd.u, solDif) annotation (Line(points={{51,12.6},{51,2},{-64,
                    2},{-64,20},{-100,20}}, color={0,0,127}));
            annotation (
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}})),
              Icon(graphics={
                  Rectangle(
                    extent={{-80,90},{80,70}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{-80,70},{80,70}},
                    pattern=LinePattern.None,
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{44,40},{44,-50}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{44,40},{38,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{44,40},{50,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{14,40},{14,-50}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{14,40},{8,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{14,40},{20,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-16,40},{-16,-50}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-16,40},{-22,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-16,40},{-10,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-46,40},{-46,-50}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-46,40},{-52,30}},
                    smooth=Smooth.None,
                    color={127,0,0}),
                  Line(
                    points={{-46,40},{-40,30}},
                    smooth=Smooth.None,
                    color={127,0,0})}),
              Documentation(info="<html>
<p>The properties for absorption by and transmission through the glazingare taken into account depending on the angle of incidence of solar irradiation and are based on the output of the <a href=\"IDEAS.Buildings.UsersGuide.References\">[WINDOW 6.3]</a> software, i.e. the shortwave properties itselves based on the layers in the window are not calculated in the model but are input parameters. </p>
</html>"));
          end SwWindowResponse;

          model ZoneLwDistribution "internal longwave radiative heat exchange"
            parameter Integer nSurf(min=1) "Number of surfaces connected to the zone";
            parameter Boolean simVieFac = false "Simplify view factor computation";
            parameter Boolean linearise=true "Linearise radiative heat exchange";
            parameter Modelica.SIunits.Temperature Tzone_nom = 295.15
              "Nominal temperature of environment, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            parameter Modelica.SIunits.TemperatureDifference dT_nom = -2
              "Nominal temperature difference between solid and air, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nSurf] port_a
              "Port for radiative heat exchange"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] A(
               each final quantity="Area", each final unit="m2")
              "Surface areas of connected surfaces" annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={40,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] epsLw(
               each final quantity="Emissivity", each final unit="1")
              "Longwave surface emissivities of connected surfaces" annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,100})));
        protected
            parameter Boolean computeCarroll(fixed=false) "if false, then a simplified model is used";
            parameter Real FMax=5 "Upper bound for F";
            parameter Real[nSurf] F1(
               each final fixed=false,
               each final min=0,
               each final max=FMax,
               each start=0.1)
              "View factor estimate by Carroll";
            parameter Real[nSurf] F2(
               each final fixed=false,
               each final min=1e-6,
               each final max=1,
               each start=1)
              "Simplified view factor estimate";
            parameter Real[nSurf] R(
               each final fixed=false,
               each final unit="K4/W")
              "Thermal resistance for longwave radiative heat exchange";
            IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.HeatRadiation[nSurf] radRes(
              R=R,
              each linearise=linearise,
              each dT_nom=dT_nom,
              each Tzone_nom=Tzone_nom)
              "Component that computes radiative heat exchange";
          initial equation
            // see Eqns 29-30 in Liesen, R. J., & Pedersen, C. O. (1997). An Evaluation of Inside Surface Heat Balance Models for Cooling Load Calculations. ASHRAE Transactions, 3(103), 485–502.
            // or Eqns 4 and 10 in Carroll, J.A. 1980. An "MRT method" of computing radiant energy exchange in rooms. Proceedings of the 2nd Sys- tems Simulation and Economics Analysis Conference, January 23-25
            // The additional min(,) and max(,) function cause the Newton solver to find a (wrong) solution instead of crashing.
            // If max(A)<sum(A)/2 is not satisfied, then the non-linear
            // algebraic loop will not converge and therefore we do not compute
            // view factors according to Carroll.
            computeCarroll = not simVieFac and max(A)<sum(A)/2;
            F1= if computeCarroll then {max(0,min(FMax,1/(1 - A[i] .* F1[i]/(A*F1)))) for i in 1:nSurf} else zeros(nSurf);
            F2= A ./ (ones(nSurf)*sum(A) - A);
            // If Carroll's model converged to a solution for F1
            // that does not equal the variable bounds
            // (i.e. the solution converged using the real model equations),
            // then use this model otherwise use a more simplified model
            // since a solution was found, but not for the real model equations.
            // This should only occur for non-physical geometries where
            // it is difficult to argue whether or not this simplification is correct.
            R= if computeCarroll and max(F1)<FMax*0.9 then
                  ((ones(nSurf) - epsLw) ./ epsLw + ones(nSurf)./F1) ./ A/ Modelica.Constants.sigma
                else
                  ((ones(nSurf) - epsLw) ./ (A .* epsLw) + (ones(nSurf) - F2) ./ A)/Modelica.Constants.sigma;
            // Throw a warning when the simplified approach is used.
            assert(max(F1)<FMax*0.9 and computeCarroll or simVieFac,
                    "WARNING: The view factor computed in ZoneLwDistribution could not properly converge. 
          A simplified method is used. 
          This may be caused by trying to model a non-physical geometry.\n",
                    AssertionLevel.warning);
          equation
            for i in 1:nSurf loop
              connect(radRes[i].port_b, port_a[i]);
            end for;
            for i in 1:nSurf - 1 loop
              connect(radRes[i].port_a, radRes[i + 1].port_a);
            end for;
            annotation (
              Diagram(graphics),
              Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{90,-80}},
                    pattern=LinePattern.None,
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Backward,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{68,60},{-68,-60}},
                    pattern=LinePattern.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    lineThickness=0.5),
                  Line(points={{6,0},{64,0}},     color={191,0,0}),
                  Line(points={{6,0},{16,6}},      color={191,0,0}),
                  Line(points={{6,0},{16,-6}},    color={191,0,0}),
                  Line(points={{0,56},{0,12}},      color={191,0,0}),
                  Line(points={{-62,0},{-8,0}},   color={191,0,0}),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={-13,-3},
                    rotation=180),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={-13,3},
                    rotation=180),
                  Line(
                    points={{-68,60},{68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{68,60},{68,-60},{-68,-60},{-68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={-3,17},
                    rotation=270),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={3,17},
                    rotation=270),
                  Line(points={{0,-10},{0,-54}},    color={191,0,0}),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={-3,-49},
                    rotation=270),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={3,-49},
                    rotation=270),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={-3,-15},
                    rotation=270),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={3,-15},
                    rotation=270),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={3,51},
                    rotation=270),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={-3,51},
                    rotation=270),
                  Line(points={{-62,0},{-52,-6}}, color={191,0,0}),
                  Line(points={{-62,0},{-52,6}},   color={191,0,0}),
                  Line(points={{-5,3},{5,-3}},   color={191,0,0},
                    origin={59,3},
                    rotation=180),
                  Line(points={{-5,-3},{5,3}},   color={191,0,0},
                    origin={59,-3},
                    rotation=180)}),
              Documentation(info="<html>
<p>
The Mean Radiant Temperature Network (MRTnet) approach from 
Carroll (1980) is used to compute the radiative heat transfer.
This is a computationally efficient approach that does not require exact view factors to be known.
Each surface exchanges heat with a fictive radiant surface,
leading to a star resistance network.
</p>
<h4>Parameters</h4>
<p>
Parameter <code>simVieFac</code> may be set to false to simplify the 
view factor calculation. This leads to a less accurate computation
of view factors, but this approach is more robust.
It may be used when the initial equation that computes the view factors does not converge.
</p>
<h4>References</h4>
<p>
Liesen, R. J., &amp; Pedersen, C. O. (1997). An Evaluation of Inside Surface Heat Balance Models for Cooling Load Calculations. ASHRAE Transactions, 3(103), 485-502.<br/>
Carroll, J.A. 1980. An \"MRT method\" of computing radiant energy exchange in rooms. Proceedings of the 2nd Sys- tems Simulation and Economics Analysis Conference, January 23-25
</p>
</html>",           revisions="<html>
<ul>
<li>
February 1, 2017 by Filip Jorissen:<br/>
Added option for disabling new view factor computation.
See issue 
<a href=https://github.com/open-ideas/IDEAS/issues/663>#663</a>.
</li>
<li>
January 20, 2017 by Filip Jorissen:<br/>
Changed view factor implementation.
See issue 
<a href=https://github.com/open-ideas/IDEAS/issues/643>#643</a>.
</li>
<li>
January 19, 2017 by Filip Jorissen:<br/>
Updated icon for issue
<a href=https://github.com/open-ideas/IDEAS/issues/641>#641
</a>.
</li>
<li>
January 19, 2017 by Filip Jorissen:<br/>
Propagated parameters for linearisation.
</li>
<li>
July 12, 2016 by Filip Jorissen:<br/>
Changed implementation to be more intuitive.
Added units to variables.
</li>
</ul>
</html>"));
          end ZoneLwDistribution;

          model ZoneLwDistributionViewFactor
            "Internal longwave radiative heat exchange using view factors"
            parameter Integer nSurf(min=1) "number of surfaces in contact with the zone";
            parameter Modelica.SIunits.Angle incCeiling = IDEAS.Types.Tilt.Ceiling;
            parameter Modelica.SIunits.Angle incFloor = IDEAS.Types.Tilt.Floor;
            parameter Modelica.SIunits.Angle incWall = IDEAS.Types.Tilt.Wall;
            parameter Modelica.SIunits.Angle aziSouth = IDEAS.Types.Azimuth.S;
            final parameter Integer numAzi = 4;
            parameter Modelica.SIunits.Length hZone "Distance between floor and ceiling";
            parameter Boolean linearise = true "Linearise radiative heat exchange"
              annotation(Evaluate=true);
            parameter Modelica.SIunits.Temperature Tzone_nom = 295.15
              "Nominal temperature of environment, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            parameter Modelica.SIunits.TemperatureDifference dT_nom = -2
              "Nominal temperature difference between solid and air, used for linearisation"
              annotation(Dialog(group="Linearisation", enable=linearise));
            parameter Real[nSurf,nSurf] vieFac(each fixed=false)
              "Emissivity weighted viewfactor from surface to surface"
              annotation(Dialog(tab="Advanced"));
            final parameter Real[nSurf,nSurf] Umat(each fixed=false);
            Modelica.Blocks.Interfaces.RealInput[nSurf] inc "Surface inclination angles"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={-100,40})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] azi "Surface azimuth angles"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=0,
                  origin={-100,-40})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nSurf] port_a
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] A "surface areas" annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={40,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] epsLw
              "longwave surface emissivities" annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,100})));
            Modelica.Blocks.Interfaces.RealOutput[nSurf] floorArea
              "Amount of floor area for each surface" annotation (Placement(
                  transformation(
                  extent={{-10,-10},{10,10}},
                  rotation=270,
                  origin={-60,-104})));
        protected
            parameter Modelica.SIunits.ThermalConductance coeffLin = 1*(2*Tzone_nom+dT_nom)*(Tzone_nom^2+(Tzone_nom+dT_nom)^2)
              "Coefficient allowing less overhead for evaluation functions. This implementation is an approximation of the real linearization f(u)_lin = df/du|(u=u_bar) * (u-u_bar) + f|u_bar. The accuracy of it has been checked.";
            parameter Real[2+numAzi] Atot(each fixed=false)
              "Total surface area per orientation";
            parameter Real[2+numAzi,2+numAzi] vieFacTot(each fixed=false)
              "Emissivity weighted viewfactor from total of surfaces to each other"
              annotation(Dialog(tab="Advanced"));
            parameter Real lWall(fixed = false);
            parameter Integer index1(fixed=false);
            parameter Integer index2(fixed=false);
            parameter Modelica.SIunits.Area[nSurf] Afloor(each fixed = false);
          initial algorithm
            //initialise surface area to zero
            Atot :=zeros(2 + numAzi);
            // calculate total area for each direction + ceiling/floor
            for i in 1:nSurf loop
              if IDEAS.Utilities.Math.Functions.isAngle(inc[i], incCeiling) then
                // ceiling area: index 1
                Atot[1]:=Atot[1] + A[i];
              elseif IDEAS.Utilities.Math.Functions.isAngle(inc[i], incFloor) then
                // floor area: index 2
                Atot[2]:=Atot[2] + A[i];
              elseif IDEAS.Utilities.Math.Functions.isAngle(inc[i], incWall) or IDEAS.Utilities.Math.Functions.isAngle(inc[i], incWall+Modelica.Constants.pi) then
                  for j in (0:numAzi-1) loop
                    // numAzi wall areas: indices 3 through 6
                    if IDEAS.Utilities.Math.Functions.isAngle(azi[i], aziSouth + j*Modelica.Constants.pi*2/numAzi) then
                      Atot[3+j] :=Atot[3 + j] + A[i];
                      //Modelica.Utilities.Streams.print(String(azi[i]) + " to " + String(j));
                      break;
                    end if;
                  end for;
              else
                Modelica.Utilities.Streams.error("Could not find matching orientation for surface with index " + String(i) +
                    ". Avoid this error by disabling explicit view factor calculation in the zone model");
              end if;
            end for;
            assert(Atot[1]>0, "Zone contains no ceiling surfaces. This needs to be fixed or explicit view factor calculation should be disabled.");
            assert(Atot[2]>0, "Zone contains no floor surfaces. This needs to be fixed or explicit view factor calculation should be disabled.");
            //view factor from ceiling/floor to floor/ceiling
            vieFacTot[1,1] :=0;
            vieFacTot[2,2] :=0;
            vieFacTot[1,2] :=
              IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.viewFactorRectRectPar(
              A=(Atot[1] + Atot[2])/2,
              d=hZone,
              l=(A[3] + A[5])/hZone/2);
            vieFacTot[2,1] := vieFacTot[1,2]*Atot[1]/Atot[2];
            for i in 3:numAzi+2 loop
              //estimate for total wall length
              lWall :=Atot[i]/hZone;
              //view factor for walls to ceiling and floor
              if lWall == 0 then
                for j in 1:numAzi+2 loop
                  vieFacTot[j,i]:=0;
                  vieFacTot[i,j]:=0;
                end for;
              else
              vieFacTot[1,i]:=
                  IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.viewFactorRectRectPerp(
                  lCommon=lWall,
                  W1=hZone,
                  W2=Atot[1]/lWall);
              vieFacTot[i,1]:=vieFacTot[1,i]*Atot[1]/Atot[i];
              vieFacTot[2,i]:=
                  IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.viewFactorRectRectPerp(
                  lCommon=lWall,
                  W1=hZone,
                  W2=Atot[2]/lWall);
              vieFacTot[i,2]:=vieFacTot[2,i]*Atot[2]/Atot[i];
              // walls to walls
                  for j in i:numAzi+2 loop
                    if i==j then
                      //a wall does not interchange radiant heat with itself
                       vieFacTot[i,i] := 0;
                    elseif Atot[i]==0 or Atot[j]==0 then
                      vieFacTot[i,j] := 0;
                      vieFacTot[j,i] := 0;
                    elseif abs(i-j)==1 or abs(i-j)==3 then
                      //surfaces are perpendicular
                      vieFacTot[i,j] :=
                      IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.viewFactorRectRectPerp(
                      lCommon=hZone,
                      W1=Atot[j]/hZone,
                      W2=Atot[i]/hZone);
                      vieFacTot[j,i]:=vieFacTot[i,j]*Atot[i]/Atot[j];
                    elseif abs(i-j) == 2 then
                      //surfaces are parallel
                      vieFacTot[i,j] :=
                      IDEAS.Buildings.Components.BaseClasses.RadiativeHeatTransfer.viewFactorRectRectPar(
                      A=(Atot[i] + Atot[j])/2,
                      d=Atot[integer((i + j)/2)]/hZone,
                      l=hZone);
                      vieFacTot[j,i]:=vieFacTot[i,j]*Atot[i]/Atot[j];
                    else
                      //fixme warning
                    end if;
                  end for;
              end if;
            end for;
            //view factors for real surfaces are calculated from the total surfaces
            for i in 1:nSurf loop
                //set floor area
                Afloor[i]:=0;
                 //determine orientation of first plane
                if IDEAS.Utilities.Math.Functions.isAngle(inc[i], incCeiling) then
                   index1:=1;
                elseif IDEAS.Utilities.Math.Functions.isAngle(inc[i], incFloor) then
                   index1:=2;
                   Afloor[i]:=A[i];
                elseif IDEAS.Utilities.Math.Functions.isAngle(inc[i], incWall) then
                   for k in 0:numAzi-1 loop
                     if IDEAS.Utilities.Math.Functions.isAngle(azi[i], aziSouth + k*Modelica.Constants.pi*2/numAzi) then
                       index1:=2+k+1;
                     break;
                     end if;
                     //warning
                   end for;
                end if;
                  for j in i:nSurf loop
                    if i==j then
                      vieFac[i,j]:=0;
                    else
                        //determine orientation of second plane
                    if IDEAS.Utilities.Math.Functions.isAngle(inc[j], incCeiling) then
                      index2:=1;
                    elseif IDEAS.Utilities.Math.Functions.isAngle(inc[j], incFloor) then
                      index2:=2;
                    elseif IDEAS.Utilities.Math.Functions.isAngle(inc[j], incWall) then
                      for k in 0:numAzi-1 loop
                        if IDEAS.Utilities.Math.Functions.isAngle(azi[j], aziSouth + k*Modelica.Constants.pi*2/numAzi) then
                          index2:=2+k+1;
                          break;
                        end if;
                        //warning
                      end for;
                    end if;
                    Umat[i,j] := if vieFacTot[index1, index2]  < Modelica.Constants.small then 0 else (if linearise then coeffLin else 1) * Modelica.Constants.sigma/(1/A[i]/(vieFacTot[index1, index2]*A[j]/Atot[index2])+(1-epsLw[i])/A[i]/epsLw[i]+(1-epsLw[j])/A[j]/epsLw[j]);
                    Umat[j,i] := if vieFacTot[index2, index1]  < Modelica.Constants.small then 0 else (if linearise then coeffLin else 1) * Modelica.Constants.sigma/(1/A[j]/(vieFacTot[index2, index1]*A[i]/Atot[index1])+(1-epsLw[i])/A[i]/epsLw[i]+(1-epsLw[j])/A[j]/epsLw[j]);
                    end if;
                  end for;
          end for;
                Umat := Umat-identity(nSurf).*(Umat*ones(nSurf,nSurf));
          equation
            if linearise then
              port_a.Q_flow=-Umat*port_a.T;
            else
              port_a.Q_flow=-Umat*port_a.T.^4;
            end if;
            floorArea=Afloor;
            annotation (
              Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                      100}}),
                      graphics),
              Icon(graphics={
                  Rectangle(
                    extent={{-90,80},{90,-80}},
                    pattern=LinePattern.None,
                    fillColor={175,175,175},
                    fillPattern=FillPattern.Backward,
                    lineColor={0,0,0}),
                  Rectangle(
                    extent={{68,60},{-68,-60}},
                    pattern=LinePattern.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,0},
                    lineThickness=0.5),
                  Line(points={{-42,0},{40,0}},     color={191,0,0}),
                  Line(points={{30,-6},{40,0}},    color={191,0,0}),
                  Line(points={{30,6},{40,0}},    color={191,0,0}),
                  Line(points={{-58,6},{-14,50}}, color={191,0,0}),
                  Line(points={{-14,38},{-14,50}},
                                                 color={191,0,0}),
                  Line(points={{-26,50},{-14,50}},
                                                 color={191,0,0}),
                  Line(
                    points={{-68,60},{68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(
                    points={{68,60},{68,-60},{-68,-60},{-68,60}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None),
                  Line(points={{-32,6},{-42,0}},  color={191,0,0}),
                  Line(points={{-32,-6},{-42,0}},  color={191,0,0}),
                  Line(points={{-58,18},{-58,6}},color={191,0,0}),
                  Line(points={{-46,6},{-58,6}}, color={191,0,0}),
                  Line(points={{14,-52},{58,-8}}, color={191,0,0}),
                  Line(points={{26,-52},{14,-52}},
                                                 color={191,0,0}),
                  Line(points={{14,-40},{14,-52}},
                                                 color={191,0,0}),
                  Line(points={{46,-8},{58,-8}}, color={191,0,0}),
                  Line(points={{58,-20},{58,-8}},color={191,0,0}),
                  Line(points={{-22,-22},{22,22}},color={191,0,0},
                    origin={36,28},
                    rotation=90),
                  Line(points={{14,50},{26,50}}, color={191,0,0}),
                  Line(points={{14,38},{14,50}}, color={191,0,0}),
                  Line(points={{46,6},{58,6}},   color={191,0,0}),
                  Line(points={{58,6},{58,18}},  color={191,0,0}),
                  Line(points={{-14,-52},{-14,-40}},
                                                 color={191,0,0}),
                  Line(points={{-22,-22},{22,22}},color={191,0,0},
                    origin={-36,-30},
                    rotation=90),
                  Line(points={{-58,-20},{-58,-8}},
                                                 color={191,0,0}),
                  Line(points={{-58,-8},{-46,-8}},
                                                 color={191,0,0}),
                  Line(points={{-26,-52},{-14,-52}},
                                                 color={191,0,0}),
                  Line(points={{-41,0},{41,0}},     color={191,0,0},
                    origin={-1,0},
                    rotation=90),
                  Line(points={{-5,3},{5,-3}},    color={191,0,0},
                    origin={-5,35},
                    rotation=90),
                  Line(points={{-5,-3},{5,3}},     color={191,0,0},
                    origin={3,35},
                    rotation=90),
                  Line(points={{-5,-3},{5,3}},     color={191,0,0},
                    origin={-5,-35},
                    rotation=90),
                  Line(points={{-5,3},{5,-3}},    color={191,0,0},
                    origin={3,-35},
                    rotation=90)}),
              Documentation(info="<html>
<p>
Computation of longwave radiative heat exchange based on view factors. 
</p>
<h4>Assumption and limitations</h4>
<p>
This implementation is only valid for rectangular geometries.
</p>
<h4>Verification</h4>
<p>
Verification test in IDEAS.Buildings.Validation.Tests.ViewFactorVerification.
</p>
</html>",           revisions="<html>
<ul>
<li>
January 19, 2017 by Filip Jorissen:<br/>
Updated icon for issue
<a href=https://github.com/open-ideas/IDEAS/issues/641>#641
</a>.
</li>
<li>
January 19, 2017 by Filip Jorissen:<br/>
Added options for properly linearising heat exchange.
</li>
<li>
December 8, 2016 by Filip Jorissen:<br/>
Fixed indexing bug in algorithm.
</li>
</ul>
</html>",           revisions="<html>
<ul>
<li>
December 8, 2016 by Filip Jorissen:<br/>
Fixed indexing bug in algorithm.
</li>
</ul>
</html>"));
          end ZoneLwDistributionViewFactor;

          model ZoneLwGainDistribution
            "Distribution of radiative internal gains"

            parameter Integer nSurf(min=1) "number of surfaces in contact with the zone";
            parameter Boolean lineariseJModelica = false
              "=true, to introduce radiative temperature node"
              annotation(Dialog(tab="Advanced"));
            parameter Modelica.SIunits.Time tau = 120
              "Time constant for radiative node"
               annotation(Dialog(enable=lineariseJModelica, tab="Advanced"));
            parameter Modelica.SIunits.Temperature T_start=296.15
              "Start value of radiative temperature node"
              annotation(Dialog(tab = "Advanced", enable=lineariseJModelica));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a iSolDir
              "Direct solar radiation gains received through windows"
              annotation (Placement(transformation(extent={{-110,30},{-90,50}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a iSolDif
              "Diffuse solar radiation gains received through windows"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a radGain
              "External long wave internal gains, e.g. from radiator"
              annotation (Placement(transformation(extent={{-110,-48},{-90,-28}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[nSurf] radSurfTot
              "Port for connecting to surfaces"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
            Modelica.Blocks.Interfaces.RealOutput TRad(start=T_start)
              "Radiative zone temperature, computed as weighted sum of surface temperatures."
              annotation (Placement(transformation(
                  extent={{20,-20},{-20,20}},
                  rotation=90,
                  origin={0,-100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] epsLw(
               each final unit="1")
              "Long wave surface emissivities of connected surfaces" annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={0,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] epsSw(
               each final unit="1")
              "Short wave surface emissivities of connected surfaces" annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={-40,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] area(
               each final unit="m2")
              "Surface areas of connected surfaces" annotation (
                Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=-90,
                  origin={-80,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] inc "Surface inclination angles"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={40,100})));
            Modelica.Blocks.Interfaces.RealInput[nSurf] azi "Surface azimuth angles"
              annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={80,100})));

        protected
            final parameter Real[nSurf] weightFactorDir(each final fixed=false)
              "Distribution factor for incident direct solar irradiation";
            final parameter Real[nSurf] weightFactorDif(each final fixed=false)
              "Distribution factor for incident diffuse solar irradiation";
            final parameter Real[nSurf] weightFactorGain(each final fixed=false)
              "Distribution factor for other radiative heat gains irradiation";
            final parameter Real[nSurf] weightFactorTRad(each final fixed=false)
              "Weight factor for radiative temperature computation";
            final parameter Modelica.SIunits.Area AfloorTot(fixed=false)
              "Total floor surface area";
            final parameter Real ASWotherSurface(fixed=false)
              "Total absorption surface area on surfaces other than the floor";
            final parameter Real fraTotAbsFloor(fixed=false)
              "Fraction of the direct solar irradiation that is absorbed by the floor";

            Modelica.SIunits.Temperature TRad_internal = radSurfTot.T * weightFactorTRad
              "To avoid duplicate operations";

          initial equation
            weightFactorDir = {if IDEAS.Utilities.Math.Functions.isAngle(inc[i], IDEAS.Types.Tilt.Floor)
                               then area[i]*epsSw[i]/AfloorTot
                               else (1-fraTotAbsFloor)*area[i]*epsSw[i]/ASWotherSurface for i in 1:nSurf};
            weightFactorDif = area .* epsSw / sum(area .* epsSw);
            weightFactorGain = area .* epsLw / sum(area .* epsLw);
            // minimum of Modelica.Constants.small to guard against division by zero
            AfloorTot = max(Modelica.Constants.small,sum({if IDEAS.Utilities.Math.Functions.isAngle(inc[i], IDEAS.Types.Tilt.Floor) then area[i] else 0 for i in 1:nSurf}));
            fraTotAbsFloor = sum({if IDEAS.Utilities.Math.Functions.isAngle(inc[i], IDEAS.Types.Tilt.Floor) then area[i]*epsSw[i] else 0 for i in 1:nSurf})/AfloorTot;
            ASWotherSurface = sum({if IDEAS.Utilities.Math.Functions.isAngle(inc[i], IDEAS.Types.Tilt.Floor) then 0 else area[i]*epsSw[i] for i in 1:nSurf});
            weightFactorTRad = weightFactorDif;

            assert(AfloorTot>2*Modelica.Constants.small, "WARNING: Zone does not contain a floor surface so incoming beam radiation is spread over all other surfaces! Is this intended? \n", AssertionLevel.warning);
            assert(AfloorTot<0.9*sum(area), "More than 90% of zone surface area is floor, this is not allowed.");
            assert(abs(1-sum(weightFactorTRad))<1e-4, "Error in computation of weightFactorTRad, please submit a bug report");
            assert(abs(1-sum(weightFactorDir))<1e-4, "Error in computation of weightFactorDir, please submit a bug report");
            assert(abs(1-sum(weightFactorDif))<1e-4, "Error in computation of weightFactorDif, please submit a bug report");
            assert(abs(1-sum(weightFactorGain))<1e-4, "Error in computation of weightFactorGain, please submit a bug report");

            if lineariseJModelica then
              TRad=T_start;
            end if;
          equation
            for k in 1:nSurf loop
              radSurfTot[k].Q_flow =
                -weightFactorDif[k]*iSolDif.Q_flow
                -weightFactorDir[k]*iSolDir.Q_flow
                -weightFactorGain[k]*radGain.Q_flow;
            end for;

            if lineariseJModelica then // this introduces a state for the radiative temperature, which is useful when linearising
              der(TRad) = (TRad_internal - TRad)/tau;
            else
              TRad = TRad_internal;
            end if;

            iSolDir.T = TRad_internal;
            iSolDif.T = TRad_internal;
            radGain.T = TRad_internal;

            annotation (
              Icon(graphics={
                  Line(points={{-40,10},{40,10}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,16}}, color={191,0,0}),
                  Line(points={{-40,10},{-30,4}}, color={191,0,0}),
                  Line(points={{-40,-10},{40,-10}}, color={191,0,0}),
                  Line(points={{30,-16},{40,-10}}, color={191,0,0}),
                  Line(points={{30,-4},{40,-10}}, color={191,0,0}),
                  Line(points={{-40,-30},{40,-30}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-24}}, color={191,0,0}),
                  Line(points={{-40,-30},{-30,-36}}, color={191,0,0}),
                  Line(points={{-40,30},{40,30}}, color={191,0,0}),
                  Line(points={{30,24},{40,30}}, color={191,0,0}),
                  Line(points={{30,36},{40,30}}, color={191,0,0}),
                  Rectangle(
                    extent={{-15,80},{15,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None,
                    origin={9,66},
                    rotation=90),
                  Rectangle(
                    extent={{90,80},{60,-80}},
                    fillColor={192,192,192},
                    fillPattern=FillPattern.Backward,
                    pattern=LinePattern.None),
                  Line(
                    points={{-70,50},{60,50},{60,-80}},
                    color={0,0,0},
                    thickness=0.5,
                    smooth=Smooth.None)}),
              Documentation(info="<html>
<p>
This model computes how radiative gains are redistributed among all surfaces.
We consider 1) diffuse solar gains, 
2) beam solar gains and 
3) other, long wave, internal gains, e.g. from occupants.
</p>
<p>
Diffuse solar gains are redistributed by computing a weighting factor equal to the surface area multiplied with the
shortwave emissivity of the surface.
This factor is used to redistribute the diffuse solar gains among all surfaces.
</p>
<p>
Internal gains from occupants are redistributed in the same way, but using
the long wave emissivity instead of the short wave emissivity.
</p>
<p>
Direct/beam solar gains are redistributed by assuming that a fixed fraction of the beam solar
gains are absorbed by the floor. 
This fraction equals the short wave emissivity of the floor. 
If there are multiple floors (based on the inclination angle) 
then their area and emissivity are used to compute a weight factor for the floors.
The remaining radiation is redistributed over all other surfaces, again using the shortwave emissivity
and surface area to determine the relative fractions.
If there is no floor then the beam radiation is spread over all surfaces and a warning is generated.
</p>
</html>",           revisions="<html>
<ul>
<li>
November 5, 2018 by Filip Jorissen:<br/>
Added initial equation for <code>TRad</code>.
</li>
<li>
October 7, 2018 by Filip Jorissen:<br/>
Improved documentation.
</li>
<li>
March 28, 2018 by Filip Jorissen:<br/>
Added option for introducing state for
radiative temperature.
</li>
<li>
December 22, 2016 by Filip Jorissen:<br/>
Fixed bug in absorption model where
<code>TRad</code> was computed using coefficients for
<code>iSolDir</code> instead of <code>iSolDif</code>.
Added asserts for checking the sum of all 
weight factors.
This closes #605.
</li>
<li>
September 8, 2016 by Filip Jorissen:<br/>
Added warning for when there are no floors and guarded against division by zero.
</li>
<li>
July 15, 2016 by Filip Jorissen:<br/>
New absorption model for beam radiation.
</li>
<li>
July 12, 2016 by Filip Jorissen:<br/>
Simplified implementation by removing intermediate variables.
</li>
</ul>
</html>"));
          end ZoneLwGainDistribution;

          function viewFactorRectRectPar
            "View factor between two equal coaxial parallel rectangular surfaces."
            extends Modelica.Icons.Function;
            input Real A "Area of surface";
            input Real d "Distance between surfaces";
            input Real l "Length of surface";
            output Real vieFac "View factor between surfaces";
        protected
            Real x = l/d;
            Real y = A/l/d;
            Real x1 = sqrt(1+x^2);
            Real y1 = sqrt(1+y^2);
          algorithm
          vieFac := 1/Modelica.Constants.pi/x/y*(log(x1^2*y1^2/(x1^2+y1^2-1)) +
                                                 2*x*(y1*atan(x/y1)-atan(x)) +
                                                 2*y*(x1*atan(y/x1)-atan(y)));
            annotation (Documentation(info="<html>
<p>source: http://webserver.dmt.upm.es/~isidoro/tc3/Radiation%20View%20factors.pdf</p>
</html>"));
          end viewFactorRectRectPar;

          function viewFactorRectRectPerp
            "View factor between two adjacent, perpendicular rectangular surfaces with one common dimension."
            extends Modelica.Icons.Function;
            input Real W1 "Width of surface 1";
            input Real W2 "Width of surface 2";
            input Real lCommon "Common surface edge length";
            output Real vieFac "View factor between surfaces";
        protected
            Real h = W1/lCommon;
            Real w = W2/lCommon;
            Real a = (1+h^2)*(1+w^2)/(1+w^2 + h^2);
            Real b = w^2*(1+h^2+w^2)/(1+w^2)/(h^2+w^2);
            Real c = h^2*(1+h^2+w^2)/(1+h^2)/(h^2+w^2);
            Real subExp = sqrt(h*h+w*w);
          algorithm
            vieFac :=1/w/Modelica.Constants.pi*(h*atan(1/h)+w*atan(1/w) - subExp*atan(1/subExp) + 1/4*log(a*b^(w^2)*c^(h^2)));
          end viewFactorRectRectPerp;
        end RadiativeHeatTransfer;

        package Varia

          model EnergyFlowMultiplicator "Component to scale the energy flow of a energyPort"
            parameter Real k = 1 "Multiplication factor for heat flow";
            ConservationOfEnergy.EnergyPort E_a
              "Unscaled port"
              annotation (Placement(transformation(extent={{-108,-10},{-88,10}})));
            ConservationOfEnergy.EnergyPort E_b
              "Scaled port"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          equation
            E_a.E  * k = - E_b.E;
            E_a.Etot = E_b.Etot;
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                    Polygon(
                    points={{-100,100},{100,-2},{-100,-100},{-100,100}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid), Text(
                    extent={{-50,28},{50,-34}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="E x n"),
                  Text(
                    extent={{-150,-138},{150,-98}},
                    lineColor={0,0,0},
                    textString="k=%k"),
                  Text(
                    extent={{-150,142},{150,102}},
                    textString="%name",
                    lineColor={0,0,255})}),                                Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(revisions="<html>
<ul>
<li>
August 10, 2018 by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
          end EnergyFlowMultiplicator;

          model HeatFlowMultiplicator "Component to scale the energy flow of a energyPort"
            parameter Real k = 1 "Multiplication factor for heat flow rate";
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a
              "Port with unscaled heat flow rate"
              annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b
              "Port with scaled heat flow rate"
              annotation (Placement(transformation(extent={{90,-10},{110,10}})));
          equation
            port_a.Q_flow * k = - port_b.Q_flow;
            port_a.T = port_b.T;
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                    Polygon(
                    points={{-100,100},{100,-2},{-100,-100},{-100,100}},
                    lineColor={255,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid), Text(
                    extent={{-78,36},{50,-34}},
                    lineColor={255,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="Q_flow x n"),
                  Text(
                    extent={{-150,-138},{150,-98}},
                    lineColor={0,0,0},
                    textString="k=%k"),
                  Text(
                    extent={{-150,142},{150,102}},
                    textString="%name",
                    lineColor={0,0,255})}),                                Diagram(
                  coordinateSystem(preserveAspectRatio=false)),
              Documentation(info="<html>
<ul>
<li>
August 10, 2018 by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
          end HeatFlowMultiplicator;
        end Varia;
      end BaseClasses;
    end Components;

    package Data "Data for transient thermal building simulation"
    extends Modelica.Icons.MaterialPropertiesPackage;

      package Constants "Package of constants for building models"

        final constant Real epsLw_glass = 0.84 "Default long wave emissivity";

        final constant Real epsSw_glass = 0.67 "Default short wave emissivity";
        annotation (Documentation(info="<html>
<p>
Package that contains default constants.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 9, 2019, by Kristoff Six:<br/>
Initial version
</li>
</ul>
</html>"));
      end Constants;

      package Constructions "Library of building envelope constructions"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record CavityWall
          "Cavity wall with fully-filled cavity"
          extends IDEAS.Buildings.Data.Interfaces.Construction(
            mats={IDEAS.Buildings.Data.Materials.BrickMe(d=0.08),
                  IDEAS.Buildings.Data.Insulation.Rockwool(d=0.1),
                  IDEAS.Buildings.Data.Materials.BrickMi(d=0.14),
                  IDEAS.Buildings.Data.Materials.Gypsum(d=0.015)});

          annotation (Documentation(info="<html>
<p>
Example implementation of a cavity wall.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
        end CavityWall;

        record FloorOnGround "Floor on ground for floor heating system"
          extends IDEAS.Buildings.Data.Interfaces.Construction(
            locGain={3},
            incLastLay = IDEAS.Types.Tilt.Floor,
            mats={
              IDEAS.Buildings.Data.Materials.Concrete(d=0.20),
              IDEAS.Buildings.Data.Insulation.Rockwool(d=0.1),
              IDEAS.Buildings.Data.Materials.Screed(d=0.08),
              IDEAS.Buildings.Data.Materials.Concrete(d=0.015)});


          annotation (Documentation(revisions="<html>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
        end FloorOnGround;
      annotation (Documentation(info="<html>
<p>By convention the last material layer of a construction type is connected to propsBus_a of the building component.</p>
</html>"));
      end Constructions;

      package Frames "Library of building glazing frames"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record None "None"
          extends IDEAS.Buildings.Data.Interfaces.Frame( present=false);
          annotation (Documentation(info="<html>
<p>
A dummy model that should be used if the window has no frame.
</p>
</html>"));
        end None;
      end Frames;

      package Glazing "Library of building glazing systems"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record Ins2 = IDEAS.Buildings.Data.Interfaces.Glazing (
            final nLay=3,
            final mats={
              Materials.Glass(d=0.004,epsLw_a=0.04),
              Materials.Air(d=0.015),
              Materials.Glass(d=0.004, epsLw_b=0.04)},
            final SwTrans=[0, 0.521;
                          10, 0.524;
                          20, 0.517;
                          30, 0.508;
                          40, 0.495;
                          50, 0.472;
                          60, 0.418;
                          70, 0.312;
                          80, 0.153;
                          90, 0.000],
            final SwAbs=[0, 0.102, 0.0, 0.022;
                        10, 0.104, 0.0, 0.022;
                        20, 0.112, 0.0, 0.023;
                        30, 0.117, 0.0, 0.023;
                        40, 0.119, 0.0, 0.025;
                        50, 0.123, 0.0, 0.026;
                        60, 0.135, 0.0, 0.027;
                        70, 0.142, 0.0, 0.029;
                        80, 0.105, 0.0, 0.031;
                        90, 0.000, 0.0, 0.000],
            final SwTransDif=0.418,
            final SwAbsDif={0.135,0.0,0.027},
            final U_value=1.4,
            final g_value=0.755)
          "Saint Gobain ClimaPlus Futur AR 1.4 4/15/4 (U = 1.4 W/m2K, g = 0.755)"
          annotation (Documentation(revisions="<html>
<ul>
<li>
September 2, 2015, by Filip Jorissen:<br/>
Moved epsLw definition to solid layer to be consistent 
with changed implementation of MultiLayerLucent.
</li>
</ul>
</html>",         info="<html>
<p>
Double insulated glazing system.
</p>
</html>"));
      end Glazing;

      package Insulation "Library of thermal insulation materials"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record Rockwool = IDEAS.Buildings.Data.Interfaces.Insulation (
            k=0.036,
            c=840,
            rho=110,
            epsLw=0.8,
            epsSw=0.8) "Rockwool" annotation (Documentation(info="<html>
<p>
Rockwool insulation thermal properties.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
      end Insulation;

      package Materials "Library of construction materials"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record Air = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.0241,
            c=1008,
            rho=1.23,
            epsSw=0,
            epsLw=0,
            gas=true,
            mhu=18.3*10e-6) "Air" annotation (Documentation(info="<html>
<p>
Constant air thermal properties.
</p>
</html>"));

        record Argon = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.0162,
            c=519,
            rho=1.70,
            epsSw=0,
            epsLw=0,
            gas=true,
            mhu=22.9*10e-6) "Argon gass" annotation (Documentation(info="<html>
<p>
Constant argon thermal properties.
</p>
</html>"));

        record BrickMe = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.75,
            c=840,
            rho=1400,
            epsLw=0.88,
            epsSw=0.55) "Medium masonry for exterior applications " annotation (
            Documentation(info="<html>
<p>
Thermal properties of medium bricks for exterior masonry.
</p>
</html>"));

        record BrickMi = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.54,
            c=840,
            rho=1400,
            epsLw=0.88,
            epsSw=0.55) "Medium masonry for interior applications " annotation (
            Documentation(info="<html>
<p>
Thermal properties of medium bricks for interior masonry.
</p>
</html>"));

        record Concrete = IDEAS.Buildings.Data.Interfaces.Material (
            k=1.4,
            c=840,
            rho=2100,
            epsLw=0.88,
            epsSw=0.55) "Dense cast concrete, also for finishing" annotation (
            Documentation(info="<html>
<p>
Thermal properties of concrete.
</p>
</html>"));

        record Glass = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.96,
            c=750,
            rho=2500,
            epsLw=IDEAS.Buildings.Data.Constants.epsLw_glass,
            epsSw=IDEAS.Buildings.Data.Constants.epsSw_glass) "Glass" annotation (Documentation(info="<html>
<p>
Thermal properties of glass.
</p>
</html>"));

        record Ground = IDEAS.Buildings.Data.Interfaces.Material (
            k=2.0,
            c=1250,
            rho=1600,
            epsLw=0.88,
            epsSw=0.68) annotation (Documentation(info="<html>
<p>
Thermal properties of ground/soil.
</p>
</html>"));

        record Gypsum = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.6,
            c=840,
            rho=975,
            epsLw=0.85,
            epsSw=0.65) "Gypsum plaster for finishing" annotation (Documentation(info="<html>
<p>
Thermal properties of gypsum.
</p>
</html>"));

        record Screed = IDEAS.Buildings.Data.Interfaces.Material (
            k=0.6,
            c=840,
            rho=1100,
            epsLw=0.88,
            epsSw=0.55) "Light cast concrete" annotation (Documentation(info="<html>
<p>
Thermal properties of screed.
</p>
</html>"));
      end Materials;

      package Interfaces "Building data interfaces"
      extends Modelica.Icons.InterfacesPackage;

        record BasicMaterial
          "Template record for properties of building materials"
          extends Modelica.Icons.MaterialProperty;
          parameter Modelica.SIunits.ThermalConductivity k "Thermal conductivity";
          parameter Modelica.SIunits.SpecificHeatCapacity c "Specific thermal capacity";
          parameter Modelica.SIunits.Density rho "Density";
          annotation (Documentation(info="<html>
<p>
This record may be used to define material properties.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
        end BasicMaterial;

        partial record Construction "Template record for surface structure: define/order layers from outer to inner"
          extends Modelica.Icons.MaterialProperty;
          final parameter Integer nLay(min=1)=size(mats,1)
            "Number of layers of the construction, including gaps";
          final parameter Integer nGain = size(locGain,1)
           "Number of gain heat ports";
          parameter Integer locGain[:](each min=1) = {1}
            "Location of possible embedded system: between layer locGain and layer locGain + 1";
          // where locGain=1 is the first layer
          parameter IDEAS.Buildings.Data.Interfaces.Material[:] mats
            "Array of materials. The last layer is connected to propsBus_a.";
          parameter Modelica.SIunits.Angle incLastLay = IDEAS.Types.Tilt.Other
            "Set to IDEAS.Types.Tilt.Floor if the last layer of mats is a floor, to .Ceiling if it is a ceiling and to .Other if other. For verification purposes.";
          annotation (Documentation(info="<html>
<p>
This record may be used to define the structure of constructions (walls).
</p>
<h4>Typical use and important parameters</h4>
<p>
Parameter <code>mats</code> should be used to define 
the type and thickness of each material layers.
</p>
<p>
Parameter <code>incLastLay</code> may be used
to define the intended inclination angle
of the last material layer.
This is to check if you correctly connect
models that used this construction since
otherwise the natural convection correlations
may be computed for instance assuming a floor
orientation instead of a ceiling orientation.
</p>
<h4>Assumption and limitations</h4>
<p>
Edge effects are neglected. 
A simple correlation for unventilated cavities
is used when modeling an air layer.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
November 14, 2016 by Filip Jorissen:<br/>
Removed insulationType and insulationThickness
as these parameters could lead to confusion.
See <a href=https://github.com/open-ideas/IDEAS/issues/583>issue 583</a>.
</li>
<li>
Augustus 1, 2016 by Filip Jorissen:<br/>
Set default <code>nLay(min=1)=size(mats,1)</code> 
and <code>nGain = size(locGain,1)</code>.
</li>
</ul>
</html>"));
        end Construction;

        partial record Frame "Template record for window frames"
          extends Modelica.Icons.MaterialProperty;
          parameter Boolean present=true;
          parameter Modelica.SIunits.ThermalConductance U_value=1.1 "U-value window frame";
          replaceable parameter IDEAS.Buildings.Components.ThermalBridges.None briTyp "Thermal bridge type";
          replaceable parameter IDEAS.Buildings.Data.Interfaces.Material mat(
            k=0.1,
            rho=1000,
            c=1000) "Material type, used for emissivity properties only";
          annotation (Documentation(info="<html>
<p>
This record may be used to define the thermal properties of a window frame. 
The U_value is used to compute the thermal losses of the frame. 
The material type <code>mat</code> is only used for the emissivity values 
and is therefore of lesser importance.
A thermal bridge may optionally be defined as well. 
</p>
</html>",         revisions="<html>
<ul>
<li>
December 19, 2016, by Filip Jorissen:<br/>
Added thermal bridge type and material type.
</li>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
        end Frame;

        record Glazing
          "Template record for glazing, based on  Window software by LBNL"
          extends Modelica.Icons.MaterialProperty;

          parameter Integer nLay(min=1)
            "Number of layers of the glazing, including gaps";
          parameter IDEAS.Buildings.Data.Interfaces.Material[nLay] mats
            "Array of materials, ordered from outside to inside. Add coatings to glass by setting epsLw_a for inward facing sides of the glass, epsLw_b for outward.";
          parameter Real[:, nLay + 1] SwAbs
            "Absorbed solar radiation for each layer as function of angle of incidence";
          parameter Real[:, 2] SwTrans
            "Transmitted solar radiation as function of angle of incidence";
          parameter Real[nLay] SwAbsDif
            "Absorbed solar radiation for each layer as function of angle of incidence";
          parameter Real SwTransDif
            "Transmitted solar radiation as function of angle of incidence";

          parameter Modelica.SIunits.CoefficientOfHeatTransfer U_value "Design U-value. (Only used for calculation Qdesign)";
          parameter Real g_value
            "Design g-value. (Not used in calculation, only informative)";
          parameter Boolean checkLowPerformanceGlazing = true
            "Throw error when the glazing does not have a coating in the cavity";
          annotation (Documentation(info="<html>
  <p>
  The <code>Glazing.mo</code> partial describes the material data 
  required for glazing construction modelling.
  </p>
  <p>
  The correct parameter values for your type of glazing can be 
  generated using the 
  <a href=\"http://windows.lbl.gov/software/window/window.html\">Window software from LBNL</a>. 
  In the software open the \"glazing system\" library. 
  On this page choose the number of layers (typical two or three) and 
  fill in the glazing types. Make sure to \"flip\" the glass sheet 
  when necessary so that the coating is on the correct side of the glass. 
  Press calc to calculate the parameters.
  </p>
  <p>
  The resulting parameters can be filled in as follows. 
  </p>
  <p>
  In result tab \"Center of Glass Results\" copy <code>Ufactor</code>
  to <code>U_value</code>. In result tab \"Angular data\" open 
  \"Angular data\". Fill in the values of <code>Tsol</code> 
  (0-90 degrees) in <code>SwTrans</code>. The last value (Hemis) is filled 
  in under <code>SwTransDif</code>. Fill in the values under <code>Abs1</code>, 
  <code>Abs2</code>, <code>Abs3</code> in into <code>SwAbs</code> and 
  <code>SwAbsDif</code> in a similar fashion. Parameter <code>g_value</code> 
  does not need to be filled in. 
  </p>
  <p>
Furthermore, it is important that the <code>epsLw_b</code>
or <code>epsLw_a</code> fields of the glazing layers are adjusted
to reflect the effect of the glazing coating, assuming it exists.
This makes the difference of a U value of about 3 W/mK or 1 W/mK for double glazing!
See <a href=\"modelica://IDEAS.Buildings.Data.Glazing.Ins2Ar\">IDEAS.Buildings.Data.Glazing.Ins2Ar</a>
for an example with double glazing that has 1 glazed sheet with a coating on the inside.
</p>
<p> When no coatings are detected, ie. when the emissivities are default, an error is thrown to inform 
the user that he/she is probably unintentionally simulating low performance glazing. The error can be 
disabled with the parameter <code>checkLowPerformanceGlazing</code>.
</p> 
<h4>Validation</h4>
<p>
To verify the U-value of your glazing system implementation,
see <a href=\"modelica://IDEAS.Buildings.Components.Validations.WindowEN673\">
IDEAS.Buildings.Components.Validations.WindowEN673</a>
</p>
</html>",         revisions="<html>
<ul>
<li>
September 9, 2019, by Kristoff Six:<br/>
Updated with <code>errorLowPerformance</code> for issue
<a href=\"https://github.com/open-ideas/IDEAS/issues/1038\">#1038</a>.
</li>
<li>
November 27, 2018, by Filip Jorissen:<br/>
Revised documentation for issue
<a href=\"https://github.com/open-ideas/IDEAS/issues/959\">#959</a>.
</li>
</ul>
</html>"));
        end Glazing;

        record Insulation
          "Template record for insulation (optional, may be directly implemented in construction!)"
          extends IDEAS.Buildings.Data.Interfaces.Material;
        end Insulation;

        record Material "Template record for properties of building materials"

          extends IDEAS.Buildings.Data.Interfaces.BasicMaterial;

          parameter Modelica.SIunits.Length d=0 "Layer thickness";
          parameter Modelica.SIunits.Emissivity epsLw=0.85 "Longwave emisivity";
          parameter Modelica.SIunits.Emissivity epsSw=0.85 "Shortwave emissivity";
          parameter Boolean gas=false "Boolean whether the material is a gas"
            annotation(Evaluate=true);
          parameter Boolean glass=false "Boolean whether the material is made of glass"
            annotation(Evaluate=true);
          parameter Modelica.SIunits.KinematicViscosity mhu = 0
            "Viscosity, i.e. if the material is a fluid";

          parameter Modelica.SIunits.Emissivity epsLw_a = epsLw
            "Longwave emisivity for surface a if different";
          parameter Modelica.SIunits.Emissivity epsLw_b = epsLw
            "Longwave emisivity for surface a if different";

          parameter Modelica.SIunits.Emissivity epsSw_a = epsSw
            "Shortwave emisivity for surface a if different";
          parameter Modelica.SIunits.Emissivity epsSw_b = epsSw
            "Shortwave emisivity for surface a if different";

          final parameter Modelica.SIunits.ThermalInsulance R=d/k;

          final parameter Modelica.SIunits.ThermalDiffusivity alpha=k/(c*rho)
            "Thermal diffusivity";
          final parameter Integer nStaRef=3
            "Number of states of a reference case, ie. 20 cm dense concrete";
          final parameter Real piRef=224
            "d/sqrt(mat.alpha) of a reference case, ie. 20 cm dense concrete";
          final parameter Real piLay=d/sqrt(alpha)
            "d/sqrt(mat.alpha) of the depicted layer";
          final parameter Integer nSta(min=2) = max(2, integer(ceil(nStaRef*piLay/piRef)))
            "Actual number of state variables in material";

          annotation (Documentation(info="<html>
<p>
This record may be used to define material properties.
</p>
</html>",         revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
        end Material;
      end Interfaces;
    end Data;

    package Validation "BESTEST Validation"
    extends Modelica.Icons.SensorsPackage;

      package Data
      extends Modelica.Icons.MaterialPropertiesPackage;

        package Constructions
        extends Modelica.Icons.MaterialPropertiesPackage;

          record HeavyFloor "BESTEST heavy floor"
            extends IDEAS.Buildings.Data.Interfaces.Construction(
              incLastLay = IDEAS.Types.Tilt.Floor,
              final mats={
                IDEAS.Buildings.Validation.Data.Insulation.InsulationFloor(d=1.007),
                IDEAS.Buildings.Validation.Data.Materials.ConcreteSlab(d=0.08)});

          end HeavyFloor;
        end Constructions;

        package Insulation
        extends Modelica.Icons.MaterialPropertiesPackage;

          record InsulationFloor =
            IDEAS.Buildings.Data.Interfaces.Insulation (
              final k=0.040,
              final c=10,
              final rho=10,
              epsLw=0.9,
              epsSw=0.6) "BESTEST floor insulation";
        end Insulation;

        package Materials
        extends Modelica.Icons.MaterialPropertiesPackage;

          record ConcreteSlab
            "BESTEST concrete slab"
            extends IDEAS.Buildings.Data.Interfaces.Material(
              final k=1.130,
              final c=1000,
              final rho=1400,
              epsLw=0.9,
              epsSw=0.6);
          end ConcreteSlab;
        end Materials;
      end Data;
    end Validation;
  end Buildings;

  package Controls "Package with models for controls"
    extends Modelica.Icons.Package;

    package Continuous "Package with models for discrete time controls"
      extends Modelica.Icons.Package;

      block LimPID
        "P, PI, PD, and PID controller with limited output, anti-windup compensation and setpoint weighting"

        extends Modelica.Blocks.Interfaces.SVcontrol;
        output Real controlError = u_s - u_m
          "Control error (set point - measurement)";

        parameter Modelica.Blocks.Types.SimpleController controllerType=
               Modelica.Blocks.Types.SimpleController.PID "Type of controller";
        parameter Real k(min=0, unit="1") = 1 "Gain of controller";
        parameter Modelica.SIunits.Time Ti(min=Modelica.Constants.small)=0.5
          "Time constant of Integrator block" annotation (Dialog(enable=
                controllerType == Modelica.Blocks.Types.SimpleController.PI or
                controllerType == Modelica.Blocks.Types.SimpleController.PID));
        parameter Modelica.SIunits.Time Td(min=0)=0.1
          "Time constant of Derivative block" annotation (Dialog(enable=
                controllerType == Modelica.Blocks.Types.SimpleController.PD or
                controllerType == Modelica.Blocks.Types.SimpleController.PID));
        parameter Real yMax(start=1)=1 "Upper limit of output";
        parameter Real yMin=0 "Lower limit of output";
        parameter Real wp(min=0) = 1 "Set-point weight for Proportional block (0..1)";
        parameter Real wd(min=0) = 0 "Set-point weight for Derivative block (0..1)"
             annotation(Dialog(enable=controllerType==.Modelica.Blocks.Types.SimpleController.PD or
                                      controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real Ni(min=100*Modelica.Constants.eps) = 0.9
          "Ni*Ti is time constant of anti-windup compensation"
           annotation(Dialog(enable=controllerType==.Modelica.Blocks.Types.SimpleController.PI or
                                    controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real Nd(min=100*Modelica.Constants.eps) = 10
          "The higher Nd, the more ideal the derivative block"
             annotation(Dialog(enable=controllerType==.Modelica.Blocks.Types.SimpleController.PD or
                                      controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Modelica.Blocks.Types.InitPID initType= Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState
          "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)"
                                           annotation(Evaluate=true,
            Dialog(group="Initialization"));
            // Removed as the Limiter block no longer uses this parameter.
            // parameter Boolean limitsAtInit = true
            //  "= false, if limits are ignored during initialization"
            // annotation(Evaluate=true, Dialog(group="Initialization"));
        parameter Real xi_start=0
          "Initial or guess value value for integrator output (= integrator state)"
          annotation (Dialog(group="Initialization",
                      enable=controllerType==.Modelica.Blocks.Types.SimpleController.PI or
                             controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real xd_start=0
          "Initial or guess value for state of derivative block"
          annotation (Dialog(group="Initialization",
                               enable=controllerType==.Modelica.Blocks.Types.SimpleController.PD or
                                      controllerType==.Modelica.Blocks.Types.SimpleController.PID));
        parameter Real y_start=0 "Initial value of output"
          annotation(Dialog(enable=initType == Modelica.Blocks.Types.InitPID.InitialOutput, group=
                "Initialization"));
        parameter Boolean strict=true "= true, if strict limits with noEvent(..)"
          annotation (Evaluate=true, choices(checkBox=true), Dialog(tab="Advanced"));

        parameter Boolean reverseAction = false
          "Set to true for throttling the water flow rate through a cooling coil controller";

        parameter IDEAS.Types.Reset reset = IDEAS.Types.Reset.Disabled
          "Type of controller output reset"
          annotation(Evaluate=true, Dialog(group="Integrator reset"));

        parameter Real y_reset=xi_start
          "Value to which the controller output is reset if the boolean trigger has a rising edge, used if reset == IDEAS.Types.Reset.Parameter"
          annotation(Dialog(enable=reset == IDEAS.Types.Reset.Parameter,
                            group="Integrator reset"));

        Modelica.Blocks.Interfaces.BooleanInput trigger if
             reset <> IDEAS.Types.Reset.Disabled
          "Resets the controller output when trigger becomes true"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}},
              rotation=90,
              origin={-80,-120})));

        Modelica.Blocks.Interfaces.RealInput y_reset_in if
             reset == IDEAS.Types.Reset.Input
          "Input signal for state to which integrator is reset, enabled if reset = IDEAS.Types.Reset.Input"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

        Modelica.Blocks.Math.Add addP(k1=revAct*wp, k2=-revAct) "Adder for P gain"
         annotation (Placement(
              transformation(extent={{-80,40},{-60,60}})));
        Modelica.Blocks.Math.Add addD(k1=revAct*wd, k2=-revAct) if with_D
          "Adder for D gain"
          annotation (Placement(
              transformation(extent={{-80,-10},{-60,10}})));
        Modelica.Blocks.Math.Gain P(k=1) "Proportional term"
          annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
        Utilities.Math.IntegratorWithReset I(
          final reset=if reset == IDEAS.Types.Reset.Disabled then reset else IDEAS.Types.Reset.Input,
          final y_reset=y_reset,
          final k=unitTime/Ti,
          final y_start=xi_start,
          final initType=if initType == Modelica.Blocks.Types.InitPID.SteadyState then
              Modelica.Blocks.Types.Init.SteadyState
                   else if initType == Modelica.Blocks.Types.InitPID.InitialState
                        or initType == Modelica.Blocks.Types.InitPID.DoNotUse_InitialIntegratorState
                   then Modelica.Blocks.Types.Init.InitialState
                   else Modelica.Blocks.Types.Init.NoInit) if
             with_I "Integral term"
             annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));

        Modelica.Blocks.Continuous.Derivative D(
          final k=Td/unitTime,
          final T=max([Td/Nd,1.e-14]),
          final x_start=xd_start,
          final initType=if initType == Modelica.Blocks.Types.InitPID.SteadyState or
                      initType == Modelica.Blocks.Types.InitPID.InitialOutput
                   then
                     Modelica.Blocks.Types.Init.SteadyState
                   else
                     if initType == Modelica.Blocks.Types.InitPID.InitialState then
                       Modelica.Blocks.Types.Init.InitialState
                     else
                       Modelica.Blocks.Types.Init.NoInit) if with_D "Derivative term"
                                                           annotation (Placement(
              transformation(extent={{-40,-10},{-20,10}})));

        Modelica.Blocks.Math.Add3 addPID(
          final k1=1,
          final k2=1,
          final k3=1) "Adder for the gains"
          annotation (Placement(transformation(extent={{0,-10},{20,10}})));

    protected
        constant Modelica.SIunits.Time unitTime=1 annotation (HideResult=true);

        final parameter Real revAct = if reverseAction then -1 else 1
          "Switch for sign for reverse action";

        parameter Boolean with_I = controllerType==Modelica.Blocks.Types.SimpleController.PI or
                                   controllerType==Modelica.Blocks.Types.SimpleController.PID
          "Boolean flag to enable integral action"
          annotation(Evaluate=true, HideResult=true);
        parameter Boolean with_D = controllerType==Modelica.Blocks.Types.SimpleController.PD or
                                   controllerType==Modelica.Blocks.Types.SimpleController.PID
          "Boolean flag to enable derivative action"
          annotation(Evaluate=true, HideResult=true);

        Modelica.Blocks.Sources.Constant Dzero(final k=0) if not with_D
          "Zero input signal"
          annotation(Evaluate=true, HideResult=true,
                     Placement(transformation(extent={{-30,20},{-20,30}})));

        Modelica.Blocks.Sources.Constant Izero(final k=0) if not with_I
          "Zero input signal"
          annotation(Evaluate=true, HideResult=true,
                     Placement(transformation(extent={{10,-55},{0,-45}})));

        Modelica.Blocks.Interfaces.RealInput y_reset_internal
         "Internal connector for controller output reset"
         annotation(Evaluate=true);

        Modelica.Blocks.Math.Add3 addI(
          final k1=revAct,
          final k2=-revAct) if with_I
          "Adder for I gain"
             annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));

        Modelica.Blocks.Math.Add addSat(
          final k1=+1,
          final k2=-1) if with_I
          "Adder for integrator feedback"
          annotation (Placement(
              transformation(
              origin={80,-50},
              extent={{-10,-10},{10,10}},
              rotation=270)));

        Modelica.Blocks.Math.Gain gainPID(final k=k) "Multiplier for control gain"
         annotation (Placement(transformation(
                extent={{30,-10},{50,10}})));

        Modelica.Blocks.Math.Gain gainTrack(k=1/(k*Ni)) if with_I
          "Gain for anti-windup compensation"
          annotation (
            Placement(transformation(extent={{60,-80},{40,-60}})));

        Modelica.Blocks.Nonlinear.Limiter limiter(
          final uMax=yMax,
          final uMin=yMin,
          final strict=strict,
          homotopyType=Modelica.Blocks.Types.LimiterHomotopy.NoHomotopy)
                               "Output limiter"
          annotation (Placement(transformation(extent={{70,-10},{90,10}})));


        Modelica.Blocks.Sources.RealExpression intRes(
          final y=y_reset_internal/k - addPID.u1 - addPID.u2) if
             reset <> IDEAS.Types.Reset.Disabled
          "Signal source for integrator reset"
          annotation (Placement(transformation(extent={{-80,-90},{-60,-70}})));

      initial equation
        if initType==Modelica.Blocks.Types.InitPID.InitialOutput then
           gainPID.y = y_start;
        end if;

      equation
        assert(yMax >= yMin, "LimPID: Limits must be consistent. However, yMax (=" + String(yMax) +
                             ") < yMin (=" + String(yMin) + ")");
        if initType == Modelica.Blocks.Types.InitPID.InitialOutput and (y_start < yMin or y_start > yMax) then
            Modelica.Utilities.Streams.error("LimPID: Start value y_start (=" + String(y_start) +
               ") is outside of the limits of yMin (=" + String(yMin) +") and yMax (=" + String(yMax) + ")");
        end if;

        // Equations for conditional connectors
        connect(y_reset_in, y_reset_internal);

        if reset <> IDEAS.Types.Reset.Input then
          y_reset_internal = y_reset;
        end if;

        connect(u_s, addP.u1) annotation (Line(points={{-120,0},{-96,0},{-96,56},{
                -82,56}}, color={0,0,127}));
        connect(u_s, addD.u1) annotation (Line(points={{-120,0},{-96,0},{-96,6},{
                -82,6}}, color={0,0,127}));
        connect(u_s, addI.u1) annotation (Line(points={{-120,0},{-96,0},{-96,-42},{
                -82,-42}}, color={0,0,127}));
        connect(addP.y, P.u) annotation (Line(points={{-59,50},{-42,50}}, color={0,
                0,127}));
        connect(addD.y, D.u)
          annotation (Line(points={{-59,0},{-42,0}}, color={0,0,127}));
        connect(addI.y, I.u) annotation (Line(points={{-59,-50},{-42,-50}}, color={
                0,0,127}));
        connect(P.y, addPID.u1) annotation (Line(points={{-19,50},{-10,50},{-10,8},
                {-2,8}}, color={0,0,127}));
        connect(D.y, addPID.u2)
          annotation (Line(points={{-19,0},{-2,0}}, color={0,0,127}));
        connect(I.y, addPID.u3) annotation (Line(points={{-19,-50},{-10,-50},{-10,
                -8},{-2,-8}}, color={0,0,127}));
        connect(addPID.y, gainPID.u)
          annotation (Line(points={{21,0},{28,0}}, color={0,0,127}));
        connect(gainPID.y, addSat.u2) annotation (Line(points={{51,0},{60,0},{60,
                -20},{74,-20},{74,-38}}, color={0,0,127}));
        connect(gainPID.y, limiter.u)
          annotation (Line(points={{51,0},{68,0}}, color={0,0,127}));
        connect(limiter.y, addSat.u1) annotation (Line(points={{91,0},{94,0},{94,
                -20},{86,-20},{86,-38}}, color={0,0,127}));
        connect(limiter.y, y)
          annotation (Line(points={{91,0},{110,0}}, color={0,0,127}));
        connect(addSat.y, gainTrack.u) annotation (Line(points={{80,-61},{80,-70},{62,
                -70}},    color={0,0,127}));
        connect(gainTrack.y, addI.u3) annotation (Line(points={{39,-70},{-88,-70},{-88,
                -58},{-82,-58}},     color={0,0,127}));
        connect(u_m, addP.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,44},{-82,44}},
            color={0,0,127},
            thickness=0.5));
        connect(u_m, addD.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,-6},{-82,-6}},
            color={0,0,127},
            thickness=0.5));
        connect(u_m, addI.u2) annotation (Line(
            points={{0,-120},{0,-92},{-92,-92},{-92,-50},{-82,-50}},
            color={0,0,127},
            thickness=0.5));
        connect(Dzero.y, addPID.u2) annotation (Line(points={{-19.5,25},{-14,25},{
                -14,0},{-2,0}}, color={0,0,127}));
        connect(Izero.y, addPID.u3) annotation (Line(points={{-0.5,-50},{-10,-50},{
                -10,-8},{-2,-8}}, color={0,0,127}));
        connect(trigger, I.trigger) annotation (Line(points={{-80,-120},{-80,-88},{-30,
                -88},{-30,-62}}, color={255,0,255}));
        connect(intRes.y, I.y_reset_in) annotation (Line(points={{-59,-80},{-50,-80},{
                -50,-58},{-42,-58}}, color={0,0,127}));
         annotation (
      defaultComponentName="conPID",
      Documentation(info="<html>
<p>
This model is similar to
<a href=\"modelica://Modelica.Blocks.Continuous.LimPID\">Modelica.Blocks.Continuous.LimPID</a>,
except for the following changes:
</p>

<ol>
<li>
<p>
It can be configured to have a reverse action.
</p>
<p>If the parameter <code>reverseAction=false</code> (the default), then
<code>u_m &lt; u_s</code> increases the controller output,
otherwise the controller output is decreased. Thus,
</p>
<ul>
  <li>for a heating coil with a two-way valve, set <code>reverseAction = false</code>, </li>
  <li>for a cooling coils with a two-way valve, set <code>reverseAction = true</code>. </li>
</ul>
</li>

<li>
<p>
It can be configured to enable an input port that allows resetting the controller
output. The controller output can be reset as follows:
</p>
<ul>
  <li>
  If <code>reset = IDEAS.Types.Reset.Disabled</code>, which is the default,
  then the controller output is never reset.
  </li>
  <li>
  If <code>reset = IDEAS.Types.Reset.Parameter</code>, then a boolean
  input signal <code>trigger</code> is enabled. Whenever the value of
  this input changes from <code>false</code> to <code>true</code>,
  the controller output is reset by setting <code>y</code>
  to the value of the parameter <code>y_reset</code>.
  </li>
  <li>
  If <code>reset = IDEAS.Types.Reset.Input</code>, then a boolean
  input signal <code>trigger</code> is enabled. Whenever the value of
  this input changes from <code>false</code> to <code>true</code>,
  the controller output is reset by setting <code>y</code>
  to the value of the input signal <code>y_reset_in</code>.
  </li>
</ul>
<p>
Note that this controller implements an integrator anti-windup. Therefore,
for most applications, keeping the default setting of
<code>reset = IDEAS.Types.Reset.Disabled</code> is sufficient.
Examples where it may be beneficial to reset the controller output are situations
where the equipment control input should continuously increase as the equipment is
switched on, such as as a light dimmer that may slowly increase the luminance, or
a variable speed drive of a motor that should continuously increase the speed.
</p>
</li>

<li>
The parameter <code>limitsAtInit</code> has been removed.
</li>

<li>
Some parameters assignments in the instances have been made final.
</li>

</ol>
</html>",
      revisions="<html>
<ul>
<li>
September 29, 2016, by Michael Wetter:<br/>
Refactored model.
</li>
<li>
August 25, 2016, by Michael Wetter:<br/>
Removed parameter <code>limitsAtInit</code> because it was only propagated to
the instance <code>limiter</code>, but this block no longer makes use of this parameter.
This is a non-backward compatible change.<br/>
Revised implemenentation, added comments, made some parameter in the instances final.
</li>
<li>July 18, 2016, by Philipp Mehrfeld:<br/>
Added integrator reset.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/494\">issue 494</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Changed the default value to <code>strict=true</code> in order to avoid events
when the controller saturates.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/433\">issue 433</a>.
</li>
<li>
February 24, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Rectangle(
                extent={{-6,-20},{66,-66}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.P),
                extent={{-32,-22},{68,-62}},
                lineColor={0,0,0},
                textString="P",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PI),
                extent={{-28,-22},{72,-62}},
                lineColor={0,0,0},
                textString="PI",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PD),
                extent={{-16,-22},{88,-62}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175},
                textString="P D"),
              Text(
                visible=(controllerType == Modelica.Blocks.Types.SimpleController.PID),
                extent={{-14,-22},{86,-62}},
                lineColor={0,0,0},
                textString="PID",
                fillPattern=FillPattern.Solid,
                fillColor={175,175,175}),
              Polygon(
                points={{-80,90},{-88,68},{-72,68},{-80,90}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(points={{-80,78},{-80,-90}}, color={192,192,192}),
              Line(points={{-80,-80},{-80,-20},{30,60},{80,60}}, color={0,0,127}),
              Line(points={{-90,-80},{82,-80}}, color={192,192,192}),
              Polygon(
                points={{90,-80},{68,-72},{68,-88},{90,-80}},
                lineColor={192,192,192},
                fillColor={192,192,192},
                fillPattern=FillPattern.Solid),
              Line(
                visible=strict,
                points={{30,60},{81,60}},
                color={255,0,0},
                smooth=Smooth.None)}));
      end LimPID;
    annotation (
    preferredView="info", Documentation(info="<html>
This package contains component models for continuous time controls.
For additional models, see also
<a href=\"modelica://Modelica.Blocks.Continuous\">
Modelica.Blocks.Discrete</a>.
</html>"),
    Icon(graphics={Line(
              origin={0.061,4.184},
              points={{81.939,36.056},{65.362,36.056},{14.39,-26.199},{-29.966,
                  113.485},{-65.374,-61.217},{-78.061,-78.184}},
              color={95,95,95},
              smooth=Smooth.Bezier)}));
    end Continuous;

    package ControlHeating "Controllers for thermal systems"
    extends Modelica.Icons.Package;

      model RunningMeanTemperatureEN15251
        "Calculate the running mean temperature of 7 days, acccording to norm EN15251"
         discrete Modelica.Blocks.Interfaces.RealOutput TRm(unit="K",displayUnit = "degC")
          "Running mean average temperature"
           annotation (Placement(transformation(extent={{96,-10},{116,10}})));
        Modelica.Blocks.Sources.RealExpression TAmb(y=sim.Te)
          annotation (Placement(transformation(extent={{-80,-10},{-60,10}})));
        outer BoundaryConditions.SimInfoManager sim
          annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
    protected
        parameter Modelica.SIunits.Time t_start(fixed=false) "Start time of the model";
        parameter Real coeTRm[7] = {1, 0.8, 0.6, 0.5, 0.4, 0.3, 0.2}./3.8
          "weighTAmb.yg coefficient for the running average";
        discrete Real[7] TAveDay(each unit="K",each displayUnit = "degC")
          "Vector with the average day temperatures of the previous nTermRm days";
        Real intTAmb "integral of TAmb.y";
      initial equation
        intTAmb=0;
        t_start = time;
        TAveDay=ones(7).*sim.Te;
        TRm=sim.Te;
      equation
        der(intTAmb) =  TAmb.y;
      algorithm
        when sample(t_start+24*3600,24*3600) then
          // Update of TAveDay
          for i in 2:7 loop
            TAveDay[i] := pre(TAveDay[i-1]);
          end for;
          TAveDay[1] := intTAmb / 24/3600;
          TRm :=TAveDay*coeTRm;
        end when;
      equation
          // reinitialisation of the intTAmb
        when sample(t_start+24*3600,24*3600) then
          reinit(intTAmb,0);
        end when;
        annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics),
          experiment(StopTime=864000),
          __Dymola_experimentSetupOutput,
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Rectangle(
                extent={{100,100},{-100,-100}},
                lineColor={100,100,100},
                fillPattern=FillPattern.Solid,
                fillColor={255,255,255}),
              Line(
                points={{0,100},{98,0},{0,-100}},
                color={100,100,100},
                smooth=Smooth.None),
              Text(
                extent={{-100,140},{100,100}},
                lineColor={0,0,255},
                textString="%name"),
              Text(
                extent={{-48,32},{58,-26}},
                lineColor={0,0,255},
                textString="EN15251")}),
      Documentation(revisions="<html>
<ul>
<li>
April 17, 2018, by Damien Picard:<br/>
Add t_start in sample to compute correctly for non zero initial time.<br/>
Use sim.Te as initialization instead of an arbitrary value of 283.15K.
</li>
<li>
January 19, 2015, by Damien Picard:<br/>
First implementation.
</li>
</ul>
</html>"));
      end RunningMeanTemperatureEN15251;
    end ControlHeating;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains component models for controls.
For additional models, see also
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
        Rectangle(
          origin={0.0,35.1488},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Rectangle(
          origin={0.0,-34.8512},
          fillColor={255,255,255},
          extent={{-30.0,-20.1488},{30.0,20.1488}}),
        Line(
          origin={-51.25,0.0},
          points={{21.25,-35.0},{-13.75,-35.0},{-13.75,35.0},{6.25,35.0}}),
        Polygon(
          origin={-40.0,35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{10.0,0.0},{-5.0,5.0},{-5.0,-5.0}}),
        Line(
          origin={51.25,0.0},
          points={{-21.25,35.0},{13.75,35.0},{13.75,-35.0},{-6.25,-35.0}}),
        Polygon(
          origin={40.0,-35.0},
          pattern=LinePattern.None,
          fillPattern=FillPattern.Solid,
          points={{-10.0,0.0},{5.0,5.0},{5.0,-5.0}})}));
  end Controls;

  package Fluid "Package with models for fluid flow systems"
    extends Modelica.Icons.Package;

    package Actuators "Package with actuator models such as valves and dampers"
      extends Modelica.Icons.VariantsPackage;

      package Valves "Package with valve models"
        extends Modelica.Icons.VariantsPackage;

        model ThreeWayEqualPercentageLinear
          "Three way valve with equal percentage and linear characteristics"
            extends BaseClasses.PartialThreeWayValve(
              redeclare TwoWayEqualPercentage res1(R=R, delta0=delta0),
              redeclare TwoWayLinear res3);
          parameter Real R = 50 "Rangeability, R=50...100 typically";
          parameter Real delta0 = 0.01
            "Range of significant deviation from equal percentage law";
        equation
          connect(inv.y, res3.y) annotation (Line(points={{-62.6,46},{20,46},{20,46},{
                  20,-50},{12,-50}},
                                 color={0,0,127}));
          connect(y_actual, inv.u2) annotation (Line(points={{50,70},{84,70},{84,32},{-68,
                  32},{-68,41.2}},
                                 color={0,0,127}));
          connect(y_actual, res1.y) annotation (Line(points={{50,70},{84,70},{84,32},{
                  -50,32},{-50,12}},
                color={0,0,127}));
          annotation (                       Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                  extent={{-72,24},{-34,-20}},
                  lineColor={255,255,255},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="%%")}),
        defaultComponentName="val",
        Documentation(info="<html>
<p>
Three way valve with equal percentage characteristics
between <code>port_1</code> and <code>port_2</code>
and linear opening characteristic between <code>port_3</code> and <code>port_2</code>.
Such opening characteristics were typical for valves from Landis &amp; Gyr (now
Siemens).
</p><p>
This model is based on the partial valve models
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a> and
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
See
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>
for the implementation of the three way valve
and see
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>
for the implementation of the regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal</code>.
See
<a href=\"modelica://IDEAS.Fluid.Actuators.UsersGuide\">
IDEAS.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
February 14, 2012 by Michael Wetter:<br/>
Added filter to approximate the travel time of the actuator.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy method.
</li>
<li>
June 16, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ThreeWayEqualPercentageLinear;

        model ThreeWayEqualPercentageMixedLinear
          "Three way valve with mixed equal percentage and linear characteristics"
            extends IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve(
            final fraK=1,
            redeclare IDEAS.Fluid.Actuators.Valves.TwoWayEqualPercentageLinear res1,
            redeclare IDEAS.Fluid.Actuators.Valves.TwoWayLinear res3);
        equation
          connect(inv.y, res3.y) annotation (Line(points={{-62.6,46},{20,46},{20,46},{
                  20,-50},{12,-50}},
                                 color={0,0,127}));
          connect(y_actual, inv.u2) annotation (Line(points={{50,70},{84,70},{84,32},{-68,
                  32},{-68,41.2}},
                                 color={0,0,127}));
          connect(y_actual, res1.y) annotation (Line(points={{50,70},{84,70},{84,32},{
                  -50,32},{-50,12}},
                color={0,0,127}));
          annotation (                       Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Text(
                  extent={{-72,24},{-34,-20}},
                  lineColor={255,255,255},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="%%")}),
        defaultComponentName="val",
        Documentation(info="<html>
<p>
Three way valve with mixed equal percentage characteristics
between <code>port_1</code> and <code>port_2</code>
and linear opening characteristic between <code>port_3</code> and <code>port_2</code>.
Such opening characteristics are typical for valves from Siemens three-way valves.
</p><p>
This model is based on the partial valve models
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a> and
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
See
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>
for the implementation of the three way valve
and see
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>
for the implementation of the regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
October 14, 2018 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ThreeWayEqualPercentageMixedLinear;

        model TwoWayEqualPercentage
          "Two way valve with equal percentage flow characteristics"
          extends BaseClasses.PartialTwoWayValveKv(phi=if homotopyInitialization then
                homotopy(actual=IDEAS.Fluid.Actuators.BaseClasses.equalPercentage(
                y_actual,
                R,
                l,
                delta0), simplified=l + y_actual*(1 - l)) else
                IDEAS.Fluid.Actuators.BaseClasses.equalPercentage(
                y_actual,
                R,
                l,
                delta0));
          parameter Real R=50 "Rangeability, R=50...100 typically";
          parameter Real delta0=0.01
            "Range of significant deviation from equal percentage law";
        initial equation
          // Since the flow model IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow computes
          // 1/k^2, the parameter l must not be zero.
          assert(l > 0, "Valve leakage parameter l must be bigger than zero.");
          assert(l < 1/R, "Wrong parameters in valve model.\n"
                        + "  Rangeability R = " + String(R) + "\n"
                        + "  Leakage flow l = " + String(l) + "\n"
                        + "  Must have l < 1/R = " + String(1/R));
          annotation (
            defaultComponentName="val",
            Documentation(info="<html>
<p>
Two way valve with an equal percentage valve opening characteristic.
</p><p>
This model is based on the partial valve model
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
Check this model for more information, such
as the regularization near the origin.
</p>
</html>",         revisions="<html>
<ul>
<li>
April 4, 2014, by Michael Wetter:<br/>
Moved the assignment of the flow function <code>phi</code>
to the model instantiation because in its base class,
the keyword <code>input</code>
has been added to the variable <code>phi</code>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal</code>.
See
<a href=\"modelica://IDEAS.Fluid.Actuators.UsersGuide\">
IDEAS.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
February 14, 2012 by Michael Wetter:<br/>
Added filter to approximate the travel time of the actuator.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy method.
</li>
<li>
June 5, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),         Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Text(
                  extent={{-74,20},{-36,-24}},
                  lineColor={255,255,255},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  textString="%%")}));
        end TwoWayEqualPercentage;

        model TwoWayEqualPercentageLinear
          "Two way valve with mixed equal-percentage and linear characteristic"
          extends IDEAS.Fluid.Actuators.Valves.TwoWayPolynomial(
            final c={0,0.5304,-0.7698,1.2278});
          annotation (Documentation(revisions="<html>
<ul>
<li>
October 14, 2018 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Two way valve with a mixed equal percentage / linear valve opening characteristic.
The characteristic is linear for valve openings smaller than 30 % and equal percentage otherwise.
This valve characteristic is based on the Siemens VVF series.
</p>
<p>
This model is based on the partial valve model
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
Check this model for more information, such
as the regularization near the origin.
</p>
</html>"));
        end TwoWayEqualPercentageLinear;

        model TwoWayLinear "Two way valve with linear flow characteristics"
          extends BaseClasses.PartialTwoWayValveKv(phi=l + y_actual*(1 - l));
        initial equation
          // Since the flow model IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow computes
          // 1/k^2, the parameter l must not be zero.
          assert(l > 0, "Valve leakage parameter l must be bigger than zero.");
        annotation (
        defaultComponentName="val",
        Documentation(info="<html>
<p>
Two way valve with linear opening characteristic.
</p><p>
This model is based on the partial valve model
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
Check this model for more information, such
as the regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 4, 2014, by Michael Wetter:<br/>
Moved the assignment of the flow function <code>phi</code>
to the model instantiation because in its base class,
the keyword <code>input</code>
has been added to the variable <code>phi</code>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal=0</code>.
See
<a href=\"modelica://IDEAS.Fluid.Actuators.UsersGuide\">
IDEAS.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TwoWayLinear;

        model TwoWayPolynomial "Two way valve with polynomial characteristic"
          extends IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValveKv(
            phi=l + pol_y*(1 - l));
          parameter Real[:] c
            "Polynomial coefficients, starting with fixed offset";
      protected
          constant Integer nP = 100
            "Number of points for initial algorithm test";
          Real pol_y = sum(c.*{y_actual^i for i in 0:size(c,1)-1})
            "Polynomial of valve control signal";
          // Test the validity of the provided valve coefficients
        initial equation
          // We compute the analytic derivative of the polynomial for y=(1/points),
          // where the derivative of y^j = j*y^(j-1).
          if size(c, 1)>=2 then
            for i in 0:nP/2 loop
              assert(sum({c[j+1]*j*(i/nP)^(j-1) for j in 1:size(c, 1) - 1})>=0,
              "The provided valve polynomial coefficients 
      do not lead to a strictly increasing characteristic for y="         + String(i/nP)+ ". This is not allowed.");
            end for;
          end if;
          assert(c[1]>=0, "The provided valve polynomial coefficients do not lead to 
  a valve opening that is larger than or equal to zero for a control signal of zero.");
          assert(sum(c)<=1.1, "The provided valve polynomial coefficients do not lead to 
  a valve opening that is smaller than or equal to one for a control signal of one.");
        annotation (
        defaultComponentName="val",
        Documentation(info="<html>
<p>
Two way valve with polynomial opening characteristic.
The polynomial coefficients are defined using parameter <code>c</code>.
The elements of <code>c</code> are coefficients for increasing powers of <code>y</code>,
starting with the power <code>0</code>, which corresponds to a fixed offset.
This valve model can be used to implement valves with a custom
opening characteristic, such as a combination
of a linear and an equal percentage characteristic.
</p>
<p>
This model is based on the partial valve model
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
Check this model for more information, such
as the regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 30, 2017 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TwoWayPolynomial;

        model TwoWayPressureIndependent "Model of a pressure-independent two way valve"
          extends IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve(
                    final linearized = false,
                    from_dp=true,
                    phi=l + y_actual*(1 - l));
          parameter Real l2(min=1e-10) = 0.01
            "Gain for mass flow increase if pressure is above nominal pressure"
            annotation(Dialog(tab="Advanced"));
          parameter Real deltax = 0.02 "Transition interval for flow rate"
            annotation(Dialog(tab="Advanced"));
      protected
          parameter Real coeff1 = l2/dp_nominal*m_flow_nominal
            "Parameter for avoiding unnecessary computations";
          parameter Real coeff2 = 1/coeff1
            "Parameter for avoiding unnecessary computations";
          constant Real y2dd = 0
            "Second derivative at second support point";
          Modelica.SIunits.MassFlowRate m_flow_set
            "Requested mass flow rate";
          Modelica.SIunits.PressureDifference dp_min(displayUnit="Pa")
            "Minimum pressure difference required for delivering requested mass flow rate";
          Modelica.SIunits.PressureDifference dp_x, dp_x1, dp_x2, dp_y2, dp_y1
            "Support points for interpolation flow functions";
          Modelica.SIunits.MassFlowRate m_flow_x, m_flow_x1, m_flow_x2, m_flow_y2, m_flow_y1
            "Support points for interpolation flow functions";
          Modelica.SIunits.MassFlowRate m_flow_smooth
            "Smooth interpolation result between two flow regimes";
          Modelica.SIunits.PressureDifference dp_smooth
            "Smooth interpolation result between two flow regimes";
        equation
          m_flow_set = m_flow_nominal*phi;
          kVal = Kv_SI;
          if (dpFixed_nominal > Modelica.Constants.eps) then
            k = sqrt(1/(1/kFixed^2 + 1/kVal^2));
          else
            k = kVal;
          end if;
          dp_min = IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                      m_flow=m_flow_set,
                      k=k,
                      m_flow_turbulent=m_flow_turbulent);
          if from_dp then
            m_flow_x=0;
            m_flow_x1=0;
            m_flow_x2=0;
            dp_y1=0;
            dp_y2=0;
            dp_smooth=0;
            dp_x = dp-dp_min;
            dp_x1 = -dp_x2;
            dp_x2 = deltax*dp_min;
            // min function ensures that m_flow_y1 does not increase further for dp_x > dp_x1
            m_flow_y1 = IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                                          dp=min(dp, dp_min+dp_x1),
                                          k=k,
                                          m_flow_turbulent=m_flow_turbulent);
            // max function ensures that m_flow_y2 does not decrease further for dp_x < dp_x2
            m_flow_y2 = m_flow_set + coeff1*max(dp_x,dp_x2);
            m_flow_smooth = noEvent(smooth(2,
                if dp_x <= dp_x1
                then m_flow_y1
                elseif dp_x >=dp_x2
                then m_flow_y2
                else IDEAS.Utilities.Math.Functions.quinticHermite(
                         x=dp_x,
                         x1=dp_x1,
                         x2=dp_x2,
                         y1=m_flow_y1,
                         y2=m_flow_y2,
                         y1d= IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der(
                                             dp=dp_min + dp_x1,
                                             k=k,
                                             m_flow_turbulent=m_flow_turbulent,
                                             dp_der=1),
                         y2d=coeff1,
                         y1dd=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2(
                                             dp=dp_min + dp_x1,
                                             k=k,
                                             m_flow_turbulent=m_flow_turbulent,
                                             dp_der=1,
                                             dp_der2=0),
                         y2dd=y2dd)));
          else
            dp_x=0;
            dp_x1=0;
            dp_x2=0;
            m_flow_y1=0;
            m_flow_y2=0;
            m_flow_smooth=0;
            m_flow_x = m_flow-m_flow_set;
            m_flow_x1 = -m_flow_x2;
            m_flow_x2 = deltax*m_flow_set;
            // min function ensures that dp_y1 does not increase further for m_flow_x > m_flow_x1
            dp_y1 = IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                                             m_flow=min(m_flow, m_flow_set + m_flow_x1),
                                             k=k,
                                             m_flow_turbulent=m_flow_turbulent);
            // max function ensures that dp_y2 does not decrease further for m_flow_x < m_flow_x2
            dp_y2 = dp_min + coeff2*max(m_flow_x, m_flow_x2);
            dp_smooth = noEvent(smooth(2,
                if m_flow_x <= m_flow_x1
                then dp_y1
                elseif m_flow_x >=m_flow_x2
                then dp_y2
                else IDEAS.Utilities.Math.Functions.quinticHermite(
                         x=m_flow_x,
                         x1=m_flow_x1,
                         x2=m_flow_x2,
                         y1=dp_y1,
                         y2=dp_y2,
                         y1d=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der(
                                             m_flow=m_flow_set + m_flow_x1,
                                             k=k,
                                             m_flow_turbulent=m_flow_turbulent,
                                             m_flow_der=1),
                         y2d=coeff2,
                         y1dd=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2(
                                             m_flow=m_flow_set + m_flow_x1,
                                             k=k,
                                             m_flow_turbulent=m_flow_turbulent,
                                             m_flow_der=1,
                                             m_flow_der2=0),
                         y2dd=y2dd)));
          end if;
          if homotopyInitialization then
            if from_dp then
              m_flow=homotopy(actual=m_flow_smooth,
                              simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
            else
                dp=homotopy(
                   actual=dp_smooth,
                   simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
            end if;
          else
            if from_dp then
              m_flow=m_flow_smooth;
            else
              dp=dp_smooth;
            end if;
          end if;
          annotation (defaultComponentName="val",
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}),       graphics={
                Polygon(
                  points={{2,-2},{-76,60},{-76,-60},{2,-2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-50,40},{0,-2},{54,40},{54,40},{-50,40}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-52,-42},{0,-4},{60,40},{60,-42},{-52,-42}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,-2},{82,60},{82,-60},{0,-2}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{0,40},{0,-4}}),
                Line(
                  visible=not use_inputFilter,
                  points={{0,100},{0,40}})}),
        Documentation(info="<html>
<p>
Two way valve with a pressure-independent valve opening characteristic.
The mass flow rate is controlled such that it is nearly equal to its
set point <code>y*m_flow_nominal</code>, unless the pressure
<code>dp</code> is too low, in which case a regular <code>Kv</code>
characteristic is used.
</p>
<h4>Main equations</h4>
<p>
First the minimum pressure head <code>dp_min</code>
required for delivering the requested mass flow rate
<code>y*m_flow_nominal</code> is computed. If
<code>dp &gt; dp_min</code> then the requested mass flow
rate is supplied. If <code>dp &lt; dp_min</code> then
<code>m_flow = Kv/sqrt(dp)</code>. Transition between
these two flow regimes happens in a smooth way.
</p>
<h4>Typical use and important parameters</h4>
<p>
This model is configured by setting <code>m_flow_nominal</code>
to the mass flow rate that the valve should supply when it is
completely open, i.e., <code>y = 1</code>. The pressure drop corresponding
to this working point can be set using <code>dpValve_nominal</code>,
or using a <code>Kv</code>, <code>Cv</code> or <code>Av</code>
value. The parameter <code>dpValve_fixed</code> can be used to add
additional pressure drops, although in this valve it is equivalent to
add these to <code>dpValve_nominal</code>.
</p>
<p>
The parameter <code>l2</code> represents the non-ideal
leakage behaviour of this valve for high pressures.
It is assumed that the mass flow rate will rise beyond
the requested mass flow rate <code>y*m_flow_nominal</code>
if <code>dp &gt; dpValve_nominal+dpFixed_nominal</code>.
The parameter <code>l2</code> represents the slope
of this rise:
<code>d(m_flow)/d(dp) = l2* m_flow_nominal/dp_nominal</code>.
In the ideal case <code>l2=0</code>, but
this may introduce singularities, for instance when
connecting this component with a fixed mass flow source.
</p>
<h4>Options</h4>
<p>
Parameter <code>deltax</code> sets the duration of
the transition region between the two flow regimes
as a fraction of <code>dp_nominal</code> or <code>m_flow_nominal</code>,
depending on the value of <code>from_dp</code>.
</p>
<h4>Implementation</h4>
<p>
Note that the result in the transition region when
using <code>from_dp = true</code> is not identical to
the result when using <code>from_dp = false</code>.
</p>
<p>
Variables <code>*_y1</code> and <code>*_y2</code>
serve a dual use.
They are used to
1) compute the support points at <code>*_x1</code> and <code>*_x2</code>,
which should not depend on <code>m_flow</code> or <code>dp</code> and
2) to compute the flow functions when outside of this regime,
which does depend on <code>m_flow</code> or <code>dp</code>.
Min and max functions are therefore used such that one equation
can serve both puroposes.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 14, 2017, by Filip Jorissen:<br/>
Revised implementation using <code>cubicHermite</code>
such that it does not have a local maximum
and such that it is C2-continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/156\">#156</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
January 29, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TwoWayPressureIndependent;

        model TwoWayQuickOpening
          "Two way valve with quick opening flow characteristics"
          extends BaseClasses.PartialTwoWayValveKv(phi=if homotopyInitialization then
                homotopy(actual=l + Modelica.Fluid.Utilities.regPow(
                y_actual,
                alpInv,
                delta0)*(1 - l), simplified=l + y_actual*(1 - l)) else l +
                Modelica.Fluid.Utilities.regPow(
                y_actual,
                alpInv,
                delta0)*(1 - l));
          parameter Real alp = 2 "Parameter for valve characteristics, alp>0";
          parameter Real delta0 = 0.01 "Range of significant deviation from power law";
      protected
           parameter Real alpInv = 1/alp "Inverse of alpha";
        initial equation
          // Since the flow model IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow computes
          // 1/k^2, the parameter l must not be zero.
          assert(l > 0, "Valve leakage parameter l must be bigger than zero.");
        annotation (
        defaultComponentName="val",
        Documentation(info="<html>
<p>
Two way valve with a power function for the valve opening characteristic.
Valves that need to open quickly typically have such a valve characteristics.
</p><p>
This model is based on the partial valve model
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>.
Check this model for more information, such
as the regularization near the origin.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 4, 2014, by Michael Wetter:<br/>
Moved the assignment of the flow function <code>phi</code>
to the model instantiation because in its base class,
the keyword <code>input</code>
has been added to the variable <code>phi</code>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal=0</code>.
See
<a href=\"modelica://IDEAS.Fluid.Actuators.UsersGuide\">
IDEAS.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy method.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end TwoWayQuickOpening;

        package Simplified
          extends Modelica.Icons.VariantsPackage;

          model ThreeWayValveMotor
            "Ideal three way valve with a krane controlled with a Real input with value between 0 and 1"
            extends BaseClasses.Partial3WayValve(idealSource(dp_start=0));
            Modelica.Blocks.Interfaces.RealInput ctrl(min=0, max=1)
              "procentage of flow through flowPort_a1" annotation (Placement(transformation(
                  extent={{20,-20},{-20,20}},
                  rotation=90,
                  origin={10,118}),iconTransformation(
                  extent={{10,-10},{-10,10}},
                  rotation=90,
                  origin={0,108})));
            Modelica.Blocks.Sources.RealExpression realExpression(y=-(l + (1 - ctrl)*(1 -
                  2*l))*port_b.m_flow)
              annotation (Placement(transformation(extent={{92,-60},{28,-40}})));
          equation
            connect(realExpression.y, idealSource.m_flow_in) annotation (Line(
                points={{24.8,-50},{8,-50}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                                graphics), Icon(coordinateSystem(preserveAspectRatio=false,
                             extent={{-100,-100},{100,100}}),
                                                graphics={
                  Polygon(
                    points={{-60,30},{-60,-30},{0,0},{-60,30}},
                    lineColor={0,0,127},
                    smooth=Smooth.None,
                    fillColor={0,127,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-30,30},{-30,-30},{30,0},{-30,30}},
                    lineColor={0,0,127},
                    smooth=Smooth.None,
                    origin={0,-30},
                    rotation=90,
                    fillColor={0,127,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-30,-70},{30,-70}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Line(
                    points={{0,-70},{0,-100}},
                    color={0,0,127},
                    smooth=Smooth.None),
                  Text(
                    extent={{-100,-56},{100,-100}},
                    lineColor={0,0,255},
                    textString="%name")}),
              Documentation(revisions="<html>
<ul>
<li>
March 26, 2018 by Filip Jorissen:<br/> 
Implemented valve leakage,
see <a href=\"https://github.com/open-ideas/IDEAS/issues/782\">#782</a>.
</li>
<li>March 2014 by Filip Jorissen:<br/> 
Annex60 compatibility
</li>
<li>January 2014, Damien Picard:<br/> 
First implementation
</li>
</ul>
</html>
"));
          end ThreeWayValveMotor;

          package BaseClasses
          extends Modelica.Icons.BasesPackage;

            model Partial3WayValve "Partial for 3-way valves"
              extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations;
              parameter Real tau = 1 "Thermal time constant"
                annotation(Dialog(tab="Dynamics", group="Filter"));
              parameter Real l = 0.001
                "Valve leakage, minimum fraction of flow rate passing through ports 
    a";
              parameter Modelica.SIunits.MassFlowRate m_flow_nominal
                "Nominal mass flow rate";
              parameter Boolean allowFlowReversal=true
                "= true to allow flow reversal";
              final parameter Modelica.SIunits.Mass m = m_flow_nominal*tau
                "Fluid content of the mixing valve";

              Modelica.Fluid.Interfaces.FluidPort_a port_a1(
                redeclare package Medium = Medium) "First fluid inlet"
                annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
              Modelica.Fluid.Interfaces.FluidPort_a port_a2(
                redeclare package Medium = Medium) "Second fluid inlet"
                annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
              Modelica.Fluid.Interfaces.FluidPort_b port_b(
                redeclare package Medium = Medium) "Fluid outlet"
                annotation (Placement(transformation(extent={{90,-10},{110,10}})));

              IDEAS.Fluid.MixingVolumes.MixingVolume vol(nPorts=3,
                redeclare package Medium = Medium,
                m_flow_nominal=m_flow_nominal,
                energyDynamics=energyDynamics,
                massDynamics=massDynamics,
                p_start=p_start,
                T_start=T_start,
                X_start=X_start,
                C_start=C_start,
                C_nominal=C_nominal,
                V=m/Medium.density(Medium.setState_pTX(
                    Medium.p_default,
                    Medium.T_default,
                    Medium.X_default)),
                allowFlowReversal=allowFlowReversal,
                mSenFac=mSenFac) if have_controlVolume
                annotation (Placement(transformation(extent={{-10,0},{10,20}})));

              IDEAS.Fluid.Interfaces.IdealSource idealSource(
                redeclare package Medium = Medium,
                control_m_flow=true,
                allowFlowReversal=allowFlowReversal)
                                       annotation (Placement(transformation(
                    extent={{-10,10},{10,-10}},
                    rotation=90,
                    origin={0,-44})));
          protected
              parameter Boolean have_controlVolume=
                  energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState or
                   massDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState
                "Boolean flag used to remove conditional components";
              Modelica.Fluid.Interfaces.FluidPort_a port_internal(
                redeclare package Medium = Medium) if not have_controlVolume
                "Internal dummy port for easier connection of conditional connections"
                annotation (Placement(transformation(extent={{-10,50},{10,70}})));
            equation
              connect(port_a1, vol.ports[1]) annotation (Line(
                  points={{-100,0},{-2.66667,0}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(port_b, vol.ports[2]) annotation (Line(
                  points={{100,0},{2.22045e-16,0}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(idealSource.port_a, port_a2) annotation (Line(
                  points={{0,-54},{4.44089e-16,-54},{4.44089e-16,-100}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(idealSource.port_b, vol.ports[3]) annotation (Line(
                  points={{0,-34},{0,-4.44089e-16},{2.66667,-4.44089e-16}},
                  color={0,127,255},
                  smooth=Smooth.None));
              connect(port_a1, port_internal) annotation (Line(points={{-100,0},{-100,32},{0,
                      32},{0,60}}, color={0,127,255}));
              connect(idealSource.port_b, port_internal) annotation (Line(points={{4.44089e-16,
                      -34},{0,-34},{0,60}}, color={0,127,255}));
              connect(port_b, port_internal) annotation (Line(points={{100,0},{100,32},{0,32},
                      {0,60}}, color={0,127,255}));
              annotation (
                Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{
                        100,100}})),
                Icon(graphics={
                    Polygon(
                      points={{-60,30},{-60,-30},{0,0},{-60,30}},
                      lineColor={0,0,127},
                      smooth=Smooth.None),
                    Polygon(
                      points={{60,30},{60,-30},{0,0},{60,30}},
                      lineColor={0,0,127},
                      smooth=Smooth.None),
                    Polygon(
                      points={{-30,30},{-30,-30},{30,0},{-30,30}},
                      lineColor={0,0,127},
                      smooth=Smooth.None,
                      origin={0,-30},
                      rotation=90),
                    Ellipse(extent={{-20,80},{20,40}}, lineColor={0,0,127}),
                    Line(
                      points={{0,0},{0,40}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Text(
                      extent={{-10,70},{10,50}},
                      lineColor={0,0,127},
                      textString="M"),
                    Line(
                      points={{-70,30},{-70,-30}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Line(
                      points={{70,30},{70,-30}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Line(
                      points={{-30,-70},{30,-70}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Line(
                      points={{-70,0},{-100,0}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Line(
                      points={{70,0},{100,0}},
                      color={0,0,127},
                      smooth=Smooth.None),
                    Line(
                      points={{0,-70},{0,-100}},
                      color={0,0,127},
                      smooth=Smooth.None)}),
                Documentation(info="<html>
<p><b>Description</b> </p>
<p>3-way valve with temperature set point for mixing a cold and hot fluid to obtain outlet fluid at the desired temperature. If the desired temperature is higher than the hot fluid, no mixing will occur and the outlet will have the temperature of the hot fluid. </p>
<p>Inside the valve, the cold water flowrate is fixed with a pump component.  The fluid content in the valve is equally split between the mixing volume and this pump.  Without fluid content in the pump, this model does not work in all operating conditions.  </p>
<h4>Assumptions and limitations </h4>
<ol>
<li>Correct connections of hot and cold fluid to the corresponding flowPorts is NOT CHECKED.</li>
<li>The fluid content m of the valve has to be larger than zero</li>
<li>There is an internal parameter mFlowMin which sets a minimum mass flow rate for mixing to start. </li>
</ol>
<h4>Model use</h4>
<ol>
<li>Set medium and the internal fluid content of the valve (too small values of m could increase simulation times)</li>
<li>Set mFlowMin, the minimum mass flow rate for mixing to start. </li>
<li>Supply a set temperature at the outlet</li>
</ol>
<h4>Validation </h4>
<p>None </p>
<h4>Example (optional) </h4>
<p>Examples of this model can be found in<a href=\"modelica://IDEAS.Thermal.Components.Examples.TempMixingTester\"> IDEAS.Thermal.Components.Examples.TempMixingTester</a> and<a href=\"modelica://IDEAS.Thermal.Components.Examples.RadiatorWithMixingValve\"> IDEAS.Thermal.Components.Examples.RadiatorWithMixingValve</a></p>
</html>",             revisions="<html>
<ul>
<li>
October 2, 2019 by Filip Jorissen:<br/> 
Avoiding division by zero for zero flow rates when <code>SteadyState</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1063\">#1063</a>.
</li>
<li>
May 3, 2019 by Filip Jorissen:<br/> 
Propagated <code>mSenFac</code>.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1018\">#1018</a>.
</li>
<li>
April 23, 2019 by Filip Jorissen:<br/> 
Using separate port for each connection to avoid algebraic loops.
See <a href=\"https://github.com/open-ideas/IDEAS/issues/1019\">#1019</a>.
</li>
<li>
March 26, 2018 by Filip Jorissen:<br/> 
Implemented valve leakage,
see <a href=\"https://github.com/open-ideas/IDEAS/issues/782\">#782</a>.
</li>
<li>
March 2014 by Filip Jorissen:<br/> 
Initial implementation
</li>
</ul>
</html>
"));
            end Partial3WayValve;
          end BaseClasses;
        end Simplified;
      annotation (preferredView="info", Documentation(info="<html>
This package contains component models for two- and three-way valves.
For motor models, see
<a href=\"modelica://IDEAS.Fluid.Actuators.Motors\">IDEAS.Fluid.Actuators.Motors</a>.
</html>"));
      end Valves;

      package BaseClasses "Package with base classes for IDEAS.Fluid.Actuators"
        extends Modelica.Icons.BasesPackage;

        model ActuatorSignal
          "Partial model that implements the filtered opening for valves and dampers"
          parameter Boolean use_inputFilter=true
            "= true, if opening is filtered with a 2nd order CriticalDamping filter"
            annotation(Dialog(tab="Dynamics", group="Filtered opening"));
          parameter Modelica.SIunits.Time riseTime=120
            "Rise time of the filter (time to reach 99.6 % of an opening step)"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          parameter Integer order(min=1) = 2 "Order of filter"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.InitialOutput
            "Type of initialization (no init/steady state/initial state/initial output)"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          parameter Real y_start=1 "Initial value of output"
            annotation(Dialog(tab="Dynamics", group="Filtered opening",enable=use_inputFilter));
          Modelica.Blocks.Interfaces.RealInput y(min=0, max=1)
            "Actuator position (0: closed, 1: open)"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                  rotation=270,
                origin={0,120}),iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,120})));
          Modelica.Blocks.Interfaces.RealOutput y_actual "Actual valve position"
            annotation (Placement(transformation(extent={{40,60},{60,80}})));
          // Classes used to implement the filtered opening
      protected
          Modelica.Blocks.Interfaces.RealOutput y_filtered if use_inputFilter
            "Filtered valve position in the range 0..1"
            annotation (Placement(transformation(extent={{40,78},{60,98}}),
                iconTransformation(extent={{60,50},{80,70}})));
          Modelica.Blocks.Continuous.Filter filter(
             final order=order,
             f_cut=5/(2*Modelica.Constants.pi*riseTime),
             final init=init,
             final y_start=y_start,
             final analogFilter=Modelica.Blocks.Types.AnalogFilter.CriticalDamping,
             final filterType=Modelica.Blocks.Types.FilterType.LowPass,
             x(each stateSelect=StateSelect.always)) if
                use_inputFilter
            "Second order filter to approximate valve opening time, and to improve numerics"
            annotation (Placement(transformation(extent={{6,81},{20,95}})));
        equation
         connect(filter.y, y_filtered) annotation (Line(
              points={{20.7,88},{50,88}},
              color={0,0,127}));
          if use_inputFilter then
          connect(y, filter.u) annotation (Line(
              points={{1.11022e-15,120},{1.11022e-15,88},{4.6,88}},
              color={0,0,127}));
          connect(filter.y, y_actual) annotation (Line(
              points={{20.7,88},{30,88},{30,70},{50,70}},
              color={0,0,127}));
          else
            connect(y, y_actual) annotation (Line(
              points={{1.11022e-15,120},{0,120},{0,70},{50,70}},
              color={0,0,127}));
          end if;
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={
                Line(
                  points={{0,40},{0,100}}),
                Line(
                  points={{0,70},{40,70}}),
                Rectangle(
                  visible=use_inputFilter,
                  extent={{-32,40},{32,100}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  visible=use_inputFilter,
                  extent={{-32,100},{32,40}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  visible=use_inputFilter,
                  extent={{-20,92},{20,48}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  textString="M",
                  textStyle={TextStyle.Bold})}),
        Documentation(info="<html>
<p>
This model implements the filter that is used to approximate the travel
time of the actuator.
Models that extend this model use the signal
<code>y_actual</code> to obtain the
current position of the actuator.
</p>
<p>
The filter order can be changed to modify the transient response
of the actuator.
</p>
<p>
See
<a href=\"modelica://IDEAS.Fluid.Actuators.UsersGuide\">
IDEAS.Fluid.Actuators.UsersGuide</a>
for a description of the filter.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 16, 2018, by Filip Jorissen:<br/>
Propagated parameter <code>order</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/891\">#891</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
February 14, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ActuatorSignal;

        partial model PartialThreeWayValve "Partial three way valve"
          extends IDEAS.Fluid.BaseClasses.PartialThreeWayResistance(
            m_flow_small = m_flow_nominal*1e-4,
            final mDyn_flow_nominal = m_flow_nominal,
              redeclare replaceable
              IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve res1
                constrainedby
            IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve(
                  deltaM=deltaM,
                  dp(start=dpValve_nominal/2),
                  from_dp=from_dp,
                  final l=l[1],
                  final linearized=linearized[1],
                  final homotopyInitialization=homotopyInitialization,
                  final CvData=IDEAS.Fluid.Types.CvTypes.OpPoint,
                  final m_flow_nominal=m_flow_nominal,
                  final dpValve_nominal=dpValve_nominal,
                  final dpFixed_nominal=dpFixed_nominal[1],
                  final use_inputFilter=false),
              redeclare FixedResistances.LosslessPipe res2(
                m_flow_nominal=m_flow_nominal),
              redeclare replaceable
              IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve res3
                constrainedby
            IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve(
                  deltaM=deltaM,
                  dp(start=dpValve_nominal/2),
                  from_dp=from_dp,
                  final l=l[2],
                  final linearized=linearized[2],
                  final homotopyInitialization=homotopyInitialization,
                  final CvData=IDEAS.Fluid.Types.CvTypes.OpPoint,
                  final m_flow_nominal=m_flow_nominal,
                  final dpValve_nominal=dpValve_nominal/fraK^2,
                  final dpFixed_nominal=dpFixed_nominal[2],
                  final use_inputFilter=false));
            extends IDEAS.Fluid.Actuators.BaseClasses.ActuatorSignal;
            extends IDEAS.Fluid.Actuators.BaseClasses.ValveParameters(
              rhoStd=Medium.density_pTX(101325, 273.15+4, Medium.X_default));
          parameter Modelica.SIunits.PressureDifference dpFixed_nominal[2](each displayUnit="Pa",
                                                                 each min=0) = {0, 0}
            "Nominal pressure drop of pipes and other equipment in flow legs at port_1 and port_3"
            annotation(Dialog(group="Nominal condition"));
          parameter Real fraK(min=0, max=1) = 0.7
            "Fraction Kv(port_3&rarr;port_2)/Kv(port_1&rarr;port_2)";
          parameter Real[2] l(each min=0, each max=1) = {0.0001, 0.0001}
            "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          parameter Real deltaM = 0.02
            "Fraction of nominal flow rate where linearization starts, if y=1"
            annotation(Dialog(group="Pressure-flow linearization"));
          parameter Boolean[2] linearized = {false, false}
            "= true, use linear relation between m_flow and dp for any flow rate"
            annotation(Dialog(tab="Advanced"));
          parameter Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
      protected
          Modelica.Blocks.Math.Feedback inv "Inversion of control signal"
            annotation (Placement(transformation(extent={{-74,40},{-62,52}})));
          Modelica.Blocks.Sources.Constant uni(final k=1)
            "Outputs one for bypass valve"
            annotation (Placement(transformation(extent={{-92,40},{-80,52}})));
        equation
          connect(uni.y, inv.u1)
            annotation (Line(points={{-79.4,46},{-72.8,46}},
                             color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
                Line(
                  points={{0,70},{40,70}}),
                Rectangle(
                  extent={{-100,44},{100,-36}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,26},{100,-20}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Polygon(
                  points={{0,2},{-78,64},{-78,-56},{0,2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-68,56},{0,2},{56,44},{76,60},{-68,56}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-56,-40},{0,2},{56,44},{60,-40},{-56,-40}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,2},{82,64},{82,-54},{0,2}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-24,-56},{24,-100}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.VerticalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-14,-56},{14,-100}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.VerticalCylinder,
                  fillColor={0,127,255}),
                Polygon(
                  points={{0,2},{62,-80},{-58,-80},{0,2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-30,46},{30,46}}),
                Line(
                  points={{0,100},{0,-2}}),
                Rectangle(
                  visible=use_inputFilter,
                  extent={{-36,36},{36,100}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  visible=use_inputFilter,
                  extent={{-36,100},{36,36}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid),
                Text(
                  visible=use_inputFilter,
                  extent={{-22,92},{20,46}},
                  lineColor={0,0,0},
                  fillColor={135,135,135},
                  fillPattern=FillPattern.Solid,
                  textString="M",
                  textStyle={TextStyle.Bold})}),
            Documentation(info="<html>
<p>
Partial model of a three way valve. This is the base model for valves
with different opening characteristics, such as linear, equal percentage
or quick opening. The three way valve model consists of a mixer where
valves are placed in two of the flow legs. The third flow leg
has no friction.
The flow coefficient <code>Kv</code> for flow from <code>port_1 &rarr; port_2</code> is
a parameter.
The flow coefficient for the bypass flow from <code>port_3 &rarr; port_2</code>
is computed as
</p>
<pre>
         Kv(port_3 &rarr; port_2)
  fraK = ----------------------
         Kv(port_1 &rarr; port_2)
</pre>
<p>
where <code>0 &lt; fraK &le; 1</code> is a parameter with a default value
of <code>fraK=0.7</code>.
</p>
<p>
Since this model uses two way valves to construct a three way valve, see
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>
for details regarding the valve implementation.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
December 17, 2015, by Michael Wetter:<br/>
Removed assignment <code>redeclare final package Medium=Medium</code>
as this is now done in the base class.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/475\">
https://github.com/lbl-srg/modelica-buildings/issues/475</a>.
</li>
<li>
November 23, 2015 by Filip Jorissen:<br/>
Corrected valve leakage value to avoid warnings.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters.
Removed default value for <code>dpValve_nominal</code>, as this
parameter has the attribute <code>fixed=false</code> for some values
of <code>CvData</code>. In this case, assigning a value is not allowed.
Corrected wrong documentation of parameter <code>fraK(min=0, max=1) = 0.7</code>.
The documenation was
<i>Fraction Kv(port_1&rarr;port_2)/Kv(port_3&rarr;port_2)</i> instead of
<i>Fraction Kv(port_3&rarr;port_2)/Kv(port_1&rarr;port_2)</i>.
Because the parameter set correctly its attributes <code>min=0</code> and <code>max=1</code>,
instances of this model used the correct value.
</li>
<li>
April 12, 2012 by Michael Wetter:<br/>
Removed duplicate declaration of <code>m_flow_nominal</code>.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal=0</code>.
See
<a href=\"modelica://IDEAS.Fluid.Actuators.UsersGuide\">
IDEAS.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
March 25, 2011, by Michael Wetter:<br/>
Added homotopy method.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialThreeWayValve;

        partial model PartialTwoWayValve "Partial model for a two way valve"
          extends IDEAS.Fluid.BaseClasses.PartialResistance(
               final dp_nominal=dpValve_nominal + dpFixed_nominal,
               dp(nominal=6000),
               final m_flow_turbulent = deltaM * abs(m_flow_nominal));
          extends IDEAS.Fluid.Actuators.BaseClasses.ValveParameters(
              rhoStd=Medium.density_pTX(101325, 273.15+4, Medium.X_default));
          extends IDEAS.Fluid.Actuators.BaseClasses.ActuatorSignal;
          parameter Modelica.SIunits.PressureDifference dpFixed_nominal(displayUnit="Pa", min=0) = 0
            "Pressure drop of pipe and other resistances that are in series"
             annotation(Dialog(group = "Nominal condition"));
          parameter Real l(min=1e-10, max=1) = 0.0001
            "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          input Real phi
            "Ratio actual to nominal mass flow rate of valve, phi=Kv(y)/Kv(y=1)";
          parameter Real kFixed(unit="", min=0) = if dpFixed_nominal > Modelica.Constants.eps
            then m_flow_nominal / sqrt(dpFixed_nominal) else 0
            "Flow coefficient of fixed resistance that may be in series with valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
          Real kVal(unit="", min=Modelica.Constants.small)
            "Flow coefficient of valve, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
          Real k(unit="", min=Modelica.Constants.small)
            "Flow coefficient of valve and pipe in series, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2).";
        initial equation
          assert(dpFixed_nominal > -Modelica.Constants.eps, "Require dpFixed_nominal >= 0. Received dpFixed_nominal = "
                + String(dpFixed_nominal) + " Pa.");
        equation
          assert(phi > -0.2, "Valve control signal needs to be bigger than zero, received phi = " + String(phi));
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}),       graphics={
                Polygon(
                  points={{2,-2},{-76,60},{-76,-60},{2,-2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-50,40},{0,-2},{54,40},{54,40},{-50,40}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-52,-42},{0,-4},{60,40},{60,-42},{-52,-42}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,-2},{82,60},{82,-60},{0,-2}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{0,40},{0,-4}}),
                Line(
                  visible=not use_inputFilter,
                  points={{0,100},{0,40}})}),
        Documentation(info="<html>
<p>
Partial model for a two way valve. This is the base model for valves
with different opening characteristics, such as linear, equal percentage,
quick opening or pressure-independent.
</p>
<p>
To prevent the derivative <code>d/dP (m_flow)</code> to be infinite near
the origin, this model linearizes the pressure drop versus flow relation
ship. The region in which it is linearized is parameterized by
</p>
<pre>
  m_turbulent_flow = deltaM * m_flow_nominal
</pre>
<p>
Because the parameterization contains <code>Kv_SI</code>, the values for
<code>deltaM</code> and <code>dp_nominal</code> need not be changed if the valve size
changes.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e.,
it is the ratio between mass flow rate in <code>kg/s</code> and square root
of pressure drop in <code>Pa</code>.
</p>
<h4>Options</h4>
<p>
This model allows different parameterization of the flow resistance.
The different parameterizations are described in
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.ValveParameters\">
IDEAS.Fluid.Actuators.BaseClasses.ValveParameters</a>.
</p>
<h4>Implementation</h4>
<p>
The two way valve models are implemented using this partial model, as opposed to using
different functions for the valve opening characteristics, because
each valve opening characteristics has different parameters.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
November 16, 2017, by Michael Wetter:<br/>
Relaxed assertion on <code>phi</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/592\">#592</a>.
</li>
<li>
October 27, 2016, by Filip Jorissen:<br/>
Added assert for <code>phi &gt; 0</code>.
This fixes a bug that caused valves to behave
like pumps for negative control signals.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/558\">#558</a>.
</li>
<li>
April 23, 2016, by Michael Wetter:<br/>
Changed test in assertion from <code>dpFixed_nominal > -Modelica.Constants.small</code>
to
<code>dpFixed_nominal > -Modelica.Constants.eps</code>.
Otherwise, JModelica evaluates it as <code>true</code> in
<a href=\"modelica://IDEAS.Fluid.Actuators.Valves.Examples.TwoWayValves\">
IDEAS.Fluid.Actuators.Valves.Examples.TwoWayValves</a>.
See also
<a href=\"https://trac.jmodelica.org/ticket/4932\">https://trac.jmodelica.org/ticket/4932</a>.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/510\">Buildings, issue 510</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
January 29, 2015, by Filip Jorissen:<br/>
Moved the governing equations to
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValveKv\">
PartialTwoWayValveKv</a>
in order to be able to extend from this partial in
<a href=\"modelica://IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent\">
TwoWayPressureIndependent</a>
</li>
<li>
August 8, 2014, by Michael Wetter:<br/>
Reformulated the computation of <code>k</code> to make the model
work in OpenModelica.
</li>
<li>
April 4, 2014, by Michael Wetter:<br/>
Added keyword <code>input</code> to variable <code>phi</code>
to require models that extend this model to provide a binding equation.
This is done to use the same modeling concept as is used for example in
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
March 27, 2014 by Michael Wetter:<br/>
Revised model for implementation of new valve model that computes the flow function
based on a table.
</li>
<li>
March 20, 2013, by Michael Wetter:<br/>
Set <code>dp(nominal=6000)</code> as the previous formulation gives an error during model check
in Dymola 2014. The reason is that the previous formulation used <code>dpValve_nominal</code>, which
is not known at translation time.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters.
Removed default value for <code>dpValve_nominal</code>, as this
parameter has the attribute <code>fixed=false</code> for some values
of <code>CvData</code>. In this case, assigning a value is not allowed.
Changed assignment of nominal attribute of <code>dp</code> to avoid assigning
a non-literal value.
</li>
<li>
February 20, 2012 by Michael Wetter:<br/>
Renamed parameter <code>dp_nominal</code> to <code>dpValve_nominal</code>,
and added new parameter <code>dpFixed_nominal</code>.
See
<a href=\"modelica://IDEAS.Fluid.Actuators.UsersGuide\">
IDEAS.Fluid.Actuators.UsersGuide</a>.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IDEAS.Fluid.BaseClasses.PartialResistance</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IDEAS.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 12, 2011 by Michael Wetter:<br/>
Added <code>assert</code> statement to prevent <code>l=0</code> due to the
implementation of
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>.
</li>
<li>
April 4, 2011 by Michael Wetter:<br/>
Revised implementation to use new base class for actuators.
</li>
<li>
February 18, 2009 by Michael Wetter:<br/>
Implemented parameterization of flow coefficient as in
<code>Modelica.Fluid</code>.
</li>
<li>
August 15, 2008 by Michael Wetter:<br/>
Set valve leakage to nonzero value.
</li>
<li>
June 3, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialTwoWayValve;

        partial model PartialTwoWayValveKv
          "Partial model for a two way valve using a Kv characteristic"
          extends IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve;
        equation
         kVal = phi*Kv_SI;
         if (dpFixed_nominal > Modelica.Constants.eps) then
           k = sqrt(1/(1/kFixed^2 + 1/kVal^2));
         else
           k = kVal;
         end if;
         if linearized then
           // This implementation yields m_flow_nominal = phi*kv_SI * sqrt(dp_nominal)
           // if m_flow = m_flow_nominal and dp = dp_nominal
           m_flow*m_flow_nominal_pos = k^2 * dp;
         else
           if homotopyInitialization then
             if from_dp then
                 m_flow=homotopy(actual=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                        m_flow_turbulent=m_flow_turbulent),
                                        simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                 dp=homotopy(actual=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                        m_flow_turbulent=m_flow_turbulent),
                                        simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
             end if;
           else // do not use homotopy
             if from_dp then
               m_flow=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                        m_flow_turbulent=m_flow_turbulent);
              else
                dp=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow, k=k,
                                        m_flow_turbulent=m_flow_turbulent);
              end if;
            end if; // homotopyInitialization
         end if; // linearized
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},
                    {100,100}}),       graphics={
                Polygon(
                  points={{2,-2},{-76,60},{-76,-60},{2,-2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-50,40},{0,-2},{54,40},{54,40},{-50,40}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-52,-42},{0,-4},{60,40},{60,-42},{-52,-42}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,-2},{82,60},{82,-60},{0,-2}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{0,40},{0,-4}}),
                Line(
                  visible=not use_inputFilter,
                  points={{0,100},{0,40}})}),
        Documentation(info="<html>
<p>
Partial model for valves with different opening characteristics,
such as linear, equal percentage or quick opening. This partial extends from
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</a>
and also contains the governing equations for these three two way valve models.
</p>
<h4>Implementation</h4>
<p>
Models that extend this model need to provide a binding equation
for the flow function <code>phi</code>.
An example of such a code can be found in
<a href=\"modelica://IDEAS.Fluid.Actuators.Valves.TwoWayLinear\">
IDEAS.Fluid.Actuators.Valves.TwoWayLinear</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredInput</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
January 29, 2015 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialTwoWayValveKv;

        partial model ValveParameters "Model with parameters for valves"
          parameter IDEAS.Fluid.Types.CvTypes CvData=IDEAS.Fluid.Types.CvTypes.OpPoint
            "Selection of flow coefficient"
           annotation(Dialog(group = "Flow Coefficient"));
          parameter Real Kv(
            fixed= if CvData==IDEAS.Fluid.Types.CvTypes.Kv then true else false)
            "Kv (metric) flow coefficient [m3/h/(bar)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==IDEAS.Fluid.Types.CvTypes.Kv)));
          parameter Real Cv(
            fixed= if CvData==IDEAS.Fluid.Types.CvTypes.Cv then true else false)
            "Cv (US) flow coefficient [USG/min/(psi)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==IDEAS.Fluid.Types.CvTypes.Cv)));
          parameter Modelica.SIunits.Area Av(
            fixed= if CvData==IDEAS.Fluid.Types.CvTypes.Av then true else false)
            "Av (metric) flow coefficient"
           annotation(Dialog(group = "Flow Coefficient",
                             enable = (CvData==IDEAS.Fluid.Types.CvTypes.Av)));
          parameter Real deltaM = 0.02
            "Fraction of nominal flow rate where linearization starts, if y=1"
            annotation(Dialog(group="Pressure-flow linearization"));
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal
            "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.PressureDifference dpValve_nominal(
             displayUnit="Pa",
             min=0,
             fixed= if CvData==IDEAS.Fluid.Types.CvTypes.OpPoint then true else false)
            "Nominal pressure drop of fully open valve, used if CvData=IDEAS.Fluid.Types.CvTypes.OpPoint"
            annotation(Dialog(group="Nominal condition",
                       enable = (CvData==IDEAS.Fluid.Types.CvTypes.OpPoint)));
          parameter Modelica.SIunits.Density rhoStd
            "Inlet density for which valve coefficients are defined"
          annotation(Dialog(group="Nominal condition", tab="Advanced"));
      protected
          parameter Real Kv_SI(
            min=0,
            fixed= false)
            "Flow coefficient for fully open valve in SI units, Kv=m_flow/sqrt(dp) [kg/s/(Pa)^(1/2)]"
          annotation(Dialog(group = "Flow Coefficient",
                            enable = (CvData==IDEAS.Fluid.Types.CvTypes.OpPoint)));
        initial equation
          if  CvData == IDEAS.Fluid.Types.CvTypes.OpPoint then
            Kv_SI =           m_flow_nominal/sqrt(dpValve_nominal);
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            Av    =           Kv_SI/sqrt(rhoStd);
          elseif CvData == IDEAS.Fluid.Types.CvTypes.Kv then
            Kv_SI =           Kv*rhoStd/3600/sqrt(1E5)
              "Unit conversion m3/(h*sqrt(bar)) to kg/(s*sqrt(Pa))";
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            Av    =           Kv_SI/sqrt(rhoStd);
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          elseif CvData == IDEAS.Fluid.Types.CvTypes.Cv then
            Kv_SI =           Cv*rhoStd*0.0631/1000/sqrt(6895)
              "Unit conversion USG/(min*sqrt(psi)) to kg/(s*sqrt(Pa))";
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Av    =           Kv_SI/sqrt(rhoStd);
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          else
            assert(CvData == IDEAS.Fluid.Types.CvTypes.Av, "Invalid value for CvData.
Obtained CvData = "         + String(CvData) + ".");
            Kv_SI =           Av*sqrt(rhoStd);
            Kv    =           Kv_SI/(rhoStd/3600/sqrt(1E5));
            Cv    =           Kv_SI/(rhoStd*0.0631/1000/sqrt(6895));
            dpValve_nominal =  (m_flow_nominal/Kv_SI)^2;
          end if;
          annotation (Documentation(info="<html>
<p>
Model that computes the flow coefficients of valves. This base class allows the following modeling options,
which have been adapted from the valve implementation
in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
to specify the valve flow coefficient in fully open conditions:
</p>
<ul>
<li><code>CvData = IDEAS.Fluid.Types.CvTypes.Av</code>: the flow coefficient is given by the metric <code>Av</code> coefficient (m^2).</li>
<li><code>CvData = IDEAS.Fluid.Types.CvTypes.Kv</code>: the flow coefficient is given by the metric <code>Kv</code> coefficient (m^3/h).</li>
<li><code>CvData = IDEAS.Fluid.Types.CvTypes.Cv</code>: the flow coefficient is given by the US <code>Cv</code> coefficient (USG/min).</li>
<li><code>CvData = IDEAS.Fluid.Types.CvTypes.OpPoint</code>: the flow is computed from the nominal operating point specified by <code>dp_nominal</code> and <code>m_flow_nominal</code>.</li>
</ul>
<p>
The treatment of parameters <code>Kv</code> and <code>Cv</code> is
explained in detail in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">Users Guide</a>.
</p>
<p>
In contrast to the model in <a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>, this model uses the protected parameter <code>Kv_SI</code>,
which is the flow coefficient in SI units, i.e.,
it is the ratio between mass flow rate in <code>kg/s</code> and square root
of pressure drop in <code>Pa</code>.
The value of <code>Kv_SI</code> is computed based on the parameters
<code>Av</code>,
<code>Kv</code>,
<code>Cv</code>, or, if
<code>CvData = IDEAS.Fluid.Types.CvTypes.OpPoint</code>, based on
<code>m_flow_nominal</code> and <code>dpValve_nominal</code>.
Conversely, if
<code>CvData &lt;&gt; IDEAS.Fluid.Types.CvTypes.OpPoint</code>, then
<code>dpValve_nominal</code> is computed based on
<code>Av</code>,
<code>Kv</code>, or
<code>Cv</code>, and the nominal mass flow rate <code>m_flow_nominal</code>.
Therefore, if
<code>CvData &lt;&gt; IDEAS.Fluid.Types.CvTypes.OpPoint</code>,
then specifying a value for <code>dpValve_nominal</code> is a syntax error.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
August 12, 2014, by Michael Wetter:<br/>
Changed attribute <code>min</code> of <code>dpValve_nominal</code>
to <code>0</code>.
This is needed as for example in
<a href=\"modelica://IDEAS.Fluid.Actuators.Valves.Examples.TwoWayValveTable\">
IDEAS.Fluid.Actuators.Valves.Examples.TwoWayValveTable</a>,
<code>dpValve_nominal=0</code>.
</li>
<li>
August 8, 2014, by Michael Wetter:<br/>
Changed the <code>initial algorithm</code> to an <code>initial equation</code>
section. Otherwise, OpenModelica attempts to solve for the parameter
values using numerical iteration, and fails in doing so.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 25, 2013, by Michael Wetter:<br/>
Removed stray backslash in write statement.
</li>
<li>
February 28, 2013, by Michael Wetter:<br/>
Reformulated assignment of parameters, and removed <code>Kv_SI</code> as
a public parameter because it is always computed based on other parameters.
This change avoids a translation error in Dymola 2014 beta1 in
the pedantic mode, and a translation warning otherwise.
</li>
<li>
February 18, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end ValveParameters;

        function der_equalPercentage
          "Derivative of valve opening characteristics for equal percentage valve"
          extends Modelica.Icons.Function;
          input Real y "Valve opening signal, y=1 is fully open";
          input Real R "Rangeability, R=50...100 typically";
          input Real l(min=0, max=1) "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          input Real delta "Range of significant deviation from equal percentage law";
          input Real der_y "Derivative of valve opening signal";
          output Real der_phi
            "Derivative of ratio actual to nominal mass flow rate, dphi/dy";
      protected
           Real a "Polynomial coefficient";
           Real b "Polynomial coefficient";
           Real c "Polynomial coefficient";
           Real logR "=log(R)";
           Real z "Auxiliary variable";
           Real q "Auxiliary variable";
           Real p "Auxiliary variable";
        algorithm
          if y < delta/2 then
            der_phi := (R^(delta-1) - l) / delta * der_y;
          else
            if (y > (3/2 * delta)) then
              der_phi := R^(y-1)*Modelica.Math.log(R) * der_y;
            else
              logR := Modelica.Math.log(R);
              z := (3*delta/2);
              q := delta*R^z*logR;
              p := R^z;
              a := (q - 2*p + 2*R^delta)/(delta^3*R);
              b := (-5*q + 12*p - 13*R^delta + l*R)/(2*delta^2*R);
              c := (7*q - 18*p + 24*R^delta - 6*l*R)/(4*delta*R);
              der_phi  := (c + y * ( 2*b + 3*a*y)) * der_y;
            end if;
          end if;
        annotation (
        Documentation(info="<html>
<p>
This function computes the derivative of the opening characteristics of an equal percentage valve.
</p><p>
The function is the derivative of
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.equalPercentage\">
IDEAS.Fluid.Actuators.BaseClasses.equalPercentage</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 30, 2011 by Michael Wetter:<br/>
Removed inputs for which no derivative is implemented from the argument list, and added
<code>zeroDerivative</code> keyword in function that calls this function.
</li>
<li>
February 4, 2010 by Michael Wetter:<br/>
Fixed implementation of derivative function.
</li>
<li>
June 6, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end der_equalPercentage;

        function equalPercentage
          "Valve opening characteristics for equal percentage valve"
          extends Modelica.Icons.Function;
          input Real y "Valve opening signal, y=1 is fully open";
          input Real R "Rangeability, R=50...100 typically";
          input Real l(min=0, max=1) "Valve leakage, l=Kv(y=0)/Kv(y=1)";
          input Real delta "Range of significant deviation from equal percentage law";
          output Real phi "Ratio actual to nominal mass flow rate, phi=Cv(y)/Cv(y=1)";
      protected
           Real a "Polynomial coefficient";
           Real b "Polynomial coefficient";
           Real c "Polynomial coefficient";
           Real d "Polynomial coefficient";
           Real logR "=log(R)";
           Real z "Auxiliary variable";
           Real q "Auxiliary variable";
           Real p "Auxiliary variable";
        algorithm
          if y < delta/2 then
            phi := l + y * (R^(delta-1) - l) / delta;
          else
            if (y > (3/2 * delta)) then
              phi := R^(y-1);
            else
              logR := Modelica.Math.log(R);
              z := (3*delta/2);
              q := delta*R^z*logR;
              p := R^z;
              a := (q - 2*p + 2*R^delta)/(delta^3*R);
              b := (-5*q + 12*p - 13*R^delta + l*R)/(2*delta^2*R);
              c := (7*q - 18*p + 24*R^delta - 6*l*R)/(4*delta*R);
              d := (-3*q + 8*p - 9*R^delta + 9*l*R)/(8*R);
              phi  := d + y * ( c + y * ( b + y * a));
            end if;
          end if;
        annotation (
        Documentation(info="<html>
<p>
This function computes the opening characteristics of an equal percentage valve.
</p><p>
The function is used by the model
<a href=\"modelica://IDEAS.Fluid.Actuators.Valves.TwoWayEqualPercentage\">
IDEAS.Fluid.Actuators.Valves.TwoWayEqualPercentage</a>.
</p><p>
For <code>y &lt; delta/2</code>, the valve characteristics is linear. For <code> y &gt; 3*delta/2</code>
the valve characteristics is equal percentage. In between, a cubic spline is used to ensure
that the valve characteristics is once continuously differentiable with respect to <code>y</code>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
March 30, 2011 by Michael Wetter:<br/>
Added <code>zeroDerivative</code> keyword.
</li>
<li>
June 5, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        smoothOrder=1,
        derivative(zeroDerivative=R, zeroDerivative=l, zeroDerivative=delta)=der_equalPercentage);
        end equalPercentage;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.Actuators\">IDEAS.Fluid.Actuators</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains component models for actuators.
</html>"));
    end Actuators;

    package Delays "Package with delay models"
      extends Modelica.Icons.VariantsPackage;

      model DelayFirstOrder
        "Delay element, approximated by a first order differential equation"
        extends IDEAS.Fluid.MixingVolumes.MixingVolume(final V=V_nominal,
                                                         final mSenFac=1);
        parameter Modelica.SIunits.Time tau = 60 "Time constant at nominal flow"
          annotation (Dialog(tab="Dynamics", group="Nominal condition"));
    protected
         parameter Modelica.SIunits.Volume V_nominal = m_flow_nominal*tau/rho_default
          "Volume of delay element";
        annotation (    Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-100,98},{100,-102}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={170,213,255}), Text(
                extent={{-72,22},{68,-18}},
                lineColor={0,0,0},
                textString="tau=%tau")}),
      defaultComponentName="del",
          Documentation(info="<html>
<p>
This model approximates a transport delay using a first order differential equations.
</p>
<p>
The model consists of a mixing volume with two ports. The size of the
mixing volume is such that at the nominal mass flow rate
<code>m_flow_nominal</code>,
the time constant of the volume is equal to the parameter <code>tau</code>.
</p>
<p>
The heat flux connector is optional, it need not be connnected.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 14, 2013, by Michael Wetter:<br/>
Renamed <code>V0</code> to <code>V_nominal</code> to use consistent notation.
</li>
<li>
September 24, 2008, by Michael Wetter:<br/>
Changed base class from <code>Modelica.Fluid</code> to <code>IDEAS</code> library.
This was done to track the auxiliary species flow <code>mC_flow</code>.
</li>
<li>
September 4, 2008, by Michael Wetter:<br/>
Fixed bug in assignment of parameter <code>sta0</code>.
The earlier implementation
required temperature to be a state, which is not always the case.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end DelayFirstOrder;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for transport delays in
piping networks.
</p>
<p>
The model
<a href=\"modelica://IDEAS.Fluid.Delays.DelayFirstOrder\">
IDEAS.Fluid.Delays.DelayFirstOrder</a>
approximates transport delays using a first order differential equation.
</p>
</html>"));
    end Delays;

    package FixedResistances "Package with models for fixed flow resistances"
      extends Modelica.Icons.VariantsPackage;

      model Junction
        "Flow splitter with fixed resistance at each port"
          extends IDEAS.Fluid.BaseClasses.PartialThreeWayResistance(
          m_flow_small=mDyn_flow_nominal*1e-4,
          mDyn_flow_nominal = sum(abs(m_flow_nominal[:])/3),
          redeclare IDEAS.Fluid.FixedResistances.PressureDrop res1(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[1],
            final dp_nominal=dp_nominal[1],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM),
          redeclare IDEAS.Fluid.FixedResistances.PressureDrop res2(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[2],
            final dp_nominal=dp_nominal[2],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM),
          redeclare IDEAS.Fluid.FixedResistances.PressureDrop res3(
            from_dp=from_dp,
            final m_flow_nominal=m_flow_nominal[3],
            final dp_nominal=dp_nominal[3],
            linearized=linearized,
            homotopyInitialization=homotopyInitialization,
            deltaM=deltaM));
        parameter Modelica.SIunits.MassFlowRate[3] m_flow_nominal
          "Mass flow rate. Set negative at outflowing ports."
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.Pressure[3] dp_nominal(each displayUnit = "Pa")
          "Pressure drop at nominal mass flow rate, set to zero or negative number at outflowing ports."
          annotation(Dialog(group = "Nominal condition"));
        parameter Real deltaM(min=0) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Dialog(group = "Transition to laminar",
                               enable = not linearized));
        parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(tab="Advanced"));
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}), graphics={
              Polygon(
                points={{-100,-46},{-32,-40},{-32,-100},{30,-100},{30,-36},{100,-30},
                    {100,38},{-100,52},{-100,-46}},
                lineColor={0,0,0},
                fillColor={175,175,175},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-100,-34},{-18,-28},{-18,-100},{18,-100},{18,-26},{100,-20},
                    {100,22},{-100,38},{-100,-34}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,128,255}),
              Ellipse(
                visible=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState,
                extent={{-38,36},{40,-40}},
                lineColor={0,0,127},
                fillColor={0,0,127},
                fillPattern=FillPattern.Solid),
              Text(
                extent={{-151,142},{149,102}},
                lineColor={0,0,255},
                textString="%name")}),
      defaultComponentName="jun",
          Documentation(info="<html>
<p>
Model of a flow junction with an optional fixed resistance in each flow leg
and an optional mixing volume at the junction.
</p>
<p>
The pressure drop is implemented using the model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.PressureDrop\">
IDEAS.Fluid.FixedResistances.PressureDrop</a>.
If its nominal pressure drop is set to zero, then the pressure drop
model will be removed.
For example, the pressure drop declaration
</p>
<pre>
  m_flow_nominal={ 0.1, 0.1,  -0.2},
  dp_nominal =   {500,    0, -6000}
</pre>
<p>
would model a flow mixer that has the nominal flow rates and associated pressure drops
as shown in the figure below. Note that <code>port_3</code> is set to negative values.
The negative values indicate that at the nominal conditions, fluid is leaving the component.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/FixedResistances/Junction.png\"/>
</p>
<p>
If
<code>energyDynamics &lt;&gt; Modelica.Fluid.Types.Dynamics.SteadyState</code>,
then at the flow junction, a fluid volume is modeled.
The fluid volume is implemented using the model
<a href=\"modelica://IDEAS.Fluid.Delays.DelayFirstOrder\">
IDEAS.Fluid.Delays.DelayFirstOrder</a>.
The fluid volume has the size
</p>
<pre>
  V = sum(abs(m_flow_nominal[:])/3)*tau/rho_nominal
</pre>
<p>
where <code>tau</code> is a parameter and <code>rho_nominal</code> is the density
of the medium in the volume at nominal condition.
Setting <code>energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial</code>
can help reducing the size of the nonlinear
system of equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
March 26, 2018 by Filip Jorissen:<br/>
Removed <code>final allowFlowReversal=true</code> from all resistances 
since this overrides the default simplification when the flow
is not bidirectional.
This change can lead to smaller algebraic loops.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/898\">issue 898</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Renamed model from <code>SplitterFixedResistanceDpM</code> to
<code>FlowJunction</code> and removed the parameters
<code>use_dh</code>, <code>dh</code> and <code>ReC</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/451\">issue 451</a>.
</li>
<li>
October 14, 2016 by Michael Wetter:<br/>
Added to Annex 60 library.<br/>
Updated comment for parameter <code>use_dh</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/451\">issue 451</a>.
</li>
<li>
Removed parameter <code>dynamicBalance</code> that overwrote the setting
of <code>energyDynamics</code> and <code>massDynamics</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/411\">
Annex 60, issue 411</a>.
</li>
<li>
February 1, 2012 by Michael Wetter:<br/>
Expanded documentation.
</li>
<li>
August 4, 2011 by Michael Wetter:<br/>
Added <code>final allowFlowReversal=true</code> to all resistances since it is impractical
to avoid flow reversal in large flow networks where such a setting may be useful.
</li>
<li>
June 11, 2008 by Michael Wetter:<br/>
Based class on
<a href=\"modelica://IDEAS.Fluid.BaseClasses.PartialThreeWayFixedResistance\">
PartialThreeWayFixedResistance</a>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end Junction;

      model LosslessPipe "Pipe with no flow friction and no heat transfer"
        extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface;
        final parameter Boolean from_dp=true "Used to satisfy replaceable models";
      equation
        dp=0;
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
        port_b.h_outflow = inStream(port_a.h_outflow);
        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;
        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);
        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,60},{100,-60}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,50},{100,-48}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={217,236,255})}),
      defaultComponentName="pip",
          Documentation(info="<html>
<p>
Model of a pipe with no flow resistance, no heat loss and no transport delay.
This model can be used to replace a <code>replaceable</code> pipe model
in flow legs in which no friction should be modeled.
This is for example done in the outlet port of the
base class for three way valves,
<a href=\"modelica://IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve\">
IDEAS.Fluid.Actuators.BaseClasses.PartialThreeWayValve</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
June 23, 2018, by Filip Jorissen:<br/>
Implementation is now more efficient for <code>allowFlowReversal=false</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/949\">#949</a>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
June 13, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LosslessPipe;

      model ParallelPressureDrop
        "Fixed flow resistance with multiple parallel circuits"
        extends IDEAS.Fluid.BaseClasses.PartialResistance(
          final m_flow_turbulent = if (computeFlowResistance and use_dh) then
                             eta_default*dh/4*Modelica.Constants.pi*ReC*nParCir
                             elseif (computeFlowResistance) then
                             deltaM * m_flow_nominal_pos
               else 0);
        parameter Real nParCir "Number of parallel circuits";
        parameter Boolean use_dh = false "Set to true to specify hydraulic diameter"
             annotation(Evaluate=true, Dialog(enable = not linearized));
        parameter Modelica.SIunits.Length dh=1 "Hydraulic diameter"
             annotation(Evaluate=true, Dialog(enable = use_dh and not linearized));
        parameter Real ReC(min=0)=4000
          "Reynolds number where transition to turbulent starts"
             annotation(Evaluate=true, Dialog(enable = use_dh and not linearized));
        parameter Real deltaM(min=0.01) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Evaluate=true, Dialog(enable = not use_dh and not linearized));
        final parameter Real k(unit="") = if computeFlowResistance then
              m_flow_nominal_pos/nParCir / sqrt(dp_nominal_pos) else 0
          "Flow coefficient for 1 of the parallel circuits";
        parameter Boolean computeFlowResistance=true
          "Flag to enable/disable computation of flow resistance"
         annotation(Evaluate=true);
      initial equation
       if computeFlowResistance then
         assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
       end if;
       assert(m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
       if ( m_flow_turbulent > m_flow_nominal_pos) then
         Modelica.Utilities.Streams.print("Warning: In FixedResistanceDpM, m_flow_nominal is smaller than m_flow_turbulent."
                 + "\n"
                 + "  m_flow_nominal = " + String(m_flow_nominal) + "\n"
                 + "  dh      = " + String(dh) + "\n"
                 + "  To fix, set dh < " +
                      String(     4*m_flow_nominal/eta_default/Modelica.Constants.pi/ReC) + "\n"
                 + "  Suggested value: dh = " +
                      String(1/10*4*m_flow_nominal/eta_default/Modelica.Constants.pi/ReC));
       end if;
      equation
        // Pressure drop calculation
        if computeFlowResistance then
          if linearized then
            m_flow*m_flow_nominal_pos/nParCir^2 = k^2*dp;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(actual=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                         m_flow_turbulent=m_flow_turbulent/nParCir)*nParCir,
                                         simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                dp=homotopy(actual=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow/nParCir, k=k,
                                         m_flow_turbulent=m_flow_turbulent/nParCir),
                          simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
               end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(dp=dp, k=k,
                                         m_flow_turbulent=m_flow_turbulent/nParCir)*nParCir;
              else
                dp=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(m_flow=m_flow/nParCir, k=k,
                                         m_flow_turbulent=m_flow_turbulent/nParCir);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        else // do not compute flow resistance
          dp = 0;
        end if;  // computeFlowResistance
        annotation (Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}),
                            graphics),
      defaultComponentName="res",
      Documentation(info="<html>
<p>
This is a model of a resistance with a fixed flow coefficient.
The mass flow rate is computed as
</p>
<p align=\"center\" style=\"font-style:italic;\">
m&#775; = k  
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>,
</p>
<p>
where 
<i>k</i> is a constant and 
<i>&Delta;P</i> is the pressure drop.
The constant <i>k</i> is equal to
<code>k=m_flow_nominal/dp_nominal</code>,
where <code>m_flow_nominal</code> and <code>dp_nominal</code>
are parameters.
In the region
<code>abs(m_flow) &lt; m_flow_turbulent</code>, 
the square root is replaced by a differentiable function
with finite slope.
The value of <code>m_flow_turbulent</code> is
computed as follows:
</p>
<ul>
<li>
If the parameter <code>use_dh</code> is <code>false</code>
(the default setting), 
the equation 
<code>m_flow_turbulent = deltaM * abs(m_flow_nominal)</code>,
where <code>deltaM=0.3</code> and 
<code>m_flow_nominal</code> are parameters that can be set by the user.
</li>
<li>
Otherwise, the equation
<code>m_flow_turbulent = eta_nominal*dh/4*&pi;*ReC</code> is used,
where 
<code>eta_nominal</code> is the dynamic viscosity, obtained from
the medium model. The parameter
<code>dh</code> is the hydraulic diameter and
<code>ReC=4000</code> is the critical Reynolds number, which both
can be set by the user.
</li>
</ul>
<p>
The figure below shows the pressure drop for the parameters
<code>m_flow_nominal=5</code> kg/s,
<code>dp_nominal=10</code> Pa and
<code>deltaM=0.3</code>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/FixedResistances/FixedResistanceDpM.png\"/>
</p>
<p>
If the parameter
<code>show_T</code> is set to <code>true</code>,
then the model will compute the
temperature at its ports. Note that this can lead to state events
when the mass flow rate approaches zero,
which can increase computing time.
</p>
<p>
The parameter <code>from_dp</code> is used to determine
whether the mass flow rate is computed as a function of the 
pressure drop (if <code>from_dp=true</code>), or vice versa.
This setting can affect the size of the nonlinear system of equations.
</p>
<p>
If the parameter <code>linearized</code> is set to <code>true</code>,
then the pressure drop is computed as a linear function of the
mass flow rate.
</p>
<p>
Setting <code>allowFlowReversal=false</code> can lead to simpler
equations. However, this should only be set to <code>false</code>
if one can guarantee that the flow never reverses its direction.
This can be difficult to guarantee, as pressure imbalance after 
the initialization, or due to medium expansion and contraction,
can lead to reverse flow.
</p>
<h4>Notes</h4>
<p>
For more detailed models that compute the actual flow friction, 
models from the package 
<a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
can be used and combined with models from the 
<code>Buildings</code> library.
</p>
<h4>Implementation</h4>
<p>
The pressure drop is computed by calling a function in the package
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels\">
IDEAS.Fluid.BaseClasses.FlowModels</a>,
This package contains regularized implementations of the equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
and its inverse function.
</p>
<p>
To decouple the energy equation from the mass equations,
the pressure drop is a function of the mass flow rate,
and not the volume flow rate.
This leads to simpler equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IDEAS.Fluid.BaseClasses.PartialResistance</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IDEAS.Fluid.FixedResistances.FixedResistanceDpM</code>.
</li>
<li>
May 30, 2008 by Michael Wetter:<br/>
Added parameters <code>use_dh</code> and <code>deltaM</code> for easier parameterization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Text(
                extent={{-102,86},{-4,22}},
                lineColor={0,0,255},
                textString="dp_nominal=%dp_nominal"), Text(
                extent={{-106,106},{6,60}},
                lineColor={0,0,255},
                textString="m0=%m_flow_nominal")}));
      end ParallelPressureDrop;

      model PressureDrop
        "Fixed flow resistance with dp and m_flow as parameter"
        extends IDEAS.Fluid.BaseClasses.PartialResistance(
          final m_flow_turbulent = if computeFlowResistance then deltaM * m_flow_nominal_pos else 0);
        parameter Real deltaM(min=1E-6) = 0.3
          "Fraction of nominal mass flow rate where transition to turbulent occurs"
             annotation(Evaluate=true,
                        Dialog(group = "Transition to laminar",
                               enable = not linearized));
        final parameter Real k = if computeFlowResistance then
              m_flow_nominal_pos / sqrt(dp_nominal_pos) else 0
          "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
    protected
        final parameter Boolean computeFlowResistance=(dp_nominal_pos > Modelica.Constants.eps)
          "Flag to enable/disable computation of flow resistance"
         annotation(Evaluate=true);
        final parameter Real coeff=
          if linearized and computeFlowResistance
          then if from_dp then k^2/m_flow_nominal_pos else m_flow_nominal_pos/k^2
          else 0
          "Precomputed coefficient to avoid division by parameter";
      initial equation
       if computeFlowResistance then
         assert(m_flow_turbulent > 0, "m_flow_turbulent must be bigger than zero.");
       end if;
       assert(m_flow_nominal_pos > 0, "m_flow_nominal_pos must be non-zero. Check parameters.");
      equation
        // Pressure drop calculation
        if computeFlowResistance then
          if linearized then
            if from_dp then
              m_flow = dp*coeff;
            else
              dp = m_flow*coeff;
            end if;
          else
            if homotopyInitialization then
              if from_dp then
                m_flow=homotopy(
                  actual=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                    dp=dp,
                    k=k,
                    m_flow_turbulent=m_flow_turbulent),
                  simplified=m_flow_nominal_pos*dp/dp_nominal_pos);
              else
                dp=homotopy(
                  actual=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                    m_flow=m_flow,
                    k=k,
                    m_flow_turbulent=m_flow_turbulent),
                  simplified=dp_nominal_pos*m_flow/m_flow_nominal_pos);
               end if;  // from_dp
            else // do not use homotopy
              if from_dp then
                m_flow=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                  dp=dp,
                  k=k,
                  m_flow_turbulent=m_flow_turbulent);
              else
                dp=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                  m_flow=m_flow,
                  k=k,
                  m_flow_turbulent=m_flow_turbulent);
              end if;  // from_dp
            end if; // homotopyInitialization
          end if; // linearized
        else // do not compute flow resistance
          dp = 0;
        end if;  // computeFlowResistance
        annotation (defaultComponentName="res",
      Documentation(info="<html>
<p>
Model of a flow resistance with a fixed flow coefficient.
The mass flow rate is
</p>
<p align=\"center\" style=\"font-style:italic;\">
m&#775; = k
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>,
</p>
<p>
where
<i>k</i> is a constant and
<i>&Delta;P</i> is the pressure drop.
The constant <i>k</i> is equal to
<code>k=m_flow_nominal/sqrt(dp_nominal)</code>,
where <code>m_flow_nominal</code> and <code>dp_nominal</code>
are parameters.
</p>
<h4>Assumptions</h4>
<p>
In the region
<code>abs(m_flow) &lt; m_flow_turbulent</code>,
the square root is replaced by a differentiable function
with finite slope.
The value of <code>m_flow_turbulent</code> is
computed as
<code>m_flow_turbulent = deltaM * abs(m_flow_nominal)</code>,
where <code>deltaM=0.3</code> and
<code>m_flow_nominal</code> are parameters that can be set by the user.
</p>
<p>
The figure below shows the pressure drop for the parameters
<code>m_flow_nominal=5</code> kg/s,
<code>dp_nominal=10</code> Pa and
<code>deltaM=0.3</code>.
</p>
<p align=\"center\">
<img alt=\"image\" src=\"modelica://IDEAS/Resources/Images/Fluid/FixedResistances/PressureDrop.png\"/>
</p>
<h4>Important parameters</h4>
<p>
The parameter <code>from_dp</code> is used to determine
whether the mass flow rate is computed as a function of the
pressure drop (if <code>from_dp=true</code>), or vice versa.
This setting can affect the size of the nonlinear system of equations.
</p>
<p>
If the parameter <code>linearized</code> is set to <code>true</code>,
then the pressure drop is computed as a linear function of the
mass flow rate.
</p>
<p>
Setting <code>allowFlowReversal=false</code> can lead to simpler
equations. However, this should only be set to <code>false</code>
if one can guarantee that the flow never reverses its direction.
This can be difficult to guarantee, as pressure imbalance after
the initialization, or due to medium expansion and contraction,
can lead to reverse flow.
</p>
<p>
If the parameter
<code>show_T</code> is set to <code>true</code>,
then the model will compute the
temperature at its ports. Note that this can lead to state events
when the mass flow rate approaches zero,
which can increase computing time.
</p>
<h4>Notes</h4>
<p>
For more detailed models that compute the actual flow friction,
models from the package
<a href=\"modelica://Modelica.Fluid\">
Modelica.Fluid</a>
can be used and combined with models from the
<code>IDEAS</code> library.
</p>
<p>
For a model that uses the hydraulic parameter and flow velocity at nominal conditions
as a parameter, use
<a href=\"modelica://IDEAS.Fluid.FixedResistances.HydraulicDiameter\">
IDEAS.Fluid.FixedResistances.HydraulicDiameter</a>.
</p>
<h4>Implementation</h4>
<p>
The pressure drop is computed by calling a function in the package
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels\">
IDEAS.Fluid.BaseClasses.FlowModels</a>,
This package contains regularized implementations of the equation
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
and its inverse function.
</p>
<p>
To decouple the energy equation from the mass equations,
the pressure drop is a function of the mass flow rate,
and not the volume flow rate.
This leads to simpler equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 21, 2018, by Michael Wetter:<br/>
Decrease value of <code>deltaM(min=...)</code> attribute.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1026\">#1026</a>.
</li>
<li>
February 3, 2018, by Filip Jorissen:<br/>
Revised implementation of pressure drop equation
such that it depends on <code>from_dp</code>
when <code>linearized=true</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/884\">#884</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Simplified model by removing the geometry dependent parameters into the new
model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.HydraulicDiameter\">
IDEAS.Fluid.FixedResistances.HydraulicDiameter</a>.
</li>
<li>
November 23, 2016, by Filip Jorissen:<br/>
Removed <code>dp_nominal</code> and
<code>m_flow_nominal</code> labels from icon.
</li>
<li>
October 14, 2016, by Michael Wetter:<br/>
Updated comment for parameter <code>use_dh</code>.
</li>
<li>
November 26, 2014, by Michael Wetter:<br/>
Added the required <code>annotation(Evaluate=true)</code> so
that the system of nonlinear equations in
<a href=\"modelica://IDEAS.Fluid.FixedResistances.Validation.PressureDropsExplicit\">
IDEAS.Fluid.FixedResistances.Validation.PressureDropsExplicit</a>
remains the same.
</li>
<li>
November 20, 2014, by Michael Wetter:<br/>
Rewrote the warning message using an <code>assert</code> with
<code>AssertionLevel.warning</code>
as this is the proper way to write warnings in Modelica.
</li>
<li>
August 5, 2014, by Michael Wetter:<br/>
Corrected error in documentation of computation of <code>k</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
January 16, 2012 by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IDEAS.Fluid.BaseClasses.PartialResistance</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IDEAS.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
May 30, 2008 by Michael Wetter:<br/>
Added parameters <code>use_dh</code> and <code>deltaM</code> for easier parameterization.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PressureDrop;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains component models for fixed flow resistances.
By fixed flow resistance, we mean resistances that do not change the
flow coefficient
</p>
<p align=\"center\" style=\"font-style:italic;\">
k = m &frasl;
&radic;<span style=\"text-decoration:overline;\">&Delta;P</span>.
</p>
<p>
For models of valves and air dampers, see
<a href=\"modelica://IDEAS.Fluid.Actuators\">
IDEAS.Fluid.Actuators</a>.
For models of flow resistances as part of the building constructions, see
<a href=\"modelica://IDEAS.Airflow.Multizone\">
IDEAS.Airflow.Multizone</a>.
</p>
<p>
The model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.PressureDrop\">
IDEAS.Fluid.FixedResistances.PressureDrop</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and a nominal pressure drop. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.HydraulicDiameter\">
IDEAS.Fluid.FixedResistances.HydraulicDiameter</a>
is a fixed flow resistance that takes as parameter a nominal flow rate and
a hydraulic diameter. The actual resistance is scaled using the above equation.
</p>
<p>
The model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.LosslessPipe\">
IDEAS.Fluid.FixedResistances.LosslessPipe</a>
is an ideal pipe segment with no pressure drop. It is primarily used
in models in which the above pressure drop model need to be replaced by a model with no pressure drop.
</p>
<p>
The model
<a href=\"modelica://IDEAS.Fluid.FixedResistances.Junction\">
IDEAS.Fluid.FixedResistances.Junction</a>
can be used to model flow splitters or flow merges.
</p>
</html>"));
    end FixedResistances;

    package HeatExchangers "Package with heat exchanger models"
      extends Modelica.Icons.VariantsPackage;

      package RadiantSlab
      extends Modelica.Icons.VariantsPackage;

        model EmbeddedPipe
          "Embedded pipe model based on prEN 15377 and (Koschenz, 2000), water capacity lumped to TOut"
          extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations;
          replaceable parameter
            IDEAS.Fluid.HeatExchangers.RadiantSlab.BaseClasses.RadiantSlabChar RadSlaCha constrainedby
          IDEAS.Fluid.HeatExchangers.RadiantSlab.BaseClasses.RadiantSlabChar
            "Properties of the floor heating or TABS, if present"
            annotation (choicesAllMatching=true);
          final parameter Modelica.SIunits.Length pipeDiaInt = RadSlaCha.d_a - 2*RadSlaCha.s_r
            "Pipe internal diameter";
          extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface(allowFlowReversal=false);
          extends IDEAS.Fluid.Interfaces.TwoPortFlowResistanceParameters(
            dp_nominal=Modelica.Fluid.Pipes.BaseClasses.WallFriction.Detailed.pressureLoss_m_flow(
              m_flow=m_flow_nominal/nParCir,
              rho_a=rho_default,
              rho_b=rho_default,
              mu_a=mu_default,
              mu_b=mu_default,
              length=pipeEqLen/nParCir,
              diameter=pipeDiaInt,
              roughness=roughness,
              m_flow_small=m_flow_small/nParCir));
          parameter Modelica.SIunits.Area A_floor "Floor/tabs surface area";
          parameter Integer nDiscr(min=1) = 1
            "Number of series discretisations along the flow direction"
            annotation(Evaluate=true);
          parameter Real nParCir(min=1) = 1 "Number of parallel circuits in the tabs"
            annotation(Evaluate=true);
          parameter Modelica.SIunits.Length roughness(min=0) = 2.5e-5
            "Absolute roughness of pipe, with a default for a smooth steel pipe"
            annotation(Dialog(tab="Flow resistance"));
          parameter Modelica.SIunits.Length L_floor = A_floor^(1/2)
            "Floor length - along the pipe direction"
            annotation(Dialog(tab="Flow resistance"));
          parameter Real N_pipes = A_floor/L_floor/RadSlaCha.T - 1
            "Number of parallel pipes in the slab"
        annotation(Dialog(tab="Flow resistance"));
          parameter Modelica.SIunits.Length pipeBendEqLen = 2*(N_pipes-1)*(2.267*RadSlaCha.T/2/pipeDiaInt+6.18)*pipeDiaInt
            "Pipe bends equivalent length, default according to Fox and McDonald (chapter 8.7, twice the linearized losses of a 90 degree bend)"
        annotation(Dialog(tab="Flow resistance"));
          parameter Modelica.SIunits.Length pipeEqLen = pipeBendEqLen + (L_floor-2*RadSlaCha.T)*N_pipes
            "Total pipe equivalent length, default assuming 180 dg turns starting at RadSlaCha.T from the end of the slab"
        annotation(Dialog(tab="Flow resistance"));
          parameter Modelica.SIunits.MassFlowRate m_flowMin = m_flow_nominal*0.5
            "Minimal flowrate when in operation - used for validity check"
            annotation(Dialog(group="Nominal condition"));

          final parameter Modelica.SIunits.ThermalInsulance R_r_val=RadSlaCha.T*log(RadSlaCha.d_a
              /pipeDiaInt)/(2*Modelica.Constants.pi*RadSlaCha.lambda_r)
            "Fix resistance value of thermal conduction through pipe wall * surface of floor between 2 pipes (see RadSlaCha documentation)";
          //Calculation of the resistance from the outer pipe wall to the center of the tabs / floorheating. eqn 4-25 Koschenz
          final parameter Modelica.SIunits.ThermalInsulance R_x_val=RadSlaCha.T*(log(RadSlaCha.T
              /(3.14*RadSlaCha.d_a)) + corr)/(2*Modelica.Constants.pi*RadSlaCha.lambda_b)
            "Fix resistance value of thermal conduction from pipe wall to layer";
          final parameter Real corr = if RadSlaCha.tabs then 0 else
            sum( -(RadSlaCha.alp2/RadSlaCha.lambda_b * RadSlaCha.T - 2*3.14*s)/(RadSlaCha.alp2/RadSlaCha.lambda_b * RadSlaCha.T + 2*3.14*s)*exp(-4*3.14*s/RadSlaCha.T*RadSlaCha.S_2)/s for s in 1:10) "correction factor for the floor heating according to Multizone Building modeling with Type56 and TRNBuild (see documentation). 
    If tabs is used, corr=0 - fixme: deprecated?";

          parameter Boolean from_dp = false
            "= true, use m_flow = f(dp) else dp = f(m_flow)"
            annotation (Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean linearized = false
            "= true, use linear relation between m_flow and dp for any flow rate"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Modelica.SIunits.ThermalInsulance R_c = 1/(RadSlaCha.lambda_b/RadSlaCha.S_1 + RadSlaCha.lambda_b/RadSlaCha.S_2)
            "Specific thermal resistivity of (parallel) slabs connected to top and bottom of tabs"
            annotation(Dialog(group="Thermal"));

          Modelica.SIunits.Temperature[nDiscr] Tin = cat(1, {senTemIn.T}, vol[1:nDiscr-1].heatPort.T);
          Modelica.SIunits.Power[nDiscr] Q "Thermal power going into tabs";
          //For high flow rates see [Koshenz, 2000] eqn 4.37 in between
          // for laminar flow Nu_D = 4 is assumed: correlation for heat transfer constant heat flow and constant wall temperature
          Modelica.SIunits.ThermalInsulance R_w_val= IDEAS.Utilities.Math.Functions.spliceFunction(
            x=rey-(reyHi+reyLo)/2,
            pos=RadSlaCha.T^0.13/8/Modelica.Constants.pi*abs((pipeDiaInt/(m_flowSpLimit*L_r)))^0.87,
            neg=RadSlaCha.T/(4*Medium.thermalConductivity(sta_default)*Modelica.Constants.pi),
            deltax=(reyHi-reyLo)/2)
            "Flow dependent resistance value of convective heat transfer inside pipe for both turbulent and laminar heat transfer.";
          Modelica.SIunits.ThermalInsulance R_t
            "Total equivalent specific resistivity as defined by Koschenz in eqn 4-59";
          Modelica.SIunits.ThermalConductance G_t
            "Equivalent thermal conductance";
          Modelica.SIunits.ThermalConductance G_max
            "Maximum thermal conductance based on mass flow rate";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[nDiscr] heatPortEmb
            "Port to the core of a floor heating/concrete activation"
            annotation (Placement(transformation(extent={{-10,90},{10,110}}),
                iconTransformation(extent={{-10,90},{10,110}})));
          //Reynold number Re = ( (m_flow / rho / A) * D * rho )  / mu / numParCir.
          Modelica.SIunits.ReynoldsNumber rey=
            m_flow/nParCir/A_pipe*pipeDiaInt/mu_default "Reynolds number";

          IDEAS.Fluid.MixingVolumes.MixingVolume[nDiscr] vol(each nPorts=2, each m_flow_nominal = m_flow_nominal, each V=m/nDiscr/rho_default,
            redeclare each package Medium = Medium,
            each p_start=p_start,
            each T_start=T_start,
            each X_start=X_start,
            each C_start=C_start,
            each C_nominal=C_nominal,
            each allowFlowReversal=allowFlowReversal,
            each mSenFac=mSenFac,
            each m_flow_small=m_flow_small,
            each final prescribedHeatFlowRate=true,
            each energyDynamics=energyDynamics,
            each massDynamics=massDynamics)
            annotation (Placement(transformation(extent={{-50,0},{-70,20}})));

          FixedResistances.ParallelPressureDrop          res(
            redeclare package Medium = Medium,
            m_flow_nominal=m_flow_nominal,
            final dp_nominal=dp_nominal,
            allowFlowReversal=allowFlowReversal,
            from_dp=from_dp,
            homotopyInitialization=homotopyInitialization,
            linearized=linearized,
            dp(nominal=L_r*10),
            computeFlowResistance=abs(dp_nominal)> 1e-5 and computeFlowResistance,
            final nParCir=nParCir,
            final dh=pipeDiaInt,
            final ReC=reyHi)
            annotation (Placement(transformation(extent={{20,-10},{40,10}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow[nDiscr] heatFlowWater(
            each final alpha=0) "Heat flow rate that is extracted from the fluid"
            annotation (Placement(transformation(extent={{-40,30},{-20,50}})));
          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow[nDiscr] heatFlowSolid(
            each final alpha=0)
            "Heat flow rate that is injected in the solid material"
            annotation (Placement(transformation(extent={{-40,70},{-20,90}})));
          Modelica.Blocks.Math.Gain[nDiscr] negate(each k=-1)
            annotation (Placement(transformation(extent={{-56,36},{-48,44}})));
          Modelica.Blocks.Sources.RealExpression[nDiscr] Q_tabs(y=Q)
            annotation (Placement(transformation(extent={{-100,50},{-72,70}})));

          Modelica.Blocks.Math.Sum sumQTabs(nin=nDiscr, k=ones(nDiscr))
          "Block that sums the volume heat flow rates"
            annotation (Placement(transformation(extent={{20,50},{40,70}})));
          Modelica.Blocks.Interfaces.RealOutput QTot
            "Total thermal power going into the heat port"
            annotation (Placement(transformation(extent={{100,50},{120,70}})));
          Sensors.TemperatureTwoPort senTemIn(
            redeclare package Medium = Medium,
            m_flow_nominal=m_flow_nominal,
            tau=0) "Sensor for inlet temperature"
                   annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
      protected
          final parameter Modelica.SIunits.Length L_r=A_floor/RadSlaCha.T/nParCir
            "Length of one of the parallel circuits";
          final parameter Modelica.SIunits.Area A_pipe=
            Modelica.Constants.pi/4*pipeDiaInt^2
            "Pipe internal cross section surface area";
          final parameter Medium.ThermodynamicState sta_default=
             Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
          final parameter Modelica.SIunits.Density rho_default = Medium.density(sta_default);
          final parameter Modelica.SIunits.DynamicViscosity mu_default = Medium.dynamicViscosity(sta_default)
            "Dynamic viscosity at nominal condition";
          final parameter Modelica.SIunits.SpecificHeatCapacity cp_default = Medium.specificHeatCapacityCp(sta_default)
            "Heat capacity at nominal condition";
          final parameter Modelica.SIunits.MassFlowRate m_flow_nominal_pos = abs(m_flow_nominal)
            "Absolute value of nominal flow rate";
          final parameter Modelica.SIunits.MassFlowRate m_flow_turbulent =  mu_default*pipeDiaInt/4*Modelica.Constants.pi*reyHi
            "Turbulent flow if |m_flow| >= m_flow_turbulent";
          final parameter Modelica.SIunits.Pressure dp_nominal_pos = abs(dp_nominal)
            "Absolute value of nominal pressure";
          final parameter Modelica.SIunits.ReynoldsNumber reyLo=2700
            "Reynolds number where transition to turbulence starts"
            annotation(Evaluate=true);
          final parameter Modelica.SIunits.ReynoldsNumber reyHi=4000
            "Reynolds number where transition to turbulence ends"
            annotation(Evaluate=true);
          final parameter Real deltaXR = m_flow_nominal/A_floor*cp_default/1000
            "Transition threshold for regularization function";
          final parameter Modelica.SIunits.ThermalInsulance R_w_val_min=
            IDEAS.Utilities.Math.Functions.spliceFunction(x=m_flowMin/nParCir/A_pipe*pipeDiaInt/mu_default-(reyHi+reyLo)/2,
              pos=RadSlaCha.T^0.13/8/Modelica.Constants.pi*abs((pipeDiaInt/(m_flow_nominal/A_floor*L_r)))^0.87,
              neg=RadSlaCha.T/(4*Medium.thermalConductivity(sta_default)*Modelica.Constants.pi),
              deltax=(reyHi-reyLo)/2)
            "Lowest value for R_w that is expected for the set mass flow rate";
          final parameter Modelica.SIunits.Mass m(start=1) = A_pipe*L_r*rho_default
            "Mass of medium";
          Real m_flowSp(unit="kg/(m2.s)")=port_a.m_flow/(A_floor/nDiscr)
            "mass flow rate per unit floor area";
          Real m_flowSpLimit
            "Specific mass flow rate regularized for no flow conditions";
        initial equation
          if RadSlaCha.tabs then
            assert(RadSlaCha.S_1 > 0.3*RadSlaCha.T, "Thickness of the concrete or screed layer above the tubes is smaller than 0.3 * the tube interdistance. 
    The model is not valid for this case");
            assert(RadSlaCha.S_2 > 0.3*RadSlaCha.T, "Thickness of the concrete or screed layer under the tubes is smaller than 0.3 * the tube interdistance. 
      The model is not valid for this case");
          else
            assert(RadSlaCha.alp2 < 1.212, "In order to use the floor heating model, RadSlaCha.alp2 need to be < 1.212");
            assert(RadSlaCha.d_a/2 < RadSlaCha.S_2, "In order to use the floor heating model, RadSlaCha.alp2RadSlaCha.d_a/2 < RadSlaCha.S_2 needs to be true");
            assert(RadSlaCha.S_1/RadSlaCha.T <0.3, "In order to use the floor heating model, RadSlaCha.S_1/RadSlaCha.T <0.3 needs to be true");
          end if;
        equation
          assert(allowFlowReversal or port_a.m_flow>-m_flow_small, "In " + getInstanceName() + ": flow reversal detected.");
          assert(not allowFlowReversal, "In " +getInstanceName() + ": parameter allowFlowReversal=true, but the EmbeddedPipe model does not support it.", AssertionLevel.warning);
          // this need not be smooth since when active, G_max is already active
          m_flowSpLimit = max(m_flowSp, 1e-8);
          // Koschenz eq 4-59
          R_t = 1/(m_flowSpLimit*cp_default*(1-exp(-1/((R_w_val+R_r_val+R_x_val+R_c)*m_flowSpLimit*cp_default))))-R_c;
          G_t = abs(A_floor/nDiscr/R_t);
          // maximum thermal conductance based on second law
          G_max = abs(m_flow)*cp_default;
          // no smoothmin since this undershoots for near-zero values
          Q = (Tin - heatPortEmb.T)*min(G_t, G_max);

          connect(res.port_b, port_b) annotation (Line(
                 points={{40,0},{100,0}},
               color={0,127,255},
               smooth=Smooth.None));
          connect(senTemIn.port_b, vol[1].ports[1]) annotation (Line(
               points={{-70,0},{-58,0}},
               color={0,127,255},
                      smooth=Smooth.None));
          connect(res.port_a, vol[nDiscr].ports[2]) annotation (Line(
               points={{20,0},{-62,0}},
               color={0,127,255},
               smooth=Smooth.None));

          for i in 2:nDiscr loop
            connect(vol[i-1].ports[2], vol[i].ports[1]) annotation (Line(
              points={{-62,0},{-58,0}},
              color={0,127,255},
              smooth=Smooth.None));
          end for;

          connect(heatFlowWater.port, vol.heatPort) annotation (Line(
              points={{-20,40},{-20,10},{-50,10}},
              color={191,0,0},
              smooth=Smooth.None));
          connect(heatFlowWater.Q_flow, negate.y) annotation (Line(
              points={{-40,40},{-47.6,40}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(negate.u, Q_tabs.y) annotation (Line(
              points={{-56.8,40},{-60,40},{-60,60},{-70.6,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(heatFlowSolid.Q_flow, Q_tabs.y) annotation (Line(
              points={{-40,80},{-60,80},{-60,60},{-70.6,60}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(heatFlowSolid.port, heatPortEmb) annotation (Line(
              points={{-20,80},{0,80},{0,100}},
              color={191,0,0},
              smooth=Smooth.None));

          connect(Q_tabs.y, sumQTabs.u)
            annotation (Line(points={{-70.6,60},{18,60}}, color={0,0,127}));
          connect(sumQTabs.y, QTot)
            annotation (Line(points={{41,60},{110,60}}, color={0,0,127}));
          connect(port_a, senTemIn.port_a)
            annotation (Line(points={{-100,0},{-90,0}}, color={0,127,255}));
           annotation (
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}})),
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}),
                 graphics={
                Ellipse(
                  extent={{-20,22},{20,-20}},
                  fillColor={127,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-95,6},{106,-4}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={0,0,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-102,-4},{-2,6}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={255,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-20,22},{20,-20}},
                  fillColor={127,0,0},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Rectangle(
                  extent={{-80,60},{80,-60}},
                  lineColor={0,0,0},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-66,60},{-66,-60}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{66,60},{66,-60}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Polygon(
                  points={{-66,60},{-66,-60},{66,-60},{-66,60}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Forward)}),
            Documentation(info="<html>
<p>
Dynamic model of an embedded pipe for a concrete core activation. 
This model is based on (Koschenz, 2000). 
In addition the model provides the options to simulate the concrete 
core activation as if there were multiple parallel branches. 
This affects the pressure drop calculation and also the thermal calculations.
</p>
<h4>Assumptions and limitations</h4>
<p>
The implementation of Koschenz mentions that a minimum
discretization (i.e. using <code>nDiscr</code>) is required to avoid violation of the
second law of thermodynamics. The model explicitly
enforces the second law even for <code>nDiscr=1</code> by upper bounding
the heat flow rate such that this minimum discretization does not apply to our implementation.
The parameter <code>nDiscr</code> thus
only affects the results at larger flow rates.
The example <a href=\"IDEAS.Fluid.HeatExchangers.RadiantSlab.Examples.EmbeddedPipeNDiscr\">
IDEAS.Fluid.HeatExchangers.RadiantSlab.Examples.EmbeddedPipeNDiscr</a> provides an indication
of the sensitivity of the results to the value of <code>nDiscr</code>.
</p>
<p>
The embeddedPipe model is designed to be used together with an 
<a href=\"IDEAS.Buildings.Components.InternalWall\">IDEAS.Buildings.Components.InternalWall</a>. 
When <code>nDiscr>1</code>, the wall/floor should also be discretized to be physically correct,
although the discretizations can also be connected to the same wall/floor, which gives a reasonable
approximation as illustrated by the example 
<a href=\"IDEAS.Fluid.HeatExchangers.RadiantSlab.Examples.EmbeddedPipeNDiscr\">
IDEAS.Fluid.HeatExchangers.RadiantSlab.Examples.EmbeddedPipeNDiscr</a>.
</p>
<h4>Typical use and important parameters</h4>
<p>
Following parameters need to be set:
</p>
<ul>
<li>RadSlaCha is a record with all the parameters of the geometry, materials and even number of discretization layers in the nakedTabs model.</li>
<li>mFlow_min is used to check the validity of the operating conditions and is by default half of the nominal mass flow rate.</li>
<li><code>A_floor</code> is the surface area of (one side of) the Thermally Activated Building part (TAB). </li>
<li><code>nDiscr</code> can be used for discretizing the EmbeddedPipe along the flow direction. See above for a more detailed discussion.</li>
<li><code>nParCir</code> can be used for calculating the pressure drops as if there were multiple EmbeddedPipes connected in parallel. The total mass flow rate is then split over multiple circuits and the pressure drop is calculated accordingly.</li>
<li><code>R_C</code> is the thermal resistivity from the center of the tabs to the zones. Note that the upper and lower resistivities need to be calculated as if they were in parallel. This parameter has a default value based on RadSlaCha but it may be improved if necessary. The impact of the value of this parameter on the model performance is low except in cases of very low mass flow rates.</li>
</ul>
<h4>Options</h4>
<p>
By default <code>dp_nominal</code> is calculated by making an estimate of the total pipe length. 
This pressure drop can be an underestimation of the real pressure drop. 
The used pipe lengths can be changed in the Pressure drop tab.
Parameter <code>dp_nominal</code> can be used to override the default calculation.
</p>
<h4>Validation </h4>
<p>
A limited verification has been performed in IDEAS.Fluid.HeatExchangers.RadiantSlab.Examples.EmbeddedPipeVerification.
</p>
<h4>References</h4>
<p>[Koshenz, 2000] - Koschenz, Markus, and Beat Lehmann. 2000. <i>Thermoaktive Bauteilsysteme - Tabs</i>. D&uuml;bendorf: EMPA D&uuml;bendorf. </p>
<p>[TRNSYS, 2007] - Multizone Building modeling with Type 56 and TRNBuild.</p>
</html>",         revisions="<html>
<ul>
<li>
October 19, 2019 by Filip Jorissen:<br/>
Removed discretization assert since we limit the heat flow rate to physically
realistic values already using a limit on <code>G_t</code>. 
Revised documentation.
See <a href=https://github.com/open-ideas/IDEAS/issues/863>#863</a>.
</li>
<li>
October 18, 2019 by Filip Jorissen:<br/>
Using <code>TemperatureTwoPort</code> sensor. 
See <a href=https://github.com/open-ideas/IDEAS/issues/1081>#1081</a>.
</li>
<li>
October 13, 2019 by Filip Jorissen:<br/>
Bugfix for division by zero when <code>dp_nominal=0</code>,
See <a href=https://github.com/open-ideas/IDEAS/issues/1031>#1031</a>.
</li>
<li>
August 14, 2019 by Iago Cupeiro:<br/>
Added output that computes the total TABS heat flow of the <code>EmbeddedPipe</code>.
</li>
<li>
April 16, 2019 by Filip Jorissen:<br/>
Added checks for flow reversal.
See <a href=https://github.com/open-ideas/IDEAS/issues/1006>#1006</a>.
</li>
<li>
April 16, 2019 by Filip Jorissen:<br/>
Removed <code>computeFlowResistance=false</code> 
since this parameter was hidden in the advanced tab
and this setting can easily lead to singularities.
See <a href=https://github.com/open-ideas/IDEAS/issues/1014>#1014</a>.
</li>
<li>
June 21, 2018 by Filip Jorissen:<br/>
Set <code>final alpha=0</code> in <code>prescribedHeatFlow</code>
to avoid large algebraic loops in specific cases.
See <a href=https://github.com/open-ideas/IDEAS/issues/852>#852</a>.
</li>
<li>
April 26, 2017 by Filip Jorissen:<br/>
Removed <code>useSimplifiedRt</code> parameter
since this leads to a violation of the second 
law for small flow rates.
See <a href=https://github.com/open-ideas/IDEAS/issues/717>#717</a>.
</li>
<li>2015 November, Filip Jorissen: Revised implementation for small flow rates: v3: replaced SmoothMin by min function</li>
<li>2015 November, Filip Jorissen: Revised implementation for small flow rates: v2</li>
<li>2015 November, Filip Jorissen: Revised implementation for small flow rates</li>
<li>2015, Filip Jorissen: Revised implementation</li>
<li>2014 March, Filip Jorissen: IDEAS baseclasses</li>
<li>2013 May, Roel De Coninck: documentation</li>
<li>2012 April, Roel De Coninck: rebasing on common Partial_Emission</li>
<li>2011, Roel De Coninck: first version and validation</li>
</ul>
</html>"));
        end EmbeddedPipe;

        package BaseClasses
        extends Modelica.Icons.BasesPackage;

          record RadiantSlabChar
            "Record containing all parameters for a given a floor heating of concrete core activation"
            // The terminology from prEN 15377 is followed, even if I find the development of the theory
            // by Koschenz and Lehmann better (see Thermoaktive Bauteilsysteme tabs, from Empa)
            // First Version 20110622
            // Changed 20110629:
            // Important: this record ALSO contains the parameters that are specific to the building.
            extends Modelica.Icons.Record;
            parameter Boolean tabs = true
              "true if the model is used for tabs, false if the model is used for floor heating. This is used for the correction factor of the thermal resistances in EmbeddedPipe";
            parameter Modelica.SIunits.Length T(
              min=0.15,
              max=0.3) = 0.2 "Pipe spacing, limits imposed by prEN 15377-3 p22";
            parameter Modelica.SIunits.Length d_a=0.02 "External diameter of the pipe";
            parameter Modelica.SIunits.Length s_r=0.0025 "Thickness of the pipe wall";
            parameter Modelica.SIunits.ThermalConductivity lambda_r=0.35
              "Thermal conductivity of the material of the pipe";
            parameter Modelica.SIunits.Length S_1=0.1
              "Thickness of the concrete/screed ABOVE the pipe layer";
            parameter Modelica.SIunits.Length S_2=0.1
              "Thickness of the concrete/screed UNDER the pipe layer";
            parameter Modelica.SIunits.ThermalConductivity lambda_b=1.8
              "Thermal conductivity of the concrete or screed layer";
            parameter Modelica.SIunits.SpecificHeatCapacity c_b=840
              "Thermal capacity of the concrete/screed material";
            parameter Modelica.SIunits.Density rho_b=2100
              "Density of the concrete/screed layer";
            constant Integer n1=3 "Number of discrete capacities in upper layer";
            constant Integer n2=3 "Number of discrete capacities in lower layer";
            parameter Integer nParCir=1 "number of circuit in parallel";
            // Extra parameters for floor heating
            parameter Modelica.SIunits.ThermalConductivity lambda_i = 0.036
              "heat conductivity of the isolation";
            parameter Modelica.SIunits.Length d_i = 0.05 "Thickness of the insulation";
            final parameter Real alp2 = lambda_i / d_i
              "help variable for resistance calculation";
            annotation (Documentation(info="<html>
<p><b>Description</b> </p>
<p>Record containing the properties of a floor heating or TABS.  The&nbsp;terminology&nbsp;from&nbsp;prEN&nbsp;15377&nbsp;is&nbsp;followed,&nbsp;even&nbsp;if&nbsp;I&nbsp;find&nbsp;the&nbsp;development&nbsp;of&nbsp;the&nbsp;theory by&nbsp;Koschenz&nbsp;and&nbsp;Lehmann&nbsp;better&nbsp;(see&nbsp;Thermoaktive&nbsp;Bauteilsysteme&nbsp;tabs,&nbsp;from&nbsp;Empa)</p>
<h4>Model use</h4>
<ol>
<li>It&apos;s important to set at least the floor surface to something different from 1</li>
<li>The embeddedPipe model has a few assertions to check the validity of some parameters and their combinations.</li>
</ol>
</html>",           revisions="<html>
<ul>
<li>2013 May, Roel De Coninck, documentation</li>
<li>2011 June, Roel De Coninck, first version</li>
</ul>
</html>"));
          end RadiantSlabChar;
        end BaseClasses;
      end RadiantSlab;

      package BaseClasses
      "Package with base classes for IDEAS.Fluid.HeatExchangers"
        extends Modelica.Icons.BasesPackage;

        partial model PartialEffectiveness
          "Partial model to implement heat exchangers based on effectiveness model"
          extends Fluid.Interfaces.StaticFourPortHeatMassExchanger(
            prescribedHeatFlowRate1=true,
            prescribedHeatFlowRate2=true,
            show_T=false);

          Medium1.Temperature T_in1 = if allowFlowReversal1 then
            fra_a1 * Medium1.temperature(state_a1_inflow) + fra_b1 * Medium1.temperature(state_b1_inflow) else
            Medium1.temperature(state_a1_inflow)
            "Inlet temperature medium 1";
          Medium2.Temperature T_in2 = if allowFlowReversal2 then
            fra_a2 * Medium2.temperature(state_a2_inflow) + fra_b2 * Medium2.temperature(state_b2_inflow) else
            Medium2.temperature(state_a2_inflow)
            "Inlet temperature medium 2";
          Modelica.SIunits.ThermalConductance C1_flow = abs(m1_flow)*
            ( if allowFlowReversal1 then
                   fra_a1 * Medium1.specificHeatCapacityCp(state_a1_inflow) +
                   fra_b1 * Medium1.specificHeatCapacityCp(state_b1_inflow) else
                Medium1.specificHeatCapacityCp(state_a1_inflow))
            "Heat capacity flow rate medium 1";
          Modelica.SIunits.ThermalConductance C2_flow = abs(m2_flow)*
            ( if allowFlowReversal2 then
                   fra_a2 * Medium2.specificHeatCapacityCp(state_a2_inflow) +
                   fra_b2 * Medium2.specificHeatCapacityCp(state_b2_inflow) else
                Medium2.specificHeatCapacityCp(state_a2_inflow))
            "Heat capacity flow rate medium 2";
          Modelica.SIunits.ThermalConductance CMin_flow(min=0) = min(C1_flow, C2_flow)
            "Minimum heat capacity flow rate";
          Modelica.SIunits.HeatFlowRate QMax_flow = CMin_flow*(T_in2 - T_in1)
            "Maximum heat flow rate into medium 1";
      protected
          parameter Real delta=1E-3 "Parameter used for smoothing";

          parameter Modelica.SIunits.SpecificHeatCapacity cp1_default(fixed=false)
            "Specific heat capacity of medium 1 at default medium state";
          parameter Modelica.SIunits.SpecificHeatCapacity cp2_default(fixed=false)
            "Specific heat capacity of medium 2 at default medium state";
          parameter Modelica.SIunits.ThermalConductance CMin_flow_small(fixed=false)
            "Small value for smoothing of minimum heat capacity flow rate";
          Real fra_a1(min=0, max=1) = if allowFlowReversal1
            then Modelica.Fluid.Utilities.regStep(
              m1_flow,
              1,
              0,
              m1_flow_small)
            else 1
            "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
          Real fra_b1(min=0, max=1) = if allowFlowReversal1
            then 1-fra_a1
            else 0
            "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
          Real fra_a2(min=0, max=1) = if allowFlowReversal2
            then Modelica.Fluid.Utilities.regStep(
              m2_flow,
              1,
              0,
              m2_flow_small)
            else 1
            "Fraction of incoming state taken from port a2 (used to avoid excessive calls to regStep)";
          Real fra_b2(min=0, max=1) = if allowFlowReversal2
            then 1-fra_a2
            else 0
            "Fraction of incoming state taken from port b2 (used to avoid excessive calls to regStep)";
        initial equation
          cp1_default = Medium1.specificHeatCapacityCp(Medium1.setState_pTX(
            Medium1.p_default,
            Medium1.T_default,
            Medium1.X_default));
          cp2_default = Medium2.specificHeatCapacityCp(Medium2.setState_pTX(
            Medium2.p_default,
            Medium2.T_default,
            Medium2.X_default));
          CMin_flow_small = min(m1_flow_small*cp1_default, m2_flow_small*cp2_default);

          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Rectangle(
                  extent={{-70,78},{70,-80}},
                  lineColor={0,0,255},
                  pattern=LinePattern.None,
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid)}),
            Documentation(info="<html>
<p>
Partial model to implement heat exchanger models.
</p>
<p>
Classes that extend this model need to implement heat and
mass balance equations in a form like
</p>
<pre>
  // transferred heat
  Q1_flow = eps * QMax_flow;
  // no heat loss to ambient
  0 = Q1_flow + Q2_flow;
  // no mass exchange
  mXi1_flow = zeros(Medium1.nXi);
  mXi2_flow = zeros(Medium2.nXi);
</pre>
<p>
Thus, if medium 1 is heated in this device, then <code>Q1_flow &gt; 0</code>
and <code>QMax_flow &gt; 0</code>.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 21, 2019, by Filip Jorissen:<br/>
Revised implementation of all equations
such that a binding equation is used. 
I.e. we set the variable value at the variable definition
instead of using the equation section.
This allows overwriting the equation
when extending the model.<br/>
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1102\">#1102</a>.
</li>
<li>
April 30, 2018, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate1=true</code> and 
<code>prescribedHeatFlowRate2=true</code>.<br/>
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/907\">#907</a>.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Changed type of <code>T_in1</code> and <code>T_in2</code>
to <code>Medium1.Temperature</code> and <code>Medium2.Temperature</code>
to avoid an error because of conflicting start values if
<a href=\"modelica://IDEAS.Examples.ChillerPlant.BaseClasses.Controls.Examples.ChillerSetPointControl\">
Buildings.Examples.ChillerPlant.BaseClasses.Controls.Examples.ChillerSetPointControl</a>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
October 8, 2011, by Michael Wetter:<br/>
Set <code>show_T=false</code> to avoid state events near zero flow.
</li>
<li>
August 31, 2011, by Michael Wetter:<br/>
Removed unused variables <code>gai1</code> and <code>gai2</code>.
</li>
<li>
February 12, 2010, by Michael Wetter:<br/>
Changed model structure to implement effectiveness-NTU model.
</li>
<li>
January 28, 2010, by Michael Wetter:<br/>
Added regularization near zero flow.
</li>
<li>
October 2, 2009, by Michael Wetter:<br/>
Changed computation of inlet temperatures to use
<code>state_*_inflow</code> which is already known in base class.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialEffectiveness;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.HeatExchangers\">IDEAS.Fluid.HeatExchangers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains models for heat exchangers with and without humidity condensation.
</html>"));
    end HeatExchangers;

    package MixingVolumes "Package with mixing volumes"
      extends Modelica.Icons.VariantsPackage;

      model MixingVolume
        "Mixing volume with inlet and outlet ports (flow reversal is allowed)"
        extends IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume(
          final initialize_p = not Medium.singleState,
          steBal(final use_C_flow = use_C_flow),
          dynBal(final use_C_flow = use_C_flow));
        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
          T(start=T_start)) "Heat port for heat exchange with the control volume"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if use_C_flow
          "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
      equation
        connect(heaFloSen.port_a, heatPort)
          annotation (Line(points={{-90,0},{-96,0},{-100,0}}, color={191,0,0}));
        connect(C_flow, steBal.C_flow) annotation (Line(points={{-120,-60},{-80,-60},
                {12,-60},{12,6},{18,6}}, color={0,0,127}));
        connect(C_flow, dynBal.C_flow) annotation (Line(points={{-120,-60},{-52,-60},
                {52,-60},{52,6},{58,6}}, color={0,0,127}));
        annotation (
      defaultComponentName="vol",
      Documentation(info="<html>
<p>
This model represents an instantaneously mixed volume.
Potential and kinetic energy at the port are neglected,
and there is no pressure drop at the ports.
The volume can exchange heat through its <code>heatPort</code>.
</p>
<p>
The volume can be parameterized as a steady-state model or as
dynamic model.</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<h4>Options</h4>
<p>
The parameter <code>mSenFac</code> can be used to increase the thermal mass of this model
without increasing its volume. This way, species concentrations are still calculated
correctly even though the thermal mass increases. The additional thermal mass is calculated
based on the density and the value of the function <code>HeatCapacityCp</code>
of the medium state <code>state_default</code>. <br/>
This parameter can for instance be useful in a pipe model when the developer wants to
lump the pipe thermal mass to the fluid volume. By default <code>mSenFac = 1</code>, hence
the mass is unchanged. For higher values of <code>mSenFac</code>, the mass will be scaled proportionally.
</p>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector for the trace substance flow rate.
This allows to directly add or subtract trace substances such as
CO2 to the volume.
See
<a href=\"modelica://IDEAS.Fluid.Sensors.Examples.PPM\">IDEAS.Fluid.Sensors.Examples.PPM</a>
for an example.
</p>
<h4>Implementation</h4>
<p>
If the model is operated in steady-state and has two fluid ports connected,
then the same energy and mass balance implementation is used as in
steady-state component models, i.e., the use of <code>actualStream</code>
is not used for the properties at the port.
</p>
<p>
The implementation of these balance equations is done in the instances
<code>dynBal</code> for the dynamic balance and <code>steBal</code>
for the steady-state balance. Both models use the same input variables:
</p>
<ul>
<li>
The variable <code>Q_flow</code> is used to add sensible <i>and</i> latent heat to the fluid.
For example, <code>Q_flow</code> participates in the steady-state energy balance<pre>
    port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
</pre>
where <code>m_flowInv</code> approximates the expression <code>1/m_flow</code>.
</li>
<li>
The variable <code>mXi_flow</code> is used to add a species mass flow rate to the fluid.
</li>
</ul>
<p>
For the rationale of selecting different energy and mass balances, and for the
use of <code>prescribedHeatFlowRate</code>, see the documentation of
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume\">
IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolume</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://IDEAS.Fluid.HeatExchangers.HeaterCooler_u\">
IDEAS.Fluid.HeatExchangers.HeaterCooler_u</a> and
<a href=\"modelica://IDEAS.Fluid.Humidifiers.Humidifier_u\">
IDEAS.Fluid.Humidifiers.Humidifier_u</a>.
</p>

</html>",       revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Set <code>initialize_p</code> to <code>final</code> so that it does not
appear as a user-selectable parameter. This is done because
<code>initialize_p</code> has been changed from a <code>constant</code>
to a <code>parameter</code> for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Changed comment of heat port, as this needs to be the total heat flow
rate in order to be able to use this model for modeling steam humidifiers
and adiabatic humidifiers.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 19, 2016, by Michael Wetter:<br/>
Updated documentation due to the addition of an input for trace substance
in the mixing volume.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">
issue 372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Changed code for handling trace substance insertions using input <code>C_flow</code>.
</li>
<li>
May 1, 2015 by Michael Wetter<br/>
Set <code>final</code> keyword for <code>masExc(final k=0)</code>.
This addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/230\">
issue 230</a>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Redesigned implementation of latent and sensible heat flow rates
as port of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IDEAS.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations\">
IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
IDEAS.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                  100}}), graphics={Ellipse(
                extent={{-100,98},{100,-102}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={170,213,255}), Text(
                extent={{-58,14},{58,-18}},
                lineColor={0,0,0},
                textString="V=%V"),         Text(
                extent={{-152,100},{148,140}},
                textString="%name",
                lineColor={0,0,255})}));
      end MixingVolume;

      model MixingVolumeMoistAir
        "Mixing volume with heat port for latent heat exchange, to be used if moisture is added or removed"
        extends BaseClasses.PartialMixingVolume(
          dynBal(
            final use_mWat_flow = true,
            final use_C_flow = use_C_flow),
          steBal(final use_mWat_flow = true,
            final use_C_flow = use_C_flow),
          final initialize_p = not Medium.singleState);
        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       final unit = "kg/s")
          "Water flow rate added into the medium"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealOutput X_w(final unit="kg/kg")
          "Species composition of medium"
          annotation (Placement(transformation(extent={{100,-60},{140,-20}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort(
          T(start=T_start))
          "Heat port for sensible plus latent heat exchange with the control volume"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if use_C_flow
          "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
    protected
        parameter Real s[Medium.nXi] = {
        if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false) then 1 else 0
                                                  for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";
        Modelica.Blocks.Sources.RealExpression XLiq(y=s*Xi)
          "Species composition of the medium"
          annotation (Placement(transformation(extent={{72,-52},{94,-28}})));
      equation
        connect(mWat_flow, steBal.mWat_flow) annotation (Line(
            points={{-120,80},{-120,80},{4,80},{4,14},{18,14}},
            color={0,0,127}));
        connect(mWat_flow, dynBal.mWat_flow) annotation (Line(
            points={{-120,80},{-50,80},{52,80},{52,12},{58,12}},
            color={0,0,127}));
        connect(XLiq.y, X_w) annotation (Line(
            points={{95.1,-40},{120,-40}},
            color={0,0,127}));
        connect(heaFloSen.port_a, heatPort)
          annotation (Line(points={{-90,0},{-100,0}}, color={191,0,0}));
        connect(C_flow, steBal.C_flow) annotation (Line(points={{-120,-60},{-80,-60},{
                12,-60},{12,6},{18,6}}, color={0,0,127}));
        connect(C_flow, dynBal.C_flow) annotation (Line(points={{-120,-60},{-52,-60},{
                52,-60},{52,6},{58,6}}, color={0,0,127}));
        annotation (defaultComponentName="vol",
      Documentation(info="<html>
<p>
Model for an ideally mixed fluid volume and the ability
to store mass and energy. The volume is fixed,
and latent and sensible heat can be exchanged.
</p>
<p>
This model represents the same physics as
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolume\">
IDEAS.Fluid.MixingVolumes.MixingVolume</a>, but in addition, it allows
adding or subtracting water to the control volume.
The mass flow rate of the added or subtracted water is
specified at the port <code>mWat_flow</code>.
Adding <code>mWat_flow</code> itself does not affect the energy balance
in this model. Hence, the enthalpy that is added or removed with the
flow of <code>mWat_flow</code> needs to be added to the heat port
<code>heatPort</code>.
</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<h4>Options</h4>
<p>
The parameter <code>mSenFac</code> can be used to increase the thermal mass of this model
without increasing its volume. This way, species concentrations are still calculated
correctly even though the thermal mass increases. The additional thermal mass is calculated
based on the density and the value of the function <code>HeatCapacityCp</code>
of the medium state <code>state_default</code>. <br/>
This parameter can for instance be useful in a pipe model when the developer wants to
lump the pipe thermal mass to the fluid volume. By default <code>mSenFac = 1</code>, hence
the mass is unchanged. For higher values of <code>mSenFac</code>, the mass will be scaled proportionally.
</p>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector for the trace substance flow rate.
This allows to directly add or subtract trace substances such as
CO2 to the volume.
See
<a href=\"modelica://IDEAS.Fluid.Sensors.Examples.PPM\">IDEAS.Fluid.Sensors.Examples.PPM</a>
for an example.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Set <code>initialize_p</code> to <code>final</code> so that it does not
appear as a user-selectable parameter. This is done because
<code>initialize_p</code> has been changed from a <code>constant</code>
to a <code>parameter</code> for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Changed comment of heat port, as this needs to be the total heat flow
rate in order to be able to use this model for modeling steam humidifiers
and adiabatic humidifiers.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>steBal</code>
as this constant is no longer used.
</li>
<li>
January 19, 2016, by Michael Wetter:<br/>
Updated documentation due to the addition of an input for trace substance
in the mixing volume.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">
issue 372</a>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Redesigned implementation of latent and sensible heat flow rates
as port of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
December 18, 2013 by Michael Wetter:<br/>
Changed computation of <code>s</code> to allow this model to also be used
with <code>IDEAS.Media.Water</code>.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Removed dublicate declaration of medium model.
</li>
<li>
September 27, 2013 by Michael Wetter:<br/>
Reformulated assignment of <code>i_w</code> to avoid a warning in OpenModelica.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Changed model to no longer use the obsolete model <code>IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</code>.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>
in the conservation equation model.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the use of the deprecated
<code>cardinality</code> function.
Therefore, all input signals must be connected.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IDEAS.Fluid.Interfaces</code>.
</li>
<li>
February 22, by Michael Wetter:<br/>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
May 29, 2010 by Michael Wetter:<br/>
Rewrote computation of index of water substance.
For the old formulation, Dymola 7.4 failed to differentiate the
model when trying to reduce the index of the DAE.
</li>
<li>
August 7, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end MixingVolumeMoistAir;

      package BaseClasses
      "Package with base classes for IDEAS.Fluid.MixingVolumes"
        extends Modelica.Icons.BasesPackage;

        model PartialMixingVolume
          "Partial mixing volume with inlet and outlet ports (flow reversal is allowed)"

          extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations;
          parameter Boolean initialize_p = not Medium.singleState
            "= true to set up initial equations for pressure"
            annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

          // We set prescribedHeatFlowRate=false so that the
          // volume works without the user having to set this advanced parameter,
          // but to get high robustness, a user can set it to the appropriate value
          // as described in the info section.
          constant Boolean prescribedHeatFlowRate = false
            "Set to true if the model has a prescribed heat flow at its heatPort. If the heat flow rate at the heatPort is only based on temperature difference, then set to false";

          constant Boolean simplify_mWat_flow = true
            "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate"
            annotation(Dialog(group = "Nominal condition"));
          // Port definitions
          parameter Integer nPorts=0 "Number of ports"
            annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));
          parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
            "Small mass flow rate for regularization of zero flow"
            annotation(Dialog(tab = "Advanced"));
          parameter Boolean allowFlowReversal = true
            "= false to simplify equations, assuming, but not enforcing, no flow reversal. Used only if model has two ports."
            annotation(Dialog(tab="Assumptions"), Evaluate=true);
          parameter Modelica.SIunits.Volume V "Volume";
          Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
              redeclare each package Medium = Medium) "Fluid inlets and outlets"
            annotation (Placement(transformation(extent={{-40,-10},{40,10}},
              origin={0,-100})));

          Medium.Temperature T = Medium.temperature_phX(p=p, h=hOut_internal, X=cat(1,Xi,{1-sum(Xi)}))
            "Temperature of the fluid";
          Modelica.Blocks.Interfaces.RealOutput U(unit="J")
            "Internal energy of the component";
          Modelica.SIunits.Pressure p = if nPorts > 0 then ports[1].p else p_start
            "Pressure of the fluid";
          Modelica.Blocks.Interfaces.RealOutput m(unit="kg") "Mass of the component";
          Modelica.SIunits.MassFraction Xi[Medium.nXi] = XiOut_internal
            "Species concentration of the fluid";
          Modelica.Blocks.Interfaces.RealOutput mXi[Medium.nXi](each unit="kg")
            "Species mass of the component";
          Medium.ExtraProperty C[Medium.nC](nominal=C_nominal) = COut_internal
            "Trace substance mixture content";
          Modelica.Blocks.Interfaces.RealOutput mC[Medium.nC](each unit="kg")
            "Trace substance mass of the component";

      protected
          IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation steBal(
            final simplify_mWat_flow = simplify_mWat_flow,
            redeclare final package Medium=Medium,
            final m_flow_nominal = m_flow_nominal,
            final allowFlowReversal = allowFlowReversal,
            final m_flow_small = m_flow_small,
            final prescribedHeatFlowRate=prescribedHeatFlowRate) if
                 useSteadyStateTwoPort "Model for steady-state balance if nPorts=2"
                annotation (Placement(transformation(extent={{20,0},{40,20}})));
          IDEAS.Fluid.Interfaces.ConservationEquation dynBal(
            final simplify_mWat_flow = simplify_mWat_flow,
            redeclare final package Medium = Medium,
            final energyDynamics=energyDynamics,
            final massDynamics=massDynamics,
            final p_start=p_start,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final C_nominal=C_nominal,
            final fluidVolume = V,
            final initialize_p = initialize_p,
            m(start=V*rho_start),
            nPorts=nPorts,
            final mSenFac=mSenFac) if
                 not useSteadyStateTwoPort "Model for dynamic energy balance"
            annotation (Placement(transformation(extent={{60,0},{80,20}})));

          // Density at start values, used to compute initial values and start guesses
          parameter Modelica.SIunits.Density rho_start=Medium.density(
           state=state_start) "Density, used to compute start and guess values";
          final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
              T=Medium.T_default,
              p=Medium.p_default,
              X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
          // Density at medium default values, used to compute the size of control volumes
          final parameter Modelica.SIunits.Density rho_default=Medium.density(
            state=state_default) "Density, used to compute fluid mass";
          final parameter Medium.ThermodynamicState state_start = Medium.setState_pTX(
              T=T_start,
              p=p_start,
              X=X_start[1:Medium.nXi]) "Medium state at start values";
          // See info section for why prescribedHeatFlowRate is used here.
          // The condition below may only be changed if StaticTwoPortConservationEquation
          // contains a correct solution for all foreseeable parameters/inputs.
          // See Buildings, issue 282 for a discussion.
          final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
              (prescribedHeatFlowRate or (not allowFlowReversal)) and (
              energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState) and (
              traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
            "Flag, true if the model has two ports only and uses a steady state balance"
            annotation (Evaluate=true);
          // Outputs that are needed to assign the medium properties
          Modelica.Blocks.Interfaces.RealOutput hOut_internal(unit="J/kg")
            "Internal connector for leaving temperature of the component";
          Modelica.Blocks.Interfaces.RealOutput XiOut_internal[Medium.nXi](each unit="1")
            "Internal connector for leaving species concentration of the component";
          Modelica.Blocks.Interfaces.RealOutput COut_internal[Medium.nC](each unit="1")
            "Internal connector for leaving trace substances of the component";

          Modelica.Thermal.HeatTransfer.Sources.PrescribedTemperature preTem
            "Port temperature"
            annotation (Placement(transformation(extent={{-40,-10},{-60,10}})));
          Modelica.Blocks.Sources.RealExpression portT(y=T) "Port temperature"
            annotation (Placement(transformation(extent={{-10,-10},{-30,10}})));
          Modelica.Thermal.HeatTransfer.Sensors.HeatFlowSensor heaFloSen
            "Heat flow sensor"
            annotation (Placement(transformation(extent={{-90,-10},{-70,10}})));
        equation
          ///////////////////////////////////////////////////////////////////////////
          // asserts
          if not allowFlowReversal then
            assert(ports[1].m_flow > -m_flow_small,
          "In " + getInstanceName() + ": Model has flow reversal, but the parameter allowFlowReversal is set to false.
  m_flow_small    = "         + String(m_flow_small) + "
  ports[1].m_flow = "         + String(ports[1].m_flow) + "
");       end if;
          // Actual definition of port variables.
          //
          // If the model computes the energy and mass balances as steady-state,
          // and if it has only two ports,
          // then we use the same base class as for all other steady state models.
          if useSteadyStateTwoPort then
          connect(steBal.port_a, ports[1]) annotation (Line(
              points={{20,10},{10,10},{10,-20},{0,-20},{0,-20},{0,-100}},
              color={0,127,255}));

          connect(steBal.port_b, ports[2]) annotation (Line(
              points={{40,10},{46,10},{46,-20},{0,-20},{0,-100}},
              color={0,127,255}));
            U=0;
            mXi=zeros(Medium.nXi);
            m=0;
            mC=zeros(Medium.nC);
            connect(hOut_internal,  steBal.hOut);
            connect(XiOut_internal, steBal.XiOut);
            connect(COut_internal,  steBal.COut);
          else
              connect(dynBal.ports, ports) annotation (Line(
              points={{70,0},{70,-80},{62,-80},{2.22045e-15,-80},{2.22045e-15,-90},{2.22045e-15,
                    -100}},
              color={0,127,255}));
            connect(U,dynBal.UOut);
            connect(mXi,dynBal.mXiOut);
            connect(m,dynBal.mOut);
            connect(mC,dynBal.mCOut);
            connect(hOut_internal,  dynBal.hOut);
            connect(XiOut_internal, dynBal.XiOut);
            connect(COut_internal,  dynBal.COut);
          end if;

          connect(portT.y, preTem.T)
            annotation (Line(points={{-31,0},{-38,0}},   color={0,0,127}));
          connect(heaFloSen.port_b, preTem.port)
            annotation (Line(points={{-70,0},{-65,0},{-60,0}},    color={191,0,0}));
          connect(heaFloSen.Q_flow, steBal.Q_flow) annotation (Line(points={{-80,-10},{
                  -80,-16},{6,-16},{6,18},{18,18}},
                                             color={0,0,127}));
          connect(heaFloSen.Q_flow, dynBal.Q_flow) annotation (Line(points={{-80,-10},{
                  -80,-10},{-80,-16},{6,-16},{6,24},{50,24},{50,16},{58,16}},
                                                                       color={0,0,127}));
          annotation (
        defaultComponentName="vol",
        Documentation(info="<html>
<p>
This is a partial model of an instantaneously mixed volume.
It is used as the base class for all fluid volumes of the package
<a href=\"modelica://IDEAS.Fluid.MixingVolumes\">
IDEAS.Fluid.MixingVolumes</a>.
</p>


<h4>Typical use and important parameters</h4>
<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
Set the constant <code>simplify_mWat_flow = true</code> to simplify the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
to
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set by the user.
This constant only has an effect if the model has exactly two fluid ports connected,
and if it is used as a steady-state model.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
Set the parameter <code>use_C_flow = true</code> to enable an input connector
for the trace substance flow rate.
</p>
<h4>Implementation</h4>
<p>
If the model is (i) operated in steady-state,
(ii) has two fluid ports connected, and
(iii) <code>prescribedHeatFlowRate=true</code> or <code>allowFlowReversal=false</code>,
then the model uses
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
in order to use
the same energy and mass balance implementation as is used as in
steady-state component models.
In this situation, the functions <code>inStream</code> are used for the two
flow directions rather than the function
<code>actualStream</code>, which is less efficient.
However, the use of <code>inStream</code> has the disadvantage
that <code>hOut</code> has to be computed, in
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>,
using
</p>
<pre>
if allowFlowReversal then
  hOut = IDEAS.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                    y2=port_a.h_outflow,
                                                    x=port_a.m_flow,
                                                    x_small=m_flow_small/1E3);
else
  hOut = port_b.h_outflow;
end if;
</pre>
<p>
Hence, for <code>allowFlowReversal=true</code>, if <code>hOut</code>
were to be used to compute the temperature that
drives heat transfer such as by conduction,
then the heat transfer would depend on upstream and the <i>downstream</i>
temperatures for small mass flow rates.
This can give wrong results. Consider for example a mass flow rate that is positive
but very close to zero. Suppose the upstream temperature is <i>20</i>&circ;C,
the downstream temperature is <i>10</i>&circ;C, and the heat port is
connected through a heat conductor to a boundary condition of <i>20</i>&circ;C.
Then, <code>hOut = (port_b.h_outflow + port_a.h_outflow)/2</code> and hence
the temperature <code>heatPort.T</code>
is <i>15</i>&circ;C. Therefore, heat is added to the component.
As the mass flow rate is by assumption very small, the fluid that leaves the component
will have a very high temperature, violating the 2nd law.
To avoid this situation, if
<code>prescribedHeatFlowRate=false</code>, then the model
<a href=\"modelica://IDEAS.Fluid.Interfaces.ConservationEquation\">
IDEAS.Fluid.Interfaces.ConservationEquation</a>
is used instead of
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
</p>
<p>
For simple models that uses this model, see
<a href=\"modelica://IDEAS.Fluid.MixingVolumes\">
IDEAS.Fluid.MixingVolumes</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
Removed <code>partial</code> keyword as this model is not partial.<br/>
Moved <code>C_flow</code> and <code>use_C_flow</code> to child classes.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
April 11, 2017, by Michael Wetter:<br/>
Moved heat port to the extending classes to provide better comment.
Otherwise, the mixing volume without water input would have a comment
that says latent heat can be added at this port.<br/>
Removed blocks <code>QSen_flow</code> and
<code>QLat_flow</code>.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs U, m, mXi, mC for being able to
check conservation of quantities.
This if or <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Updated model to use the new parameter <code>use_mWat_flow</code>
rather than <code>sensibleOnly</code>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Removed <code>protected</code> block <code>masExc</code> as
this revision introduces a conditional connector for the
moisture flow rate in the energy and mass balance models.
This change was done to use the same modeling concept for the
moisture input as is used for the trace substance input.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added conditional input <code>C_flow</code> for
handling trace substance insertions.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Set <code>prescribedHeatFlowRate=prescribedHeatflowRate</code> for
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>.
This results in equations that are solved more easily.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
June 9, 2015 by Michael Wetter:<br/>
Set start value for <code>heatPort.T</code> and changed
type of <code>T</code> to <code>Medium.Temperature</code> rather than
<code>Modelica.SIunits.Temperature</code>
to avoid an
error because of conflicting start values if
<code>IDEAS.Fluid.Chillers.Carnot_y</code>
is translated using pedantic mode in Dymola 2016.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/426\">#426</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> to the actual model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Improved documentation and changed the test
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 prescribedHeatFlowRate and ...
</pre>
to
<pre>
 final parameter Boolean useSteadyStateTwoPort=(nPorts == 2) and
 (prescribedHeatFlowRate or (not allowFlowReversal)) and ...
</pre>
The reason is that if there is no flow reversal, then
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
computes <code>hOut =  port_b.h_outflow;</code>, and hence
it is correct to use <code>hOut</code> to compute
temperature-driven heat flow, such as by conduction or convection.
See also the model documentation.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/412\">
#412</a>.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
October 29, 2014, by Michael Wetter:<br/>
Made assignment of <code>mFactor</code> final, and changed computation of
density to use default medium states as are also used to compute the
specific heat capacity.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Removed <code>Q_flow</code> and added <code>QSen_flow</code>.
This was done to clarify what is sensible and total heat flow rate
as part of the correction of issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/197\">#197</a>.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to instance <code>steBal</code> as it has no longer this parameter.
</li>
<li>
September 13, 2013 by Michael Wetter:<br/>
Renamed <code>rho_nominal</code> to <code>rho_start</code>
because this quantity is computed using start values and not
nominal values.
</li>
<li>
April 18, 2013 by Michael Wetter:<br/>
Removed the check of multiple connections to the same element
of a fluid port, as this check required the use of the deprecated
<code>cardinality</code> function.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IDEAS.Fluid.Interfaces</code>.
</li>
<li>
September 17, 2011 by Michael Wetter:<br/>
Removed instance <code>medium</code> as this is already used in <code>dynBal</code>.
Removing the base properties led to 30% faster computing time for a solar thermal system
that contains many fluid volumes.
</li>
<li>
September 13, 2011 by Michael Wetter:<br/>
Changed in declaration of <code>medium</code> the parameter assignment
<code>preferredMediumStates=true</code> to
<code>preferredMediumStates= not (energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)</code>.
Otherwise, for a steady-state model, Dymola 2012 may differentiate the model to obtain <code>T</code>
as a state. See ticket Dynasim #13596.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Revised model to use new declarations from
<a href=\"IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations\">
IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start values for mass and internal energy of dynamic balance
model.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
<ul>
<li>
Changed implementation of balance equation. The new implementation uses a different model if
exactly two fluid ports are connected, and in addition, the model is used as a steady-state
component. For this model configuration, the same balance equations are used as were used
for steady-state component models, i.e., instead of <code>actualStream(...)</code>, the
<code>inStream(...)</code> formulation is used.
This changed required the introduction of a new parameter <code>m_flow_nominal</code> which
is used for smoothing in the steady-state balance equations of the model with two fluid ports.
This implementation also simplifies the implementation of
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort\">
IDEAS.Fluid.MixingVolumes.BaseClasses.PartialMixingVolumeWaterPort</a>,
which now uses the same equations as this model.
</li>
<li>
Another revision was the removal of the parameter <code>use_HeatTransfer</code> as there is
no noticeable overhead in always having the <code>heatPort</code> connector present.
</li>
</ul>
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added nominal value for <code>mC</code> to avoid wrong trajectory
when concentration is around 1E-7.
See also <a href=\"https://trac.modelica.org/Modelica/ticket/393\">
https://trac.modelica.org/Modelica/ticket/393</a>.
</li>
<li>
February 7, 2010 by Michael Wetter:<br/>
Simplified model and its base classes by removing the port data
and the vessel area.
Eliminated the base class <code>PartialLumpedVessel</code>.
</li>
<li>
October 12, 2009 by Michael Wetter:<br/>
Changed base class to
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.BaseClasses.ClosedVolume\">
IDEAS.Fluid.MixingVolumes.BaseClasses.ClosedVolume</a>.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,
                    100}}), graphics={Ellipse(
                  extent={{-100,98},{100,-102}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={170,213,255}), Text(
                  extent={{-58,14},{58,-18}},
                  lineColor={0,0,0},
                  textString="V=%V"),         Text(
                  extent={{-152,100},{148,140}},
                  textString="%name",
                  lineColor={0,0,255})}));
        end PartialMixingVolume;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.MixingVolumes\">IDEAS.Fluid.MixingVolumes</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (Documentation(info="<html>
<p>
This package contains models for completely mixed volumes.
</p>
<p>
For most situations, the model
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolume\">
IDEAS.Fluid.MixingVolumes.MixingVolume</a> should be used.
The other models are only of interest if water should be added to
or subtracted from the fluid volume, such as in a
coil with water vapor condensation.
</p>
</html>"));
    end MixingVolumes;

    package Movers "Package with fan and pump models"
      extends Modelica.Icons.Package;

      model FlowControlled_dp
        "Fan or pump with ideally controlled head dp as input signal"
        extends IDEAS.Fluid.Movers.BaseClasses.PartialFlowMachine(
          final preVar=IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.PressureDifference,
          final computePowerUsingSimilarityLaws=per.havePressureCurve,
          preSou(dp_start=dp_start, control_dp= not prescribeSystemPressure),
          final stageInputs(each final unit="Pa") = heads,
          final constInput(final unit="Pa") = constantHead,
          filter(
            final y_start=dp_start,
            u_nominal=abs(dp_nominal),
            u(final unit="Pa"),
            y(final unit="Pa")),
          eff(
            per(
              final pressure = if per.havePressureCurve then
                per.pressure
              else
                IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters(
                  V_flow = {i/(nOri-1)*2.0*m_flow_nominal/rho_default for i in 0:(nOri-1)},
                  dp =     {i/(nOri-1)*2.0*dp_nominal for i in (nOri-1):-1:0}),
            final use_powerCharacteristic = if per.havePressureCurve then per.use_powerCharacteristic else false)));
        parameter Modelica.SIunits.PressureDifference dp_start(
          min=0,
          displayUnit="Pa")=0 "Initial value of pressure raise"
          annotation(Dialog(tab="Dynamics", group="Filtered speed"));
        // For air, we set dp_nominal = 600 as default, for water we set 10000
        parameter Modelica.SIunits.PressureDifference dp_nominal(
          min=0,
          displayUnit="Pa")=
            if rho_default < 500 then 500 else 10000 "Nominal pressure raise, used to normalized the filter if use_inputFilter=true,
        to set default values of constantHead and heads, and
        and for default pressure curve if not specified in record per"
          annotation(Dialog(group="Nominal condition"));
        parameter Modelica.SIunits.PressureDifference constantHead(
          min=0,
          displayUnit="Pa")=dp_nominal
          "Constant pump head, used when inputType=Constant"
          annotation(Dialog(enable=inputType == IDEAS.Fluid.Types.InputType.Constant));
        // By default, set heads proportional to sqrt(speed/speed_nominal)
        parameter Modelica.SIunits.PressureDifference[:] heads(
          each min=0,
          each displayUnit="Pa")=
          dp_nominal*{(per.speeds[i]/per.speeds[end])^2 for i in 1:size(per.speeds, 1)}
          "Vector of head set points, used when inputType=Stages"
          annotation(Dialog(enable=inputType == IDEAS.Fluid.Types.InputType.Stages));
        parameter Boolean prescribeSystemPressure = false
          "=true, to control mover such that pressure difference is obtained across two remote points in system"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        Modelica.Blocks.Interfaces.RealInput dpMea(
          final quantity="PressureDifference",
          final displayUnit="Pa",
          final unit="Pa")=gain.u if prescribeSystemPressure
          "Measurement of pressure difference between two points where the set point should be obtained"
          annotation (Placement(transformation(
              extent={{20,-20},{-20,20}},
              rotation=90,
              origin={-80,120})));
        Modelica.Blocks.Interfaces.RealInput dp_in(final unit="Pa") if
          inputType == IDEAS.Fluid.Types.InputType.Continuous
          "Prescribed pressure rise"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120})));
        Modelica.Blocks.Interfaces.RealOutput dp_actual(final unit="Pa")
          "Pressure difference between the mover inlet and outlet"
          annotation (Placement(transformation(extent={{100,40},{120,60}}),
              iconTransformation(extent={{100,40},{120,60}})));
    protected
        Modelica.Blocks.Math.Gain gain(final k=-1)
          annotation (Placement(transformation(extent={{10,-10},{-10,10}},
              rotation=90,
              origin={36,30})));
      equation
        assert(inputSwitch.u >= -1E-3,
          "Pressure set point for mover cannot be negative. Obtained dp = " + String(inputSwitch.u));
        if use_inputFilter then
          connect(filter.y, gain.u) annotation (Line(
            points={{34.7,88},{36,88},{36,42}},
            color={0,0,127},
            smooth=Smooth.None));
        else
          connect(inputSwitch.y, gain.u) annotation (Line(
            points={{1,50},{36,50},{36,42}},
            color={0,0,127},
            smooth=Smooth.None));
        end if;
        connect(inputSwitch.u, dp_in) annotation (Line(
            points={{-22,50},{-26,50},{-26,80},{0,80},{0,120}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(preSou.dp_in, gain.y) annotation (Line(
            points={{56,8},{56,14},{36,14},{36,19}},
            color={0,0,127},
            smooth=Smooth.None));
        connect(senRelPre.p_rel, dp_actual) annotation (Line(points={{50.5,-26.35},{
                50.5,-38},{74,-38},{74,50},{110,50}},
                                                 color={0,0,127}));
        annotation (defaultComponentName="fan",
        Documentation(info="<html>
<p>
This model describes a fan or pump with prescribed head.
The input connector provides the difference between
outlet minus inlet pressure.
The efficiency of the device is computed based
on the efficiency and pressure curves that are defined
in record <code>per</code>, which is of type
<a href=\"modelica://IDEAS.Fluid.Movers.SpeedControlled_Nrpm\">
IDEAS.Fluid.Movers.SpeedControlled_Nrpm</a>.
</p>
<h4>Main equations</h4>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a>.
</p>
<h4>Typical use and important parameters</h4>
<p>
If <code>use_inputFilter=true</code>, then the parameter <code>dp_nominal</code> is
used to normalize the filter. This is used to improve the numerics of the transient response.
The actual pressure raise of the mover at steady-state is independent
of the value of <code>dp_nominal</code>. It is recommended to set
<code>dp_nominal</code> to approximately the pressure raise that the mover has during
full speed.
</p>
<h4>Options</h4>
<p>
Parameter <code>prescribeSystemPressure</code>
can be used to control the mover such that the pressure
difference set point is obtained across two points
in the system, instead of across the fan.
This allows an efficient implementation of
static pressure reset controllers.
A measurement of the pressure difference between the
two points in system then needs to be connected
to <code>RealInput dpMea</code>.
This functionality is demonstrated in
<a href=\"modelica://IDEAS.Fluid.Movers.Validation.FlowControlled_dpSystem\">
IDEAS.Fluid.Movers.Validation.FlowControlled_dpSystem</a>.
</p>
</html>",   revisions="<html>
<ul>
<li>
May 5, 2017, by Filip Jorissen:<br/>
Added parameters, documentation and functionality for
<code>prescribeSystemPressure</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/770\">#770</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 14, 2016, by Michael Wetter:<br/>
Changed default values for <code>heads</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/583\">#583</a>.
</li>
<li>
March 2, 2016, by Filip Jorissen:<br/>
Refactored model such that it directly extends <code>PartialFlowMachine</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 5, 2015, by Michael Wetter:<br/>
Removed the parameters <code>use_powerCharacteristics</code> and <code>power</code>
from the performance data record <code>per</code>
because
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_dp\">
IDEAS.Fluid.Movers.FlowControlled_dp</a>
and
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_m_flow\">
IDEAS.Fluid.Movers.FlowControlled_m_flow</a>
fix the flow rate or head, which can give a flow work that is higher
than the power consumption specified in this record.
Hence, users should use the efficiency data for this model.
The record has been moved to
<a href=\"modelica://IDEAS.Fluid.Movers.Data.SpeedControlled_y\">
IDEAS.Fluid.Movers.Data.SpeedControlled_y</a>
as it makes sense to use it for the movers
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_Nrpm\">
IDEAS.Fluid.Movers.FlowControlled_Nrpm</a>
and
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_y\">
IDEAS.Fluid.Movers.FlowControlled_y</a>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/457\">
issue 457</a>.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>July 5, 2010, by Michael Wetter:<br/>
Changed <code>assert(dp_in >= 0, ...)</code> to <code>assert(dp_in >= -0.1, ...)</code>.
The former implementation triggered the assert if <code>dp_in</code> was solved for
in a nonlinear equation since the solution can be slightly negative while still being
within the solver tolerance.
</li>
<li>March 24, 2010, by Michael Wetter:<br/>
Revised implementation to allow zero flow rate.
</li>
<li>October 1, 2009,
    by Michael Wetter:<br/>
       Added model to the IDEAS library.
</ul>
</html>"),Icon(graphics={
              Line(
                points={{2,50},{100,50}},
                color={0,0,0},
                smooth=Smooth.None),
              Text(
                visible = inputType == IDEAS.Fluid.Types.InputType.Continuous,
                extent={{20,142},{104,108}},
                textString="dp_in"),
              Text(extent={{60,66},{110,52}},
                lineColor={0,0,127},
                textString="dp"),
              Rectangle(
                visible=use_inputFilter,
                extent={{-34,40},{32,100}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                visible=use_inputFilter,
                extent={{-34,100},{32,40}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Text(
                visible=use_inputFilter,
                extent={{-22,92},{20,46}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                textString="M",
                textStyle={TextStyle.Bold})}));
      end FlowControlled_dp;

      model SpeedControlled_y
        "Fan or pump with ideally controlled normalized speed y as input signal"
        extends IDEAS.Fluid.Movers.BaseClasses.PartialFlowMachine(
          final preVar=IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed,
          final nominalValuesDefineDefaultPressureCurve=false,
          final computePowerUsingSimilarityLaws=true,
          final m_flow_nominal = max(per.pressure.V_flow)*rho_default,
          final stageInputs(each final unit="1") = per.speeds,
          final constInput(final unit="1") =       per.constantSpeed,
          filter(
            final y_start=y_start,
            u_nominal=1,
            u(final unit="1"),
            y(final unit="1")),
          eff(
            per(final pressure = per.pressure,
                final use_powerCharacteristic = per.use_powerCharacteristic)),
          gaiSpe(u(final unit="1"),
                 final k=1/per.speed_nominal));
        Modelica.Blocks.Interfaces.RealInput y(
          unit="1") if
          inputType == IDEAS.Fluid.Types.InputType.Continuous
          "Constant normalized rotational speed"
          annotation (Placement(transformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=-90,
              origin={0,120})));
    protected
        Modelica.Blocks.Math.Gain gain(final k=-1) "Pressure gain"
          annotation (Placement(transformation(extent={{10,-10},{-10,10}},
              rotation=270,
              origin={10,-20})));
      initial equation
        assert(per.havePressureCurve,
         "SpeedControlled_y requires to set the pressure vs. flow rate curve in record 'per'.");
      equation
        connect(gaiSpe.u, y)
          annotation (Line(points={{-2.8,80},{0,80},{0,120}}, color={0,0,127}));
        connect(gaiSpe.y, inputSwitch.u) annotation (Line(points={{-16.6,80},{-26,80},
                {-26,50},{-22,50}}, color={0,0,127}));
        connect(eff.dp, gain.u)
          annotation (Line(points={{-11,-50},{10,-50},{10,-32}}, color={0,0,127}));
        connect(gain.y, preSou.dp_in)
          annotation (Line(points={{10,-9},{10,14},{56,14},{56,8},{56,8}},
                                                           color={0,0,127}));
        if use_inputFilter then
          connect(filter.y, eff.y_in) annotation (Line(points={{34.7,88},{38,88},{38,26},
                  {-26,26},{-26,-46},{-26,-48},{-26,-46},{-26,-46}},
                                            color={0,0,127}));
        else
          connect(inputSwitch.y, eff.y_in) annotation (Line(points={{1,50},{38,50},{38,
                  26},{-26,26},{-26,-46}},
                                         color={0,0,127}));
        end if;
          annotation (defaultComponentName="fan",
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}),
                  graphics={
                  Text(
                    extent={{6,136},{104,114}},
                lineColor={0,0,127},
                textString="y [0..1]"),
              Rectangle(
                visible=use_inputFilter,
                extent={{-34,40},{32,100}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Ellipse(
                visible=use_inputFilter,
                extent={{-34,100},{32,40}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid),
              Text(
                visible=use_inputFilter,
                extent={{-22,92},{20,46}},
                lineColor={0,0,0},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                textString="M",
                textStyle={TextStyle.Bold})}),
          Documentation(info="<html>
<p>
This model describes a fan or pump with prescribed normalized speed.
The input connector provides the normalized rotational speed (between 0 and 1).
The head is computed based on the performance curve that take as an argument
the actual volume flow rate divided by the maximum flow rate and the relative
speed of the fan.
The efficiency of the device is computed based
on the efficiency curves that take as an argument
the actual volume flow rate divided by the maximum possible volume flow rate, or
based on the motor performance curves.
</p>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>",   revisions="<html>
<ul>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
March 2, 2016, by Filip Jorissen:<br/>
Refactored model such that it directly extends <code>PartialFlowMachine</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
February 17, 2016, by Michael Wetter:<br/>
Updated parameter names for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/396\">#396</a>.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
November 22, 2014, by Michael Wetter:<br/>
Revised implementation that uses the new performance data as a record.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24, 2010, by Michael Wetter:<br/>
Revised implementation to allow zero flow rate.
</li>
<li>
October 1, 2009, by Michael Wetter:<br/>
Model added to the IDEAS library. Changed control signal from rpm to normalized value between 0 and 1</li>
<li>
October 31, 2005 by <a href=\"mailto:francesco.casella@polimi.it\">Francesco Casella</a>:<br/>
Model added to the Fluid library
</li>
</ul>
</html>"));
      end SpeedControlled_y;

      package Data "Package containing data for real pumps/fans"
      extends Modelica.Icons.MaterialPropertiesPackage;

        record Generic "Generic data record for movers"
          extends Modelica.Icons.Record;
          // Pressure requires default values to avoid in Dymola the message
          // Failed to expand the variable pressure.V_flow.
          parameter IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters pressure(
            V_flow = {0, 0},
            dp =     {0, 0}) "Volume flow rate vs. total pressure rise"
            annotation(Evaluate=true,
                       Dialog(group="Pressure curve"));
          parameter Boolean use_powerCharacteristic=false
            "Use power data instead of motor efficiency"
            annotation (Dialog(group="Power computation"));
          parameter
            IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
            hydraulicEfficiency(
              V_flow={0},
              eta={0.7}) "Hydraulic efficiency (used if use_powerCharacteristic=false)"
            annotation (Dialog(group="Power computation",
                               enable=not use_powerCharacteristic));
          parameter
            IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters
            motorEfficiency(
              V_flow={0},
              eta={0.7})
            "Electric motor efficiency (used if use_powerCharacteristic=false)"
            annotation (Dialog(group="Power computation",
                               enable=not use_powerCharacteristic));
          // Power requires default values to avoid in Dymola the message
          // Failed to expand the variable Power.V_flow
          parameter BaseClasses.Characteristics.powerParameters power(
            V_flow={0},
            P={0})
            "Volume flow rate vs. electrical power consumption (used if use_powerCharacteristic=true)"
           annotation (Dialog(group="Power computation",
                              enable=use_powerCharacteristic));
          parameter Boolean motorCooledByFluid=true
            "If true, then motor heat is added to fluid stream"
            annotation(Dialog(group="Motor heat rejection"));
          parameter Real speed_nominal(
            final min=0,
            final unit="1") = 1 "Nominal rotational speed for flow characteristic"
            annotation (Dialog(group="Normalized speeds (used in model, default values assigned from speeds in rpm)"));
          parameter Real constantSpeed(final min=0, final unit="1") = constantSpeed_rpm/speed_rpm_nominal
            "Normalized speed set point, used if inputType = IDEAS.Fluid.Types.InputType.Constant"
            annotation (Dialog(group="Normalized speeds (used in model, default values assigned from speeds in rpm)"));
          parameter Real[:] speeds(each final min = 0, each final unit="1") = speeds_rpm/speed_rpm_nominal
            "Vector of normalized speed set points, used if inputType = IDEAS.Fluid.Types.InputType.Stages"
            annotation (Dialog(group="Normalized speeds (used in model, default values assigned from speeds in rpm)"));
          parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm speed_rpm_nominal=1500
            "Nominal rotational speed for flow characteristic"
            annotation (Dialog(group="Speeds in RPM"));
          parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm constantSpeed_rpm=speed_rpm_nominal
            "Speed set point, used if inputType = IDEAS.Fluid.Types.InputType.Constant"
            annotation (Dialog(group="Speeds in RPM"));
          parameter Modelica.SIunits.Conversions.NonSIunits.AngularVelocity_rpm[:] speeds_rpm = {speed_rpm_nominal}
            "Vector of speed set points, used if inputType = IDEAS.Fluid.Types.InputType.Stages"
            annotation (Dialog(group="Speeds in RPM"));
          // Set a parameter in order for
          // (a) FlowControlled_m_flow and FlowControlled_dp being able to set a reasonable
          //     default pressure curve if it is not specified here, and
          // (b) SpeedControlled_y and SpeedControlled_Nrpm being able to issue an assert
          //     if no pressure curve is specified.
          final parameter Boolean havePressureCurve=
            sum(pressure.V_flow) > Modelica.Constants.eps and
            sum(pressure.dp) > Modelica.Constants.eps
            "= true, if default record values are being used";
          annotation (
          defaultComponentPrefixes = "parameter",
          defaultComponentName = "per",
          Documentation(revisions="<html>
<ul>
<li>
February 19, 2016, by Filip Jorissen:<br/>
Refactored model such that <code>SpeedControlled_Nrpm</code>,
<code>SpeedControlled_y</code> and <code>FlowControlled</code>
are integrated into one record.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
February 17, 2016, by Michael Wetter:<br/>
Changed parameter <code>N_nominal</code> to
<code>speed_rpm_nominal</code> as it is the same quantity as <code>speeds_rmp</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/396\">#396</a>.
</li>
<li>
January 19, 2016, by Filip Jorissen:<br/>
Added parameter <code>speeds_rpm</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/396\">#396</a>.
</li>
<li>
February 13, 2015, by Michael Wetter:<br/>
Updated documentation.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised record for OpenModelica.
</li>
<li>
November 22, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Record containing parameters for pumps or fans.
</p>
<h4>Typical use</h4>
<p>
This record may be used to assign for example fan performance data using
declaration such as
</p>
<pre>
  IDEAS.Fluid.Movers.SpeedControlled_y fan(
    redeclare package Medium = Medium,
      per(pressure(V_flow={0,m_flow_nominal,2*m_flow_nominal}/1.2,
                   dp={2*dp_nominal,dp_nominal,0}))) \"Fan\";
</pre>
<p>
This data record can be used with
<a href=\"modelica://IDEAS.Fluid.Movers.SpeedControlled_Nrpm\">
IDEAS.Fluid.Movers.SpeedControlled_Nrpm</a>,
<a href=\"modelica://IDEAS.Fluid.Movers.SpeedControlled_y\">
IDEAS.Fluid.Movers.SpeedControlled_y</a>,
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_dp\">
IDEAS.Fluid.Movers.FlowControlled_dp</a>,
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_m_flow\">
IDEAS.Fluid.Movers.FlowControlled_m_flow</a>.
</p>
<p>
An example that uses manufacturer data can be found in
<a href=\"modelica://IDEAS.Fluid.Movers.Validation.Pump_Nrpm_stratos\">
IDEAS.Fluid.Movers.Validation.Pump_Nrpm_stratos</a>.
</p>
<h4>Parameters in RPM</h4>
<p>
The parameters <code>speed_rpm_nominal</code>,
<code>constantSpeed_rpm</code> and
<code>speeds_rpm</code> are used to assign the non-dimensional speeds
</p>
<pre>
  parameter Real constantSpeed(final min=0, final unit=\"1\") = constantSpeed_rpm/speed_rpm_nominal;
  parameter Real[:] speeds(each final min = 0, each final unit=\"1\") = speeds_rpm/speed_rpm_nominal;
</pre>
<p>
In addition, <code>speed_rpm_nominal</code> is used in
<a href=\"modelica://IDEAS.Fluid.Movers.SpeedControlled_Nrpm\">
IDEAS.Fluid.Movers.SpeedControlled_Nrpm</a>
to normalize the control input signal.
Otherwise, these speed parameters in RPM are not used in the models.
</p>
</html>"));
        end Generic;

        package Pumps "Package containing data for pumps"
          extends Modelica.Icons.Package;

          package Wilo "Package with performance data for Wilo pumps"
            extends Modelica.Icons.Package;

            record Stratos30slash1to12
              "Pump data for a Wilo Stratos 30/1-12 pump"
              extends Generic(
                speed_rpm_nominal=4800,
                use_powerCharacteristic=true,
                power(V_flow={0,0.00055555,0.00111111,
                      0.00166666,0.00222222, 0.00277777,
                      0.00333333}, P={152.21, 212.39, 258.41,
                      260.18,292.04, 300.88, 300.88}),
                pressure(V_flow={0,0.00055555,0.00111111,
                      0.00166666,0.00222222, 0.00277777,
                      0.00333333},dp={125000, 120000,
                      113230, 89733, 70148, 49496,
                      21721}));
              annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="per",
            Documentation(info="<html>
<p>Data from: 
<a href=\"http://productfinder.wilo.com/be/en/c0000001b0000accb00010023/_00000018000029430002003a/product.html\">
http://productfinder.wilo.com/be/en/c0000001b0000accb00010023/_00000018000029430002003a/product.html
</a>
</p>
<p>See 
<a href=\"modelica://IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6\">
IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6 
</a>
for more information about how the data is derived. 
</p>
</html>",               revisions="<html>
<ul>
<li>March 23, 2018
    by Iago Cupeiro:<br/>
       Initial version
</li>
</ul>
</html>"));
            end Stratos30slash1to12;

            record Stratos40slash1to12CANPN6slash10
              "Pump data for a Wilo Stratos 40/1-12 CAN PN 6/10 pump"
              extends Generic(
                speed_rpm_nominal=4600,
                use_powerCharacteristic=true,
                power(V_flow={0,4,8,12,16,20}/3600,
                    P={322.48, 412.40, 452.71, 493.02, 524.03, 542.64}),
                pressure(V_flow={0,4,8,12,16,20}/3600,
                    dp={13, 12.741, 11.153, 9.2835, 7.1028, 4.7040}*9806.65));
              annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="per",
            Documentation(info="<html>
  <p>Data from:
  <a href=\"http://productfinder.wilo.com/com/en/c0000001b0000accb00010023/_00000018000029380002003a/product.html\">
  http://productfinder.wilo.com/com/en/c0000001b0000accb00010023/_00000018000029380002003a/product.html
  </a>
  </p>
  <p>See
  <a href=\"modelica://IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6\">
  IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6
  </a>
  for more information about how the data is derived.
  </p>
  </html>",             revisions="<html>
<ul>
<li>March 23, 2018
    by Iago Cupeiro:<br/>
       Initial version
</li>
</ul>
</html>"));
            end Stratos40slash1to12CANPN6slash10;

            record Stratos65slash1to12_CAN_PN6slash10
              "Pump data for a Wilo Stratos 65/1-12 CAN PN 6/10 pump"
              extends Generic(
                speed_rpm_nominal=3300,
                use_powerCharacteristic=true,
                power(V_flow={0.0,0.00111111, 0.00222222, 0.00333333, 0.00444444, 0.00555555, 0.00666666, 0.00777777, 0.00888888, 0.01, 0.01111111}, P={615.76, 698.18, 756.36, 785.45, 806.0, 806.0, 806.0, 806.0, 806.0, 806.0, 806.0}),
                pressure(V_flow={0.0,0.00111111, 0.00222222, 0.00333333, 0.00444444, 0.00555555, 0.00666666, 0.00777777, 0.00888888, 0.01, 0.01111111}, dp={107873, 103950, 102190, 96930, 89912, 82456, 73684, 64035, 54386, 44298, 32456}),
                motorCooledByFluid=true);
              annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="per",
            Documentation(info="<html>
  <p>Data from:
  <a href=\"http://productfinder.wilo.com/ie/en/c0000001b0000accb00010023/_000000610001fe090001003a/product.html\">
  http://productfinder.wilo.com/ie/en/c0000001b0000accb00010023/_000000610001fe090001003a/product.html
  </a>
  </p>
  <p>See
  <a href=\"modelica://IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6\">
  IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6
  </a>
  for more information about how the data is derived.
  </p>
  </html>",             revisions="<html>
<ul>
<li>March 23, 2018
    by Iago Cupeiro:<br/>
       Initial version
</li>
</ul>
</html>"));
            end Stratos65slash1to12_CAN_PN6slash10;

            record Stratos80slash1to12_CAN_PN6
              "Pump data for a Wilo Stratos 80/1-12 CAN PN 6 pump"
              extends Generic(
                speed_rpm_nominal=3300,
                use_powerCharacteristic=true,
                power(V_flow={0.0,0.00277777, 0.00555555, 0.00833333, 0.01111111, 0.01388888, 0.01666666}, P={870.97, 1096.8, 1419.4, 1548.4, 1548.4, 1548.4, 1548.4}),
                pressure(V_flow={0.0,0.00277777, 0.00555555, 0.00833333, 0.01111111, 0.01388888, 0.01666666}, dp={125760, 124360, 123940, 112800, 92160, 67680, 36480}));
              annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="per",
            Documentation(info="<html>
  <p>Data from:
  <a href=\"http://productfinder.wilo.com/es/en/c0000001b0000accb00010023/_0000004b00027bcc0001003a/product.html\">
  http://productfinder.wilo.com/es/en/c0000001b0000accb00010023/_0000004b00027bcc0001003a/product.html
  </a>
  </p>
  <p>See
  <a href=\"modelica://IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6\">
  IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6
  </a>
  for more information about how the data is derived.
  </p>
  </html>",             revisions="<html>
<ul>
<li>March 23, 2018
    by Iago Cupeiro:<br/>
       Initial version
</li>
</ul>
</html>"));
            end Stratos80slash1to12_CAN_PN6;

            record VeroLine32slash160dash1comma1slash2
              "Pump data for a Wilo Veroline IP-E 32/160-1,1/2 pump"
              extends Generic(
                speed_rpm_nominal=2840,
                use_powerCharacteristic=true,
                power(V_flow={0,1,2,3,4,5,6,7,8,9,10,11,12}/3600,
                      P={1.1053, 1.1842, 1.2947, 1.4053, 1.4684, 1.5158, 1.5474, 1.5789, 1.5947, 1.6263, 1.6421, 1.6737, 1.6737}*1000),
                pressure(V_flow={0,1,2,3,4,5,6,7,8,9,10,11,12}/3600, dp={26.242,25.879,25.274,24.67,23.823, 22.856, 21.767, 20.679, 19.228, 17.777, 15.963, 14.028, 11.730}*9806.65),
                motorCooledByFluid=true);
              annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="per",
            Documentation(info="<html>
<p>Data not available at this moment
</p>
<p>See 
<a href=\"modelica://IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6\">
IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6 
</a>
for more information about how the data is derived. 
</p>
</html>",               revisions="<html>
<ul>
<li>March 23, 2018
    by Iago Cupeiro:<br/>
       Initial version
</li>
</ul>
</html>"));
            end VeroLine32slash160dash1comma1slash2;

            record VeroLine40slash120dash1comma5slash2
              "Pump data for a Wilo Veroline IP-E 40/120-1,5/2 pump"
              extends Generic(
                speed_rpm_nominal=2890,
                use_powerCharacteristic=true,
                power(V_flow={0,5,10,15,20,25,30,35}/3600,
                      P={0.69495, 0.92202, 1.1766, 1.4312, 1.6651, 1.8028, 1.8853, 1.9404}*1000),
                pressure(V_flow={0,5,10,15,20,25,30,35}/3600,
                         dp={18.396, 18.140, 18.000, 17.879, 16.698, 14.765, 11.973, 8.8054}*9806.65),
                motorCooledByFluid=true);
              annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="per",
            Documentation(info="<html>
<p>Data from:
<a href=\"http://productfinder.wilo.com/com/en/Wilo/c0000002a0003a36300010023/c0000002a0003a36d00010023/c0000002200012eb000020023/_000000650002b9810001003a/product.html\"> 
http://productfinder.wilo.com/com/en/Wilo/c0000002a0003a36300010023/c0000002a0003a36d00010023/c0000002200012eb000020023/_000000650002b9810001003a/product.html
</a>
</p>
<p>See 
<a href=\"modelica://IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6\">
IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6 
</a>for more information about how the data is derived. 
</p>
</html>",               revisions="<html>
<ul>
<li>March 23, 2018
    by Iago Cupeiro:<br/>
       Initial version
</li>
</ul>
</html>"));
            end VeroLine40slash120dash1comma5slash2;

            record VeroLine40slash130dash2comma2slash2
              "Pump data for a Wilo Veroline IP-E 40/130-2,2/2 pump"
              extends Generic(
                speed_rpm_nominal=2890,
                use_powerCharacteristic=true,
                power(V_flow={0.0,0.00277777, 0.00555555, 0.00833333, 0.01111111}, P={861.79,1495.9,2081.3, 2471.5, 2666.7}),
                pressure(V_flow={0.0,0.00277777, 0.00555555, 0.00833333, 0.01111111}, dp={227870.0,227170.0,215220.0,172830.0,100000.0}),
                motorCooledByFluid=true);
              annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="per",
            Documentation(info="<html>
<p>Data from:
<a href=\"http://productfinder.wilo.com/com/en/Wilo/c0000002a0003a36300010023/c0000002a0003a36d00010023/c0000002200012eb000020023/_000000650002b98f0001003a/product.html\"> 
http://productfinder.wilo.com/com/en/Wilo/c0000002a0003a36300010023/c0000002a0003a36d00010023/c0000002200012eb000020023/_000000650002b98f0001003a/product.html
</a>
</p>
<p>See 
<a href=\"modelica://IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6\">
IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6 
</a>
for more information about how the data is derived. 
</p>
</html>",               revisions="<html>
<ul>
<li>March 23, 2018
    by Iago Cupeiro:<br/>
       Initial version
</li>
</ul>
</html>"));
            end VeroLine40slash130dash2comma2slash2;

            record VeroLine50slash150dash4slash2
              "Pump data for a Wilo Veroline IP-E 50/150-4/2 pump"
              extends Generic(
                speed_rpm_nominal=2900,
                use_powerCharacteristic=true,
                power(V_flow={0.0,0.00277777, 0.00555555, 0.00833333, 0.01111111, 0.01388888, 0.01666666}, P={1607.8, 2235.3, 2862.7, 3529.4, 4078.4, 4392.2, 4666.7}),
                pressure(V_flow={0.0,0.00277777, 0.00555555, 0.00833333, 0.01111111, 0.01388888, 0.01666666}, dp={255400, 253000, 250600, 248200, 232010, 199640, 156470}),
                motorCooledByFluid=true);
              annotation (
            defaultComponentPrefixes="parameter",
            defaultComponentName="per",
            Documentation(info="<html>
<p>Data from:<a href=\"http://productfinder.wilo.com/com/en/c0000002200012eb000020023/_0000004f0003f94e0001003a/product.html\"> http://productfinder.wilo.com/com/en/c0000002200012eb000020023/_0000004f0003f94e0001003a/product.html</a></p>
<p>See <a href=\"modelica://IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6\">IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos25slash1to6</a>for more information about how the data is derived.</p>
</html>",               revisions="<html>
<ul>
<li>
May 28, 2017, by Iago Cupeiro:
<br/>
Initial version
</li>
</ul>
</html>"));
            end VeroLine50slash150dash4slash2;
          annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains performance data for Wilo pumps.
</p>
</html>"));
          end Wilo;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains data for pumps.
</p>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>"));
        end Pumps;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains data for fans and pumps.
</p>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>
</html>"));
      end Data;

      package BaseClasses "Package with base classes for IDEAS.Fluid.Movers"
        extends Modelica.Icons.BasesPackage;

        model FlowMachineInterface
          "Partial model with performance curves for fans or pumps"
          extends Modelica.Blocks.Icons.Block;
          import cha = IDEAS.Fluid.Movers.BaseClasses.Characteristics;
          parameter IDEAS.Fluid.Movers.Data.Generic per
            "Record with performance data"
            annotation (choicesAllMatching=true,
              Placement(transformation(extent={{60,-80},{80,-60}})));
          parameter IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable preVar=
            IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed "Type of prescribed variable";
          parameter Boolean computePowerUsingSimilarityLaws
            "= true, compute power exactly, using similarity laws. Otherwise approximate.";
          final parameter Modelica.SIunits.VolumeFlowRate V_flow_nominal=
            per.pressure.V_flow[nOri] "Nominal volume flow rate, used for homotopy";
          parameter Modelica.SIunits.Density rho_default
            "Fluid density at medium default state";
          parameter Boolean haveVMax
            "Flag, true if user specified data that contain V_flow_max";
          parameter Modelica.SIunits.VolumeFlowRate V_flow_max
            "Maximum volume flow rate, used for smoothing";
          parameter Integer nOri(min=1) "Number of data points for pressure curve"
            annotation(Evaluate=true);
          parameter Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
         // Normalized speed
          Modelica.Blocks.Interfaces.RealInput y_in(final unit="1") if preSpe
            "Prescribed mover speed"
            annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={-40,120})));
          Modelica.Blocks.Interfaces.RealOutput y_out(
            final unit="1") "Mover speed (prescribed or computed)"
            annotation (Placement(transformation(extent={{100,90},{120,110}})));
          Modelica.Blocks.Interfaces.RealInput m_flow(
            final quantity="MassFlowRate",
            final unit="kg/s") "Mass flow rate"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealInput rho(
            final quantity="Density",
            final unit="kg/m3",
            min=0.0) "Medium density"
            annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
          Modelica.Blocks.Interfaces.RealOutput V_flow(
            quantity="VolumeFlowRate",
            final unit="m3/s") "Volume flow rate"
            annotation (Placement(transformation(extent={{100,38},{120,58}}),
                iconTransformation(extent={{100,38},{120,58}})));
          Modelica.Blocks.Interfaces.RealInput dp_in(
            quantity="PressureDifference",
            final unit="Pa") if prePre "Prescribed pressure increase"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=270,
                origin={40,120})));
          Modelica.Blocks.Interfaces.RealOutput dp(
            quantity="Pressure",
            final unit="Pa") if not prePre "Pressure increase (computed or prescribed)"
            annotation (Placement(transformation(extent={{100,70},{120,90}})));
          Modelica.Blocks.Interfaces.RealOutput WFlo(
            quantity="Power",
            final unit="W") "Flow work"
            annotation (Placement(transformation(extent={{100,10},{120,30}})));
          Modelica.Blocks.Interfaces.RealOutput PEle(
            quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{100,-20},{120,0}}),
                iconTransformation(extent={{100,-20},{120,0}})));
          Modelica.Blocks.Interfaces.RealOutput eta(
            final quantity="Efficiency",
            final unit="1") "Overall efficiency"
            annotation (Placement(transformation(extent={{100,-50},{120,-30}}),
                iconTransformation(extent={{100,-50},{120,-30}})));
          Modelica.Blocks.Interfaces.RealOutput etaHyd(
            final quantity="Efficiency",
            final unit="1") "Hydraulic efficiency"
            annotation (Placement(transformation(extent={{100,-80},{120,-60}}),
                iconTransformation(extent={{100,-80},{120,-60}})));
          Modelica.Blocks.Interfaces.RealOutput etaMot(
            final quantity="Efficiency",
            final unit="1") "Motor efficiency"
            annotation (Placement(transformation(extent={{100,-110},{120,-90}}),
                iconTransformation(extent={{100,-110},{120,-90}})));
          // "Shaft rotational speed";
          Modelica.Blocks.Interfaces.RealOutput r_N(unit="1")
            "Ratio N_actual/N_nominal";
          Real r_V(start=1, unit="1") "Ratio V_flow/V_flow_max";
      protected
          final parameter Boolean preSpe=
            preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed
            "True if speed is a prescribed variable of this block";
          final parameter Boolean prePre=
            preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.PressureDifference or
            preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate
            "True if pressure head is a prescribed variable of this block";
          // Derivatives for cubic spline
          final parameter Real motDer[size(per.motorEfficiency.V_flow, 1)](each fixed=false)
            "Coefficients for polynomial of motor efficiency vs. volume flow rate";
          final parameter Real hydDer[size(per.hydraulicEfficiency.V_flow,1)](each fixed=false)
            "Coefficients for polynomial of hydraulic efficiency vs. volume flow rate";
          parameter Modelica.SIunits.PressureDifference dpMax(displayUnit="Pa")=
            if haveDPMax then
              per.pressure.dp[1]
            else
              per.pressure.dp[1] - ((per.pressure.dp[2] - per.pressure.dp[1])/(
                per.pressure.V_flow[2] - per.pressure.V_flow[1]))*per.pressure.V_flow[1]
            "Maximum head";
          parameter Real delta = 0.05
            "Small value used to for regularization and to approximate an internal flow resistance of the fan";
          parameter Real kRes(min=0, unit="kg/(s.m4)") =  dpMax/V_flow_max*delta^2/10
            "Coefficient for internal pressure drop of fan or pump";
          parameter Integer curve=
             if (haveVMax and haveDPMax) or (nOri == 2) then 1
             elseif haveVMax or haveDPMax then 2
             else 3
            "Flag, used to pick the right representatio of the fan or pump pressure curve";
          final parameter
            IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur1(
            final n = nOri,
            final V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                     {per.pressure.V_flow[i] for i in 1:nOri}
                     else
                     zeros(nOri),
            final dp = if (haveVMax and haveDPMax) or (nOri == 2) then
                     {(per.pressure.dp[i] + per.pressure.V_flow[i] * kRes) for i in 1:nOri}
                     else
                     zeros(nOri))
            "Volume flow rate vs. total pressure rise with correction for pump resistance added";
          parameter
            IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur2(
            final n = nOri + 1,
            V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                        zeros(nOri + 1)
                     elseif haveVMax then
                      cat(1, {0}, {per.pressure.V_flow[i] for i in 1:nOri})
                     elseif haveDPMax then
                      cat(1, { per.pressure.V_flow[i] for i in 1:nOri}, {V_flow_max})
                     else
                      zeros(nOri + 1),
            dp = if (haveVMax and haveDPMax) or (nOri == 2) then
                        zeros(nOri + 1)
                     elseif haveVMax then
                      cat(1, {dpMax}, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri})
                     elseif haveDPMax then
                      cat(1, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri}, {0})
                     else
                       zeros(nOri+1))
            "Volume flow rate vs. total pressure rise with correction for pump resistance added";
          parameter
            IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal pCur3(
            final n = nOri + 2,
            V_flow = if (haveVMax and haveDPMax) or (nOri == 2) then
                       zeros(nOri + 2)
                     elseif haveVMax or haveDPMax then
                       zeros(nOri + 2)
                     else
                       cat(1, {0}, {per.pressure.V_flow[i] for i in 1:nOri}, {V_flow_max}),
            dp =     if (haveVMax and haveDPMax) or (nOri == 2) then
                       zeros(nOri + 2)
                     elseif haveVMax or haveDPMax then
                       zeros(nOri + 2)
                     else
                       cat(1, {dpMax}, {per.pressure.dp[i] + per.pressure.V_flow[i] * kRes for i in 1:nOri}, {0}))
            "Volume flow rate vs. total pressure rise with correction for pump resistance added";
          parameter Real preDer1[nOri](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real preDer2[nOri+1](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real preDer3[nOri+2](each fixed=false)
            "Derivatives of flow rate vs. pressure at the support points";
          parameter Real powDer[size(per.power.V_flow,1)]=
           if per.use_powerCharacteristic then
             IDEAS.Utilities.Math.Functions.splineDerivatives(
                           x=per.power.V_flow,
                           y=per.power.P,
                           ensureMonotonicity=IDEAS.Utilities.Math.Functions.isMonotonic(x=per.power.P,
                                                                                             strict=false))
           else
             zeros(size(per.power.V_flow,1))
            "Coefficients for polynomial of power vs. flow rate";
          parameter Boolean haveMinimumDecrease=
            Modelica.Math.BooleanVectors.allTrue({(per.pressure.dp[i + 1] -
            per.pressure.dp[i])/(per.pressure.V_flow[i + 1] - per.pressure.V_flow[
            i]) < -kRes for i in 1:nOri - 1}) "Flag used for reporting";
          parameter Boolean haveDPMax = (abs(per.pressure.V_flow[1])  < Modelica.Constants.eps)
            "Flag, true if user specified data that contain dpMax";
          Modelica.Blocks.Interfaces.RealOutput dp_internal
            "If dp is prescribed, use dp_in and solve for r_N, otherwise compute dp using r_N";
        function getPerformanceDataAsString
          input IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters pressure
              "Performance data";
          input Real derivative[:](unit="kg/(s.m4)") "Derivative";
          input Integer minimumLength =  6 "Minimum width of result";
          input Integer significantDigits = 6 "Number of significant digits";
          output String str "String representation";
        algorithm
          str :="";
          for i in 1:size(derivative, 1) loop
            str :=str + "  V_flow[" + String(i) + "]=" + String(
                pressure.V_flow[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\t" + "dp[" + String(i) + "]=" +
                String(
                pressure.dp[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\tResulting derivative dp/dV_flow = "
                 + String(
                derivative[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\n";
          end for;
        end getPerformanceDataAsString;

        function getArrayAsString
          input Real array[:] "Array to be printed";
          input String varName "Variable name";
          input Integer minimumLength =  6 "Minimum width of result";
          input Integer significantDigits = 6 "Number of significant digits";
          output String str "String representation";
        algorithm
          str :="";
          for i in 1:size(array, 1) loop
            str :=str + "  " + varName + "[" + String(i) + "]=" + String(
                array[i],
                minimumLength=minimumLength,
                significantDigits=significantDigits) + "\n";
          end for;
        end getArrayAsString;
        initial equation
          // Check validity of data
          assert(nOri > 1, "Must have at least two data points for pressure.V_flow.");
          assert(IDEAS.Utilities.Math.Functions.isMonotonic(x=per.pressure.V_flow, strict=true) and
          per.pressure.V_flow[1] > -Modelica.Constants.eps,
          "The fan pressure rise must be a strictly decreasing sequence with respect to the volume flow rate,
  with the first element for the fan pressure raise being non-zero.
The following performance data have been entered:
"         + getArrayAsString(per.pressure.V_flow, "pressure.V_flow"));
          if not haveVMax then
            assert((per.pressure.V_flow[nOri]-per.pressure.V_flow[nOri-1])
                 /((per.pressure.dp[nOri]-per.pressure.dp[nOri-1]))<0,
            "The last two pressure points for the fan or pump performance curve must be decreasing.
    You need to set more reasonable parameters.
Received
"         + getArrayAsString(per.pressure.dp, "dp"));
          end if;
          // Write warning if the volumetric flow rate versus pressure curve does not satisfy
          // the minimum decrease condition
          if (not haveMinimumDecrease) then
            Modelica.Utilities.Streams.print("
Warning:
========
It is recommended that the volume flow rate versus pressure relation
of the fan or pump satisfies the minimum decrease condition

        (per.pressure.dp[i+1]-per.pressure.dp[i])
d[i] = ------------------------------------------------- < "         + String(-kRes) + "
       (per.pressure.V_flow[i+1]-per.pressure.V_flow[i])

 is
"         + getArrayAsString({(per.pressure.dp[i+1]-per.pressure.dp[i])
                /(per.pressure.V_flow[i+1]-per.pressure.V_flow[i]) for i in 1:nOri-1}, "d") + "
Otherwise, a solution to the equations may not exist if the fan or pump speed is reduced.
In this situation, the solver will fail due to non-convergence and
the simulation stops.");
          end if;
          // Correction for flow resistance of pump or fan
          if (haveVMax and haveDPMax) or (nOri == 2) then  // ----- Curve 1
            // V_flow_max and dpMax are provided by the user, or we only have two data points
            preDer1= IDEAS.Utilities.Math.Functions.splineDerivatives(x=pCur1.V_flow,
              y=pCur1.dp);
            preDer2= zeros(nOri + 1);
            preDer3= zeros(nOri + 2);
          elseif haveVMax or haveDPMax then  // ----- Curve 2
            // V_flow_max or dpMax is provided by the user, but not both
            preDer1= zeros(nOri);
            preDer2= IDEAS.Utilities.Math.Functions.splineDerivatives(x=pCur2.V_flow,
              y=pCur2.dp);
            preDer3= zeros(nOri + 2);
          else  // ----- Curve 3
            // Neither V_flow_max nor dpMax are provided by the user
            preDer1= zeros(nOri);
            preDer2= zeros(nOri + 1);
            preDer3= IDEAS.Utilities.Math.Functions.splineDerivatives(x=pCur3.V_flow,
              y=pCur3.dp);
          end if;
         // Compute derivatives for cubic spline
         motDer = if per.use_powerCharacteristic then zeros(size(per.motorEfficiency.V_flow,
            1)) elseif (size(per.motorEfficiency.V_flow, 1) == 1) then {0} else
            IDEAS.Utilities.Math.Functions.splineDerivatives(
            x=per.motorEfficiency.V_flow,
            y=per.motorEfficiency.eta,
            ensureMonotonicity=IDEAS.Utilities.Math.Functions.isMonotonic(x=per.motorEfficiency.eta,
              strict=false));
          hydDer = if per.use_powerCharacteristic then zeros(size(per.hydraulicEfficiency.V_flow,
            1)) elseif (size(per.hydraulicEfficiency.V_flow, 1) == 1) then {0}
             else IDEAS.Utilities.Math.Functions.splineDerivatives(x=per.hydraulicEfficiency.V_flow,
            y=per.hydraulicEfficiency.eta);
        equation
          //assign values of dp and r_N, depending on which variable exists and is prescribed
          connect(dp_internal,dp);
          connect(dp_internal,dp_in);
          connect(r_N, y_in);
          y_out=r_N;
          V_flow = m_flow/rho;
          // Hydraulic equations
          r_V = V_flow/V_flow_max;
          // If the speed is not prescribed and we do not require exact power computations, we set r_N = 1.
          // Similarity laws are then not used, meaning the power computation is less accurate.
          // This however has the advantage that no non-linear algebraic loop is formed and
          // it allows an implementation when the pressure curve is unknown.
          if (computePowerUsingSimilarityLaws == false) and preVar <> IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed then
            r_N=1;
          else
          // For the homotopy method, we approximate dp by an equation
          // that is linear in V_flow, and that goes linearly to 0 as r_N goes to 0.
          // The three branches below are identical, except that we pass either
          // pCur1, pCur2 or pCur3, and preDer1, preDer2 or preDer3
          if (curve == 1) then
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1),
                                                   simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1)
                                       +(V_flow-V_flow_nominal) * (cha.pressure(
                                                             V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer1,
                                                             per=pCur1))
                                                            /(2*delta*V_flow_nominal)));
            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                       r_N=r_N,
                                                       dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                       d=preDer1,
                                                       per=pCur1);
            end if;     // end of computation for this branch
           elseif (curve == 2) then
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2),
                                                    simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2)
                                       +(V_flow-V_flow_nominal) * (cha.pressure(
                                                             V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer2,
                                                             per=pCur2))
                                                            /(2*delta*V_flow_nominal)));
            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                              r_N=r_N,
                                                              dpMax=dpMax,
                                                              V_flow_max=V_flow_max,
                                                              d=preDer2,
                                                              per=pCur2);
            end if;     // end of computation for this branch
          else
            if homotopyInitialization then
               V_flow*kRes + dp_internal = homotopy(actual=cha.pressure(
                                                             V_flow=V_flow,
                                                             r_N=r_N,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3),
                                  simplified=r_N * (cha.pressure(
                                                             V_flow=V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3)
                                       +(V_flow-V_flow_nominal)*
                                               (cha.pressure(V_flow=(1+delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3)
                                               -cha.pressure(V_flow=(1-delta)*V_flow_nominal,
                                                             r_N=1,
                                                             dpMax=dpMax,
                                                             V_flow_max=V_flow_max,
                                                             d=preDer3,
                                                             per=pCur3))
                                                            /(2*delta*V_flow_nominal)));
            else
               V_flow*kRes + dp_internal= cha.pressure(V_flow=V_flow,
                                                              r_N=r_N,
                                                              dpMax=dpMax,
                                                              V_flow_max=V_flow_max,
                                                              d=preDer3,
                                                              per=pCur3);
            end if;
            // end of computation for this branch
          end if;
            // end of if/else choosing between exact/simplified power computation
          end if;
          // Flow work
          WFlo = dp_internal*V_flow;
          // Power consumption
          if per.use_powerCharacteristic then
            // For the homotopy, we want P/V_flow to be bounded as V_flow -> 0 to avoid a very high medium
            // temperature near zero flow.
            if homotopyInitialization then
              PEle = homotopy(actual=cha.power(per=per.power, V_flow=V_flow, r_N=r_N, d=powDer, delta=delta),
                              simplified=V_flow/V_flow_nominal*
                                    cha.power(per=per.power, V_flow=V_flow_nominal, r_N=1, d=powDer, delta=delta));
            else
              PEle = (rho/rho_default)*cha.power(per=per.power, V_flow=V_flow, r_N=r_N, d=powDer, delta=delta);
            end if;
            // To compute the efficiency, we set a lower bound on the electricity consumption.
            // This is needed because WFlo can be close to zero when P is zero, thereby
            // causing a division by zero.
            // Earlier versions of the model computed WFlo = eta * P, but this caused
            // a division by zero.
            eta = WFlo / IDEAS.Utilities.Math.Functions.smoothMax(x1=PEle, x2=1E-5, deltaX=1E-6);
            // In this configuration, we only know the total power consumption.
            // Because nothing is known about etaMot versus etaHyd, we set etaHyd=1. This will
            // cause etaMot=eta, because eta=etaHyd*etaMot.
            // Earlier versions used etaMot=sqrt(eta), but as eta->0, this function has
            // and infinite derivative.
            etaHyd = 1;
            etaMot = eta;
          else
            if homotopyInitialization then
              etaHyd = homotopy(actual=cha.efficiency(per=per.hydraulicEfficiency,     V_flow=V_flow, d=hydDer, r_N=r_N, delta=delta),
                                simplified=cha.efficiency(per=per.hydraulicEfficiency, V_flow=V_flow_max,   d=hydDer, r_N=r_N, delta=delta));
              etaMot = homotopy(actual=cha.efficiency(per=per.motorEfficiency,     V_flow=V_flow, d=motDer, r_N=r_N, delta=delta),
                                simplified=cha.efficiency(per=per.motorEfficiency, V_flow=V_flow_max,   d=motDer, r_N=r_N, delta=delta));
            else
              etaHyd = cha.efficiency(per=per.hydraulicEfficiency, V_flow=V_flow, d=hydDer, r_N=r_N, delta=delta);
              etaMot = cha.efficiency(per=per.motorEfficiency,     V_flow=V_flow, d=motDer, r_N=r_N, delta=delta);
            end if;
            // To compute the electrical power, we set a lower bound for eta to avoid
            // a division by zero.
            PEle = WFlo / IDEAS.Utilities.Math.Functions.smoothMax(x1=eta, x2=1E-5, deltaX=1E-6);
            eta = etaHyd * etaMot;
          end if;
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
                            graphics={
                Text(extent={{56,66},{106,52}},
                  lineColor={0,0,127},
                  textString="dp"),
                Text(extent={{56,8},{106,-6}},
                  lineColor={0,0,127},
                  textString="PEle"),
                Text(extent={{52,-22},{102,-36}},
                  lineColor={0,0,127},
                  textString="eta"),
                Text(extent={{50,-52},{100,-66}},
                  lineColor={0,0,127},
                  textString="etaHyd"),
                Text(extent={{50,-72},{100,-86}},
                  lineColor={0,0,127},
                  textString="etaMot"),
                Ellipse(
                  extent={{-78,34},{44,-88}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-62,18},{28,-72}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Ellipse(
                  extent={{-26,-18},{-8,-36}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-26,-22},{-32,-8},{-30,10},{-8,20},{-6,14},{-24,6},{-24,-8},{
                      -18,-20},{-26,-22}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{-8,-32},{-2,-46},{-4,-64},{-26,-74},{-28,-68},{-10,-60},{-10,
                      -46},{-16,-34},{-8,-32}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier),
                Polygon(
                  points={{7,21},{13,7},{11,-11},{-11,-21},{-13,-15},{5,-7},{5,7},{-1,19},
                      {7,21}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier,
                  origin={9,-23},
                  rotation=90),
                Polygon(
                  points={{-7,-21},{-13,-7},{-11,11},{11,21},{13,15},{-5,7},{-5,-7},{1,-19},
                      {-7,-21}},
                  lineColor={0,0,0},
                  fillColor={100,100,100},
                  fillPattern=FillPattern.Solid,
                  smooth=Smooth.Bezier,
                  origin={-43,-31},
                  rotation=90),
                Text(extent={{56,36},{106,22}},
                  lineColor={0,0,127},
                  textString="WFlo"),
                Text(extent={{56,94},{106,80}},
                  lineColor={0,0,127},
                  textString="V_flow"),
                Line(
                  points={{-74,92},{-74,40}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-74,40},{46,40}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Line(
                  points={{-70,86},{-40,84},{8,68},{36,42}},
                  color={0,0,0},
                  smooth=Smooth.Bezier)}),
            Documentation(info="<html>
<p>
This is an interface that implements the functions to compute the head, power draw
and efficiency of fans and pumps.
</p>
<p>
The nominal hydraulic characteristic (volume flow rate versus total pressure)
is given by a set of data points
using the data record <code>per</code>, which is an instance of
<a href=\"modelica://IDEAS.Fluid.Movers.Data.Generic\">
IDEAS.Fluid.Movers.Data.Generic</a>.
A cubic hermite spline with linear extrapolation is used to compute
the performance at other operating points.
</p>
<p>
The fan or pump energy balance can be specified in two alternative ways:
</p>
<ul>
<li>
If <code>per.use_powerCharacteristic = false</code>, then the data points for
normalized volume flow rate versus efficiency is used to determine the efficiency,
and then the power consumption. The default is a constant efficiency of <i>0.7</i>.
</li>
<li>
If <code>per.use_powerCharacteristic = true</code>, then the data points for
normalized volume flow rate versus power consumption
is used to determine the power consumption, and then the efficiency
is computed based on the actual power consumption and the flow work.
</li>
</ul>
<p>
For exceptions to this general rule, check the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a> for more information.
</p>

<h4>Implementation</h4>
<p>
For numerical reasons, the user-provided data points for volume flow rate
versus pressure rise are modified to add a fan internal flow resistance.
Because this flow resistance is subtracted during the simulation when
computing the fan pressure rise, the model reproduces the exact points
that were provided by the user.
</p>
<p>
Also for numerical reasons, the pressure rise at zero flow rate and
the flow rate at zero pressure rise is added to the user-provided data,
unless the user already provides these data points.
Since Modelica 3.2 does not allow dynamic memory allocation, this
implementation required the use of three different arrays for the
situation where no additional point is added, where one additional
point is added and where two additional points are added.
The parameter <code>curve</code> causes the correct data record
to be used during the simulation.
</p>
</html>",
        revisions="<html>
<ul>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
February 19, 2016, by Michael Wetter and Filip Jorissen:<br/>
Refactored model to make implementation clearer.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference and reformatted code.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
September 2, 2015, by Michael Wetter:<br/>
Corrected computation of
<code>etaMot = cha.efficiency(per=per.motorEfficiency, V_flow=V_flow, d=motDer, r_N=r_N, delta=1E-4)</code>
which previously used <code>V_flow_max</code> instead of <code>V_flow</code>.
</li>
<li>
January 6, 2015, by Michael Wetter:<br/>
Revised model for OpenModelica.
</li>
<li>
November 22, 2014, by Michael Wetter:<br/>
Removed in <code>N_actual</code> and <code>N_filtered</code>
the <code>max</code> attribute to
avoid a translation warning.
</li>
<li>
April 21, 2014, by Filip Jorissen and Michael Wetter:<br/>
Changed model to use
<a href=\"modelica://IDEAS.Fluid.Movers.Data.Generic\">
IDEAS.Fluid.Movers.Data.Generic</a>.
April 19, 2014, by Filip Jorissen:<br/>
Passed extra parameters to power() and efficiency()
to be able to properly evaluate the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 27, 2013, by Michael Wetter:<br/>
Reformulated <code>per=if (curve == 1) then pCur1 elseif (curve == 2) then pCur2 else pCur3</code>
by moving the computation into the idividual logical branches because OpenModelica generates an
error when assign the statement to <code>data</code>
as <code>pCur1</code>, <code>pCur2</code> and <code>pCur3</code> have different dimensions.
</li>
<li>
September 17, 2013, by Michael Wetter:<br/>
Added missing <code>each</code> keyword in declaration of parameters
that are an array.
</li>
<li>
March 20, 2013, by Michael Wetter:<br/>
Removed assignment in declaration of <code>pCur?.V_flow</code> as
these parameters have the attribute <code>fixed=false</code> set.
</li>
<li>
October 11, 2012, by Michael Wetter:<br/>
Added implementation of <code>WFlo = eta * P</code> with
guard against division by zero.
Changed implementation of <code>etaMot=sqrt(eta)</code> to
<code>etaHyd = 1</code> to avoid infinite derivative as <code>eta</code>
converges to zero.
</li>
<li>
February 20, 2012, by Michael Wetter:<br/>
Assigned value to nominal attribute of <code>V_flow</code>.
</li>
<li>
February 14, 2012, by Michael Wetter:<br/>
Added filter for start-up and shut-down transient.
</li>
<li>
October 4 2011, by Michael Wetter:<br/>
Revised the implementation of the pressure drop computation as a function
of speed and volume flow rate.
The new implementation avoids a singularity near zero volume flow rate and zero speed.
</li>
<li>
March 28 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 23 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end FlowMachineInterface;

        model IdealSource
          "Base class for pressure and mass flow source with optional power input"
          extends IDEAS.Fluid.Interfaces.PartialTwoPortTransport(show_T=false);
          // Quantity to control
          parameter Boolean control_m_flow
            "if true, then the mass flow rate is equal to the value of m_flow_in"
            annotation(Evaluate = true);
          parameter Boolean control_dp = not control_m_flow
            "if true, then the head is equal to the value of dp_in"
            annotation(Evaluate = true);
          Modelica.Blocks.Interfaces.RealInput m_flow_in(unit="kg/s") if control_m_flow
            "Prescribed mass flow rate"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-60,80})));
          Modelica.Blocks.Interfaces.RealInput dp_in(unit="Pa") if control_dp
            "Prescribed pressure difference port_a.p-port_b.p"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={50,82}), iconTransformation(
                extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={60,80})));
      protected
          Modelica.Blocks.Interfaces.RealInput m_flow_internal(unit="kg/s")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput dp_internal(unit="Pa")
            "Needed to connect to conditional connector";
        equation
          // Ideal control
          if control_m_flow then
            m_flow = m_flow_internal;
          else
            m_flow_internal = 0;
          end if;
          if control_dp then
            dp = dp_internal;
          else
            dp_internal = 0;
          end if;
          connect(dp_internal, dp_in);
          connect(m_flow_internal, m_flow_in);
          // Energy balance (no storage)
          port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
          port_b.h_outflow = inStream(port_a.h_outflow);
          annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                    -100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,60},{100,-60}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-100,50},{100,-48}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Text(
                  visible=not control_m_flow,
                  extent={{24,44},{80,24}},
                  lineColor={255,255,255},
                  textString="dp"),
                Text(
                  visible=control_m_flow,
                  extent={{-80,44},{-24,24}},
                  lineColor={255,255,255},
                  textString="m")}),
            Documentation(info="<html>
<p>
Model of a fictitious pipe that is used as a base class
for a pressure source or to prescribe a mass flow rate.
</p>
<p>
Note that for fans and pumps with dynamic balance,
both the heat and the flow work are added to the volume of
air or water. This simplifies the equations compared to
adding heat to the volume, and flow work to this model.
</p>
<p>
Typically either <code>control_m_flow</code> or
<code>control_dp</code> should be <code>true</code> to avoid a
singular system.
If <code>control_m_flow = true</code>, then the mass flow rate
is set to the value of the input connector <code>m_flow_in</code>.
Otherwise, this model does not specify the mass flow rate.
Similarly, if <code>control_dp = true</code>, the head is equal to the
value of the input connector <code>dp_in</code>.
Otherwise, this model does not specify the head.
</p>
</html>",
        revisions="<html>
<ul>
<li>
May 4, 2017, by Filip Jorissen:<br/>
Implemented option to set <code>control_dp</code>
independently from <code>control_m_flow</code>.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/770\">#770</a>.
</li>
<li>
March 2, 2017, by Filip Jorissen:<br/>
Implemented simplification when <code>allowFlowReversal=false</code>.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/673\">#673</a>.
</li>
<li>
March 20, 2016, by Michael Wetter:<br/>
Corrected documentation for <code>dp_in</code>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Added units to the signal connectors.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
Removed the option to add power to the medium, as this is dealt with in the volume
that is used in the mover model.
</li>
<li>
July 27, 2010 by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>
April 13, 2010 by Michael Wetter:<br/>
Made heat connector optional.
</li>
<li>
March 23, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end IdealSource;

        partial model PartialFlowMachine
          "Partial model to interface fan or pump models with the medium"
          extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations(
            final mSenFac=1);
          extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
            m_flow_nominal(final min=Modelica.Constants.small),
            show_T=false,
            port_a(
              h_outflow(start=h_outflow_start)),
            port_b(
              h_outflow(start=h_outflow_start),
              p(start=p_start),
              final m_flow(max = if allowFlowReversal then +Modelica.Constants.inf else 0)));

          replaceable parameter IDEAS.Fluid.Movers.Data.Generic per
            constrainedby IDEAS.Fluid.Movers.Data.Generic
            "Record with performance data"
            annotation (choicesAllMatching=true,
              Placement(transformation(extent={{52,60},{72,80}})));

          parameter IDEAS.Fluid.Types.InputType inputType = IDEAS.Fluid.Types.InputType.Continuous
            "Control input type"
            annotation(Dialog(
              group="Control"));
          parameter Real constInput = 0 "Constant input set point"
            annotation(Dialog(
              group="Control",
              enable=inputType == IDEAS.Fluid.Types.InputType.Constant));
          parameter Real stageInputs[:]
            "Vector of input set points corresponding to stages"
            annotation(Dialog(
              group="Control",
              enable=inputType == IDEAS.Fluid.Types.InputType.Stages));

          parameter Boolean computePowerUsingSimilarityLaws
            "= true, compute power exactly, using similarity laws. Otherwise approximate.";

          parameter Boolean addPowerToMedium=true
            "Set to false to avoid any power (=heat and flow work) being added to medium (may give simpler equations)";

          parameter Boolean nominalValuesDefineDefaultPressureCurve = false
            "Set to true to avoid warning if m_flow_nominal and dp_nominal are used to construct the default pressure curve";

          parameter Modelica.SIunits.Time tau=1
            "Time constant of fluid volume for nominal flow, used if energy or mass balance is dynamic"
            annotation (Dialog(tab="Dynamics",
                                group="Nominal condition",
                                enable=energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState or
                                       massDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState));

          // Classes used to implement the filtered speed
          parameter Boolean use_inputFilter=true
            "= true, if speed is filtered with a 2nd order CriticalDamping filter"
            annotation(Dialog(tab="Dynamics", group="Filtered speed"));
          parameter Modelica.SIunits.Time riseTime=30
            "Rise time of the filter (time to reach 99.6 % of the speed)"
            annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=use_inputFilter));
          parameter Modelica.Blocks.Types.Init init=Modelica.Blocks.Types.Init.InitialOutput
            "Type of initialization (no init/steady state/initial state/initial output)"
            annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=use_inputFilter));
          parameter Real y_start(min=0, max=1, unit="1")=0 "Initial value of speed"
            annotation(Dialog(tab="Dynamics", group="Filtered speed",enable=use_inputFilter));

          // Connectors and ports
            Modelica.Blocks.Interfaces.IntegerInput stage if
               inputType == IDEAS.Fluid.Types.InputType.Stages
            "Stage input signal for the pressure head"
            annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=270,
                origin={0,120})));

          Modelica.Blocks.Interfaces.RealOutput y_actual(
            final unit="1")
            "Actual normalised pump speed that is used for computations"
            annotation (Placement(transformation(extent={{100,60},{120,80}}),
                iconTransformation(extent={{100,60},{120,80}})));

          Modelica.Blocks.Interfaces.RealOutput P(
            quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{100,80},{120,100}}),
                iconTransformation(extent={{100,80},{120,100}})));

          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
            "Heat dissipation to environment"
            annotation (Placement(transformation(extent={{-70,-110},{-50,-90}}),
                iconTransformation(extent={{-10,-78},{10,-58}})));

          // Variables
          Modelica.SIunits.VolumeFlowRate VMachine_flow(start=_VMachine_flow) = eff.V_flow "Volume flow rate";
          Modelica.SIunits.PressureDifference dpMachine(displayUnit="Pa")=
              -preSou.dp "Pressure difference";

          Real eta(unit="1", final quantity="Efficiency") =    eff.eta "Global efficiency";
          Real etaHyd(unit="1", final quantity="Efficiency") = eff.etaHyd "Hydraulic efficiency";
          Real etaMot(unit="1", final quantity="Efficiency") = eff.etaMot "Motor efficiency";

          // Quantity to control
      protected
          final parameter Modelica.SIunits.VolumeFlowRate _VMachine_flow = 0
            "Start value for VMachine_flow, used to avoid a warning if not specified";

          parameter Types.PrescribedVariable preVar "Type of prescribed variable";

          // The parameter speedIsInput is required to conditionally remove the instance gain.
          // If the conditional removal of this instance where to use the test
          // preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed,
          // then OpenModelica fails to translate the model with the message
          // .../PartialFlowMachine.mo:185:3-189:70:writable]
          // Error: Variable Types.PrescribedVariable.Speed not found in scope
          // IDEAS.Fluid.Movers.SpeedControlled_y$floMac1.
          final parameter Boolean speedIsInput=
            (preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed)
            "Parameter that is true if speed is the controlled variables";

          final parameter Integer nOri = size(per.pressure.V_flow, 1)
            "Number of data points for pressure curve"
            annotation(Evaluate=true);

          final parameter Boolean haveVMax = (abs(per.pressure.dp[nOri]) < Modelica.Constants.eps)
            "Flag, true if user specified data that contain V_flow_max";

          final parameter Modelica.SIunits.VolumeFlowRate V_flow_max=
            if per.havePressureCurve then
            (if haveVMax then
              per.pressure.V_flow[nOri]
             else
              per.pressure.V_flow[nOri] - (per.pressure.V_flow[nOri] - per.pressure.V_flow[
              nOri - 1])/((per.pressure.dp[nOri] - per.pressure.dp[nOri - 1]))*per.pressure.dp[nOri])
            else
              m_flow_nominal/rho_default "Maximum volume flow rate, used for smoothing";
          final parameter Modelica.SIunits.Density rho_default=
            Medium.density_pTX(
              p=Medium.p_default,
              T=Medium.T_default,
              X=Medium.X_default) "Default medium density";

          final parameter Medium.ThermodynamicState sta_start=Medium.setState_pTX(
            T=T_start,
            p=p_start,
            X=X_start) "Medium state at start values";

          final parameter Modelica.SIunits.SpecificEnthalpy h_outflow_start = Medium.specificEnthalpy(sta_start)
            "Start value for outflowing enthalpy";

          Modelica.Blocks.Sources.Constant[size(stageInputs, 1)] stageValues(
            final k=stageInputs) if
              inputType == IDEAS.Fluid.Types.InputType.Stages "Stage input values"
            annotation (Placement(transformation(extent={{-80,40},{-60,60}})));
          Modelica.Blocks.Sources.Constant setConst(
            final k=constInput) if
              inputType == IDEAS.Fluid.Types.InputType.Constant
            "Constant input set point"
            annotation (Placement(transformation(extent={{-80,70},{-60,90}})));

          Extractor extractor(final nin=size(stageInputs,1)) if
              inputType == IDEAS.Fluid.Types.InputType.Stages "Stage input extractor"
            annotation (Placement(transformation(extent={{-50,60},{-30,40}})));

          Modelica.Blocks.Routing.RealPassThrough inputSwitch
            "Dummy connection for easy connection of input options"
            annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                origin={-10,50})));

          IDEAS.Fluid.Delays.DelayFirstOrder vol(
            redeclare final package Medium = Medium,
            final tau=tau,
            final energyDynamics=energyDynamics,
            final massDynamics=massDynamics,
            final T_start=T_start,
            final X_start=X_start,
            final C_start=C_start,
            final m_flow_nominal=m_flow_nominal,
            final m_flow_small=m_flow_small,
            final p_start=p_start,
            final prescribedHeatFlowRate=true,
            final allowFlowReversal=allowFlowReversal,
            nPorts=2) "Fluid volume for dynamic model"
            annotation (Placement(transformation(extent={{-70,0},{-90,20}})));

          Modelica.Blocks.Continuous.Filter filter(
             order=2,
             f_cut=5/(2*Modelica.Constants.pi*riseTime),
             final init=init,
             x(each stateSelect=StateSelect.always),
             final analogFilter=Modelica.Blocks.Types.AnalogFilter.CriticalDamping,
             final filterType=Modelica.Blocks.Types.FilterType.LowPass) if
                use_inputFilter
            "Second order filter to approximate valve opening time, and to improve numerics"
            annotation (Placement(transformation(extent={{20,81},{34,95}})));

          Modelica.Blocks.Math.Gain gaiSpe(y(final unit="1")) if
            inputType == IDEAS.Fluid.Types.InputType.Continuous and
            speedIsInput
            "Gain to normalized speed using speed_nominal or speed_rpm_nominal"
            annotation (Placement(transformation(extent={{-4,74},{-16,86}})));

          IDEAS.Fluid.Movers.BaseClasses.IdealSource preSou(
            redeclare final package Medium = Medium,
            final m_flow_small=m_flow_small,
            final allowFlowReversal=allowFlowReversal,
            final control_m_flow= (preVar ==  IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.FlowRate))
            "Pressure source"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));

          IDEAS.Fluid.Movers.BaseClasses.PowerInterface heaDis(
            final motorCooledByFluid=per.motorCooledByFluid,
            final delta_V_flow=1E-3*V_flow_max) if
              addPowerToMedium "Heat dissipation into medium"
            annotation (Placement(transformation(extent={{20,-80},{40,-60}})));

          Modelica.Blocks.Math.Add PToMed(final k1=1, final k2=1) if
            addPowerToMedium "Heat and work input into medium"
            annotation (Placement(transformation(extent={{50,-90},{70,-70}})));

          Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow prePow(
            final alpha=0) if
            addPowerToMedium
            "Prescribed power (=heat and flow work) flow for dynamic model"
            annotation (Placement(transformation(extent={{-14,-104},{-34,-84}})));

          Modelica.Blocks.Sources.RealExpression rho_inlet(y=
            Medium.density(
              Medium.setState_phX(port_a.p,
                                  inStream(port_a.h_outflow),
                                  inStream(port_a.Xi_outflow))))
            "Density of the inflowing fluid"
            annotation (Placement(transformation(extent={{-90,-74},{-70,-54}})));

          IDEAS.Fluid.Sensors.MassFlowRate senMasFlo(
            redeclare final package Medium = Medium) "Mass flow rate sensor"
            annotation (Placement(transformation(extent={{-50,10},{-30,-10}})));

          Sensors.RelativePressure senRelPre(
            redeclare final package Medium = Medium) "Head of mover"
            annotation (Placement(transformation(extent={{58,-27},{43,-14}})));

          // Because the speed data are not used by FlowMachineInterface, we set them
          // to zero.
          FlowMachineInterface eff(
            per(
              final hydraulicEfficiency = per.hydraulicEfficiency,
              final motorEfficiency =     per.motorEfficiency,
              final motorCooledByFluid =  per.motorCooledByFluid,
              final speed_nominal =       0,
              final constantSpeed =       0,
              final speeds =              {0},
              final power =               per.power),
            final nOri = nOri,
            final rho_default=rho_default,
            final computePowerUsingSimilarityLaws=computePowerUsingSimilarityLaws,
            final haveVMax=haveVMax,
            final V_flow_max=V_flow_max,
            r_N(start=y_start),
            r_V(start=m_flow_nominal/rho_default),
            final preVar=preVar) "Flow machine"
            annotation (Placement(transformation(extent={{-32,-68},{-12,-48}})));

      protected
          block Extractor
            "Extract scalar signal out of signal vector dependent on IntegerRealInput index"
            extends Modelica.Blocks.Interfaces.MISO;

            Modelica.Blocks.Interfaces.IntegerInput index "Integer input for control input"
            annotation (Placement(
                  transformation(
                  origin={0,-120},
                  extent={{-20,-20},{20,20}},
                  rotation=90)));
          equation
          y = sum({if index == i then u[i] else 0 for i in 1:nin});

          annotation (Icon(graphics={
                  Rectangle(
                    extent={{-80,50},{-40,-50}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-84.4104,1.9079},{-84.4104,-2.09208},{-80.4104,-0.09208},{
                        -84.4104,1.9079}},
                    lineColor={0,0,127},
                    fillColor={0,0,0},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-62,2},{-50.1395,12.907},{-39.1395,12.907}}, color={0,0,
                        127}),
                  Line(points={{-63,4},{-49,40},{-39,40}}, color={0,0,127}),
                  Line(points={{-102,0},{-65.0373,-0.01802}}, color={0,0,127}),
                  Ellipse(
                    extent={{-70.0437,4.5925},{-60.0437,-4.90745}},
                    lineColor={0,0,127},
                    fillColor={0,0,127},
                    fillPattern=FillPattern.Solid),
                  Line(points={{-63,-5},{-50,-40},{-39,-40}}, color={0,0,127}),
                  Line(points={{-62,-2},{-50.0698,-12.907},{-39.0698,-12.907}}, color={
                        0,0,127}),
                  Polygon(
                    points={{-38.8808,-11},{-38.8808,-15},{-34.8808,-13},{-38.8808,-11}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-39,42},{-39,38},{-35,40},{-39,42}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-38.8728,-38.0295},{-38.8728,-42.0295},{-34.8728,-40.0295},
                        {-38.8728,-38.0295}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{-38.9983,14.8801},{-38.9983,10.8801},{-34.9983,12.8801},{-38.9983,
                        14.8801}},
                    lineColor={0,0,127},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{-30,50},{30,-50}},
                    fillColor={235,235,235},
                    fillPattern=FillPattern.Solid,
                    lineColor={0,0,127}),
                  Line(points={{100,0},{0,0}}, color={0,0,127}),
                  Line(points={{0,2},{0,-104}}, color={255,128,0}),
                  Line(points={{-35,40},{-20,40}}, color={0,0,127}),
                  Line(points={{-35,13},{-20,13}}, color={0,0,127}),
                  Line(points={{-35,-13},{-20,-13}}, color={0,0,127}),
                  Line(points={{-35,-40},{-20,-40}}, color={0,0,127}),
                  Polygon(points={{0,0},{-20,13},{-20,13},{0,0},{0,0}}, lineColor={0,0,
                        127}),
                  Ellipse(
                    extent={{-6,6},{6,-6}},
                    lineColor={255,128,0},
                    fillColor={255,128,0},
                    fillPattern=FillPattern.Solid)}));
          end Extractor;

        initial equation
          // Check incorrect value of m_flow_nominal
          assert(m_flow_nominal >= Modelica.Constants.small, "In "+ getInstanceName()+
          ": The value of parameter m_flow_nominal should be greater or equal than " +
          String(Modelica.Constants.small) + " but it equals " + String(m_flow_nominal));
          // The control signal is dp or m_flow but the user did not provide a pump curve.
          // Hence, the speed is computed using default values, which likely are wrong.
          // Therefore, scaling the power using the speed is inaccurate.
          assert(nominalValuesDefineDefaultPressureCurve or
                 per.havePressureCurve or
                 (preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed),
        "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve.
             This leads to approximate calculations of the electrical power
             consumption. Add the correct pressure curve in the record per
             to obtain an accurate computation.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.",
                 level=AssertionLevel.warning);

          // The control signal is dp or m_flow but the user did not provide a pump curve.
          // Hence, the speed is computed using default values, which likely are wrong.
          // In addition, the user wants to use (V_flow, P) to compute the power.
          // This can lead to using a power that is less than the flow work. We avoid
          // this by ignoring the setting of per.use_powerCharacteristics.
          // The comment is split into two parts since otherwise the JModelica C-compiler
          // throws warnings.
          assert(nominalValuesDefineDefaultPressureCurve or
                 (per.havePressureCurve or
                   (preVar == IDEAS.Fluid.Movers.BaseClasses.Types.PrescribedVariable.Speed)) or
                 per.use_powerCharacteristic == false,
        "*** Warning: You are using a flow or pressure controlled mover with the
             default pressure curve and you set use_powerCharacteristic = true.
             Since this can cause wrong power consumption, the model will overwrite
             this setting and use instead use_powerCharacteristic = false."         +
                     "Since this causes the efficiency curve to be used,
             make sure that the efficiency curves in the performance record per
             are correct or add the pressure curve of the mover.
             Setting nominalValuesDefineDefaultPressureCurve=true will suppress this warning.",
                 level=AssertionLevel.warning);

        equation
          connect(prePow.port, vol.heatPort) annotation (Line(
              points={{-34,-94},{-60,-94},{-60,10},{-70,10}},
              color={191,0,0}));

          connect(vol.heatPort, heatPort) annotation (Line(
              points={{-70,10},{-70,10},{-60,10},{-60,-100}},
              color={191,0,0}));
          connect(preSou.port_b, port_b) annotation (Line(
              points={{60,0},{100,0}},
              color={0,127,255},
              smooth=Smooth.None));
          connect(stageValues.y, extractor.u) annotation (Line(
              points={{-59,50},{-52,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(extractor.y, inputSwitch.u) annotation (Line(
              points={{-29,50},{-22,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(setConst.y, inputSwitch.u) annotation (Line(
              points={{-59,80},{-26,80},{-26,50},{-22,50}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(extractor.index, stage) annotation (Line(
              points={{-40,62},{-40,90},{0,90},{0,120}},
              color={255,127,0},
              smooth=Smooth.None));

          connect(PToMed.y, prePow.Q_flow) annotation (Line(points={{71,-80},{80,-80},{80,
                  -94},{-14,-94}},                 color={0,0,127}));
          connect(PToMed.u1, heaDis.Q_flow) annotation (Line(points={{48,-74},{44,-74},{
                  44,-72},{44,-70},{41,-70}},
                                     color={0,0,127}));

          connect(senRelPre.port_b, preSou.port_a) annotation (Line(points={{43,-20.5},{
                  20,-20.5},{20,0},{40,0}},
                                       color={0,127,255}));
          connect(senRelPre.port_a, preSou.port_b) annotation (Line(points={{58,-20.5},{
                  80,-20.5},{80,0},{60,0}},
                                       color={0,127,255}));
          connect(heaDis.etaHyd,eff. etaHyd) annotation (Line(points={{18,-60},{10,-60},
                  {10,-65},{-11,-65}},                     color={0,0,127}));
          connect(heaDis.V_flow,eff. V_flow) annotation (Line(points={{18,-66},{14,-66},
                  {14,-53.2},{-6,-53.2},{-11,-53.2}},
                                             color={0,0,127}));
          connect(eff.PEle, heaDis.PEle) annotation (Line(points={{-11,-59},{0,-59},{0,-80},
                  {18,-80}},      color={0,0,127}));
          connect(eff.WFlo, heaDis.WFlo) annotation (Line(points={{-11,-56},{-8,-56},{-8,
                  -74},{18,-74}}, color={0,0,127}));
          connect(rho_inlet.y,eff. rho) annotation (Line(points={{-69,-64},{-69,-64},{-34,
                  -64}},                          color={0,0,127}));
          connect(eff.m_flow, senMasFlo.m_flow) annotation (Line(points={{-34,-54},{-34,
                  -54},{-40,-54},{-40,-11}},               color={0,0,127}));
          connect(eff.PEle, P) annotation (Line(points={{-11,-59},{0,-59},{0,-50},{90,
                  -50},{90,90},{110,90}},
                                     color={0,0,127}));
          connect(eff.WFlo, PToMed.u2) annotation (Line(points={{-11,-56},{-8,-56},{-8,-86},
                  {48,-86}},      color={0,0,127}));
          connect(inputSwitch.y, filter.u) annotation (Line(points={{1,50},{16,50},{16,88},
                  {18.6,88}},     color={0,0,127}));

          connect(senRelPre.p_rel, eff.dp_in) annotation (Line(points={{50.5,-26.35},{50.5,
                  -38},{-18,-38},{-18,-46}},               color={0,0,127}));
          connect(eff.y_out, y_actual) annotation (Line(points={{-11,-48},{92,-48},{92,
                  70},{110,70}},
                             color={0,0,127}));
          connect(port_a, vol.ports[1])
            annotation (Line(points={{-100,0},{-78,0},{-78,0}}, color={0,127,255}));
          connect(vol.ports[2], senMasFlo.port_a)
            annotation (Line(points={{-82,0},{-82,0},{-50,0}}, color={0,127,255}));
          connect(senMasFlo.port_b, preSou.port_a)
            annotation (Line(points={{-30,0},{40,0},{40,0}}, color={0,127,255}));
           annotation(Icon(coordinateSystem(preserveAspectRatio=false,
            extent={{-100,-100},{100,100}}),
            graphics={
                Line(
                  points={{0,70},{100,70}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,90},{100,90}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  visible=not use_inputFilter,
                  points={{0,100},{0,40}}),
                Rectangle(
                  extent={{-100,16},{100,-14}},
                  lineColor={0,0,0},
                  fillColor={0,127,255},
                  fillPattern=FillPattern.HorizontalCylinder),
                Ellipse(
                  extent={{-58,50},{54,-58}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={0,100,199}),
                Polygon(
                  points={{0,50},{0,-56},{54,2},{0,50}},
                  lineColor={0,0,0},
                  pattern=LinePattern.None,
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={255,255,255}),
                Ellipse(
                  extent={{4,14},{34,-16}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  visible=energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState,
                  fillColor={0,100,199}),
                Text(extent={{64,106},{114,92}},
                  lineColor={0,0,127},
                  textString="P"),
                Text(extent={{42,86},{92,72}},
                  lineColor={0,0,127},
                  textString="y_actual"),
                Line(
                  points={{0,100},{0,50}},
                  color={0,0,0},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>
This is the base model for fans and pumps.
It provides an interface
between the equations that compute head and power consumption,
and the implementation of the energy and pressure balance
of the fluid.
</p>
<p>
Optionally, the fluid volume
is computed using a dynamic balance or a steady-state balance.
</p>
<p>
The parameter <code>addPowerToMedium</code> determines whether
any power is added to the fluid. The default is <code>addPowerToMedium=true</code>,
and hence the outlet enthalpy is higher than the inlet enthalpy if the
flow device is operating.
The setting <code>addPowerToMedium=false</code> is physically incorrect
(since the flow work, the flow friction and the fan heat do not increase
the enthalpy of the medium), but this setting does in some cases lead to simpler equations
and more robust simulation, in particular if the mass flow is equal to zero.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 22, 2019, by Filip Jorissen:<br/>
Split long assert output string into two strings to avoid compiler warnings
in JModelica.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1081\">#1081</a>.
</li>
<li>
January 8, 2019, by Filip Jorissen:<br/>
Added assert for value of <code>m_flow_nominal</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/908\">#908</a>.
</li>
<li>
March 24, 2017, by Michael Wetter:<br/>
Renamed <code>filteredSpeed</code> to <code>use_inputFilter</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/665\">#665</a>.
</li>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Set start value for <code>VMachine_flow</code> to avoid a warning in
<a href=\"modelica://IDEAS.Fluid.Movers.Examples.MoverContinuous\">
IDEAS.Fluid.Movers.Examples.MoverContinuous</a>.
</li>
<li>
July 29, 2016, by Michael Wetter:<br/>
Made <code>Extractor</code> protected so that it can be removed later
with a backwards compatible change.
</li>
<li>
July 19, 2016, by Filip Jorissen:<br/>
Created custom implementation for extractor.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/498\">#498</a>.
</li>
<li>
June 16, 2016, by Filip Jorissen:<br/>
Switched position of mixing volume and mass flow rate sensor.
This is to have a consistent operating point tuple
of <code>dp</code> and <code>m_flow</code> when having
compressible flow.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
February 19, 2016, by Michael Wetter and Filip Jorissen:<br/>
Refactored model to make implementation clearer.
This model now includes code for both speed and flow prescribed models,
eliminating the need for an additional level of partial models.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
<li>
Removed the parameter <code>dynamicBalance</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/411\">#411</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
Removed assignment of <code>min</code> and <code>max</code> attributes
of the port mass flow rate as this is already done in the base class.
Removed <code>import</code> statement.
</li>
<li>
April 2, 2015, by Filip Jorissen:<br/>
Added code for supporting stage input and constant input.
Added code for displaying constant set point in symbol.
</li>
<li>
January 24, 2015, by Michael Wetter:<br/>
Propagated <code>m_flow_small</code> of instance <code>vol</code> and made
all its parameters final.
</li>
<li>
May 25, 2011, by Michael Wetter:<br/>
Revised implementation of energy balance to avoid having to use conditionally removed models.
</li>
<li>
July 29, 2010, by Michael Wetter:<br/>
Reduced fan time constant from 10 to 1 second.
</li>
<li>
July 27, 2010, by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>March 24 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialFlowMachine;

        model PowerInterface
          "Partial model to compute power draw and heat dissipation of fans and pumps"
          extends Modelica.Blocks.Icons.Block;
          parameter Boolean homotopyInitialization = true "= true, use homotopy method"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          parameter Boolean motorCooledByFluid
            "Flag, true if the motor is cooled by the fluid stream";
          parameter Modelica.SIunits.VolumeFlowRate delta_V_flow
            "Factor used for setting heat input into medium to zero at very small flows";
          Modelica.Blocks.Interfaces.RealInput etaHyd(
            final quantity="Efficiency",
            final unit="1") "Hydraulic efficiency"
            annotation (Placement(transformation(extent={{-140,80},{-100,120}}),
                iconTransformation(extent={{-140,80},{-100,120}})));
          Modelica.Blocks.Interfaces.RealInput V_flow(
            final quantity="VolumeFlowRate",
            final unit="m3/s") "Volume flow rate"
            annotation (Placement(transformation(extent={{-140,20},{-100,60}}),
                iconTransformation(extent={{-140,20},{-100,60}})));
          Modelica.Blocks.Interfaces.RealInput WFlo(
            final quantity="Power",
            final unit="W") "Flow work"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}}),
                iconTransformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput PEle(
            final quantity="Power",
            final unit="W") "Electrical power consumed"
            annotation (Placement(transformation(extent={{-140,-120},{-100,-80}})));
          Modelica.Blocks.Interfaces.RealOutput Q_flow(
            quantity="Power",
            final unit="W") "Heat input from fan or pump to medium"
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.SIunits.Power WHyd
            "Hydraulic power input (converted to flow work and heat)";
      protected
          Modelica.SIunits.HeatFlowRate QThe_flow
            "Heat input from fan or pump to medium";
        equation
          // Hydraulic power (transmitted by shaft), etaHyd = WFlo/WHyd
          etaHyd * WHyd   = WFlo;
          // Heat input into medium
          QThe_flow +  WFlo = if motorCooledByFluid then PEle else WHyd;
          // At m_flow = 0, the solver may still obtain positive values for QThe_flow.
          // The next statement sets the heat input into the medium to zero for very small flow rates.
          Q_flow = if homotopyInitialization then
            homotopy(actual=IDEAS.Utilities.Math.Functions.regStep(
                              y1=QThe_flow,
                              y2=0,
                              x=noEvent(abs(V_flow))-2*delta_V_flow,
                              x_small=delta_V_flow),
                    simplified=0)
            else
              IDEAS.Utilities.Math.Functions.regStep(
                              y1=QThe_flow,
                              y2=0,
                              x=noEvent(abs(V_flow))-2*delta_V_flow,
                              x_small=delta_V_flow);
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
            Line( origin={-49.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Line( origin={0.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Line( origin={50.5,7.6667},
                  points={{-2.5,-91.6667},{17.5,-71.6667},{-22.5,-51.6667},{17.5,-31.6667},
                      {-22.5,-11.667},{17.5,8.3333},{-2.5,28.3333},{-2.5,48.3333}},
                  smooth=Smooth.Bezier,
                  color={255,0,0}),
            Polygon(
            origin={48,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0}),
            Polygon(
            origin={-2,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0}),
            Polygon(
            origin={-52,64.333},
            pattern=LinePattern.None,
            fillPattern=FillPattern.Solid,
              points={{0.0,21.667},{-10.0,-8.333},{10.0,-8.333}},
                  lineColor={0,0,0},
                  fillColor={255,0,0})}),
            Documentation(info="<html>
<p>Block that implements the functions to compute the
heat dissipation of fans and pumps. It is used by the model
<a href=\"modelica://IDEAS.Fluid.Movers.BaseClasses.PartialFlowMachine\">
IDEAS.Fluid.Movers.BaseClasses.PartialFlowMachine</a>.
</p>
</html>",     revisions="<html>
<ul>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
February 19, 2016, by Michael Wetter:<br/>
First implementation during refactoring of mover models to make implementation clearer.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">#417</a>.
</li>
</ul>
</html>"));
        end PowerInterface;

        package Characteristics "Functions for fan or pump characteristics"

          function efficiency "Flow vs. efficiency characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input IDEAS.Fluid.Movers.BaseClasses.Characteristics.efficiencyParameters per
              "Efficiency performance data";
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real d[:] "Derivatives at support points for spline interpolation";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real delta "Small value for switching implementation around zero rpm";
            output Real eta(unit="1", final quantity="Efficiency") "Efficiency";
        protected
            Integer n = size(per.V_flow, 1) "Number of data points";
            Real rat "Ratio of V_flow/r_N";
            Integer i "Integer to select data interval";
          algorithm
            if n == 1 then
              eta := per.eta[1];
            else
              // The use of the max function to avoids problems for low speeds
              // and turned off pumps
              rat:=V_flow/
                      IDEAS.Utilities.Math.Functions.smoothMax(
                        x1=r_N,
                        x2=0.1,
                        deltaX=delta);
              i :=1;
              for j in 1:n-1 loop
                 if rat > per.V_flow[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              eta:=IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=rat,
                          x1=per.V_flow[i],
                          x2=per.V_flow[i + 1],
                          y1=per.eta[i],
                          y2=per.eta[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;
            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan or pump efficiency for given normalized volume flow rate
and performance data. The efficiency is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &eta; = s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>&eta;</i> is the efficiency,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate, and
<i>d</i> are performance data for fan or pump efficiency.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>", revisions="<html>
<ul>
<li>
December 2, 2016, by Michael Wetter:<br/>
Removed <code>min</code> attribute as otherwise numerical noise can cause
the assertion on the limit to fail.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/606\">#606</a>.
</li>
<li>
November 22, 2014, by Michael Wetter:<br/>
Corrected documentation as curve uses <i>V&#775;</i>
as an independent variable.
</li>
<li>
September 30, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>V_flow</code>
instead of <code>r_V</code>.
</li>
<li>
April 19, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>r_V/r_N</code>
instead of <code>r_V</code> to properly account for the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end efficiency;

          function power "Flow vs. electrical power characteristics for fan or pump"
            extends Modelica.Icons.Function;
            input IDEAS.Fluid.Movers.BaseClasses.Characteristics.powerParameters per
              "Pressure performance data";
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real d[:] "Derivatives at support points for spline interpolation";
            input Real delta "Small value for switching implementation around zero rpm";
            output Modelica.SIunits.Power P "Power consumption";
        protected
             Integer n=size(per.V_flow, 1) "Dimension of data vector";
             Modelica.SIunits.VolumeFlowRate rat "Ratio of V_flow/r_N";
             Integer i "Integer to select data interval";
          algorithm
            if n == 1 then
              P := r_N^3*per.P[1];
            else
              i :=1;
              // The use of the max function to avoids problems for low speeds
              // and turned off pumps
              rat:=V_flow/
                      IDEAS.Utilities.Math.Functions.smoothMax(
                        x1=r_N,
                        x2=0.1,
                        deltaX=delta);
              for j in 1:n-1 loop
                 if rat > per.V_flow[j] then
                   i := j;
                 end if;
              end for;
              // Extrapolate or interpolate the data
              P:=r_N^3*IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                          x=rat,
                          x1=per.V_flow[i],
                          x2=per.V_flow[i + 1],
                          y1=per.P[i],
                          y2=per.P[i + 1],
                          y1d=d[i],
                          y2d=d[i+1]);
            end if;
            annotation(smoothOrder=1,
                        Documentation(info="<html>
<p>
This function computes the fan power consumption for given volume flow rate,
speed and performance data. The power consumption is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  P = r<sub>N</sub><sup>3</sup> &nbsp; s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>P</i> is the power consumption,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate and
<i>d</i> are performance data for fan or pump power consumption at <i>r<sub>N</sub>=1</i>.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 26, 2014, by Filip Jorissen:<br/>
Changed polynomial to be evaluated at <code>V_flow/r_N</code>
instead of <code>V_flow</code> to properly account for the
scaling law. See
<a href=\"https://github.com/lbl-srg/modelica-buildings/pull/202\">#202</a>
for a discussion and validation.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end power;

          function pressure
            "Pump or fan head away from the origin without correction for mover flow resistance"
            extends Modelica.Icons.Function;
            input Modelica.SIunits.VolumeFlowRate V_flow "Volumetric flow rate";
            input Real r_N(unit="1") "Relative revolution, r_N=N/N_nominal";
            input Real d[:] "Derivatives of flow rate vs. pressure at the support points";
            input Modelica.SIunits.PressureDifference dpMax(displayUnit="Pa")
              "Maximum pressure drop at nominal speed, for regularisation";
            input Modelica.SIunits.VolumeFlowRate V_flow_max
              "Maximum flow rate at nominal speed, for regularisation";
            input IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParametersInternal per
              "Pressure performance data";
            output Modelica.SIunits.PressureDifference dp(displayUnit="Pa") "Pressure raise";
        protected
            constant Real delta = 0.05
              "Small number for r_N below which we don't care about the affinity laws";
            constant Real delta2 = delta/2 "= delta/2";
            Real r_R(unit="1") "Relative revolution, bounded below by delta";
            Integer i "Integer to select data interval";
            Modelica.SIunits.VolumeFlowRate rat "Ratio of V_flow/r_R";
          algorithm
            // For r_N < delta, we restrict r_N in the term V_flow/r_N.
            // This is done using a cubic spline in a region 0.75*delta < r_N < 1.25*r_N
            // We call this restricted value r_R
            if r_N > delta then
              r_R :=r_N;
            elseif r_N < 0 then
              r_R := delta2;
            else
              // Restrict r_N using a spline
              r_R :=Modelica.Fluid.Utilities.cubicHermite(
                x=r_N,
                x1=0,
                x2=delta,
                y1=delta2,
                y2=delta,
                y1d=0,
                y2d=1);
            end if;
            i :=1;
            rat := V_flow/r_R;
            for j in 1:size(d, 1)-1 loop
              if rat > per.V_flow[j] then
                i := j;
              end if;
            end for;
            // In the assignment below,
            // dp -> 0 as r_N -> 0 quadratically, because rat is bounded
            // by the above regularization
            if r_N>=0 then
              dp:=r_N^2*IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation(
                        x=rat,
                        x1=per.V_flow[i],
                        x2=per.V_flow[i + 1],
                        y1=per.dp[i],
                        y2=per.dp[i + 1],
                        y1d=d[i],
                        y2d=d[i+1]);
            else
              dp:=-r_N^2*(dpMax-dpMax/V_flow_max*V_flow);
            end if;
          annotation(smoothOrder=1,
          Documentation(info="<html>
<p>
This function computes the fan static
pressure raise as a function of volume flow rate and revolution in the form
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = r<sub>N</sub><sup>2</sup> &nbsp; s(V&#775;/r<sub>N</sub>, d),
</p>
<p>
where
<i>&Delta;p</i> is the pressure rise,
<i>r<sub>N</sub></i> is the normalized fan speed,
<i>V&#775;</i> is the volume flow rate and
<i>d</i> are performance data for fan or pump power consumption at <i>r<sub>N</sub>=1</i>.
</p>
<h4>Implementation</h4>
<p>
The function <i>s(&middot;, &middot;)</i> is a cubic hermite spline.
If the data <i>d</i> define a monotone decreasing sequence, then
<i>s(&middot;, d)</i> is a monotone decreasing function.
</p>
<p>
The function allows <i>r<sub>N</sub></i> to be zero.
</p>
</html>",   revisions="<html>
<ul>
<li>
September 8, 2016, by Michael Wetter and Filip Jorissen:<br/>
Changed implementation to allow <code>r_N = 0</code>.<br/>
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
September 7, 2016, by Michael Wetter:<br/>
Moved function which was a protected function to make it public, as it
is now called by
<a href=\"modelica://IDEAS.Fluid.Movers.BaseClasses.FlowMachineInterface\">
IDEAS.Fluid.Movers.BaseClasses.FlowMachineInterface</a>.
</li>
</ul>
</html>"));
          end pressure;

          record efficiencyParameters "Record for efficiency parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](
              each min=0) "Volumetric flow rate at user-selected operating points";
            parameter Modelica.SIunits.Efficiency eta[size(V_flow,1)](
              each max=1) "Fan or pump efficiency at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
efficiency.
The volume flow rate <code>r_V</code> must be increasing, i.e.,
<code>r_V[i] &lt; r_V[i+1]</code>.
Both vectors, <code>r_V</code> and <code>eta</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end efficiencyParameters;

          record flowParameters "Record for flow parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.PressureDifference dp[size(V_flow,1)](
               each min=0, each displayUnit="Pa")
              "Fan or pump total pressure at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
pressure rise.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>dp</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end flowParameters;

          record flowParametersInternal "Record for flow parameters with prescribed size"
            extends Modelica.Icons.Record;
            parameter Integer n "Number of elements in each array"
             annotation(Evaluate=true);
            parameter Modelica.SIunits.VolumeFlowRate V_flow[n](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.PressureDifference dp[n](
               each min=0, each displayUnit="Pa")
              "Fan or pump total pressure at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
pressure rise.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>dp</code>
must have the same size.
</p>
<p>
This record is identical to
<a href=\"modelica://IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters\">
IDEAS.Fluid.Movers.BaseClasses.Characteristics.flowParameters</a>,
except that it takes the size of the array as a parameter. This is required
in Dymola 2014. Otherwise, the array size would need to be computed in
<a href=\"modelica://IDEAS.Fluid.Movers.BaseClasses.FlowMachineInterface\">
IDEAS.Fluid.Movers.BaseClasses.FlowMachineInterface</a>
in the <code>initial algorithm</code> section, which is not supported.
</p>
</html>", revisions="<html>
<ul>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
March 22, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end flowParametersInternal;

          record powerParameters "Record for electrical power parameters"
            extends Modelica.Icons.Record;
            parameter Modelica.SIunits.VolumeFlowRate V_flow[:](each min=0)
              "Volume flow rate at user-selected operating points";
            parameter Modelica.SIunits.Power P[size(V_flow,1)](each min=0)
              "Fan or pump electrical power at these flow rates";
            annotation (Documentation(info="<html>
<p>
Data record for performance data that describe volume flow rate versus
electrical power.
The volume flow rate <code>V_flow</code> must be increasing, i.e.,
<code>V_flow[i] &lt; V_flow[i+1]</code>.
Both vectors, <code>V_flow</code> and <code>P</code>
must have the same size.
</p>
</html>", revisions="<html>
<ul>
<li>
October 10, 2012, by Michael Wetter:<br/>
Fixed wrong <code>displayUnit</code> and
<code>max</code> attribute for power.
</li>
<li>
September 28, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end powerParameters;
          annotation (Documentation(info="<html>
<p>
This package implements performance curves for fans and pumps,
and records for parameter that can be used with these performance
curves.
</p>
<p>
See the
<a href=\"modelica://IDEAS.Fluid.Movers.UsersGuide\">
User's Guide</a> for information about these performance curves.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 8, 2016, by Michael Wetter:<br/>
Deleted function <code>performanceCurve</code> as it is no longer needed. Instead, the function
<a href=\"modelica://IDEAS.Fluid.Movers.BaseClasses.Characteristics.pressure\">
IDEAS.Fluid.Movers.BaseClasses.Characteristics.pressure</a>
is used for all speeds.<br/>
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/458\">#458</a>.
</li>
<li>
September 29, 2011, by Michael Wetter:<br/>
New implementation due to changes from polynomial to cubic hermite splines.
</li>
</ul>
</html>"));
        end Characteristics;

        package Types "Package with type definitions"
          extends Modelica.Icons.TypesPackage;

          type PrescribedVariable = enumeration(
            Speed   "Speed is prescribed",
            FlowRate   "Flow rate is prescribed",
            PressureDifference   "Pressure difference is prescribed")
            "Enumeration to choose what variable is prescribed";
         annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions for movers.
</p>
</html>"));
        end Types;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.Movers\">IDEAS.Fluid.Movers</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
This package contains component models for fans and pumps.
</html>"),
      Icon(graphics={Ellipse(
            extent={{-66,66},{68,-68}},
            lineColor={0,0,0},
            fillColor={255,255,255},
            fillPattern=FillPattern.Solid), Polygon(
            points={{0,66},{0,-68},{68,0},{0,66}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid)}));
    end Movers;

    package Sensors "Package with sensor models"
      extends Modelica.Icons.SensorsPackage;

      model EnthalpyFlowRate "Ideal enthalphy flow rate sensor"
        extends IDEAS.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor;
        extends Modelica.Icons.RotationalSensor;
        Modelica.Blocks.Interfaces.RealOutput H_flow(final unit="W")
          "Enthalpy flow rate, positive if from port_a to port_b"
          annotation (Placement(transformation(
              origin={0,110},
              extent={{-10,-10},{10,10}},
              rotation=90)));
        parameter Modelica.SIunits.SpecificEnthalpy h_out_start=
          Medium.specificEnthalpy_pTX(
            p=Medium.p_default,
            T=Medium.T_default,
            X=Medium.X_default)
          "Initial or guess value of measured specific enthalpy"
          annotation (Dialog(group="Initialization"));
    protected
        Modelica.SIunits.SpecificEnthalpy hMed_out(start=h_out_start)
          "Medium enthalpy to which the sensor is exposed";
        Modelica.SIunits.SpecificEnthalpy h_out(start=h_out_start)
          "Medium enthalpy that is used to compute the enthalpy flow rate";
      initial equation
        if dynamic then
          if initType == Modelica.Blocks.Types.Init.SteadyState then
            der(h_out) = 0;
          elseif initType == Modelica.Blocks.Types.Init.InitialState or
                 initType == Modelica.Blocks.Types.Init.InitialOutput then
            h_out = h_out_start;
          end if;
        end if;
      equation
        if allowFlowReversal then
          hMed_out = Modelica.Fluid.Utilities.regStep(
                       x=port_a.m_flow,
                       y1=port_b.h_outflow,
                       y2=port_a.h_outflow,
                       x_small=m_flow_small);
        else
          hMed_out = port_b.h_outflow;
        end if;
        // Specific enthalpy measured by sensor
        if dynamic then
          der(h_out) = (hMed_out-h_out)*k*tauInv;
        else
          h_out = hMed_out;
        end if;
        // Sensor output signal
        H_flow = port_a.m_flow * h_out;
      annotation (defaultComponentName="senEntFlo",
        Icon(graphics={
              Line(points={{-100,0},{-70,0}}, color={0,128,255}),
              Line(points={{70,0},{100,0}}, color={0,128,255}),
              Line(points={{0,100},{0,70}}, color={0,0,127}),
              Text(
                extent={{180,151},{20,99}},
                lineColor={0,0,0},
                textString="H_flow")}),
        Documentation(info="<html>
<p>
This model outputs the enthalphy flow rate of the medium in the flow
between fluid ports. The sensor is ideal, i.e., it does not influence the fluid.
</p>
<p>
If the parameter <code>tau</code> is non-zero, then the measured
specific enthalpy <i>h<sub>out</sub></i> that is used to
compute the enthalpy flow rate
<i>H&#775; = m&#775; h<sub>out</sub></i>
is computed using a first order differential equation.
See <a href=\"modelica://IDEAS.Fluid.Sensors.UsersGuide\">
IDEAS.Fluid.Sensors.UsersGuide</a> for an explanation.
</p>
<p>
For a sensor that measures the latent enthalpy flow rate, use
<a href=\"modelica://IDEAS.Fluid.Sensors.LatentEnthalpyFlowRate\">
IDEAS.Fluid.Sensors.LatentEnthalpyFlowRate</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 26, 2016, by Michael Wetter:<br/>
Made unit assignment of output signal final.
</li>
<li>
January 18, 2016 by Filip Jorissen:<br/>
Using parameter <code>tauInv</code>
since this now exists in
<a href=\"modelica://IDEAS.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor\">IDEAS.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor</a>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
August 31, 2013, by Michael Wetter:<br/>
Removed default value <code>tau=0</code> as the base class
already sets <code>tau=1</code>.
This change was made so that all sensors use the same default value.
</li>
<li>
June 3, 2011 by Michael Wetter:<br/>
Revised implementation to add dynamics in such a way that
the time constant increases as the mass flow rate tends to zero.
This can improve the numerics.
</li>
<li>
April 9, 2008 by Michael Wetter:<br/>
First implementation.
Implementation is based on enthalpy sensor of <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end EnthalpyFlowRate;

      model MassFlowRate "Ideal sensor for mass flow rate"
        extends IDEAS.Fluid.Sensors.BaseClasses.PartialFlowSensor(
          final m_flow_nominal = 0,
          final m_flow_small = 0);
        extends Modelica.Icons.RotationalSensor;
        Modelica.Blocks.Interfaces.RealOutput m_flow(quantity="MassFlowRate",
                                                     final unit="kg/s")
          "Mass flow rate from port_a to port_b" annotation (Placement(
              transformation(
              origin={0,110},
              extent={{10,-10},{-10,10}},
              rotation=270)));
      equation
        m_flow = port_a.m_flow;
      annotation (defaultComponentName="senMasFlo",
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Line(points={{70,0},{100,0}}, color={0,128,255}),
              Text(
                extent={{162,120},{2,90}},
                lineColor={0,0,0},
                textString="m_flow"),
              Line(points={{0,100},{0,70}}, color={0,0,127}),
              Line(points={{-100,0},{-70,0}}, color={0,128,255})}),
        Documentation(info="<html>
<p>
This model outputs the mass flow rate flowing from
<code>port_a</code> to <code>port_b</code>.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end MassFlowRate;

      model PPM
        "Ideal one port trace substances sensor outputting in parts per million"
        extends IDEAS.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor(
          port(C_outflow(each final quantity="MassFraction",
                         each final unit="1",
                         each min=0,
                         each max=1)));
        extends Modelica.Icons.RotationalSensor;
        parameter String substanceName = "CO2" "Name of trace substance";
        parameter Modelica.SIunits.MolarMass MM=
          Modelica.Media.IdealGases.Common.SingleGasesData.CO2.MM
          "Molar mass of the trace substance";
        Modelica.Blocks.Interfaces.RealOutput ppm(min=0)
          "Trace substance in port medium in ppm"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
        parameter Real s[:]= {
          if ( Modelica.Utilities.Strings.isEqual(string1=Medium.extraPropertiesNames[i],
                                                  string2=substanceName,
                                                  caseSensitive=false))
          then 1 else 0 for i in 1:Medium.nC}
          "Vector with zero everywhere except where species is";
        final parameter Modelica.SIunits.MolarMass MMBul=Medium.molarMass(
          Medium.setState_phX(
            p=Medium.p_default,
            h=Medium.h_default,
            X=Medium.X_default)) "Molar mass of bulk medium";
        final parameter Real MMFraction(
          min=0,
          max=1,
          final unit="1",
          final quantity="MassFraction")=MMBul/MM
          "Molar mass of the medium divided by the molar mass of the trace substance";
        final parameter Real coeff = MMFraction*1e6
          "Conversion from mass fraction to ppm";
      initial equation
        assert(max(s) > 0.9, "Trace substance '" + substanceName + "' is not present in medium '"
               + Medium.mediumName + "'.\n"
               + "Check sensor parameter and medium model.");
      equation
        // We obtain the species concentration with a vector multiplication
        // because Dymola 7.3 cannot find the derivative in the model
        // Buildings.Examples.VAVSystemCTControl.mo
        // if we set C = CVec[ind];
        ppm = s*inStream(port.C_outflow)*coeff;
      annotation (defaultComponentName="senPPM",
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Line(points={{0,-70},{0,-100}}, color={0,0,127}),
              Text(
                extent={{-150,80},{150,120}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{160,-30},{60,-60}},
                lineColor={0,0,0},
                textString="ppm"),
              Line(points={{70,0},{100,0}}, color={0,0,127})}),
        Documentation(info="<html>
<p>
This model outputs the trace substance concentration in ppm contained in the fluid connected to its port.
The sensor is ideal, i.e., it does not influence the fluid.
</p>
<p>
The parameter <code>MM</code> is the molar mass of the trace substance.
For a list of molar masses, see
<a href=\"modelica://Modelica.Media.IdealGases.Common.SingleGasesData\">
Modelica.Media.IdealGases.Common.SingleGasesData</a>
and
<a href=\"modelica://Modelica.Media.IdealGases.Common.FluidData\">
Modelica.Media.IdealGases.Common.FluidData</a>.
</p>
<p>
Read the
<a href=\"modelica://IDEAS.Fluid.Sensors.UsersGuide\">
IDEAS.Fluid.Sensors.UsersGuide</a>
prior to using this model with one fluid port.
</p>
<h4>Assumptions</h4>
<p>
This sensor assumes that the concentration <i>C</i> of the medium
is in mass fraction. Otherwise, the conversion to <i>ppm</i> will be
wrong.
</p>
</html>",       revisions="<html>
<ul>
<li>
December 16, 2015, by Michael Wetter:<br/>
Revised implementation, corrected error in the molar fraction which
used the inverse ratio.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PPM;

      model RelativeHumidity "Ideal one port relative humidity sensor"
        extends IDEAS.Fluid.Sensors.BaseClasses.PartialAbsoluteSensor;
        extends Modelica.Icons.RotationalSensor;
        Modelica.Blocks.Interfaces.RealOutput phi(final unit="1", min=0)
          "Relative humidity in port medium"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
        Modelica.SIunits.Temperature T "Temperature of the medium";
        Medium.MassFraction Xi[Medium.nXi](
          quantity=Medium.substanceNames[1:Medium.nXi]) "Mass fraction of the medium";
      equation
        Xi = inStream(port.Xi_outflow);
        T=Medium.temperature_phX(
            p=port.p,
            h=inStream(port.h_outflow),
            X=Xi);
        phi = IDEAS.Utilities.Psychrometrics.Functions.phi_pTX(
          p=port.p,
          T=T,
          X_w=Xi[1]);
      annotation (defaultComponentName="senRelHum",
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
              graphics={
              Line(points={{0,-70},{0,-100}}, color={0,0,127}),
              Text(
                extent={{-150,80},{150,120}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{160,-30},{60,-60}},
                lineColor={0,0,0},
                textString="phi"),
              Line(points={{70,0},{100,0}}, color={0,0,127})}),
        Documentation(info="<html>
<p>
This model outputs the relative humidity of the fluid connected to its port.
The sensor is ideal, i.e. it does not influence the fluid.
</p>
<p>
Note that this sensor can only be used with media that contain the variable <code>phi</code>,
which is typically the case for moist air models.
</p>
<p>
Read the
<a href=\"modelica://IDEAS.Fluid.Sensors.UsersGuide\">
IDEAS.Fluid.Sensors.UsersGuide</a>
prior to using this model with one fluid port.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 26, 2016 by Michael Wetter:<br/>
Added <code>quantity</code> attribute for mass fraction variables.<br/>
Made unit assignment of output signal final.
</li>
<li>
May 12, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end RelativeHumidity;

      model RelativePressure "Ideal relative pressure sensor"
        extends Modelica.Icons.TranslationalSensor;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the sensor"
            annotation (choices(
              choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
              choice(redeclare package Medium = IDEAS.Media.Water "Water"),
              choice(redeclare package Medium =
                  IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        Modelica.Fluid.Interfaces.FluidPort_a port_a(m_flow(min=0),
                                      p(start=Medium.p_default),
                                      redeclare package Medium = Medium)
          "Fluid connector of stream a"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(m_flow(min=0),
                                      p(start=Medium.p_default),
                                      redeclare package Medium = Medium)
          "Fluid connector of stream b"
          annotation (Placement(transformation(extent={{110,-12},{90,8}}), iconTransformation(extent={{110,-10},{90,10}})));

        Modelica.Blocks.Interfaces.RealOutput p_rel(final quantity="PressureDifference",
                                                    final unit="Pa",
                                                    displayUnit="Pa")
          "Relative pressure of port_a minus port_b" annotation (Placement(transformation(
              origin={0,-90},
              extent={{10,-10},{-10,10}},
              rotation=90)));
      equation
        // Zero flow equations for connectors
        port_a.m_flow = 0;
        port_b.m_flow = 0;

        // No contribution of specific quantities
        port_a.h_outflow = 0;
        port_b.h_outflow = 0;
        port_a.Xi_outflow = zeros(Medium.nXi);
        port_b.Xi_outflow = zeros(Medium.nXi);
        port_a.C_outflow  = zeros(Medium.nC);
        port_b.C_outflow  = zeros(Medium.nC);

        // Relative pressure
        p_rel = port_a.p - port_b.p;
        annotation (defaultComponentName="senRelPre",
          Icon(graphics={
              Line(points={{-100,0},{-70,0}}, color={0,127,255}),
              Line(points={{70,0},{100,0}}, color={0,127,255}),
              Line(points={{0,-30},{0,-80}}, color={0,0,127}),
              Text(
                extent={{-150,40},{150,80}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{130,-70},{4,-100}},
                lineColor={0,0,0},
                textString="p_rel"),
              Line(
                points={{32,3},{-58,3}},
                color={0,128,255}),
              Polygon(
                points={{22,18},{62,3},{22,-12},{22,18}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid)}),
          Documentation(info="<html>
<p>
The relative pressure <code>port_a.p - port_b.p</code> is determined between
the two ports of this component and is provided as output signal. The
sensor should be connected in parallel with other equipment, no flow
through the sensor is allowed.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
February 19, 2016, by Michael Wetter:<br/>
Corrected the quantity of the output signal from <code>Pressure</code>
to <code>PressureDifference</code>.
This was needed for the model
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_m_flow\">
IDEAS.Fluid.Movers.FlowControlled_m_flow</a>
when revising it for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/417\">
issue 417</a>.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation, based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
      end RelativePressure;

      model TemperatureTwoPort "Ideal two port temperature sensor"
        extends IDEAS.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor;
        Modelica.Blocks.Interfaces.RealOutput T(final quantity="ThermodynamicTemperature",
                                                final unit="K",
                                                displayUnit = "degC",
                                                min = 0,
                                                start=T_start)
          "Temperature of the passing fluid"
          annotation (Placement(transformation(
              origin={0,110},
              extent={{10,-10},{-10,10}},
              rotation=270)));
        parameter Modelica.SIunits.Temperature T_start=Medium.T_default
          "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        parameter Boolean transferHeat = false
          "if true, temperature T converges towards TAmb when no flow"
          annotation(Evaluate=true, Dialog(group="Heat transfer"));
        parameter Modelica.SIunits.Temperature TAmb=Medium.T_default
          "Fixed ambient temperature for heat transfer"
          annotation(Dialog(enable=transferHeat, group="Heat transfer"));
        parameter Modelica.SIunits.Time tauHeaTra(min=1)=1200
          "Time constant for heat transfer, default 20 minutes"
          annotation(Dialog(enable=transferHeat, group="Heat transfer"));
    protected
        parameter Real tauHeaTraInv(final unit = "1/s")=
          if tauHeaTra<1E-10 then 0 else 1/tauHeaTra
          "Dummy parameter to avoid division by tauHeaTra";
        parameter Real ratTau = if dynamic then tauHeaTra/tau else 1
          "Ratio of tau";
        Medium.Temperature TMed(start=T_start)
          "Medium temperature to which the sensor is exposed";
        Medium.Temperature T_a_inflow "Temperature of inflowing fluid at port_a";
        Medium.Temperature T_b_inflow
          "Temperature of inflowing fluid at port_b, or T_a_inflow if uni-directional flow";
      initial equation
        if dynamic then
          if initType == Modelica.Blocks.Types.Init.SteadyState then
            der(T) = 0;
           elseif initType == Modelica.Blocks.Types.Init.InitialState or
                 initType == Modelica.Blocks.Types.Init.InitialOutput then
            T = T_start;
          end if;
        end if;
      equation
        if allowFlowReversal then
           T_a_inflow = Medium.temperature(state=
                          Medium.setState_phX(p=port_b.p, h=port_b.h_outflow, X=port_b.Xi_outflow));
           T_b_inflow = Medium.temperature(state=
                          Medium.setState_phX(p=port_a.p, h=port_a.h_outflow, X=port_a.Xi_outflow));
           TMed = Modelica.Fluid.Utilities.regStep(
                    x=port_a.m_flow,
                    y1=T_a_inflow,
                    y2=T_b_inflow,
                    x_small=m_flow_small);
        else
           TMed = Medium.temperature(state=
                    Medium.setState_phX(p=port_b.p, h=port_b.h_outflow, X=port_b.Xi_outflow));
           T_a_inflow = TMed;
           T_b_inflow = TMed;
        end if;
        // Output signal of sensor
        if dynamic then
          if transferHeat then
            der(T) = (TMed-T)*k*tauInv + (TAmb-T)*tauHeaTraInv/(ratTau*k+1);
          else
            der(T) = (TMed-T)*k*tauInv;
          end if;
        else
          T = TMed;
        end if;
      annotation (defaultComponentName="senTem",
          Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
               graphics={
              Line(points={{-100,0},{92,0}}, color={0,128,255}),
              Ellipse(
                extent={{-20,-58},{20,-20}},
                lineColor={0,0,0},
                lineThickness=0.5,
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Line(points={{-40,60},{-12,60}}),
              Line(points={{-40,30},{-12,30}}),
              Line(points={{-40,0},{-12,0}}),
              Rectangle(
                extent={{-12,60},{12,-24}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-12,60},{-12,80},{-10,86},{-6,88},{0,90},{6,88},{10,86},{12,
                    80},{12,60},{-12,60}},
                lineColor={0,0,0},
                lineThickness=0.5),
              Text(
                extent={{102,140},{-18,90}},
                lineColor={0,0,0},
                textString="T"),
              Line(
                points={{-12,60},{-12,-25}},
                thickness=0.5),
              Line(
                points={{12,60},{12,-24}},
                thickness=0.5),
              Line(points={{0,100},{0,50}}, color={0,0,127}),
          Line(
          origin={-77.5,-22.3333},
          points={{43.5,8.3333},{37.5,0.3333},{21.5,-3.6667},{37.5,-17.6667},{7.5,-17.6667},
                    {19.5,-37.6667},{3.5,-38.3333},{-2.5,-48.3333}},
            smooth=Smooth.Bezier,
            visible=transferHeat),
              Polygon(
                points={{-90,-80},{-84,-66},{-76,-74},{-90,-80}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Solid,
                fillColor={0,0,0},
                visible=transferHeat)}),
          Documentation(info="<html>
<p>
This model outputs the temperature of the medium in the flow
between its fluid ports. The sensor does not influence the fluid.
</p>
<h4>Typical use and important parameters</h4>
<p>
If the parameter <code>tau</code> is non-zero, then its output <i>T</i>
converges to the temperature of the incoming fluid using
a first order differential equation.
Setting <code>tau=0</code> is <i>not</i> recommend. See
<a href=\"modelica://IDEAS.Fluid.Sensors.UsersGuide\">
IDEAS.Fluid.Sensors.UsersGuide</a> for an explanation.
</p>
<p>
If <code>transferHeat = true</code>, then heat transfer with the ambient is
approximated and <i>T</i> converges towards the fixed ambient
temperature <i>T<sub>Amb</sub></i> using a first order approximation
with a time constant of <code>tauHeaTra</code>
when the flow rate is small.
Note that no energy is exchanged with the fluid as the
sensor does not influence the fluid temperature.
</p>
<p>
Setting <code>transferHeat = true</code> is useful, for example,
if the sensor is used to measure the fluid temperature in
a system with on/off control on the mass flow rate.
If <code>transferHeat</code> were <code>false</code>, then the sensor output <i>T</i>
would remain constant if the mass flow rate is set to zero, and hence
the controller may never switch the mass flow rate on again.
</p>
<p>
In general, applications in which the sensor output is not used to switch
the mass flow rate on should set <code>transferHeat=false</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
October 23, 2017 by Filip Jorissen:<br/>
Revised implementation of equations 
when <code>transferHeat=true</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/840\">#840</a>.
</li>
<li>
January 12, 2016 by Filip Jorissen:<br/>
Removed parameter <code>tauInv</code>
since this now exists in
<a href=\"modelica://IDEAS.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor\">IDEAS.Fluid.Sensors.BaseClasses.PartialDynamicFlowSensor</a>.
</li>
<li>
June 19, 2015 by Michael Wetter:<br/>
Revised model and documentation.
</li>
<li>
June 18, 2015 by Filip Jorissen:<br/>
Added option for simulating thermal losses.
</li>
<li>
June 3, 2011 by Michael Wetter:<br/>
Revised implementation to add dynamics in such a way that
the time constant increases as the mass flow rate tends to zero.
This significantly improves the numerics.
</li>
<li>
February 26, 2010 by Michael Wetter:<br/>
Set start attribute for temperature output. Prior to this change,
the output was 0 at initial time, which caused the plot of the output to
use 0 Kelvin as the lower value of the ordinate.
</li>
<li>
September 10, 2008, by Michael Wetter:<br/>
First implementation, based on
<a href=\"modelica://IDEAS.Fluid.Sensors.Temperature\">IDEAS.Fluid.Sensors.Temperature</a>.
</li>
</ul>
</html>"));
      end TemperatureTwoPort;

      package BaseClasses "Package with base classes for IDEAS.Fluid.Sensors"
        extends Modelica.Icons.BasesPackage;

        partial model PartialAbsoluteSensor
          "Partial component to model a sensor that measures a potential variable"

          replaceable package Medium=Modelica.Media.Interfaces.PartialMedium
            "Medium in the sensor"
            annotation (choices(
                choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
                choice(redeclare package Medium = IDEAS.Media.Water "Water"),
                choice(redeclare package Medium =
                    IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                      property_T=293.15,
                      X_a=0.40)
                      "Propylene glycol water, 40% mass fraction")));

          Modelica.Fluid.Interfaces.FluidPort_a port(redeclare package Medium=Medium, m_flow(min=0))
            annotation (Placement(transformation(
                origin={0,-100},
                extent={{-10,-10},{10,10}},
                rotation=90)));

        equation
          port.m_flow = 0;
          port.h_outflow = 0;
          port.Xi_outflow = zeros(Medium.nXi);
          port.C_outflow = zeros(Medium.nC);
          annotation (Documentation(info="<html>
<p>
Partial component to model an absolute sensor.
The component can be used for pressure sensor models.
Use for other properties such as temperature or density is discouraged, because the enthalpy at the connector can have different meanings, depending on the connection topology. For these properties, use
<a href=\"modelica://IDEAS.Fluid.Sensors.BaseClasses.PartialFlowSensor\">
IDEAS.Fluid.Sensors.BaseClasses.PartialFlowSensor</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
September 7, 2018, by Michael Wetter:<br/>
Changed
<code>port(redeclare package Medium=Medium, m_flow(min=0, max=0))</code>
to
<code>port(redeclare package Medium=Medium, m_flow(min=0))</code>
to avoid in Dymola 2019FD01 beta1 the message
\"port.m_flow has the range [0,0] - which is suspicious since the max-value should be above the min-value\"
which causes an error in pedantic mode.
Note that the MSL also uses only a <code>min</code> value.
</li>
<li>
March 22, 2017, by Filip Jorissen:<br/>
Set <code>m_flow(max=0)</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/687\">#687</a>.
</li>
<li>
February 12, 2011, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
        end PartialAbsoluteSensor;

        partial model PartialDynamicFlowSensor
          "Partial component to model sensors that measure flow properties using a dynamic model"
          extends PartialFlowSensor;
          parameter Modelica.SIunits.Time tau(min=0) = 1
            "Time constant at nominal flow rate (use tau=0 for steady-state sensor, but see user guide for potential problems)";
          parameter Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState
            "Type of initialization (InitialState and InitialOutput are identical)"
          annotation(Evaluate=true, Dialog(group="Initialization"));
      protected
          Real k(start=1)
            "Gain to take flow rate into account for sensor time constant";
          final parameter Boolean dynamic = tau > 1E-10 or tau < -1E-10
            "Flag, true if the sensor is a dynamic sensor"
            annotation(Evaluate=true);
          Real mNor_flow "Normalized mass flow rate";
          final parameter Real tauInv(final unit="s-1")= if dynamic then 1/tau else 0
            "Inverse of tau";
        equation
          if dynamic then
            mNor_flow = port_a.m_flow/m_flow_nominal;
            k = Modelica.Fluid.Utilities.regStep(x=port_a.m_flow,
                                                 y1= mNor_flow,
                                                 y2=-mNor_flow,
                                                 x_small=m_flow_small);
          else
            mNor_flow = 1;
            k = 1;
          end if;
          annotation (Icon(graphics={
                Line(visible=(tau <> 0),
                points={{52,60},{58,74},{66,86},{76,92},{88,96},{98,96}}, color={0,
                      0,127})}), Documentation(info="<html>
<p>
Partial component to model a sensor that measures any intensive properties
of a flow, e.g., to get temperature or density in the flow
between fluid connectors.</p>
<p>
The sensor computes a gain that is zero at zero mass flow rate.
This avoids fast transients if the flow is close to zero, thereby
improving the numerical efficiency.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 9, 2016, by Michael Wetter:<br/>
Improved documentation for <code>tau</code>.
</li>
<li>
January 12, 2016, by Filip Jorissen:<br/>
Added optional parameter <code>tauInv</code>.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
March 29, 2013, by Michael Wetter:<br/>
Changed the parameter <code>initType</code> to
<code>Modelica.Blocks.Types.Init.InitialState</code>.
This allows a pedantic model check in Dymola 2014 of models that instanciate sensors
but do not set this parameter. It also ensures that different Modelica simulators solve
the same initialization problem.
</li>
<li>
July 7, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end PartialDynamicFlowSensor;

        partial model PartialFlowSensor
          "Partial component to model sensors that measure flow properties"
          extends IDEAS.Fluid.Interfaces.PartialTwoPort;
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal(min=0)
            "Nominal mass flow rate, used for regularization near zero flow"
            annotation(Dialog(group = "Nominal condition"));
          parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*m_flow_nominal
            "For bi-directional flow, temperature is regularized in the region |m_flow| < m_flow_small (m_flow_small > 0 required)"
            annotation(Dialog(tab="Advanced"));
        equation
          // mass balance
          port_b.m_flow = -port_a.m_flow;
          // momentum equation (no pressure loss)
          port_a.p = port_b.p;
          // isenthalpic state transformation (no storage and no loss of energy)
          port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
          port_b.h_outflow = inStream(port_a.h_outflow);
          port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
          port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
          port_b.C_outflow = inStream(port_a.C_outflow);
          annotation (Documentation(info="<html>
<p>
Partial component to model a sensor.
The sensor is ideal. It does not influence mass, energy,
species or substance balance, and it has no flow friction.
</p>
</html>",
        revisions="<html>
<ul>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>,
<code>port_a.h_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">#281</a>.
</li>
<li>
June 19, 2015, by Michael Wetter:<br/>
Moved <code>m_flow_small</code> to the <code>Advanced</code> tab
as it usually need not be changed by the user.
Other models such as heat exchangers also have this parameter
on the <code>Advanced</code> tab.
</li>
<li>
February 12, 2011, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"));
        end PartialFlowSensor;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.Sensors\">IDEAS.Fluid.Sensors</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
Package <code>Sensors</code> consists of idealized sensor components that
provide variables of a medium as
output signals. These signals can be, e.g., further processed
with components of the
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>
library.
</p>
</html>", revisions="<html>
<ul>
<li><i>22 Dec 2008</i>
    by R&uuml;diger Franke
    <ul>
    <li>flow sensors based on Modelica.Fluid.Interfaces.PartialTwoPort</li>
    <li>adapted documentation to stream connectors, i.e. less need for two port sensors</li>
    </ul>
</li>
<li><i>4 Dec 2008</i>
    by Michael Wetter<br/>
       included sensors for trace substance</li>
<li><i>31 Oct 2007</i>
    by Carsten Heinrich<br/>
       updated sensor models, included one and two port sensors for thermodynamic state variables</li>
</ul>
</html>"));
    end Sensors;

    package Sources "Package with boundary condition models"
      extends Modelica.Icons.SourcesPackage;

      model Boundary_pT
        "Boundary with prescribed pressure, temperature, composition and trace substances"
        extends IDEAS.Fluid.Sources.BaseClasses.PartialSource_Xi_C;

        parameter Boolean use_p_in = false
          "Get the pressure from the input connector"
          annotation(Evaluate=true, HideResult=true, Dialog(group="Conditional inputs"));
        parameter Medium.AbsolutePressure p = Medium.p_default
          "Fixed value of pressure"
          annotation (Dialog(enable = not use_p_in, group="Fixed inputs"));

        parameter Boolean use_T_in= false
          "Get the temperature from the input connector"
          annotation(Evaluate=true, HideResult=true,Dialog(group="Conditional inputs"));
        parameter Medium.Temperature T = Medium.T_default
          "Fixed value of temperature"
          annotation (Dialog(enable = not use_T_in,group="Fixed inputs"));

        Modelica.Blocks.Interfaces.RealInput p_in(final unit="Pa") if use_p_in
          "Prescribed boundary pressure"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));

        Modelica.Blocks.Interfaces.RealInput T_in(final unit="K",
                                                  displayUnit="degC") if use_T_in
          "Prescribed boundary temperature"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));

          // Boolean constants to avoid a potential string comparison in an equation section
    protected
        constant Boolean checkWaterPressure = Medium.mediumName == "SimpleLiquidWater"
          "Evaluates to true if the pressure should be checked";
        constant Boolean checkAirPressure = Medium.mediumName == "Air"
          "Evaluates to true if the pressure should be checked";

        Modelica.Blocks.Interfaces.RealInput T_in_internal(final unit="K",
                                                           displayUnit="degC")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput h_internal=
          Medium.specificEnthalpy(Medium.setState_pTX(p_in_internal, T_in_internal, X_in_internal))
          "Internal connector for enthalpy";

      initial equation
        if not use_p_in then
          if checkWaterPressure then
            assert(p_in_internal>1e4, "In "+getInstanceName() +
              ": The parameter value p="+String(p_in_internal)+" is low for water. This is likely an error.");
          end if;
          if checkAirPressure then
            assert(p_in_internal>5e4 and p_in_internal < 1.5e5, "In "+getInstanceName() +
              ": The parameter value p="+String(p_in_internal)+" is not within a realistic range for air. This is likely an error.");
          end if;
        end if;
      equation
        if use_p_in then
          if checkWaterPressure then
            assert(p_in_internal>1e4, "In "+getInstanceName() +
              ": The value of p_in="+String(p_in_internal)+" is low for water. This is likely an error.");
          end if;
          if checkAirPressure then
            assert(p_in_internal>5e4 and p_in_internal < 1.5e5, "In "+getInstanceName() +
              ": The value of p_in="+String(p_in_internal)+" is not within a realistic range for air. This is likely an error.");
          end if;
        end if;
        // Pressure
        connect(p_in, p_in_internal);
        if not use_p_in then
          p_in_internal = p;
        end if;
        for i in 1:nPorts loop
          ports[i].p = p_in_internal;
        end for;

        // Temperature
        connect(T_in, T_in_internal);
        if not use_T_in then
          T_in_internal = T;
        end if;
        for i in 1:nPorts loop
           ports[i].h_outflow  = h_internal;
        end for;
        connect(medium.h, h_internal);
        annotation (defaultComponentName="bou",
          Documentation(info="<html>
<p>
Defines prescribed values for boundary conditions:
</p>
<ul>
<li> Prescribed boundary pressure.</li>
<li> Prescribed boundary temperature.</li>
<li> Boundary composition (only for multi-substance or trace-substance flow).</li>
</ul>
<h4>Typical use and important parameters</h4>
<p>
If <code>use_p_in</code> is false (default option),
the <code>p</code> parameter is used as boundary pressure,
and the <code>p_in</code> input connector is disabled;
if <code>use_p_in</code> is true, then the <code>p</code>
parameter is ignored, and the value provided by the
input connector is used instead.
</p>
<p>
The same applies to the temperature <i>T</i>, composition <i>X<sub>i</sub></i> or <i>X</i> and trace substances <i>C</i>.
</p>
<h4>Options</h4>
<p>
Instead of using <code>Xi_in</code> (the <i>independent</i> composition fractions),
the advanced tab provides an option for setting all
composition fractions using <code>X_in</code>.
<code>use_X_in</code> and <code>use_Xi_in</code> cannot be used
at the same time.
</p>
<p>
Parameter <code>verifyInputs</code> can be set to <code>true</code>
to enable a check that verifies the validity of the used temperatures
and pressures.
This removes the corresponding overhead from the model, which is
a substantial part of the overhead of this model.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>
for more information.
</p>
<p>
Note, that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>",
      revisions="<html>
<ul>
<li>
Juni 7, 2019, by Michael Wetter:<br/>
Added constant boolean expressions to avoid a potential string comparison in an equation section.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1148\">#1148</a>.
</li>
<li>
Juni 4, 2019, by Filip Jorissen:<br/>
Added check for the value of <code>p</code> and <code>p_in</code>.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1148\">#1148</a>.
</li>
<li>
January 25, 2019, by Michael Wetter:<br/>
Refactored use of base classes.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1072\">#1072</a>.
</li>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Made <code>medium</code> conditional and refactored inputs.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
<li>
April 18, 2017, by Filip Jorissen:<br/>
Changed <code>checkBoundary</code> implementation
such that it is run as an initial equation
when it depends on parameters only.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/728\">#728</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>unit</code> and <code>quantity</code> attributes.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
September 29, 2009, by Michael Wetter:<br/>
First implementation.
Implementation is based on <code>Modelica.Fluid</code>.
</li>
</ul>
</html>"),Icon(graphics={
              Text(
                visible=use_p_in,
                extent={{-152,134},{-68,94}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="p"),
              Text(
                visible=use_T_in,
                extent={{-162,34},{-60,-6}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="T"),
               Ellipse(
                extent={{-100,100},{100,-100}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={0,127,255}), Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255})}));
      end Boundary_pT;

      model OutsideAir
        "Outside boundary that takes temperature, pressure, humidity and CO2 from the SimInfoManager"
        extends IDEAS.Fluid.Sources.BaseClasses.PartialSource(final verifyInputs=true);

        outer IDEAS.BoundaryConditions.SimInfoManager sim "SimInfoManager";

    protected
        constant Integer s[:]= {
          if ( Modelica.Utilities.Strings.isEqual(string1=Medium.extraPropertiesNames[i],
                                                  string2="CO2",
                                                  caseSensitive=false))
          then 1 else 0 for i in 1:Medium.nC}
          "Vector with zero everywhere except where species is";

        Modelica.Blocks.Interfaces.RealInput T_in_internal(final unit="K",
                                                           displayUnit="degC")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput h_internal = Medium.specificEnthalpy(
          Medium.setState_pTX(p_in_internal, T_in_internal, X_in_internal));

        IDEAS.BoundaryConditions.WeatherData.Bus bus;

        Modelica.Blocks.Interfaces.RealInput X_wEnv
          "Connector for X_wEnv";
        Modelica.Blocks.Routing.RealPassThrough p_link;

      equation
        connect(bus,sim.weaDatBus);

        connect(p_link.u, bus.pAtm);
        connect(p_link.y,p_in_internal);

        // must use sim.weaBus.Te for linearisation
        T_in_internal = sim.weaBus.Te;

        C_in_internal = {if i==1 then sim.CEnv.y  else 0 for i in s};

        // Check medium properties
        if Medium.nX>1 then
          Modelica.Fluid.Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
            Medium.singleState, true, X_in_internal, "Boundary_pT");
        end if;
        if Medium.nX == 1 then
          X_in_internal = ones(Medium.nX);
        else
          X_in_internal = {X_wEnv, 1-X_wEnv};
        end if;

        connect(X_wEnv, bus.X_wEnv);
        connect(X_in_internal[1:Medium.nXi], Xi_in_internal);

        ports.C_outflow = fill(C_in_internal, nPorts);

        if not verifyInputs then
          h_internal    = Medium.h_default;
          p_in_internal = Medium.p_default;
          X_in_internal = Medium.X_default;
          T_in_internal = Medium.T_default;
        end if;

        // Assign medium properties
        connect(medium.h, h_internal);
        connect(medium.Xi, Xi_in_internal);

        for i in 1:nPorts loop
          ports[i].p          = p_in_internal;
          ports[i].h_outflow  = h_internal;
          ports[i].Xi_outflow = Xi_in_internal;
        end for;

        annotation (
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={2,2}), graphics={
              Ellipse(
                extent={{-98,100},{102,-100}},
                lineColor={0,0,0},
                fillPattern=FillPattern.Sphere,
                fillColor={0,127,255}),
              Text(
                extent={{-150,110},{150,150}},
                textString="%name",
                lineColor={0,0,255}),
              Text(
                extent={{-60,-66},{78,72}},
                lineColor={238,46,47},
                textString="Sim.")}),
          Documentation(info="<html>
<p>
This model describes boundary conditions for
pressure, enthalpy, and CO2 that can be obtained
from weather data.
These data are obtained from the SimInfoManager,
which should be included in the model.
</p>
<p>
Note that boundary temperature,
mass fractions and trace substances have only an effect if the mass flow
is from the boundary into the port. If mass is flowing from
the port into the boundary, the boundary definitions,
with exception of boundary pressure, do not have an effect.
</p>
</html>",
      revisions="<html>
<ul>
<li>
September 21, 2019 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
      end OutsideAir;

      package BaseClasses "Package with base classes for IDEAS.Fluid.Sources"
        extends Modelica.Icons.BasesPackage;

        partial model PartialSource
          "Partial component source with one fluid connector"

          replaceable package Medium =
            Modelica.Media.Interfaces.PartialMedium "Medium in the component"
              annotation (choices(
                choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
                choice(redeclare package Medium = IDEAS.Media.Water "Water"),
                choice(redeclare package Medium =
                    IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                      property_T=293.15,
                      X_a=0.40)
                      "Propylene glycol water, 40% mass fraction")));

          parameter Integer nPorts=0 "Number of ports" annotation(Dialog(connectorSizing=true));
          parameter Boolean verifyInputs = false
            "Set to true to stop the simulation with an error if the medium temperature is outside its allowable range"
            annotation(Evaluate=true, Dialog(tab="Advanced"));

          Modelica.Fluid.Interfaces.FluidPorts_b ports[nPorts](
            redeclare each package Medium = Medium,
            m_flow(each max=if flowDirection == Modelica.Fluid.Types.PortFlowDirection.Leaving
                     then 0 else +Modelica.Constants.inf,
                   each min=if flowDirection == Modelica.Fluid.Types.PortFlowDirection.Entering
                   then 0 else -Modelica.Constants.inf))
            annotation (Placement(transformation(extent={{90,40},{110,-40}})));

      protected
          parameter Modelica.Fluid.Types.PortFlowDirection flowDirection=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
            "Allowed flow direction" annotation (Evaluate=true, Dialog(tab="Advanced"));
          Modelica.Blocks.Interfaces.RealInput p_in_internal(final unit="Pa")
            "Needed to connect to conditional connector";
          Medium.BaseProperties medium if verifyInputs "Medium in the source";
          Modelica.Blocks.Interfaces.RealInput Xi_in_internal[Medium.nXi](
            each final unit = "kg/kg")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput X_in_internal[Medium.nX](
            each final unit = "kg/kg")
            "Needed to connect to conditional connector";
          Modelica.Blocks.Interfaces.RealInput C_in_internal[Medium.nC](
            final quantity=Medium.extraPropertiesNames)
            "Needed to connect to conditional connector";


        initial equation
          // Only one connection allowed to a port to avoid unwanted ideal mixing
          for i in 1:nPorts loop
            assert(cardinality(ports[i]) <= 1,"
Each ports[i] of boundary shall at most be connected to one component.
If two or more connections are present, ideal mixing takes
place in these connections, which is usually not the intention
of the modeller. Increase nPorts to add an additional port.
");       end for;

        equation
          connect(medium.p, p_in_internal);

          annotation (defaultComponentName="bou",
          Documentation(info="<html>
<p>
Partial model for a fluid source that either prescribes
pressure or mass flow rate.
Models that extend this partial model need to prescribe the outflowing
specific enthalpy, composition and trace substances.
This partial model only declares the <code>ports</code>
and ensures that the pressures at all ports are equal.
</p>
<h4>Implementation</h4>
<p>
If the parameter <code>verifyInputs</code> is set to <code>true</code>,
then a protected instance of medium base properties is enabled.
This instance verifies that the
medium temperature is within the bounds <code>T_min</code> and <code>T_max</code>,
where <code>T_min</code> and <code>T_max</code> are constants of the <code>Medium</code>.
If the temperature is outside these bounds, the simulation will stop with an error.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
May 30, 2018, by Michael Wetter:<br/>
Improved documentation.
</li>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Initial version for refactoring inputs of sources.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
</ul>
</html>"));
        end PartialSource;

        partial model PartialSource_Xi_C
          "Partial component source with parameter definitions for Xi and C"
          extends IDEAS.Fluid.Sources.BaseClasses.PartialSource;

          parameter Boolean use_X_in = false
            "Get the composition (all fractions) from the input connector"
            annotation(Evaluate=true, HideResult=true, Dialog(tab="Advanced"));
          parameter Boolean use_Xi_in = false
            "Get the composition (independent fractions) from the input connector"
            annotation(Evaluate=true, HideResult=true, Dialog(group="Conditional inputs"));
          parameter Boolean use_C_in = false
            "Get the trace substances from the input connector"
            annotation(Evaluate=true, HideResult=true, Dialog(group="Conditional inputs"));
          parameter Medium.MassFraction X[Medium.nX](
            final quantity=Medium.substanceNames) = Medium.X_default
            "Fixed value of composition"
            annotation (Dialog(enable = (not use_X_in) and Medium.nXi > 0, group="Fixed inputs"));
          parameter Medium.ExtraProperty C[Medium.nC](
            final quantity=Medium.extraPropertiesNames) = fill(0, Medium.nC)
            "Fixed values of trace substances"
            annotation (Dialog(enable = (not use_C_in) and Medium.nC > 0, group="Fixed inputs"));
          Modelica.Blocks.Interfaces.RealInput X_in[Medium.nX](
            each final unit = "kg/kg",
            final quantity=Medium.substanceNames) if use_X_in
            "Prescribed boundary composition"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput Xi_in[Medium.nXi](
            each final unit = "kg/kg",
            final quantity=Medium.substanceNames[1:Medium.nXi]) if use_Xi_in
            "Prescribed boundary composition"
            annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));
          Modelica.Blocks.Interfaces.RealInput C_in[Medium.nC](
            final quantity=Medium.extraPropertiesNames) if use_C_in
            "Prescribed boundary trace substances"
            annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));

        initial equation
          assert(not use_X_in or not use_Xi_in,
            "Cannot use both X and Xi inputs, choose either use_X_in or use_Xi_in.");

          if not use_X_in and not use_Xi_in then
            Modelica.Fluid.Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
              Medium.singleState, true, X_in_internal, "Boundary_pT");
          end if;

        equation
          if use_X_in or use_Xi_in then
            Modelica.Fluid.Utilities.checkBoundary(Medium.mediumName, Medium.substanceNames,
              Medium.singleState, true, X_in_internal, "Boundary_pT");
          end if;
          connect(X_in[1:Medium.nXi], Xi_in_internal);
          connect(X_in,X_in_internal);
          connect(Xi_in, Xi_in_internal);
          connect(C_in, C_in_internal);

          connect(medium.Xi, Xi_in_internal);
          if not use_X_in and not use_Xi_in then
            Xi_in_internal = X[1:Medium.nXi];
          end if;
          if not use_X_in then
            X_in_internal[1:Medium.nXi] = Xi_in_internal[1:Medium.nXi];
            X_in_internal[Medium.nX] = 1-sum(X_in_internal[1:Medium.nXi]);
          end if;
          if not use_C_in then
            C_in_internal = C;
          end if;

          for i in 1:nPorts loop
            ports[i].Xi_outflow = Xi_in_internal;
            ports[i].C_outflow = C_in_internal;
          end for;


          annotation (
            Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={
                Text(
                  visible=use_X_in,
                  extent={{-164,4},{-62,-36}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="X"),
                Text(
                  visible=use_Xi_in,
                  extent={{-164,4},{-62,-36}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="Xi"),
                Text(
                  visible=use_C_in,
                  extent={{-164,-90},{-62,-130}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="C")}),
                  Documentation(info="<html>
<p>
Partial model that defines outflowing properties
<code>ports.Xi_outflow</code> and <code>ports.C_outflow</code>
using an optional input for both.
Otherwise the parameter value is used.
</p>
</html>",         revisions="<html>
<ul>
<li>
February 13, 2018, by Michael Wetter:<br/>
Corrected error in quantity assignment for <code>Xi_in</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
<li>
February 2nd, 2018 by Filip Jorissen<br/>
Initial version for refactoring inputs of sources.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/882\">#882</a>.
</li>
</ul>
</html>"));
        end PartialSource_Xi_C;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid.Sources\">IDEAS.Fluid.Sources</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info",
    Documentation(info="<html>
<p>
Package <b>Sources</b> contains generic sources for fluid connectors
to define fixed or prescribed ambient conditions.
</p>
</html>"));
    end Sources;

    package Types "Package with type definitions"
      extends Modelica.Icons.TypesPackage;

      type CvTypes = enumeration(
        OpPoint   "flow coefficient defined by m_flow_nominal/sqrt(dp_nominal)",
        Kv   "Kv (metric) flow coefficient",
        Cv   "Cv (US) flow coefficient",
        Av   "Av (metric) flow coefficient")
        "Enumeration to define the choice of valve flow coefficient" annotation (
          Documentation(info="<html>

<p>
Enumeration to define the choice of valve flow coefficient
(to be selected via choices menu):
</p>

<table summary=\"summary\"  border=\"1\">
<tr><th>Enumeration</th>
    <th>Description</th></tr>

<tr><td>OpPoint</td>
    <td>flow coefficient defined by ratio m_flow_nominal/sqrt(dp_nominal)</td></tr>

<tr><td>Kv</td>
    <td>Kv (metric) flow coefficient</td></tr>

<tr><td>Cv</td>
    <td>Cv (US) flow coefficient</td></tr>

<tr><td>Av</td>
    <td>Av (metric) flow coefficient</td></tr>

</table>

<p>
The details of the coefficients are explained in the
<a href=\"modelica://Modelica.Fluid.UsersGuide.ComponentDefinition.ValveCharacteristics\">
Users Guide</a>.
</p>

</html>"));

      type InputType = enumeration(
        Constant   "Use parameter to set stage",
        Stages   "Use integer input to select stage",
        Continuous   "Use continuous, real input") "Input options for movers"
        annotation (Documentation(info="<html>
<p>
This type allows defining which type of input should be used for movers.
This can either be
</p>
<ol>
<li>
a constant set point declared by a parameter,
</li>
<li>
a series of possible set points that can be switched using an integer input, or
</li>
<li>
a continuously variable set point.
</li>
</ol>
</html>",     revisions="<html>
<ul>
<li>
April 2, 2015, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
     annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>"));
    end Types;

    package Interfaces "Package with interfaces for fluid models"
      extends Modelica.Icons.InterfacesPackage;

      model ConservationEquation "Lumped volume with mass and energy balance"

        extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations;

        // Constants
        parameter Boolean initialize_p = not Medium.singleState
          "= true to set up initial equations for pressure"
          annotation(HideResult=true, Evaluate=true, Dialog(tab="Advanced"));

        constant Boolean simplify_mWat_flow = true
          "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero. Used only if Medium.nX > 1";

        // Port definitions
        parameter Integer nPorts=0 "Number of ports"
          annotation(Evaluate=true, Dialog(connectorSizing=true, tab="General",group="Ports"));

        parameter Boolean use_mWat_flow = false
          "Set to true to enable input connector for moisture mass flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transferred into the medium"
          annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       unit="kg/s") if
             use_mWat_flow "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,0},{-100,40}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if
             use_C_flow "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

        // Outputs that are needed in models that use this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                   start=hStart)
          "Leaving specific enthalpy of the component"
           annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));
        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));
        Modelica.Blocks.Interfaces.RealOutput UOut(unit="J")
          "Internal energy of the component" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={110,20})));
        Modelica.Blocks.Interfaces.RealOutput mXiOut[Medium.nXi](each min=0, each unit=
             "kg") "Species mass of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              origin={110,-20})));
        Modelica.Blocks.Interfaces.RealOutput mOut(min=0, unit="kg")
          "Mass of the component" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              origin={110,60})));
        Modelica.Blocks.Interfaces.RealOutput mCOut[Medium.nC](each min=0, each unit="kg")
          "Trace substance mass of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              origin={110,-60})));

        Modelica.Fluid.Vessels.BaseClasses.VesselFluidPorts_b ports[nPorts](
            redeclare each final package Medium = Medium) "Fluid inlets and outlets"
          annotation (Placement(transformation(extent={{-40,-10},{40,10}},
            origin={0,-100})));

        // Set nominal attributes where literal values can be used.
        Medium.BaseProperties medium(
          p(start=p_start),
          h(start=hStart),
          T(start=T_start),
          Xi(start=X_start[1:Medium.nXi]),
          X(start=X_start),
          d(start=rho_start)) "Medium properties";

        Modelica.SIunits.Energy U(start=fluidVolume*rho_start*
          Medium.specificInternalEnergy(Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) +
          (T_start - Medium.reference_T)*CSen,
          nominal = 1E5) "Internal energy of fluid";

        Modelica.SIunits.Mass m(
          start=fluidVolume*rho_start,
          stateSelect=if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState
          then StateSelect.default else StateSelect.prefer)
          "Mass of fluid";

        Modelica.SIunits.Mass[Medium.nXi] mXi(
          start=fluidVolume*rho_start*X_start[1:Medium.nXi])
          "Masses of independent components in the fluid";
        Modelica.SIunits.Mass[Medium.nC] mC(
          start=fluidVolume*rho_start*C_start)
          "Masses of trace substances in the fluid";
        // C need to be added here because unlike for Xi, which has medium.Xi,
        // there is no variable medium.C
        Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)
          "Trace substance mixture content";

        Modelica.SIunits.MassFlowRate mb_flow "Mass flows across boundaries";
        Modelica.SIunits.MassFlowRate[Medium.nXi] mbXi_flow
          "Substance mass flows across boundaries";
        Medium.ExtraPropertyFlowRate[Medium.nC] mbC_flow
          "Trace substance mass flows across boundaries";
        Modelica.SIunits.EnthalpyFlowRate Hb_flow
          "Enthalpy flow across boundaries or energy source/sink";

        // Parameters that need to be defined by an extending class
        parameter Modelica.SIunits.Volume fluidVolume "Volume";
        final parameter Modelica.SIunits.HeatCapacity CSen=
          (mSenFac - 1)*rho_default*cp_default*fluidVolume
          "Aditional heat capacity for implementing mFactor";
    protected
        Medium.EnthalpyFlowRate ports_H_flow[nPorts];
        Modelica.SIunits.MassFlowRate ports_mXi_flow[nPorts,Medium.nXi];
        Medium.ExtraPropertyFlowRate ports_mC_flow[nPorts,Medium.nC];
        parameter Modelica.SIunits.SpecificHeatCapacity cp_default=
        Medium.specificHeatCapacityCp(state=state_default)
          "Heat capacity, to compute additional dry mass";
        parameter Modelica.SIunits.Density rho_start=Medium.density(
         Medium.setState_pTX(
           T=T_start,
           p=p_start,
           X=X_start[1:Medium.nXi])) "Density, used to compute fluid mass";

        // Parameter for avoiding extra overhead calculations when CSen==0
        final parameter Boolean computeCSen = abs(mSenFac-1) > Modelica.Constants.eps
          annotation(Evaluate=true);
        final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
        // Density at medium default values, used to compute the size of control volumes
        final parameter Modelica.SIunits.Density rho_default=Medium.density(
          state=state_default) "Density, used to compute fluid mass";
        // Parameter that is used to construct the vector mXi_flow
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(
                                                  string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";
        parameter Modelica.SIunits.SpecificEnthalpy hStart=
          Medium.specificEnthalpy_pTX(p_start, T_start, X_start)
          "Start value for specific enthalpy";

        // Set _simplify_mWat_flow == false for Glycol47; otherwise Dymola 2018FD01
        // cannot differentiate the equations.
        constant Boolean _simplify_mWat_flow = simplify_mWat_flow and Medium.nX > 1
         "If true, then port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero, and equations are simplified";

        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
          "Needed to connect to conditional connector";

      initial equation
        // Assert that the substance with name 'water' has been found.
        assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "In " + getInstanceName() + ":
         If Medium.nXi > 1, then substance 'water' must be present for one component of '"
               + Medium.mediumName + "'.
         Check medium model.");

        // Make sure that if energyDynamics is SteadyState, then
        // massDynamics is also SteadyState.
        // Otherwise, the system of ordinary differential equations may be inconsistent.
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          assert(massDynamics == energyDynamics, "In " + getInstanceName() + ":
         If 'massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState', then it is
         required that 'energyDynamics==Modelica.Fluid.Types.Dynamics.SteadyState'.
         Otherwise, the system of equations may not be consistent.
         You need to select other parameter values.");
        end if;

        // initialization of balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
            medium.T = T_start;
        else
          if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
              der(medium.T) = 0;
          end if;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          if initialize_p then
            medium.p = p_start;
          end if;
        else
          if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            if initialize_p then
              der(medium.p) = 0;
            end if;
          end if;
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          medium.Xi = X_start[1:Medium.nXi];
        else
          if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(medium.Xi) = zeros(Medium.nXi);
          end if;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.FixedInitial then
          C = C_start[1:Medium.nC];
        else
          if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyStateInitial then
            der(C) = zeros(Medium.nC);
          end if;
        end if;

      equation
        // Conditional connectors
        connect(mWat_flow, mWat_flow_internal);
        if not use_mWat_flow then
          mWat_flow_internal = 0;
        end if;

        connect(C_flow, C_flow_internal);
        if not use_C_flow then
          C_flow_internal = zeros(Medium.nC);
        end if;

        // Total quantities
        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          m = fluidVolume*rho_start;
        else
          if _simplify_mWat_flow then
            // If moisture is neglected in mass balance, assume for computation
            // of the mass of air that the air is at Medium.X_default.
            m = fluidVolume*Medium.density(Medium.setState_phX(
              p = medium.p,
              h = hOut,
              X = Medium.X_default));
          else
            // Use actual density
            m = fluidVolume*medium.d;
          end if;
        end if;
        mXi = m*medium.Xi;
        if computeCSen then
          U = m*medium.u + CSen*(medium.T-Medium.reference_T);
        else
          U = m*medium.u;
        end if;
        mC = m*C;

        hOut = medium.h;
        XiOut = medium.Xi;
        COut = C;

        for i in 1:nPorts loop
          //The semiLinear function should be used for the equations below
          //for allowing min/max simplifications.
          //See https://github.com/ibpsa/modelica-ibpsa/issues/216 for a discussion and motivation
          ports_H_flow[i]     = semiLinear(ports[i].m_flow, inStream(ports[i].h_outflow), ports[i].h_outflow)
            "Enthalpy flow";
          for j in 1:Medium.nXi loop
            ports_mXi_flow[i,j] = semiLinear(ports[i].m_flow, inStream(ports[i].Xi_outflow[j]), ports[i].Xi_outflow[j])
              "Component mass flow";
          end for;
          for j in 1:Medium.nC loop
            ports_mC_flow[i,j]  = semiLinear(ports[i].m_flow, inStream(ports[i].C_outflow[j]),  ports[i].C_outflow[j])
              "Trace substance mass flow";
          end for;
        end for;

        for i in 1:Medium.nXi loop
          mbXi_flow[i] = sum(ports_mXi_flow[:,i]);
        end for;

        for i in 1:Medium.nC loop
          mbC_flow[i]  = sum(ports_mC_flow[:,i]);
        end for;

        mb_flow = sum(ports.m_flow);
        Hb_flow = sum(ports_H_flow);

        // Energy and mass balances
        if energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = Hb_flow + Q_flow;
        else
          der(U) = Hb_flow + Q_flow;
        end if;

        if massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          0 = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
        else
          der(m) = mb_flow + (if simplify_mWat_flow then 0 else mWat_flow_internal);
        end if;

        if substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nXi) = mbXi_flow + mWat_flow_internal * s;
        else
          der(mXi) = mbXi_flow + mWat_flow_internal * s;
        end if;

        if traceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState then
          zeros(Medium.nC)  = mbC_flow + C_flow_internal;
        else
          der(mC)  = mbC_flow + C_flow_internal;
        end if;

        // Properties of outgoing flows
        for i in 1:nPorts loop
            ports[i].p          = medium.p;
            ports[i].h_outflow  = medium.h;
            ports[i].Xi_outflow = medium.Xi;
            ports[i].C_outflow  = C;
        end for;
        UOut=U;
        mXiOut=mXi;
        mOut=m;
        mCOut=mC;
        annotation (
          Documentation(info="<html>
<p>
Basic model for an ideally mixed fluid volume with the ability to store mass and energy.
It implements a dynamic or a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code> then adding
moisture does not increase the mass of the volume or the leaving mass flow rate.
It does however change the mass fraction <code>medium.Xi</code>.
This allows to decouple the moisture balance from the pressure drop equations.
If <code>simplify_mWat_flow = false</code>, then
the outlet mass flow rate is
<i>m<sub>out</sub> = m<sub>in</sub>  (1 + &Delta; X<sub>w</sub>)</i>,
where
<i>&Delta; X<sub>w</sub></i> is the change in water vapor mass
fraction across the component. In this case,
this component couples
the energy calculation to the
pressure drop versus mass flow rate calculations.
However, in typical building HVAC systems,
<i>&Delta; X<sub>w</sub></i> &lt; <i>0.005</i> kg/kg.
Hence, by tolerating a relative error of <i>0.005</i> in the mass balance,
one can decouple these equations.
Decoupling these equations avoids having
to compute the energy balance of the humidifier
and its upstream components when solving for the
pressure drop of downstream components.
Therefore, the default value is <code>simplify_mWat_flow = true</code>.
</p>
<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
The model
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling\">
IDEAS.Fluid.MixingVolumes.Validation.MixingVolumeAdiabaticCooling</a>
shows that the relative error on the temperature difference between these
two options of <code>simplify_mWat_flow</code> is less than
<i>0.1%</i>.
</p>

<h4>Implementation</h4>
<p>
When extending or instantiating this model, the input
<code>fluidVolume</code>, which is the actual volume occupied by the fluid,
needs to be assigned.
For most components, this can be set to a parameter.
</p>
Input connectors of the model are
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can be used as a dynamic model or as a steady-state model.
However, for a steady-state model with exactly two fluid ports connected,
the model
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation\">
IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation</a>
provides a more efficient implementation.
</p>
<p>
For a model that instantiates this model, see
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolume\">
IDEAS.Fluid.MixingVolumes.MixingVolume</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 26, 2019, by Filip Jorissen:<br/>
Returning <code>getInstanceName()</code> in asserts.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1133\">1133</a>.
</li>
<li>
April 16, 2019, by Michael Wetter:<br/>
Changed computation of <code>computeCSen</code> to avoid the volume to become
a structural parameter.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1122\">IDEAS, issue 1122</a>.
</li>
<li>
April 16, 2018, by Michael Wetter:<br/>
Reformulated mass calculation so that Dymola can differentiate the equations.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/910\">IDEAS, issue 910</a>.
</li>
<li>
November 3, 2017, by Michael Wetter:<br/>
Set <code>start</code> attributes.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/727\">727</a>.
</li>
<li>
October 19, 2017, by Michael Wetter:<br/>
Changed initialization of pressure from a <code>constant</code> to a <code>parameter</code>.<br/>
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/1013\">Buildings, issue 1013</a>.
</li>
<li>
January 27, 2017, by Michael Wetter:<br/>
Added <code>stateSelect</code> for mass <code>m</code>.<br/>
This is for <a href=\"https://github.com/lbl-srg/modelica-buildings/issues/642\">
Buildings, #642</a>.
</li>
<li>
December 22, 2016, by Michael Wetter:<br/>
Set nominal value for <code>U</code>.<br/>
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/637\">637</a>.
</li>
<li>
February 19, 2016 by Filip Jorissen:<br/>
Added outputs UOut, mOut, mXiOut, mCOut for being able to
check conservation of quantities.
This is for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">
issue 247</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Added <code>C_flow</code> to the steady-state trace substance balance,
and removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
</li>
<li>
September 3, 2015, by Filip Jorissen and Michael Wetter:<br/>
Revised implementation for allowing moisture mass flow rate
to be approximated using parameter <code>simplify_mWat_flow</code>.
This may lead to smaller algebraic loops.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
June 5, 2015 by Michael Wetter:<br/>
Removed <code>preferredMediumStates= false</code> in
the instance <code>medium</code> as the default
is already <code>false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015 by Filip Jorissen:<br/>
Removed <pre>
Xi(start=X_start[1:Medium.nXi],
       each stateSelect=if (not (substanceDynamics == Modelica.Fluid.Types.Dynamics.SteadyState))
       then StateSelect.prefer else StateSelect.default),
</pre>
and set
<code>preferredMediumStates = false</code>
because the previous declaration led to more equations and
translation problems in large models.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Moved assignment of <code>dynBal.U.start</code>
from instance <code>dynBal</code> of <code>PartialMixingVolume</code>
to this model implementation.
This is required for a pedantic model check in Dymola 2016.
It addresses
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">
issue 266</a>.
This revison also renames the protected variable
<code>rho_nominal</code> to <code>rho_start</code>
as it depends on the start values and not the nominal values.
</li>
<li>
May 22, 2015 by Michael Wetter:<br/>
Removed <pre>
p(stateSelect=if not (massDynamics == Modelica.Fluid.Types.Dynamics.SteadyState)
then StateSelect.prefer else StateSelect.default)
</pre>
because the previous declaration led to the translation error
<pre>
The model requires derivatives of some inputs as listed below:
1 inlet.m_flow
1 inlet.p
</pre>
when translating
<code>Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.HeaterCooler_u</code>
with a dynamic energy balance.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
April 13, 2015, by Filip Jorissen:<br/>
Now using <code>semiLinear()</code> function for calculation of
<code>ports_H_flow</code>. This enables Dymola to simplify based on
the <code>min</code> and <code>max</code> attribute of the mass flow rate.
</li>
<li>
February 16, 2015, by Filip Jorissen:<br/>
Fixed SteadyState massDynamics implementation for compressible media.
Mass <code>m</code> is now constant.
</li>
<li>
February 5, 2015, by Michael Wetter:<br/>
Changed <code>initalize_p</code> from a <code>parameter</code> to a
<code>constant</code>. This is only required in finite volume models
of heat exchangers (to avoid consistent but redundant initial conditions)
and hence it should be set as a <code>constant</code>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Set start attributes in <code>medium</code> to avoid in OpenModelica the warning
alias set with several free start values.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
July 3, 2014, by Michael Wetter:<br/>
Added parameter <code>initialize_p</code>. This is required
to enable the coil models to initialize the pressure in the first
volume, but not in the downstream volumes. Otherwise,
the initial equations will be overdetermined, but consistent.
This change was done to avoid a long information message that appears
when translating models.
</li>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>
September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.<br/>
Corrected the syntax error
<code>Medium.ExtraProperty C[Medium.nC](each nominal=C_nominal)</code>
to
<code>Medium.ExtraProperty C[Medium.nC](nominal=C_nominal)</code>
because <code>C_nominal</code> is a vector.
This syntax error caused a compilation error in OpenModelica.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
July 31, 2011 by Michael Wetter:<br/>
Added test to stop model translation if the setting for
<code>energyBalance</code> and <code>massBalance</code>
can lead to inconsistent equations.
</li>
<li>
July 26, 2011 by Michael Wetter:<br/>
Removed the option to use <code>h_start</code>, as this
is not needed for building simulation.
Also removed the reference to <code>Modelica.Fluid.System</code>.
Moved parameters and medium to
<a href=\"IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations\">
IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations</a>.
</li>
<li>
July 14, 2011 by Michael Wetter:<br/>
Added start value for medium density.
</li>
<li>
March 29, 2011 by Michael Wetter:<br/>
Changed default value for <code>substanceDynamics</code> and
<code>traceDynamics</code> from <code>energyDynamics</code>
to <code>massDynamics</code>.
</li>
<li>
September 28, 2010 by Michael Wetter:<br/>
Changed array index for nominal value of <code>Xi</code>.
</li>
<li>
September 13, 2010 by Michael Wetter:<br/>
Set nominal attributes for medium based on default medium values.
</li>
<li>
July 30, 2010 by Michael Wetter:<br/>
Added parameter <code>C_nominal</code> which is used as the nominal attribute for <code>C</code>.
Without this value, the ODE solver gives wrong results for concentrations around 1E-7.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li><i>February 6, 2010</i> by Michael Wetter:<br/>
Added to <code>Medium.BaseProperties</code> the initialization
<code>X(start=X_start[1:Medium.nX])</code>. Previously, the initialization
was only done for <code>Xi</code> but not for <code>X</code>, which caused the
medium to be initialized to <code>reference_X</code>, ignoring the value of <code>X_start</code>.
</li>
<li><i>October 12, 2009</i> by Michael Wetter:<br/>
Implemented first version in <code>Buildings</code> library, based on model from
<code>Modelica.Fluid 1.0</code>.
</li>
</ul>
</html>"),Icon(graphics={            Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-89,17},{-54,34}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-89,52},{-54,69}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-42,-28},{-6,-28},{18,4},{40,12},{66,14}},
                color={255,255,255},
                smooth=Smooth.Bezier),
              Text(
                extent={{-155,-120},{145,-160}},
                lineColor={0,0,255},
                textString="%name")}));
      end ConservationEquation;

      model IdealSource
        "Base class for pressure and mass flow source with optional power input"
        extends IDEAS.Fluid.Movers.BaseClasses.IdealSource(m_flow_small=Modelica.Constants.small);
        annotation (Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,60},{100,-60}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,50},{100,-48}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Text(
                visible=not control_m_flow,
                extent={{24,44},{80,24}},
                lineColor={255,255,255},
                textString="dp"),
              Text(
                visible=control_m_flow,
                extent={{-80,44},{-24,24}},
                lineColor={255,255,255},
                textString="m")}),
          Documentation(info="<html>
<p>
Model of a fictitious pipe that is used as a base class
for a pressure source or to prescribe a mass flow rate.
</p>
<p>
Note that for fans and pumps with dynamic balance,
both the heat and the flow work are added to the volume of
air or water. This simplifies the equations compared to 
adding heat to the volume, and flow work to this model.
</p>
</html>",
      revisions="<html>
<ul>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
May 25, 2011 by Michael Wetter:<br/>
Removed the option to add power to the medium, as this is dealt with in the volume
that is used in the mover model.
</li>
<li>
July 27, 2010 by Michael Wetter:<br/>
Redesigned model to fix bug in medium balance.
</li>
<li>
April 13, 2010 by Michael Wetter:<br/>
Made heat connector optional.
</li>
<li>
March 23, 2010 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Diagram(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{
                  100,100}}),
                          graphics));
      end IdealSource;

      partial model PartialFourPort "Partial model with four ports"

        replaceable package Medium1 =
          Modelica.Media.Interfaces.PartialMedium "Medium 1 in the component"
            annotation (choices(
              choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
              choice(redeclare package Medium = IDEAS.Media.Water "Water"),
              choice(redeclare package Medium =
                  IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));
        replaceable package Medium2 =
          Modelica.Media.Interfaces.PartialMedium "Medium 2 in the component"
            annotation (choices(
              choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
              choice(redeclare package Medium = IDEAS.Media.Water "Water"),
              choice(redeclare package Medium =
                  IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                property_T=293.15,
                X_a=0.40)
                "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal1 = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 1"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Boolean allowFlowReversal2 = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal for medium 2"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a1(
                           redeclare final package Medium = Medium1,
                           m_flow(min=if allowFlowReversal1 then -Modelica.Constants.inf else 0),
                           h_outflow(start = Medium1.h_default, nominal = Medium1.h_default))
          "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{-110,50},{-90,70}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b1(
                           redeclare final package Medium = Medium1,
                           m_flow(max=if allowFlowReversal1 then +Modelica.Constants.inf else 0),
                           h_outflow(start = Medium1.h_default, nominal = Medium1.h_default))
          "Fluid connector b1 (positive design flow direction is from port_a1 to port_b1)"
          annotation (Placement(transformation(extent={{110,50},{90,70}})));

        Modelica.Fluid.Interfaces.FluidPort_a port_a2(
                           redeclare final package Medium = Medium2,
                           m_flow(min=if allowFlowReversal2 then -Modelica.Constants.inf else 0),
                           h_outflow(start = Medium2.h_default, nominal = Medium2.h_default))
          "Fluid connector a2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{90,-70},{110,-50}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b2(
                           redeclare final package Medium = Medium2,
                           m_flow(max=if allowFlowReversal2 then +Modelica.Constants.inf else 0),
                           h_outflow(start = Medium2.h_default, nominal = Medium2.h_default))
          "Fluid connector b2 (positive design flow direction is from port_a2 to port_b2)"
          annotation (Placement(transformation(extent={{-90,-70},{-110,-50}})));

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model defines an interface for components with four ports.
The parameters <code>allowFlowReversal1</code> and
<code>allowFlowReversal2</code> may be used by models that extend
this model to treat flow reversal.
</p>
<p>
This model is identical to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>, except for the
fowllowing:
</p>
<ol>
<li>it has four ports, and
</li>
<li>
the parameters <code>port_a_exposesState</code>,
<code>port_b_exposesState</code> and
<code>showDesignFlowDirection</code>
are not implemented.
</li>
</ol>
</html>",       revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Renamed model from <code>FourPort</code> to
<code>PartialFourPort</code>.
Removed parameters
<code>h_outflow_a1_start</code>,
<code>h_outflow_b1_start</code>,
<code>h_outflow_a2_start</code> and
<code>h_outflow_b2_start</code>.
This is for issue
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/299\">#299</a>.
</li>
<li>
October 30, 2015, by Matthis Thorade:<br/>
Added <code>partial</code> keyword to model declaration.
</li>
<li>
October 6, 2014, by Michael Wetter:<br/>
Changed medium declaration in ports to be final.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants</code> statement.
</li>
<li>
September 26, 2013 by Michael Wetter:<br/>
Added missing <code>each</code> keyword in declaration of nominal value for
<code>Xi_outflow</code>.
</li>
<li>
September 17, 2010 by Michael Wetter:<br/>
Fixed bug: The start value for <code>port_b1.h_outflow</code>
was set to <code>h_outflow_b2_start</code> instead of <code>h_outflow_b1_start</code>.
</li>
<li>
February 26, 2010 by Michael Wetter:<br/>
Added start values for outflowing enthalpy because they
are often iteration variables in nonlinear equation systems.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics={Text(
                extent={{-151,147},{149,107}},
                lineColor={0,0,255},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255},
                textString="%name")}));
      end PartialFourPort;

      partial model PartialFourPortInterface
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialFourPort;
        parameter Modelica.SIunits.MassFlowRate m1_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m2_flow_nominal(min=0)
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Medium1.MassFlowRate m1_flow_small(min=0) = 1E-4*abs(m1_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium2.MassFlowRate m2_flow_small(min=0) = 1E-4*abs(m2_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
        parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        Medium1.MassFlowRate m1_flow = port_a1.m_flow
          "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction)";
        Modelica.SIunits.PressureDifference dp1(displayUnit="Pa") = port_a1.p - port_b1.p
          "Pressure difference between port_a1 and port_b1";
        Medium2.MassFlowRate m2_flow = port_a2.m_flow
          "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction)";
        Modelica.SIunits.PressureDifference dp2(displayUnit="Pa") = port_a2.p - port_b2.p
          "Pressure difference between port_a2 and port_b2";
        Medium1.ThermodynamicState sta_a1=
            Medium1.setState_phX(port_a1.p,
                                 noEvent(actualStream(port_a1.h_outflow)),
                                 noEvent(actualStream(port_a1.Xi_outflow))) if
               show_T "Medium properties in port_a1";
        Medium1.ThermodynamicState sta_b1=
            Medium1.setState_phX(port_b1.p,
                                 noEvent(actualStream(port_b1.h_outflow)),
                                 noEvent(actualStream(port_b1.Xi_outflow))) if
               show_T "Medium properties in port_b1";
        Medium2.ThermodynamicState sta_a2=
            Medium2.setState_phX(port_a2.p,
                                 noEvent(actualStream(port_a2.h_outflow)),
                                 noEvent(actualStream(port_a2.Xi_outflow))) if
               show_T "Medium properties in port_a2";
        Medium2.ThermodynamicState sta_b2=
            Medium2.setState_phX(port_b2.p,
                                 noEvent(actualStream(port_b2.h_outflow)),
                                 noEvent(actualStream(port_b2.Xi_outflow))) if
               show_T "Medium properties in port_b2";
    protected
        Medium1.ThermodynamicState state_a1_inflow=
          Medium1.setState_phX(port_a1.p, inStream(port_a1.h_outflow), inStream(port_a1.Xi_outflow))
          "state for medium inflowing through port_a1";
        Medium1.ThermodynamicState state_b1_inflow=
          Medium1.setState_phX(port_b1.p, inStream(port_b1.h_outflow), inStream(port_b1.Xi_outflow))
          "state for medium inflowing through port_b1";
        Medium2.ThermodynamicState state_a2_inflow=
          Medium2.setState_phX(port_a2.p, inStream(port_a2.h_outflow), inStream(port_a2.Xi_outflow))
          "state for medium inflowing through port_a2";
        Medium2.ThermodynamicState state_b2_inflow=
          Medium2.setState_phX(port_b2.p, inStream(port_b2.h_outflow), inStream(port_b2.Xi_outflow))
          "state for medium inflowing through port_b2";
        annotation (
        preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models that
transport two fluid streams between four ports.
It is similar to
<a href=\"modelica://IDEAS.Fluid.Interfaces.PartialTwoPortInterface\">
IDEAS.Fluid.Interfaces.PartialTwoPortInterface</a>,
but it has four ports instead of two.
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Removed assignment of <code>min</code> and <code>max</code>
attributes of port mass flow rates, as this is already
done in the base class.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a1</code>,
<code>sta_a2</code>, <code>sta_b1</code> and <code>sta_b2</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definitions of <code>dp1</code> and <code>dp2</code> because they cause some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Replaced the erroneous function call <code>Medium.density</code> with
<code>Medium1.density</code> and <code>Medium2.density</code>.
Changed condition to remove <code>sta_a1</code> and <code>sta_a2</code> to also
compute the states at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
April 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialFourPortInterface;

      partial model PartialTwoPort "Partial component with two ports"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choices(
              choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
              choice(redeclare package Medium = IDEAS.Media.Water "Water"),
              choice(redeclare package Medium =
                  IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        parameter Boolean allowFlowReversal = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);

        Modelica.Fluid.Interfaces.FluidPort_a port_a(
          redeclare final package Medium = Medium,
           m_flow(min=if allowFlowReversal then -Modelica.Constants.inf else 0),
           h_outflow(start = Medium.h_default, nominal = Medium.h_default))
          "Fluid connector a (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_b(
          redeclare final package Medium = Medium,
          m_flow(max=if allowFlowReversal then +Modelica.Constants.inf else 0),
           h_outflow(start = Medium.h_default, nominal = Medium.h_default))
          "Fluid connector b (positive design flow direction is from port_a to port_b)"
          annotation (Placement(transformation(extent={{110,-10},{90,10}})));

        annotation (
          Documentation(info="<html>
<p>
This partial model defines an interface for components with two ports.
The treatment of the design flow direction and of flow reversal are predefined based on the parameter <code>allowFlowReversal</code>.
The component may transport fluid and may have internal storage for a given fluid <code>Medium</code>.
</p>
<h4>Implementation</h4>
<p>
This model is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPort\">
Modelica.Fluid.Interfaces.PartialTwoPort</a>
but it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed parameters
<code>port_a_exposesState</code> and
<code>port_b_exposesState</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/351\">#351</a>
and
<code>showDesignFlowDirection</code>
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
November 13, 2015, by Michael Wetter:<br/>
Assinged <code>start</code> attribute for leaving
enthalpy at <code>port_a</code> and <code>port_b</code>.
This was done to make the model similar to
<a href=\"modelica://IDEAS.Fluid.Interfaces.PartialFourPort\">
IDEAS.Fluid.Interfaces.PartialFourPort</a>.
</li>
<li>
November 12, 2015, by Michael Wetter:<br/>
Removed import statement.
</li>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
Declared medium in ports to be <code>final</code>.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}}), graphics={
              Polygon(
                points={{20,-70},{60,-85},{20,-100},{20,-70}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=not allowFlowReversal),
              Line(
                points={{55,-85},{-60,-85}},
                color={0,128,255},
                visible=not allowFlowReversal),
              Text(
                extent={{-149,-114},{151,-154}},
                lineColor={0,0,255},
                textString="%name")}));
      end PartialTwoPort;

      partial model PartialTwoPortInterface
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialTwoPort(
          port_a(p(start=Medium.p_default)),
          port_b(p(start=Medium.p_default)));
        parameter Modelica.SIunits.MassFlowRate m_flow_nominal
          "Nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Modelica.SIunits.MassFlowRate m_flow_small(min=0) = 1E-4*abs(m_flow_nominal)
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
         parameter Boolean show_T = false
          "= true, if actual temperature at port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        Modelica.SIunits.MassFlowRate m_flow(start=_m_flow_start) = port_a.m_flow
          "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction)";
        Modelica.SIunits.PressureDifference dp(start=_dp_start, displayUnit="Pa") = port_a.p - port_b.p
          "Pressure difference between port_a and port_b";
        Medium.ThermodynamicState sta_a=
            Medium.setState_phX(port_a.p,
                                noEvent(actualStream(port_a.h_outflow)),
                                noEvent(actualStream(port_a.Xi_outflow))) if
               show_T "Medium properties in port_a";
        Medium.ThermodynamicState sta_b=
            Medium.setState_phX(port_b.p,
                                noEvent(actualStream(port_b.h_outflow)),
                                noEvent(actualStream(port_b.Xi_outflow))) if
                show_T "Medium properties in port_b";
    protected
        final parameter Modelica.SIunits.MassFlowRate _m_flow_start = 0
        "Start value for m_flow, used to avoid a warning if not set in m_flow, and to avoid m_flow.start in parameter window";
        final parameter Modelica.SIunits.PressureDifference _dp_start(displayUnit="Pa") = 0
        "Start value for dp, used to avoid a warning if not set in dp, and to avoid dp.start in parameter window";
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component defines the interface for models that
transports a fluid between two ports. It is similar to
<a href=\"Modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>, but it does not
include the species balance
</p>
<pre>
  port_b.Xi_outflow = inStream(port_a.Xi_outflow);
</pre>
<p>
Thus, it can be used as a base class for a heat <i>and</i> mass transfer component
</p>
<p>
The model is used by other models in this package that add heat transfer,
mass transfer and pressure drop equations. See for example
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Renamed protected parameter <code>m_flow_start</code> to avoid
a name clash with
<a href=\"modelica://IDEAS.Fluid.Movers.FlowControlled_m_flow\">
IDEAS.Fluid.Movers.FlowControlled_m_flow</a>
which leads to an error as the definition were different,
and also renamed protected parameter <code>dp_start</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>
<br/>
Moved computation of pressure drop to variable assignment so that
the model won't mix graphical with textual modeling if used as a base
class for a graphically implemented model.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start values for mass flow rate and pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 12, 2013 by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
November 11, 2013 by Michael Wetter:<br/>
Removed the parameter <code>homotopyInitialization</code>
as it is no longer used in this model.
</li>
<li>
November 10, 2013 by Michael Wetter:<br/>
In the computation of <code>sta_a</code> and <code>sta_b</code>,
removed the branch that uses the homotopy operator.
The rational is that these variables are conditionally enables (because
of <code>... if show_T</code>). Therefore, the Modelica Language Specification
does not allow for these variables to be used in any equation. Hence,
the use of the homotopy operator is not needed here.
</li>
<li>
October 10, 2013 by Michael Wetter:<br/>
Added <code>noEvent</code> to the computation of the states at the port.
This is correct, because the states are only used for reporting, but not
to compute any other variable.
Use of the states to compute other variables would violate the Modelica
language, as conditionally removed variables must not be used in any equation.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed the computation of <code>V_flow</code> and removed the parameter
<code>show_V_flow</code>.
The reason is that the computation of <code>V_flow</code> required
the use of <code>sta_a</code> (to compute the density),
but <code>sta_a</code> is also a variable that is conditionally
enabled. However, this was not correct Modelica syntax as conditional variables
can only be used in a <code>connect</code>
statement, not in an assignment. Dymola 2014 FD01 beta3 is checking
for this incorrect syntax. Hence, <code>V_flow</code> was removed as its
conditional implementation would require a rather cumbersome implementation
that uses a new connector that carries the state of the medium.
</li>
<li>
April 26, 2013 by Marco Bonvini:<br/>
Moved the definition of <code>dp</code> because it causes some problem with PyFMI.
</li>
<li>
March 27, 2012 by Michael Wetter:<br/>
Changed condition to remove <code>sta_a</code> to also
compute the state at the inlet port if <code>show_V_flow=true</code>.
The previous implementation resulted in a translation error
if <code>show_V_flow=true</code>, but worked correctly otherwise
because the erroneous function call is removed if  <code>show_V_flow=false</code>.
</li>
<li>
March 27, 2011 by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 21, 2010 by Michael Wetter:<br/>
Changed pressure start value from <code>system.p_start</code>
to <code>Medium.p_default</code> since HVAC models may have water and
air, which are typically at different pressures.
</li>
<li>
September 19, 2008 by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
March 11, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortInterface;

      partial model PartialTwoPortTransport
        "Partial element transporting fluid between two ports without storage of mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialTwoPort;
        // Advanced
        // Note: value of dp_start shall be refined by derived model,
        // based on local dp_nominal
        parameter Modelica.SIunits.PressureDifference dp_start(displayUnit="Pa") = 0
          "Guess value of dp = port_a.p - port_b.p"
          annotation(Dialog(tab = "Advanced"));
        parameter Medium.MassFlowRate m_flow_start = 0
          "Guess value of m_flow = port_a.m_flow"
          annotation(Dialog(tab = "Advanced"));
        // Note: value of m_flow_small shall be refined by derived model,
        // based on local m_flow_nominal
        parameter Medium.MassFlowRate m_flow_small
          "Small mass flow rate for regularization of zero flow"
          annotation(Dialog(tab = "Advanced"));
        // Diagnostics
        parameter Boolean show_T = true
          "= true, if temperatures at port_a and port_b are computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        parameter Boolean show_V_flow = true
          "= true, if volume flow rate at inflowing port is computed"
          annotation(Dialog(tab="Advanced",group="Diagnostics"));
        // Variables
        Medium.MassFlowRate m_flow(
           min=if allowFlowReversal then -Modelica.Constants.inf else 0,
           start = m_flow_start) "Mass flow rate in design flow direction";
        Modelica.SIunits.PressureDifference dp(start=dp_start,
                                               displayUnit="Pa")
          "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
        Modelica.SIunits.VolumeFlowRate V_flow=
            m_flow/Modelica.Fluid.Utilities.regStep(m_flow,
                        Medium.density(
                          Medium.setState_phX(
                            p = port_a.p,
                            h = inStream(port_a.h_outflow),
                            X = inStream(port_a.Xi_outflow))),
                        Medium.density(
                             Medium.setState_phX(
                               p = port_b.p,
                               h = inStream(port_b.h_outflow),
                               X = inStream(port_b.Xi_outflow))),
                        m_flow_small) if show_V_flow
          "Volume flow rate at inflowing port (positive when flow from port_a to port_b)";
        Medium.Temperature port_a_T=
            Modelica.Fluid.Utilities.regStep(port_a.m_flow,
                        Medium.temperature(
                          Medium.setState_phX(
                            p = port_a.p,
                            h = inStream(port_a.h_outflow),
                            X = inStream(port_a.Xi_outflow))),
                        Medium.temperature(Medium.setState_phX(port_a.p, port_a.h_outflow, port_a.Xi_outflow)),
                        m_flow_small) if show_T
          "Temperature close to port_a, if show_T = true";
        Medium.Temperature port_b_T=
            Modelica.Fluid.Utilities.regStep(port_b.m_flow,
                        Medium.temperature(
                          Medium.setState_phX(
                            p = port_b.p,
                            h = inStream(port_b.h_outflow),
                            X = inStream(port_b.Xi_outflow))),
                        Medium.temperature(Medium.setState_phX(port_b.p, port_b.h_outflow, port_b.Xi_outflow)),
                        m_flow_small) if show_T
          "Temperature close to port_b, if show_T = true";
      equation
        // Pressure drop in design flow direction
        dp = port_a.p - port_b.p;
        // Design direction of mass flow rate
        m_flow = port_a.m_flow;
        assert(m_flow > -m_flow_small or allowFlowReversal,
            "Reverting flow occurs even though allowFlowReversal is false");
        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;
        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);
        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);
        annotation (
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without storing mass or energy.
Energy may be exchanged with the environment though, e.g., in the form of work.
<code>PartialTwoPortTransport</code> is intended as base class for devices like orifices, valves and simple fluid machines.</p>
<p>
Three equations need to be added by an extending class using this component:
</p>
<ul>
<li>The momentum balance specifying the relationship between the pressure drop <code>dp</code> and the mass flow rate <code>m_flow</code>,</li>
<li><code>port_b.h_outflow</code> for flow in design direction, and</li>
<li><code>port_a.h_outflow</code> for flow in reverse direction.</li>
</ul>
<p>
Moreover appropriate values shall be assigned to the following parameters:
</p>
<ul>
<li><code>dp_start</code> for a guess of the pressure drop</li>
<li><code>m_flow_small</code> for regularization of zero flow.</li>
</ul>
<h4>Implementation</h4>
<p>
This is similar to
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a>
except that it does not use the <code>outer system</code> declaration.
This declaration is omitted as in building energy simulation,
many models use multiple media, an in practice,
users have not used this global definition to assign parameters.
</p>
</html>",       revisions="<html>
<ul>
<li>
September 15, 2016, by Michael Wetter:<br/>
Removed wrong annotation, which caused an error in the pedantic model check
of Dymola 2017 FD01.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/516\">#516</a>.
</li>
<li>
January 22, 2016, by Henning Francke:<br/>
Corrected type declaration of pressure.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignments of parameters
<code>port_a_exposesState</code> and
<code>port_b_exposesState</code> in base class.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/351\">#351</a>.
</li>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/305\">#305</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Removed protected conditional variables <code>state_a</code> and <code>state_b</code>,
as they were used outside of a connect statement, which causes an
error during pedantic model check in Dymola 2016.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/128\">#128</a>.
</li>
<li>
April 1, 2015, by Michael Wetter:<br/>
Made computation of <code>state_a</code> and <code>state_p</code>
conditional on <code>show_T</code> or <code>show_V_flow</code>.
This avoids computing temperature from enthalpy if temperature is
a state of the medium, and the result is not used.
</li>
<li>
October 21, 2014, by Michael Wetter:<br/>
Revised implementation.
</li>
<li>
October 20, 2014, by Filip Jorisson:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialTwoPortTransport;

      model StaticFourPortHeatMassExchanger
        "Partial model transporting two fluid streams between four ports without storing mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialFourPortInterface;
        extends IDEAS.Fluid.Interfaces.FourPortFlowResistanceParameters(
         final computeFlowResistance1=(dp1_nominal > Modelica.Constants.eps),
         final computeFlowResistance2=(dp2_nominal > Modelica.Constants.eps));
        constant Boolean prescribedHeatFlowRate1 = false
          "Set to true if the heat flow rate into fluid 1 is not a function of the component temperature";
        constant Boolean prescribedHeatFlowRate2 = false
          "Set to true if the heat flow rate into fluid 2 is not a function of the component temperature";
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        // Q1_flow is sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q1_flow
          "Heat transferred into the medium 1";
        input Medium1.MassFlowRate mWat1_flow
          "Moisture mass flow rate added to the medium 1";
        // Q2_flow is sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q2_flow
          "Heat transferred into the medium 2";
        input Medium2.MassFlowRate mWat2_flow
          "Moisture mass flow rate added to the medium 2";
        constant Boolean sensibleOnly1
          "Set to true if sensible exchange only for medium 1";
        constant Boolean sensibleOnly2
          "Set to true if sensible exchange only for medium 2";
    protected
        IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal1(
          redeclare final package Medium=Medium1,
          final sensibleOnly = sensibleOnly1,
          final prescribedHeatFlowRate=prescribedHeatFlowRate1,
          final m_flow_nominal = m1_flow_nominal,
          final dp_nominal = dp1_nominal,
          final allowFlowReversal = allowFlowReversal1,
          final m_flow_small = m1_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final from_dp = from_dp1,
          final linearizeFlowResistance = linearizeFlowResistance1,
          final deltaM = deltaM1,
          final Q_flow = Q1_flow,
          final mWat_flow = mWat1_flow)
          "Model for heat, mass, species, trace substance and pressure balance of stream 1";
        IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger bal2(
          redeclare final package Medium=Medium2,
          final sensibleOnly = sensibleOnly2,
          final prescribedHeatFlowRate=prescribedHeatFlowRate2,
          final m_flow_nominal = m2_flow_nominal,
          final dp_nominal = dp2_nominal,
          final allowFlowReversal = allowFlowReversal2,
          final m_flow_small = m2_flow_small,
          final homotopyInitialization = homotopyInitialization,
          final from_dp = from_dp2,
          final linearizeFlowResistance = linearizeFlowResistance2,
          final deltaM = deltaM2,
          final Q_flow = Q2_flow,
          final mWat_flow = mWat2_flow)
          "Model for heat, mass, species, trace substance and pressure balance of stream 2";
      equation
        connect(bal1.port_a, port_a1);
        connect(bal1.port_b, port_b1);
        connect(bal2.port_a, port_a2);
        connect(bal2.port_b, port_b2);
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component transports two fluid streams between four ports, without
storing mass or energy. It is similar to
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>,
but it has four ports instead of two.
</p>
<p>
If <code>dp<i>N</i>_nominal &gt; Modelica.Constants.eps</code>,
where <code><i>N</i></code> denotes the fluid <i>1</i> or <i>2</i>,
then the model computes
pressure drop due to flow friction in the respective fluid stream.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m<i>N</i>_flow_nominal, dp<i>N</i>_nominal)</code>.
At <code>|m<i>N</i>_flow| &lt; deltaM<i>N</i> * m<i>N</i>_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance<i>N</i></code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>

<h4>Implementation</h4>
<p>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned, where <code><i>N</i></code> denotes <code>1</code> or
<code>2</code>:</p>
<ul>
<li>
<code>Q<i>N</i>_flow</code>, which is the sensible and latent heat flow rate added to the medium <i>N</i>.
</li>
<li>
<code>mWat<i>N</i>_flow</code>, which is the moisture mass flow rate added to the medium <i>N</i>.
</li>
</ul>
<p>
Set the constant <code>sensibleOnly<i>N</i>=true</code> if the model that extends
or instantiates this model sets <code>mWat<i>N</i>_flow = 0</code>.
</p>
<p>
     Note that the model does not implement <code>0 = Q1_flow + Q2_flow</code> or
     <code>0 = mXi1_flow + mXi2_flow</code>. If there is no heat or mass transfer
     with the environment, then a model that extends this model needs to provide these
     equations.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 11, 2017, by Michael Wetter:<br/>
Updated documentation to make clear that <code>Q1_flow</code> and <code>Q2_flow</code>
include latent heat flow rate.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>bal1</code> and <code>bal2</code>
as this constant has been removed in
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Added parameter <code>homotopyInitialization</code> as
it has been removed in the base class.
</li>
<li>
November 13, 2013, by Michael Wetter:<br/>
Removed <code>import Modelica.Constants;</code> statement.
</li>
<li>
October 8, 2013, by Michael Wetter:<br/>
Removed parameter <code>show_V_flow</code>.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constants <code>sensibleOnly1</code> and
<code>sensibleOnly2</code> to
simplify species balance equations.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
March 25, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=false,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Rectangle(
                extent={{-70,80},{70,-80}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,65},{101,55}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,-55},{101,-65}},
                lineColor={0,0,255},
                pattern=LinePattern.None,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}));
      end StaticFourPortHeatMassExchanger;

      model StaticTwoPortConservationEquation
        "Partial model for static energy and mass conservation equations"
        extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface;

        constant Boolean simplify_mWat_flow = true
          "Set to true to cause port_a.m_flow + port_b.m_flow = 0 even if mWat_flow is non-zero";

        constant Boolean prescribedHeatFlowRate = false
          "Set to true if the heat flow rate is not a function of a temperature difference to the fluid temperature";

        parameter Boolean use_mWat_flow = false
          "Set to true to enable input connector for moisture mass flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        parameter Boolean use_C_flow = false
          "Set to true to enable input connector for trace substance"
          annotation(Evaluate=true, Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealInput Q_flow(unit="W")
          "Sensible plus latent heat flow rate transferred into the medium"
          annotation (Placement(transformation(extent={{-140,60},{-100,100}})));
        Modelica.Blocks.Interfaces.RealInput mWat_flow(final quantity="MassFlowRate",
                                                       unit="kg/s") if
             use_mWat_flow "Moisture mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,20},{-100,60}})));
        Modelica.Blocks.Interfaces.RealInput[Medium.nC] C_flow if
             use_C_flow "Trace substance mass flow rate added to the medium"
          annotation (Placement(transformation(extent={{-140,-60},{-100,-20}})));

        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg",
                                                   start=Medium.specificEnthalpy_pTX(
                                                           p=Medium.p_default,
                                                           T=Medium.T_default,
                                                           X=Medium.X_default))
          "Leaving specific enthalpy of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110}), iconTransformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-50,110})));

        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={0,110})));
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component"
          annotation (Placement(transformation(extent={{-10,-10},{10,10}},
              rotation=90,
              origin={50,110})));

    protected
        final parameter Boolean use_m_flowInv=
          (prescribedHeatFlowRate or use_mWat_flow or use_C_flow)
          "Flag, true if m_flowInv is used in the model"
          annotation (Evaluate=true);
        final parameter Real s[Medium.nXi] = {if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i],
                                                  string2="Water",
                                                  caseSensitive=false)
                                                  then 1 else 0 for i in 1:Medium.nXi}
          "Vector with zero everywhere except where species is";

        Real m_flowInv(unit="s/kg") "Regularization of 1/m_flow of port_a";

        Modelica.SIunits.MassFlowRate mXi_flow[Medium.nXi]
          "Mass flow rates of independent substances added to the medium";

        // Parameters for inverseXRegularized.
        // These are assigned here for efficiency reason.
        // Otherwise, they would need to be computed each time
        // the function is invocated.
        final parameter Real deltaReg = m_flow_small/1E3
          "Smoothing region for inverseXRegularized";

        final parameter Real deltaInvReg = 1/deltaReg
          "Inverse value of delta for inverseXRegularized";

        final parameter Real aReg = -15*deltaInvReg
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real bReg = 119*deltaInvReg^2
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real cReg = -361*deltaInvReg^3
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real dReg = 534*deltaInvReg^4
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real eReg = -380*deltaInvReg^5
          "Polynomial coefficient for inverseXRegularized";
        final parameter Real fReg = 104*deltaInvReg^6
          "Polynomial coefficient for inverseXRegularized";

        final parameter Medium.ThermodynamicState state_default = Medium.setState_pTX(
            T=Medium.T_default,
            p=Medium.p_default,
            X=Medium.X_default[1:Medium.nXi]) "Medium state at default values";
        // Density at medium default values, used to compute the size of control volumes
        final parameter Modelica.SIunits.SpecificHeatCapacity cp_default=
          Medium.specificHeatCapacityCp(state=state_default)
          "Specific heat capacity, used to verify energy conservation";
        constant Modelica.SIunits.TemperatureDifference dTMax(min=1) = 200
          "Maximum temperature difference across the StaticTwoPortConservationEquation";
        // Conditional connectors
        Modelica.Blocks.Interfaces.RealInput mWat_flow_internal(unit="kg/s")
          "Needed to connect to conditional connector";
        Modelica.Blocks.Interfaces.RealInput C_flow_internal[Medium.nC]
          "Needed to connect to conditional connector";
      initial equation
        // Assert that the substance with name 'water' has been found.
        assert(Medium.nXi == 0 or abs(sum(s)-1) < 1e-5,
            "If Medium.nXi > 1, then substance 'water' must be present for one component.'"
               + Medium.mediumName + "'.\n"
               + "Check medium model.");

      equation
        // Conditional connectors
        connect(mWat_flow, mWat_flow_internal);
        if not use_mWat_flow then
          mWat_flow_internal = 0;
        end if;

        connect(C_flow, C_flow_internal);
        if not use_C_flow then
          C_flow_internal = zeros(Medium.nC);
        end if;

        // Species flow rate from connector mWat_flow
        mXi_flow = mWat_flow_internal * s;

        // Regularization of m_flow around the origin to avoid a division by zero
        // m_flowInv is only used if prescribedHeatFlowRate == true, or
        // if the input connectors mWat_flow or C_flow are enabled.
        if use_m_flowInv then
          m_flowInv = IDEAS.Utilities.Math.Functions.inverseXRegularized(
                             x=port_a.m_flow,
                             delta=deltaReg, deltaInv=deltaInvReg,
                             a=aReg, b=bReg, c=cReg, d=dReg, e=eReg, f=fReg);
        else
          // m_flowInv is not used.
          m_flowInv = 0;
        end if;

        if prescribedHeatFlowRate then
          assert(noEvent( abs(Q_flow) < dTMax*cp_default*max(m_flow_small/1E3, abs(m_flow))),
         "In " + getInstanceName() + ":
   The heat flow rate equals "       + String(Q_flow) +
         " W and the mass flow rate equals " + String(m_flow) + " kg/s,
   which results in a temperature difference "       +
         String(abs(Q_flow)/ (cp_default*max(m_flow_small/1E3, abs(m_flow)))) +
         " K > dTMax=" +String(dTMax) + " K.
   This may indicate that energy is not conserved for small mass flow rates.
   The implementation may require prescribedHeatFlowRate = false.");
        end if;

        if allowFlowReversal then
          // Formulate hOut using spliceFunction. This avoids an event iteration.
          // The introduced error is small because deltax=m_flow_small/1e3
          hOut = IDEAS.Utilities.Math.Functions.regStep(y1=port_b.h_outflow,
                                                          y2=port_a.h_outflow,
                                                          x=port_a.m_flow,
                                                          x_small=m_flow_small/1E3);
          XiOut = IDEAS.Utilities.Math.Functions.regStep(y1=port_b.Xi_outflow,
                                                           y2=port_a.Xi_outflow,
                                                           x=port_a.m_flow,
                                                           x_small=m_flow_small/1E3);
          COut = IDEAS.Utilities.Math.Functions.regStep(y1=port_b.C_outflow,
                                                          y2=port_a.C_outflow,
                                                          x=port_a.m_flow,
                                                          x_small=m_flow_small/1E3);
        else
          hOut =  port_b.h_outflow;
          XiOut = port_b.Xi_outflow;
          COut =  port_b.C_outflow;
        end if;

        //////////////////////////////////////////////////////////////////////////////////////////
        // Energy balance and mass balance

          // Mass balance (no storage)
          port_a.m_flow + port_b.m_flow = if simplify_mWat_flow then 0 else -mWat_flow_internal;

          // Substance balance
          // a) forward flow
          if use_m_flowInv then
            port_b.Xi_outflow = inStream(port_a.Xi_outflow) + mXi_flow * m_flowInv;
          else // no water is added
            assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for forward flow.");
            port_b.Xi_outflow = inStream(port_a.Xi_outflow);
          end if;

          // b) backward flow
          if allowFlowReversal then
            if use_m_flowInv then
              port_a.Xi_outflow = inStream(port_b.Xi_outflow) - mXi_flow * m_flowInv;
            else // no water added
              assert(use_mWat_flow == false, "In " + getInstanceName() + ": Wrong implementation for reverse flow.");
              port_a.Xi_outflow = inStream(port_b.Xi_outflow);
            end if;
          else // no  flow reversal
            port_a.Xi_outflow = Medium.X_default[1:Medium.nXi];
          end if;

          // Energy balance.
          // This equation is approximate since m_flow = port_a.m_flow is used for the mass flow rate
          // at both ports. Since mWat_flow_internal << m_flow, the error is small.
          if prescribedHeatFlowRate then
            port_b.h_outflow = inStream(port_a.h_outflow) + Q_flow * m_flowInv;
            if allowFlowReversal then
              port_a.h_outflow = inStream(port_b.h_outflow) - Q_flow * m_flowInv;
            else
              port_a.h_outflow = Medium.h_default;
            end if;
          else
            // Case with prescribedHeatFlowRate == false.
            // port_b.h_outflow is known and the equation needs to be solved for Q_flow.
            // Hence, we cannot use m_flowInv as for m_flow=0, any Q_flow would satisfiy
            // Q_flow * m_flowInv = 0.
            // The same applies for port_b.Xi_outflow and mXi_flow.
            port_a.m_flow * (inStream(port_a.h_outflow) - port_b.h_outflow)     = -Q_flow;
            if allowFlowReversal then
              port_a.m_flow * (inStream(port_b.h_outflow)  - port_a.h_outflow)  = +Q_flow;
            else
              // When allowFlowReversal = false, the downstream enthalpy does not matter.
              // Therefore a dummy value is used to avoid algebraic loops
              port_a.h_outflow = Medium.h_default;
            end if;
          end if;

        // Transport of trace substances
        if use_m_flowInv and use_C_flow then
          port_b.C_outflow =  inStream(port_a.C_outflow) + C_flow_internal * m_flowInv;
        else // no trace substance added.
          assert(not use_C_flow, "In " + getInstanceName() + ": Wrong implementation of trace substance balance for forward flow.");
          port_b.C_outflow =  inStream(port_a.C_outflow);
        end if;

        if allowFlowReversal then
          if use_C_flow then
            port_a.C_outflow = inStream(port_b.C_outflow) - C_flow_internal * m_flowInv;
          else
            port_a.C_outflow = inStream(port_b.C_outflow);
          end if;
        else
          port_a.C_outflow = zeros(Medium.nC);
        end if;

        ////////////////////////////////////////////////////////////////////////////
        // No pressure drop in this model
        port_a.p = port_b.p;

        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This model transports fluid between its two ports, without storing mass or energy.
It implements a steady-state conservation equation for energy and mass fractions.
The model has zero pressure drop between its ports.
</p>

<h4>Typical use and important parameters</h4>
<p>
Set the parameter <code>use_mWat_flow_in=true</code> to enable an
input connector for <code>mWat_flow</code>.
Otherwise, the model uses <code>mWat_flow = 0</code>.
</p>
<p>
If the constant <code>simplify_mWat_flow = true</code>, which is its default value,
then the equation
</p>
<pre>
  port_a.m_flow + port_b.m_flow = - mWat_flow;
</pre>
<p>
is simplified as
</p>
<pre>
  port_a.m_flow + port_b.m_flow = 0;
</pre>
<p>
This causes an error in the mass balance of about <i>0.5%</i>, but generally leads to
simpler equations because the pressure drop equations are then decoupled from the
mass exchange in this component.
</p>

<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
<h4>Implementation</h4>
<p>
Input connectors of the model are
</p>
<ul>
<li>
<code>Q_flow</code>, which is the sensible plus latent heat flow rate added to the medium,
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium, and
</li>
<li>
<code>C_flow</code>, which is the trace substance mass flow rate added to the medium.
</li>
</ul>

<p>
The model can only be used as a steady-state model with two fluid ports.
For a model with a dynamic balance, and more fluid ports, use
<a href=\"modelica://IDEAS.Fluid.Interfaces.ConservationEquation\">
IDEAS.Fluid.Interfaces.ConservationEquation</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
February 12, 2019, by Filip Jorissen:<br/>
Removed obsolete division by <code>TMax</code> in assert.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1097\">#1097</a>.
</li>
<li>
June 23, 2018, by Filip Jorissen:<br/>
Added more details to energy conservation assert to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/962\">#962</a>.
</li>
<li>
March 30, 2018, by Filip Jorissen:<br/>
Added <code>getInstanceName()</code> in asserts to facilitate
debugging.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/901\">#901</a>.
</li>
<li>
April 24, 2017, by Michael Wetter and Filip Jorissen:<br/>
Reimplemented check for energy conversion.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 24, 2017, by Michael Wetter:<br/>
Reverted change from April 21, 2017.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
April 21, 2017, by Filip Jorissen:<br/>
Revised test for energy conservation at small mass flow rates.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/741\">#741</a>.
</li>
<li>
October 23, 2016, by Filip Jorissen:<br/>
Added test for energy conservation at small mass flow rates.
</li>
<li>
March 17, 2016, by Michael Wetter:<br/>
Refactored model and implmented <code>regStep</code> instead of <code>spliceFunction</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>
and for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a>.
</li>
<li>
September 3, 2015, by Filip Jorissen:<br/>
Revised implementation of conservation of vapor mass.
Added new variable <code>mFlow_inv_b</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/247\">#247</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Removed <code>constant sensibleOnly</code> as this is no longer used because
the model uses <code>use_mWat_flow</code>.<br/>
Changed condition that determines whether <code>m_flowInv</code> needs to be
computed because the change from January 20 introduced an error in
<a href=\"modelica://IDEAS.Fluid.MassExchangers.Examples.ConstantEffectiveness\">
IDEAS.Fluid.MassExchangers.Examples.ConstantEffectiveness</a>.
</li>
<li>
January 20, 2016, by Filip Jorissen:<br/>
Removed if-else block in code for parameter <code>sensibleOnly</code>
since this is no longer needed to simplify the equations.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
January 17, 2016, by Michael Wetter:<br/>
Added parameter <code>use_C_flow</code> and converted <code>C_flow</code>
to a conditionally removed connector.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/372\">#372</a>.
</li>
<li>
December 16, 2015, by Michael Wetter:<br/>
Removed the units of <code>C_flow</code> to allow for PPM.
</li>
<li>
December 2, 2015, by Filip Jorissen:<br/>
Added input <code>C_flow</code> and code for handling trace substance insertions.
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
September 14, 2015, by Filip Jorissen:<br/>
Rewrote some equations for better readability.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
Refactored implementation of
<a href=\"modelica://IDEAS.Utilities.Math.Functions.inverseXRegularized\">
IDEAS.Utilities.Math.Functions.inverseXRegularized</a>
to allow function to be inlined and to factor out the computation
of arguments that only depend on parameters.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Corrected bug for situation with latent heat exchange and flow reversal not
allowed.
The previous formulation was singular.
This caused some models to not translate.
The error was introduced in
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>.
</li>
<li>
July 17, 2015, by Michael Wetter:<br/>
Added constant <code>simplify_mWat_flow</code> to remove dependencies of the pressure drop
calculation on the moisture balance.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015, by Filip Jorissen:<br/>
Revised implementation so that equations are always consistent
and do not lead to division by zero,
also when connecting a <code>prescribedHeatFlowRate</code>
to <code>MixingVolume</code> instances.
Renamed <code>use_safeDivision</code> into <code>prescribedHeatFlowRate</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">#282</a>
for a discussion.
</li>
<li>
May 6, 2015, by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
February 11, 2014 by Michael Wetter:<br/>
Improved documentation for <code>Q_flow</code> input.
</li>
<li>
October 21, 2013 by Michael Wetter:<br/>
Corrected sign error in the equation that is used if <code>use_safeDivision=false</code>
and <code>sensibleOnly=true</code>.
This only affects internal numerical tests, but not any examples in the library
as the constant <code>use_safeDivision</code> is set to <code>true</code> by default.
</li>
<li>
September 25, 2013 by Michael Wetter:<br/>
Reformulated computation of outlet properties to avoid an event at zero mass flow rate.
</li>
<li>
September 17, 2013 by Michael Wetter:<br/>
Added start value for <code>hOut</code>.
</li>
<li>September 10, 2013 by Michael Wetter:<br/>
Removed unrequired parameter <code>i_w</code>.
</li>
<li>
May 7, 2013 by Michael Wetter:<br/>
Removed <code>for</code> loops for species balance and trace substance balance,
as they cause the error <code>Error: Operand port_a.Xi_outflow[1] to operator inStream is not a stream variable.</code>
in OpenModelica.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
June 22, 2012 by Michael Wetter:<br/>
Reformulated implementation with <code>m_flowInv</code> to use <code>port_a.m_flow * ...</code>
if <code>use_safeDivision=false</code>. This avoids a division by zero if
<code>port_a.m_flow=0</code>.
</li>
<li>
February 7, 2012 by Michael Wetter:<br/>
Revised base classes for conservation equations in <code>IDEAS.Fluid.Interfaces</code>.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={Rectangle(
                extent={{-100,100},{100,-100}},
                fillColor={135,135,135},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Text(
                extent={{-93,72},{-58,89}},
                lineColor={0,0,127},
                textString="Q_flow"),
              Text(
                extent={{-93,37},{-58,54}},
                lineColor={0,0,127},
                textString="mWat_flow"),
              Text(
                extent={{-41,103},{-10,117}},
                lineColor={0,0,127},
                textString="hOut"),
              Text(
                extent={{10,103},{41,117}},
                lineColor={0,0,127},
                textString="XiOut"),
              Text(
                extent={{61,103},{92,117}},
                lineColor={0,0,127},
                textString="COut"),
              Line(points={{-42,55},{-42,-84}}, color={255,255,255}),
              Polygon(
                points={{-42,67},{-50,45},{-34,45},{-42,67}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{87,-73},{65,-65},{65,-81},{87,-73}},
                lineColor={255,255,255},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-56,-73},{81,-73}}, color={255,255,255}),
              Line(points={{6,14},{6,-37}},     color={255,255,255}),
              Line(points={{54,14},{6,14}},     color={255,255,255}),
              Line(points={{6,-37},{-42,-37}},  color={255,255,255})}));
      end StaticTwoPortConservationEquation;

      model StaticTwoPortHeatMassExchanger
        "Partial model transporting fluid between two ports without storing mass or energy"
        extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface;
        extends IDEAS.Fluid.Interfaces.TwoPortFlowResistanceParameters(
          final computeFlowResistance=(abs(dp_nominal) > Modelica.Constants.eps));
        constant Boolean sensibleOnly "Set to true if sensible exchange only";
        constant Boolean prescribedHeatFlowRate
          "Set to true if the heat flow rate is not a function of the component temperature";
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        // Model inputs
        // Q_flow is the sensible plus latent heat flow rate
        input Modelica.SIunits.HeatFlowRate Q_flow "Heat transferred into the medium";
        input Modelica.SIunits.MassFlowRate mWat_flow
          "Moisture mass flow rate added to the medium";
        // Models for conservation equations and pressure drop
        IDEAS.Fluid.Interfaces.StaticTwoPortConservationEquation vol(
          redeclare final package Medium = Medium,
          final use_mWat_flow = not sensibleOnly,
          final prescribedHeatFlowRate = prescribedHeatFlowRate,
          final m_flow_nominal = m_flow_nominal,
          final allowFlowReversal=allowFlowReversal,
          final m_flow_small=m_flow_small)
          "Control volume for steady-state energy and mass balance"
          annotation (Placement(transformation(extent={{15,-10}, {35,10}})));
        IDEAS.Fluid.FixedResistances.PressureDrop preDro(
          redeclare final package Medium = Medium,
          final m_flow_nominal=m_flow_nominal,
          final deltaM=deltaM,
          final allowFlowReversal=allowFlowReversal,
          final show_T=false,
          final from_dp=from_dp,
          final linearized=linearizeFlowResistance,
          final homotopyInitialization=homotopyInitialization,
          final dp_nominal=dp_nominal) "Flow resistance"
          annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
        // Outputs that are needed in models that extend this model
        Modelica.Blocks.Interfaces.RealOutput hOut(unit="J/kg")
          "Leaving temperature of the component";
        Modelica.Blocks.Interfaces.RealOutput XiOut[Medium.nXi](each unit="1",
                                                                each min=0,
                                                                each max=1)
          "Leaving species concentration of the component";
        Modelica.Blocks.Interfaces.RealOutput COut[Medium.nC](each min=0)
          "Leaving trace substances of the component";
    protected
        Modelica.Blocks.Sources.RealExpression heaInp(y=Q_flow)
          "Block to set heat input into volume"
          annotation (Placement(transformation(extent={{-20,40},{0,60}})));
        Modelica.Blocks.Sources.RealExpression
          masExc(final y=mWat_flow) "Block to set moisture exchange in volume"
          annotation (Placement(transformation(extent={{-20,20},{0,40}})));
      equation
        connect(vol.hOut, hOut);
        connect(vol.XiOut, XiOut);
        connect(vol.COut, COut);
        connect(port_a,preDro. port_a) annotation (Line(
            points={{-100,0},{-50,0}},
            color={0,127,255}));
        connect(preDro.port_b, vol.port_a) annotation (Line(
            points={{-30,0},{15,0}},
            color={0,127,255}));
        connect(vol.port_b, port_b) annotation (Line(
            points={{35,0},{67,0},{100,5.55112e-16}},
            color={0,127,255}));
        connect(heaInp.y, vol.Q_flow) annotation (Line(
            points={{1,50},{6,50},{6,8},{13,8}},
            color={0,0,127}));
        connect(masExc.y, vol.mWat_flow) annotation (Line(
            points={{1,30},{4,30},{4,4},{13,4}},
            color={0,0,127}));
        annotation (
          preferredView="info",
          Documentation(info="<html>
<p>
This component transports fluid between its two ports, without
storing mass or energy. It is based on
<a href=\"modelica://Modelica.Fluid.Interfaces.PartialTwoPortTransport\">
Modelica.Fluid.Interfaces.PartialTwoPortTransport</a> but it does
use a different implementation for handling reverse flow because
in this component, mass flow rate can be added or removed from
the medium.
</p>
<p>
If <code>dp_nominal &gt; Modelica.Constants.eps</code>, this component computes
pressure drop due to flow friction.
The pressure drop is defined by a quadratic function that goes through
the point <code>(m_flow_nominal, dp_nominal)</code>. At <code>|m_flow| &lt; deltaM * m_flow_nominal</code>,
the pressure drop vs. flow relation is linearized.
If the parameter <code>linearizeFlowResistance</code> is set to true,
then the whole pressure drop vs. flow resistance curve is linearized.
</p>
<h4>Implementation</h4>
This model uses inputs and constants that need to be set by models
that extend or instantiate this model.
The following inputs need to be assigned:
<ul>
<li>
<code>Q_flow</code>, which is the sensible and latent heat flow rate added to the medium.
</li>
<li>
<code>mWat_flow</code>, which is the moisture mass flow rate added to the medium.
</li>
</ul>

<p>
Set the constant <code>sensibleOnly=true</code> if the model that extends
or instantiates this model sets <code>mWat_flow = 0</code>.
</p>
<p>
To increase the numerical robustness of the model, the constant
<code>prescribedHeatFlowRate</code> can be set.
Use the following settings:
</p>
<ul>
<li>Set <code>prescribedHeatFlowRate=true</code> if the <i>only</i> means of heat transfer
at the <code>heatPort</code> is a prescribed heat flow rate that
is <i>not</i> a function of the temperature difference
between the medium and an ambient temperature. Examples include an ideal electrical heater,
a pump that rejects heat into the fluid stream, or a chiller that removes heat based on a performance curve.
If the <code>heatPort</code> is not connected, then set <code>prescribedHeatFlowRate=true</code> as
in this case, <code>heatPort.Q_flow=0</code>.
</li>
<li>Set <code>prescribedHeatFlowRate=false</code> if there is heat flow at the <code>heatPort</code>
computed as <i>K * (T-heatPort.T)</i>, for some temperature <i>T</i> and some conductance <i>K</i>,
which may itself be a function of temperature or mass flow rate.<br/>
If there is a combination of <i>K * (T-heatPort.T)</i> and a prescribed heat flow rate,
for example a solar collector that dissipates heat to the ambient and receives heat from
the solar radiation, then set <code>prescribedHeatFlowRate=false</code>.
</li>
</ul>
<p>
If <code>prescribedHeatFlow=true</code>, then energy and mass balance
equations are formulated to guard against numerical problems near
zero flow that can occur if <code>Q_flow</code> or <code>m_flow</code>
are the results of an iterative solver.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 11, 2017, by Michael Wetter:<br/>
Updated documentation to make clear that <code>Q_flow</code>
includes latent heat flow rate.<br/>
This is for issue
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/704\">Buildings #704</a>.
</li>
<li>
December 1, 2016, by Michael Wetter:<br/>
Updated model as <code>use_dh</code> is no longer a parameter in the pressure drop model.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/480\">#480</a>.
</li>
<li>
January 22, 2016 by Michael Wetter:<br/>
Removed assignment of <code>sensibleOnly</code> in <code>bal1</code> and <code>bal2</code>
as this constant has been removed in
<a href=\"modelica://IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger\">
IDEAS.Fluid.Interfaces.StaticTwoPortHeatMassExchanger</a>.
</li>
<li>
November 19, 2015, by Michael Wetter:<br/>
Removed assignment of parameter
<code>showDesignFlowDirection</code> in <code>extends</code> statement.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/349\">#349</a>.
</li>
<li>
July 2, 2015 by Michael Wetter:<br/>
Revised implementation of conservation equations,
added default values for outlet quantities at <code>port_a</code>
if <code>allowFlowReversal=false</code> and
updated documentation.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">
issue 281</a> for a discussion.
</li>
<li>
July 1, 2015 by Filip Jorissen:<br/>
Renamed <code>use_safeDivision</code> into
<code>prescribedHeatFlowRate</code>.
See
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/282\">
issue 282</a> for a discussion.
</li>
<li>
November 13, 2013 by Michael Wetter:<br/>
Added parameter <code>homotopyInitialization</code> as
it has been removed in the base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to pressure drop calculation, as this model no longer has
that parameter.
</li>
<li>
July 30, 2013 by Michael Wetter:<br/>
Changed connector <code>mXi_flow[Medium.nXi]</code>
to a scalar input connector <code>mWat_flow</code>.
The reason is that <code>mXi_flow</code> does not allow
to compute the other components in <code>mX_flow</code> and
therefore leads to an ambiguous use of the model.
By only requesting <code>mWat_flow</code>, the mass balance
and species balance can be implemented correctly.
</li>
<li>
March 27, 2013 by Michael Wetter:<br/>
Removed wrong unit attribute of <code>COut</code>,
and added min and max attributes for <code>XiOut</code>.
</li>
<li>
February 8, 2012 by Michael Wetter:<br/>
Changed model to use graphical modeling.
</li>
<li>
December 14, 2011 by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to no longer declare that it is continuous.
The declaration of continuity, i.e, the
<code>smooth(0, if (port_a.m_flow >= 0) then ...)</code> declaration,
was required for Dymola 2012 to simulate, but it is no longer needed
for Dymola 2012 FD01.
</li>
<li>
August 19, 2011, by Michael Wetter:<br/>
Changed assignment of <code>hOut</code>, <code>XiOut</code> and
<code>COut</code> to declare that it is not differentiable.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2011, by Michael Wetter:<br/>
Changed energy and mass balance to avoid a division by zero if <code>m_flow=0</code>.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
August 19, 2010, by Michael Wetter:<br/>
Fixed bug in energy and moisture balance that affected results if a component
adds or removes moisture to the air stream.
In the old implementation, the enthalpy and species
outflow at <code>port_b</code> was multiplied with the mass flow rate at
<code>port_a</code>. The old implementation led to small errors that were proportional
to the amount of moisture change. For example, if the moisture added by the component
was <code>0.005 kg/kg</code>, then the error was <code>0.5%</code>.
Also, the results for forward flow and reverse flow differed by this amount.
With the new implementation, the energy and moisture balance is exact.
</li>
<li>
March 22, 2010, by Michael Wetter:<br/>
Added constant <code>sensibleOnly</code> to
simplify species balance equation.
</li>
<li>
April 10, 2009, by Michael Wetter:<br/>
Added model to compute flow friction.
</li>
<li>
April 22, 2008, by Michael Wetter:<br/>
Revised to add mass balance.
</li>
<li>
March 17, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end StaticTwoPortHeatMassExchanger;

      record FourPortFlowResistanceParameters
        "Parameters for flow resistance for models with four ports"
        parameter Boolean computeFlowResistance1 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 1"));
        parameter Boolean from_dp1 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance1,
                      tab="Flow resistance", group="Medium 1"));
        parameter Modelica.SIunits.PressureDifference dp1_nominal(min=0,
                                                                  displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance1 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance1,
                     tab="Flow resistance", group="Medium 1"));
        parameter Real deltaM1 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance1,
                            tab="Flow resistance", group="Medium 1"));
        parameter Boolean computeFlowResistance2 = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance", group="Medium 2"));
        parameter Boolean from_dp2 = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance2,
                      tab="Flow resistance", group="Medium 2"));
        parameter Modelica.SIunits.PressureDifference dp2_nominal(min=0,
                                                                  displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance2 = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance2,
                     tab="Flow resistance", group="Medium 2"));
        parameter Real deltaM2 = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance2,
                            tab="Flow resistance", group="Medium 2"));
      annotation (preferredView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in components that have two fluid streams.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://IDEAS.Fluid.Interfaces.PartialFourPortInterface\">
PartialFourPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FourPortFlowResistanceParameters;

      record LumpedVolumeDeclarations "Declarations for lumped volumes"
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialMedium "Medium in the component"
            annotation (choices(
              choice(redeclare package Medium = IDEAS.Media.Air "Moist air"),
              choice(redeclare package Medium = IDEAS.Media.Water "Water"),
              choice(redeclare package Medium =
                  IDEAS.Media.Antifreeze.PropyleneGlycolWater (
                    property_T=293.15,
                    X_a=0.40)
                    "Propylene glycol water, 40% mass fraction")));

        // Assumptions
        parameter Modelica.Fluid.Types.Dynamics energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
          "Type of energy balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        parameter Modelica.Fluid.Types.Dynamics massDynamics=energyDynamics
          "Type of mass balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics substanceDynamics=energyDynamics
          "Type of independent mass fraction balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));
        final parameter Modelica.Fluid.Types.Dynamics traceDynamics=energyDynamics
          "Type of trace substance balance: dynamic (3 initialization options) or steady state"
          annotation(Evaluate=true, Dialog(tab = "Dynamics", group="Equations"));

        // Initialization
        parameter Medium.AbsolutePressure p_start = Medium.p_default
          "Start value of pressure"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.Temperature T_start=Medium.T_default
          "Start value of temperature"
          annotation(Dialog(tab = "Initialization"));
        parameter Medium.MassFraction X_start[Medium.nX](
             quantity=Medium.substanceNames) = Medium.X_default
          "Start value of mass fractions m_i/m"
          annotation (Dialog(tab="Initialization", enable=Medium.nXi > 0));
        parameter Medium.ExtraProperty C_start[Medium.nC](
             quantity=Medium.extraPropertiesNames)=fill(0, Medium.nC)
          "Start value of trace substances"
          annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Medium.ExtraProperty C_nominal[Medium.nC](
             quantity=Medium.extraPropertiesNames) = fill(1E-2, Medium.nC)
          "Nominal value of trace substances. (Set to typical order of magnitude.)"
         annotation (Dialog(tab="Initialization", enable=Medium.nC > 0));
        parameter Real mSenFac(min=1)=1
          "Factor for scaling the sensible thermal mass of the volume"
          annotation(Dialog(tab="Dynamics"));

      annotation (preferredView="info",
      Documentation(info="<html>
<p>
This class contains parameters and medium properties
that are used in the lumped  volume model, and in models that extend the
lumped volume model.
</p>
<p>
These parameters are used for example by
<a href=\"modelica://IDEAS.Fluid.Interfaces.ConservationEquation\">
IDEAS.Fluid.Interfaces.ConservationEquation</a>,
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolume\">
IDEAS.Fluid.MixingVolumes.MixingVolume</a> and
<a href=\"modelica://IDEAS.Fluid.HeatExchangers.Radiators.RadiatorEN442_2\">
IDEAS.Fluid.HeatExchangers.Radiators.RadiatorEN442_2</a>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
January 18, 2019, by Jianjun Hu:<br/>
Limited the media choice.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">#1050</a>.
</li>
<li>
November 9, 2018 by Michael Wetter:<br/>
Limited choices of media that are displayed in the pull down menu of
graphical editors.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1050\">issue 1050</a>.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Added <code>quantity=Medium.substanceNames</code> for <code>X_start</code>.
</li>
<li>
October 21, 2014, by Filip Jorissen:<br/>
Added parameter <code>mFactor</code> to increase the thermal capacity.
</li>
<li>
August 2, 2011, by Michael Wetter:<br/>
Set <code>substanceDynamics</code> and <code>traceDynamics</code> to final
and equal to <code>energyDynamics</code>,
as there is no need to make them different from <code>energyDynamics</code>.
</li>
<li>
August 1, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.DynamicFreeInitial</code> because
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code> leads
to high order DAE that Dymola cannot reduce.
</li>
<li>
July 31, 2011, by Michael Wetter:<br/>
Changed default value for <code>energyDynamics</code> to
<code>Modelica.Fluid.Types.Dynamics.SteadyStateInitial</code>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end LumpedVolumeDeclarations;

      record TwoPortFlowResistanceParameters
        "Parameters for flow resistance for models with two ports"
        parameter Boolean computeFlowResistance = true
          "=true, compute flow resistance. Set to false to assume no friction"
          annotation (Evaluate=true, Dialog(tab="Flow resistance"));
        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(enable = computeFlowResistance,
                      tab="Flow resistance"));
        parameter Modelica.SIunits.PressureDifference dp_nominal(min=0,
                                                                 displayUnit="Pa")
          "Pressure difference"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean linearizeFlowResistance = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Dialog(enable = computeFlowResistance,
                     tab="Flow resistance"));
        parameter Real deltaM = 0.1
          "Fraction of nominal flow rate where flow transitions to laminar"
          annotation(Dialog(enable = computeFlowResistance, tab="Flow resistance"));
      annotation (preferredView="info",
      Documentation(info="<html>
This class contains parameters that are used to
compute the pressure drop in models that have one fluid stream.
Note that the nominal mass flow rate is not declared here because
the model
<a href=\"modelica://IDEAS.Fluid.Interfaces.PartialTwoPortInterface\">
PartialTwoPortInterface</a>
already declares it.
</html>",
      revisions="<html>
<ul>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TwoPortFlowResistanceParameters;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains basic classes that are used to build
component models that change the state of the
fluid. The classes are not directly usable, but can
be extended when building a new model.
</p>
</html>"));
    end Interfaces;

    package BaseClasses "Package with base classes for IDEAS.Fluid"
      extends Modelica.Icons.BasesPackage;

      partial model PartialResistance "Partial model for a hydraulic resistance"
          extends IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
           show_T=false,
           dp(nominal=if dp_nominal_pos > Modelica.Constants.eps
                then dp_nominal_pos else 1),
           m_flow(
              nominal=if m_flow_nominal_pos > Modelica.Constants.eps
                then m_flow_nominal_pos else 1),
           final m_flow_small = 1E-4*abs(m_flow_nominal));
        parameter Boolean from_dp = false
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Modelica.SIunits.PressureDifference dp_nominal(displayUnit="Pa")
          "Pressure drop at nominal mass flow rate"
          annotation(Dialog(group = "Nominal condition"));
        parameter Boolean homotopyInitialization = true "= true, use homotopy method"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Boolean linearized = false
          "= true, use linear relation between m_flow and dp for any flow rate"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        parameter Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
          "Turbulent flow if |m_flow| >= m_flow_turbulent";
    protected
        parameter Medium.ThermodynamicState sta_default=
           Medium.setState_pTX(T=Medium.T_default, p=Medium.p_default, X=Medium.X_default);
        parameter Modelica.SIunits.DynamicViscosity eta_default=Medium.dynamicViscosity(sta_default)
          "Dynamic viscosity, used to compute transition to turbulent flow regime";
        final parameter Modelica.SIunits.MassFlowRate m_flow_nominal_pos = abs(m_flow_nominal)
          "Absolute value of nominal flow rate";
        final parameter Modelica.SIunits.PressureDifference dp_nominal_pos(displayUnit="Pa") = abs(dp_nominal)
          "Absolute value of nominal pressure difference";
      equation
        // Isenthalpic state transformation (no storage and no loss of energy)
        port_a.h_outflow = if allowFlowReversal then inStream(port_b.h_outflow) else Medium.h_default;
        port_b.h_outflow = inStream(port_a.h_outflow);
        // Mass balance (no storage)
        port_a.m_flow + port_b.m_flow = 0;
        // Transport of substances
        port_a.Xi_outflow = if allowFlowReversal then inStream(port_b.Xi_outflow) else Medium.X_default[1:Medium.nXi];
        port_b.Xi_outflow = inStream(port_a.Xi_outflow);
        port_a.C_outflow = if allowFlowReversal then inStream(port_b.C_outflow) else zeros(Medium.nC);
        port_b.C_outflow = inStream(port_a.C_outflow);
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                  -100},{100,100}}), graphics={
              Rectangle(
                extent={{-100,40},{100,-42}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={192,192,192}),
              Rectangle(
                extent={{-100,22},{100,-24}},
                lineColor={0,0,0},
                fillPattern=FillPattern.HorizontalCylinder,
                fillColor={0,127,255}),
              Rectangle(
                visible=linearized,
                extent={{-100,22},{100,-24}},
                fillPattern=FillPattern.Backward,
                fillColor={0,128,255},
                pattern=LinePattern.None,
                lineColor={255,255,255})}),
                defaultComponentName="res",
      Documentation(info="<html>
<p>
Partial model for a flow resistance, possible with variable flow coefficient.
Models that extend this class need to implement an equation that relates
<code>m_flow</code> and <code>dp</code>, and they need to assign the parameter
<code>m_flow_turbulent</code>.
</p>
<p>
See for example
<a href=\"modelica://IDEAS.Fluid.FixedResistances.PressureDrop\">
IDEAS.Fluid.FixedResistances.PressureDrop</a> for a model that extends
this base class.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Removed start value for pressure difference
to simplify the parameter window.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/552\">#552</a>.
</li>
<li>
January 26, 2016, by Michael Wetter:<br/>
Avoided assignment of <code>dp(nominal=0)</code> if <code>dp_nominal_pos = 0</code>
and of <code>m_flow(nominal=0)</code> if <code>m_flow_nominal_pos = 0</code>
as nominal values are not allowed to be zero.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
August 15, 2015, by Filip Jorissen:<br/>
Implemented more efficient computation of <code>port_a.Xi_outflow</code>,
<code>port_a.h_outflow</code>
and <code>port_a.C_outflow</code> when <code>allowFlowReversal=false</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/281\">#281</a>.
</li>
<li>
January 13, 2015, by Marcus Fuchs:<br/>
Revised revisions section (there were two revisions statements)
</li>
<li>
November 20, 2014 by Michael Wetter:<br/>
Removed <code>start</code> attribute for <code>m_flow</code>
as this is already set in its base class.
</li>
<li>
October 8, 2013 by Michael Wetter:<br/>
Removed propagation of <code>show_V_flow</code>
to base class as it has no longer this parameter.
</li>
<li>
December 14, 2012 by Michael Wetter:<br/>
Renamed protected parameters for consistency with the naming conventions.
</li>
<li>
February 12, 2012, by Michael Wetter:<br/>
Removed duplicate declaration of <code>m_flow_nominal</code>.
</li>
<li>
February 3, 2012, by Michael Wetter:<br/>
Made assignment of <code>m_flow_small</code> <code>final</code> as it is no
longer used in the base class.
</li>
<li>
January 16, 2012, by Michael Wetter:<br/>
To simplify object inheritance tree, revised base classes
<code>IDEAS.Fluid.BaseClasses.PartialResistance</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialTwoWayValve</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialDamperExponential</code>,
<code>IDEAS.Fluid.Actuators.BaseClasses.PartialActuator</code>
and model
<code>IDEAS.Fluid.FixedResistances.PressureDrop</code>.
</li>
<li>
August 5, 2011, by Michael Wetter:<br/>
Moved linearized pressure drop equation from the function body to the equation
section. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
June 20, 2011, by Michael Wetter:<br/>
Set start values for <code>m_flow</code> and <code>dp</code> to zero, since
most HVAC systems start at zero flow. With this change, the start values
appear in the GUI and can be set by the user.
</li>
<li>
April 2, 2011 by Michael Wetter:<br/>
Added <code>m_flow_nominal_pos</code> and <code>dp_nominal_pos</code> to allow
providing negative nominal values which will be used, for example, to set start
values of flow splitters which may have negative flow rates and pressure drop
at the initial condition.
</li>
<li>
March 27, 2011, by Michael Wetter:<br/>
Added <code>homotopy</code> operator.
</li>
<li>
March 23, 2011 by Michael Wetter:<br/>
Added homotopy operator.
</li>
<li>
March 30, 2010 by Michael Wetter:<br/>
Changed base classes to allow easier initialization.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
Extracted pressure drop computation and implemented it in the
new model
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.BasicFlowModel\">
IDEAS.Fluid.BaseClasses.FlowModels.BasicFlowModel</a>.
</li>
<li>
September 18, 2008, by Michael Wetter:<br/>
Added equations for the mass balance of extra species flow,
i.e., <code>C</code> and <code>mC_flow</code>.
</li>
<li>
July 20, 2007 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PartialResistance;

      partial model PartialThreeWayResistance
        "Flow splitter with partial resistance model at each port"
        extends IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations(
          final mSenFac=1);
        Modelica.Fluid.Interfaces.FluidPort_a port_1(
          redeclare package Medium = Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_1 == Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_1== Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "First port, typically inlet"
          annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));
        Modelica.Fluid.Interfaces.FluidPort_b port_2(
          redeclare package Medium = Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "Second port, typically outlet"
          annotation (Placement(transformation(extent={{90,-10},{110,10}})));
        Modelica.Fluid.Interfaces.FluidPort_a port_3(
          redeclare package Medium=Medium,
          h_outflow(start=Medium.h_default, nominal=Medium.h_default),
          m_flow(min=if (portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering) then 0.0 else -Modelica.Constants.inf,
                 max=if (portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving) then 0.0 else Modelica.Constants.inf))
          "Third port, can be either inlet or outlet"
          annotation (Placement(transformation(extent={{-10,-110},{10,-90}})));
        parameter Modelica.SIunits.Time tau=10
          "Time constant at nominal flow for dynamic energy and momentum balance"
          annotation(Dialog(tab="Dynamics", group="Nominal condition",
                     enable=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState));
        parameter Modelica.SIunits.MassFlowRate mDyn_flow_nominal
          "Nominal mass flow rate for dynamic momentum and energy balance"
          annotation(Dialog(tab="Dynamics", group="Equations",
                     enable=not energyDynamics == Modelica.Fluid.Types.Dynamics.SteadyState));
        parameter Boolean from_dp = true
          "= true, use m_flow = f(dp) else dp = f(m_flow)"
          annotation (Evaluate=true, Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_1"
         annotation(Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_2"
         annotation(Dialog(tab="Advanced"));
        parameter Modelica.Fluid.Types.PortFlowDirection portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Bidirectional
          "Flow direction for port_3"
         annotation(Dialog(tab="Advanced"));
        parameter Boolean verifyFlowReversal = false
          "=true, to assert that the flow does not reverse when portFlowDirection_* does not equal Bidirectional"
          annotation(Dialog(tab="Advanced"));
        parameter Modelica.SIunits.MassFlowRate m_flow_small
          "Small mass flow rate for checking flow reversal"
          annotation(Dialog(tab="Advanced",enable=verifyFlowReversal));
        replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface res1
          constrainedby IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_1 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface res2
          constrainedby IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_2 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(extent={{60,-10},{40,10}})));
        replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface res3
          constrainedby IDEAS.Fluid.Interfaces.PartialTwoPortInterface(
            redeclare final package Medium = Medium,
            allowFlowReversal=portFlowDirection_3 == Modelica.Fluid.Types.PortFlowDirection.Bidirectional)
          "Partial model, to be replaced with a fluid component"
          annotation (Placement(transformation(
              origin={0,-50},
              extent={{-10,10},{10,-10}},
              rotation=90)));
        IDEAS.Fluid.Delays.DelayFirstOrder vol(
          redeclare final package Medium = Medium,
          final nPorts=3,
          final tau=tau,
          final m_flow_nominal=mDyn_flow_nominal,
          final energyDynamics=energyDynamics,
          final massDynamics=massDynamics,
          final p_start=p_start,
          final T_start=T_start,
          final X_start=X_start,
          final C_start=C_start,
          final allowFlowReversal=true,
          final prescribedHeatFlowRate=false) if
             have_controlVolume "Fluid volume to break algebraic loop"
          annotation (Placement(transformation(extent={{-10,0},{10,20}})));
    protected
        parameter Boolean have_controlVolume=
            energyDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState or
             massDynamics <> Modelica.Fluid.Types.Dynamics.SteadyState
          "Boolean flag used to remove conditional components";
        Modelica.Fluid.Interfaces.FluidPort_a port_internal(
          redeclare package Medium = Medium) if not have_controlVolume
          "Internal dummy port for easier connection of conditional connections"
          annotation (Placement(transformation(extent={{-10,50},{10,70}})));
      initial equation
        assert(portFlowDirection_1<>Modelica.Fluid.Types.PortFlowDirection.Leaving or
               portFlowDirection_2<>Modelica.Fluid.Types.PortFlowDirection.Leaving or
               portFlowDirection_3<>Modelica.Fluid.Types.PortFlowDirection.Leaving,
               "In " + getInstanceName() + ": All ports are configured to
         Modelica.Fluid.Types.PortFlowDirection.Leaving, which is non-physical.");
        assert(portFlowDirection_1<>Modelica.Fluid.Types.PortFlowDirection.Entering or
               portFlowDirection_2<>Modelica.Fluid.Types.PortFlowDirection.Entering or
               portFlowDirection_3<>Modelica.Fluid.Types.PortFlowDirection.Entering,
               "In " + getInstanceName() + ": All ports are configured to
         Modelica.Fluid.Types.PortFlowDirection.Entering, which is non-physical.");
      equation
        if verifyFlowReversal then
          if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_1.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_1 but portFlowDirection_1=PortFlowDirection.Entering since m_flow="       +
            String(port_1.m_flow) + ">-"+String(m_flow_small));
          end if;
          if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_1.m_flow< m_flow_small,
            "In " + getInstanceName() + ":
      Flow is entering port_1 but portFlowDirection_1=PortFlowDirection.Leaving since m_flow="       +
            String(port_1.m_flow) + "<"+String(m_flow_small));
          end if;
          if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_2.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_2 but portFlowDirection_2=PortFlowDirection.Entering since m_flow="       +
            String(port_2.m_flow) + ">-"+String(m_flow_small));
          end if;
          if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_2.m_flow< m_flow_small,
            "In " + getInstanceName() + ":
      Flow is entering port_2 but portFlowDirection_2=PortFlowDirection.Leaving since m_flow="       +
            String(port_2.m_flow) + "<"+String(m_flow_small));
          end if;
          if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering then
            assert(port_3.m_flow> -m_flow_small,
            "In " + getInstanceName() + ":
      Flow is leaving port_3 but portFlowDirection_3=PortFlowDirection.Entering since m_flow="       +
            String(port_3.m_flow) + ">-"+String(m_flow_small));
          end if;
          if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving then
            assert(port_3.m_flow< m_flow_small,
            "In " + getInstanceName() + ": 
      Flow is entering port_3 but portFlowDirection_3=PortFlowDirection.Leaving since m_flow="       +
            String(port_3.m_flow) + "<"+String(m_flow_small));
          end if;
        end if;
        if portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res1.port_a, port_internal) annotation (Line(
            points={{-60,0},{-60,60},{0,60}},
            color={0,127,255}));
          else
             connect(res1.port_a, vol.ports[1]) annotation (Line(
            points={{-60,0},{-2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_1, res1.port_b) annotation (Line(points={{-100,0},{-100,0},{-40,
                  0}}, color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res1.port_b, port_internal) annotation (Line(
            points={{-40,0},{-40,60},{0,60}},
            color={0,127,255}));
          else
             connect(res1.port_b, vol.ports[1]) annotation (Line(
            points={{-40,0},{-2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_1, res1.port_a) annotation (Line(points={{-100,0},{-100,0},{-60,0}}, color={0,127,255}));
        end if;
        if portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res2.port_a, port_internal) annotation (Line(
            points={{60,0},{60,60},{0,60}},
            color={0,127,255}));
          else
             connect(res2.port_a, vol.ports[2]) annotation (Line(
            points={{60,0},{2.22045e-16,0}},
            color={0,127,255}));
          end if;
          connect(port_2, res2.port_b) annotation (Line(points={{100,0},{100,0},{40,0}},    color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res2.port_b, port_internal) annotation (Line(
            points={{40,0},{40,60},{0,60}},
            color={0,127,255}));
          else
             connect(res2.port_b, vol.ports[2]) annotation (Line(
            points={{40,0},{2.22045e-16,0}},
            color={0,127,255}));
          end if;
          connect(port_2, res2.port_a) annotation (Line(points={{100,0},{100,0},{60,0}},    color={0,127,255}));
        end if;
        if portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving then
          if not have_controlVolume then
             connect(res3.port_a, port_internal) annotation (Line(
            points={{-4.44089e-16,-60},{20,-60},{20,60},{0,60}},
            color={0,127,255}));
          else
             connect(res3.port_a, vol.ports[3]) annotation (Line(
            points={{-6.66134e-16,-60},{0,-60},{0,0},{2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_3, res3.port_b) annotation (Line(points={{0,-100},{0,-100},{0,-40}}, color={0,127,255}));
        else
          if not have_controlVolume then
             connect(res3.port_b, port_internal) annotation (Line(
            points={{4.44089e-16,-40},{20,-40},{20,60},{0,60}},
            color={0,127,255}));
          else
             connect(res3.port_b, vol.ports[3]) annotation (Line(
            points={{4.44089e-16,-40},{0,-40},{0,0},{2.66667,0}},
            color={0,127,255}));
          end if;
          connect(port_3, res3.port_a) annotation (Line(points={{0,-100},{0,-100},{0,-60}}, color={0,127,255}));
        end if;
         annotation (
          Documentation(info="<html>
<p>
Partial model for flow resistances with three ports such as a
flow mixer/splitter or a three way valve.
</p>
<p>
If <code>energyDynamics &ne; Modelica.Fluid.Types.Dynamics.SteadyState</code>,
then at the junction of the three flows,
a mixing volume will be present. This will introduce a dynamic energy and momentum
balance, which often breaks algebraic loops.
The time constant of the mixing volume is determined by the parameter <code>tau</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
July 7, 2018, by Filip Jorissen:<br/>
Added asserts that verify whether flow reversal occurs when 
<code>verifyFlowReversal=true</code> and <code>portFlowDirection&lt;&gt;Bidirectional</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/963\">#963</a>.
</li>
<li>
July 8, 2018, by Filip Jorissen:<br/>
Added nominal value of <code>h_outflow</code> in <code>FluidPorts</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/977\">#977</a>.
</li>
<li>
March 30, 2018, by Filip Jorissen:<br/>
Added graphical illustrations for the values of <code>portFlowDirection</code>.
Added asserts that verify the consistency of
the values of <code>portFlowDirection</code>.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/902\">#902</a>.
</li>
<li>
February 22, 2016, by Michael Wetter:<br/>
Conditionally removed control volume <code>vol</code>, and added the conditional connnector
<code>port_internal</code>.
This was already done when the parameter <code>dynamicBalance</code> was present, but
was updated wrong when this parameter was removed.
Without these conditional components, the regression test for
<code>IDEAS.Fluid.Examples.ResistanceVolumeFlowReversal</code> fails to simulate.
</li>
<li>
December 17, 2015, by Michael Wetter:<br/>
Added assignment <code>redeclare final package Medium=Medium</code>
as this is required for OpenModelica.
This is for
<a href=\"https://github.com/lbl-srg/modelica-buildings/issues/475\">
https://github.com/lbl-srg/modelica-buildings/issues/475</a>.
</li>
<li>
February 20, 2016, by Ruben Baetens:<br/>
Removal of <code>dynamicBalance</code> as parameter for <code>massDynamics</code> and <code>energyDynamics</code>.
</li>
<li>
April 13 2015, by Filip Jorissen:<br/>
Exposed options for flow reversal to users and added corresponding implementation.
</li>
<li>
March 23 2010, by Michael Wetter:<br/>
Changed start values from <code>system.p_start</code> or (code <code>T_start</code>)
to <code>Medium.p_default</code>.
</li>
<li>
September 18, 2008 by Michael Wetter:<br/>
Replaced splitter model with a fluid port since the
splitter model in Modelica.Fluid 1.0 beta does not transport
<code>mC_flow</code>.
</li>
<li>
June 11, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Polygon(
                points={{104,28},{124,20},{104,12},{104,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Leaving),
              Polygon(
                points={{124,28},{104,20},{124,12},{124,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_2==Modelica.Fluid.Types.PortFlowDirection.Entering),
              Polygon(
                points={{-124,28},{-104,20},{-124,12},{-124,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Entering),
              Polygon(
                points={{-104,28},{-124,20},{-104,12},{-104,28}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_1==Modelica.Fluid.Types.PortFlowDirection.Leaving),
              Polygon(
                points={{1,8},{21,6.12323e-17},{1,-8},{1,8}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Entering,
                origin={20,-125},
                rotation=90),
              Polygon(
                points={{21,14},{1,6},{21,-2},{21,14}},
                lineColor={0,128,255},
                fillColor={0,128,255},
                fillPattern=FillPattern.Solid,
                visible=portFlowDirection_3==Modelica.Fluid.Types.PortFlowDirection.Leaving,
                origin={26,-125},
                rotation=90)}));
      end PartialThreeWayResistance;

      package FlowModels "Flow models for pressure drop calculations"
        extends Modelica.Icons.BasesPackage;

        function basicFlowFunction_dp
          "Function that computes mass flow rate for given pressure drop"

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          output Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNorm=dp/dp_turbulent
            "Normalised pressure difference";
          Real dpNormSq=dpNorm^2
            "Square of normalised pressure difference";
        algorithm
           m_flow :=  if noEvent(abs(dp)>dp_turbulent)
                      then sign(dp)*k*sqrt(abs(dp))
                      else (1.40625  + (0.15625*dpNormSq - 0.5625)*dpNormSq)*m_flow_turbulent*dpNorm;
          annotation(Inline=false,
                   smoothOrder=2,
                   derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                     IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der,
                   inverse(dp=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(
                     m_flow=m_flow, k=k, m_flow_turbulent=m_flow_turbulent)),
                   Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},
                    {100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  m = sign(&Delta;p) k  &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
March 19, 2016, by Michael Wetter:<br/>
Added <code>abs</code> function for
<code>IDEAS.Fluid.FixedResistances.Validation.PressureDropsExplicit</code>
to work in OpenModelica.
See <a href=\"https://trac.openmodelica.org/OpenModelica/ticket/3778\">
OpenModelica ticket 3778</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
January 9, 2014, by Michael Wetter:<br/>
Correct revision section, of which there were two.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>m_flow=0</code> if <code>dp=0</code>,
as this causes the derivative to be discontinuous at <code>dp=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
March 29, 2010 by Michael Wetter:<br/>
Changed implementation to allow <code>k=0</code>, which is
the case for a closed valve with no leakage
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_dp;

        function basicFlowFunction_dp_der
          "1st derivative of function that computes mass flow rate for given pressure drop"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real dp_der
            "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          output Real m_flow_der(unit="kg/s2")
            "Derivative of mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNormSq=(dp/dp_turbulent)^2
            "Square of normalised pressure difference";
        algorithm
         m_flow_der := (if noEvent(abs(dp)>dp_turbulent)
                        then 0.5*k/sqrt(abs(dp))
                        else (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*m_flow_turbulent/dp_turbulent)*dp_der;
         annotation (Inline=false,
                     smoothOrder=1,
                     derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                       IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp_der2,
        Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
April 14, 2017, by Filip Jorissen:<br/>
Changed implementation such that it cannot lead to square roots
of negative numbers and reduced the number of required operations.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/723\">#723</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_dp_der;

        function basicFlowFunction_dp_der2
          "2nd derivative of flow function2nd derivative of function that computes mass flow rate for given pressure drop"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real k(min=0, unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real dp_der
            "1st derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          input Real dp_der2
            "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
          output Real m_flow_der2
            "2nd derivative of mass flow rate in design flow direction";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real dpNorm=dp/dp_turbulent
            "Normalised pressure difference";
          Real dpNormSq=dpNorm^2
            "Square of normalised pressure difference";
        algorithm
         m_flow_der2 := if noEvent(abs(dp)>dp_turbulent)
                         then 0.5*k/sqrt(abs(dp))*(-0.5/dp * dp_der^2 + dp_der2)
                         else m_flow_turbulent/dp_turbulent*(
                               (1.40625  + (0.78125*dpNormSq - 1.6875)*dpNormSq)*dp_der2
                             + (-3.375 + 3.125*dpNormSq)*dpNorm/dp_turbulent*dp_der^2);

         annotation (smoothOrder=0,
         Inline=false,
        Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_dp_der2;

        function basicFlowFunction_m_flow
          "Function that computes pressure drop for given mass flow rate"

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          output Modelica.SIunits.PressureDifference dp(displayUnit="Pa")
            "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNorm = m_flow/m_flow_turbulent
            "Normalised mass flow rate";
          Real m_flowNormSq = m_flowNorm^2
            "Square of normalised mass flow rate";

        algorithm
         dp :=if noEvent(abs(m_flow)>m_flow_turbulent)
              then sign(m_flow)*(m_flow/k)^2
              else (0.375 + (0.75-0.125*m_flowNormSq)*m_flowNormSq)*dp_turbulent*m_flowNorm;

         annotation (Inline=false,
                     smoothOrder=2,
                     derivative(order=1, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                       IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der,
                     inverse(m_flow=IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(
                       dp=dp, k=k, m_flow_turbulent=m_flow_turbulent)),
                     Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}}), graphics={Line(
                  points={{-80,-40},{-80,60},{80,-40},{80,60}},
                  color={0,0,255},
                  thickness=1), Text(
                  extent={{-40,-40},{40,-80}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.Sphere,
                  fillColor={232,0,0},
                  textString="%name")}),
        Documentation(info="<html>
<p>
Function that computes the pressure drop of flow elements as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  &Delta;p = sign(m) (m &frasl; k)<sup>2</sup>
</p>
<p>
with regularization near the origin.
Therefore, the flow coefficient is
</p>
<p align=\"center\" style=\"font-style:italic;\">
  k = m &frasl; &radic;<span style=\"text-decoration:overline;\">&nbsp;&Delta;p &nbsp;</span>
</p>
<p>
The input <code>m_flow_turbulent</code> determines the location of the regularization.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 28, 2015, by Michael Wetter:<br/>
Removed double declaration of <code>smooth(..)</code> and <code>smoothOrder</code>
and changed <code>Inline=true</code> to <code>LateInline=true</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/301\">issue 301</a>.
</li>
<li>
July 15, 2015, by Filip Jorissen:<br/>
New, more efficient implementation based on regularisation using simple polynomial.
Expanded common subexpressions for function inlining to be possible.
Set <code>Inline=true</code> for inlining to occur.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/279\">#279</a>.
</li>
<li>
August 10, 2011, by Michael Wetter:<br/>
Removed <code>if-then</code> optimization that set <code>dp=0</code> if <code>m_flow=0</code>,
as this causes the derivative to be discontinuous at <code>m_flow=0</code>.
</li>
<li>
August 4, 2011, by Michael Wetter:<br/>
Removed option to use a linear function. The linear implementation is now done
in models that call this function. With the previous implementation,
the symbolic processor may not rearrange the equations, which can lead
to coupled equations instead of an explicit solution.
</li>
<li>
April 13, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow;

        function basicFlowFunction_m_flow_der
          "1st derivative of function that computes pressure drop for given mass flow rate"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real m_flow_der(unit="kg/s2")
            "Derivative of mass flow rate in design flow direction";
          output Real dp_der
            "Derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNormSq = (m_flow/m_flow_turbulent)^2
            "Square of normalised mass flow rate";
        algorithm
         dp_der :=(if noEvent(abs(m_flow)>m_flow_turbulent)
                   then sign(m_flow)*2*m_flow/k^2
                   else (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*dp_turbulent/m_flow_turbulent)*m_flow_der;

         annotation (Inline=false,
                     smoothOrder=1,
                     derivative(order=2, zeroDerivative=k, zeroDerivative=m_flow_turbulent)=
                     IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow_der2,
        Documentation(info="<html>
<p>
Function that implements the first order derivative of
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation to avoid in Dymola 2016 the warning
\"Differentiating ... under the assumption that it is continuous at switching\".
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow_der;

        function basicFlowFunction_m_flow_der2
          "2nd derivative of function that computes pressure drop for given mass flow rate"
          extends Modelica.Icons.Function;

          input Modelica.SIunits.MassFlowRate m_flow
            "Mass flow rate in design flow direction";
          input Real k(unit="")
            "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
          input Modelica.SIunits.MassFlowRate m_flow_turbulent(min=0)
            "Mass flow rate where transition to turbulent flow occurs";
          input Real m_flow_der(unit="kg/s2")
            "1st derivative of mass flow rate in design flow direction";
          input Real m_flow_der2(unit="kg/s3")
            "2nd derivative of mass flow rate in design flow direction";
          output Real dp_der2
            "2nd derivative of pressure difference between port_a and port_b (= port_a.p - port_b.p)";
      protected
          Modelica.SIunits.PressureDifference dp_turbulent = (m_flow_turbulent/k)^2
            "Pressure where flow changes to turbulent";
          Real m_flowNorm = m_flow/m_flow_turbulent
            "Normalised mass flow rate";
          Real m_flowNormSq = m_flowNorm^2
            "Square of normalised mass flow rate";
        algorithm
         dp_der2 :=if noEvent(abs(m_flow)>m_flow_turbulent)
                   then sign(m_flow)*2/k^2 * (m_flow_der^2 + m_flow * m_flow_der2)
                   else dp_turbulent/m_flow_turbulent*(
                         (0.375  + (2.25 - 0.625*m_flowNormSq)*m_flowNormSq)*m_flow_der2
                       + (4.5 - 2.5*m_flowNormSq)*m_flowNorm/m_flow_turbulent*m_flow_der^2);

         annotation (smoothOrder=0,
         Inline=false,
        Documentation(info="<html>
<p>
Function that implements the second order derivative of
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
with respect to the mass flow rate.
</p>
</html>",
        revisions="<html>
<ul>
<li>
January 4, 2019, by Michael Wetter:<br/>
Set `Inline=false`.<br/>
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1070\">#1070</a>.
</li>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised implementation such that
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
is C2 continuous.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/725\">#725</a>.
</li>
<li>
January 22, 2016, by Michael Wetter:<br/>
Corrected type declaration of pressure difference.
This is
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/404\">#404</a>.
</li>
<li>
July 29, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end basicFlowFunction_m_flow_der2;
      annotation (Documentation(info="<html>
<p>
This package contains a basic flow model that is used by the
various models that compute pressure drop.
</p>
<h4>Assumption and limitations</h4>
<p>
Because the density does not change signficantly in heating,
ventilation and air conditioning systems for buildings,
the flow models compute the pressure drop based on the mass flow
rate and not the volume flow rate. This typically leads to simpler
equations because it does not require
the mass density, which changes when the flow is reversed.
Although, for conceptual design of building energy system, there is
in general not enough information available that would warrant a more
detailed pressure drop calculation.
If a more detailed computation of the flow resistance is needed,
then a user can use models from the
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a> library.
</p>
<p>
All functions have an argument <code>m_flow_turbulent</code> that determines where the
flow transitions to fully turbulent flow. For smaller mass flow rates,
the quadratic relation is replaced by a function that has finite slope
near zero pressure drop. This is done for numerical reasons, and to approximate
laminar flow, although the implementation does not use a linear function.
</p>
<h4>Implementation</h4>
<p>
The two main functions are
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp</a>
and
<a href=\"modelica://IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow\">
IDEAS.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow</a>
that compute the mass flow rate or the pressure drop, respectively.
Both functions are two times continuously differentiable.
First and second order derivatives are provided
in the function that have the suffix <code>_der</code> and <code>_der2</code>.
</p>
</html>",       revisions="<html>
<ul>
<li>
April 10, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end FlowModels;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Fluid\">IDEAS.Fluid</a>.
</p>
</html>"));
    end BaseClasses;
  annotation (
  preferredView="info", Documentation(info="<html>
This package contains components for fluid flow systems such as
pumps, valves and sensors. For other fluid flow models, see
<a href=\"modelica://Modelica.Fluid\">Modelica.Fluid</a>.
</html>"),
  Icon(graphics={
          Polygon(points={{-70,26},{68,-44},{68,26},{2,-10},{-70,-42},{-70,26}},
              lineColor={0,0,0}),
          Line(points={{2,42},{2,-10}}),
          Rectangle(
            extent={{-18,50},{22,42}},
            lineColor={0,0,0},
            fillColor={0,0,0},
            fillPattern=FillPattern.Solid)}));
  end Fluid;

  package Media "Package with medium models"
    extends Modelica.Icons.Package;

    package Air
      "Package with moist air model that decouples pressure and temperature"
      extends Modelica.Media.Interfaces.PartialCondensingGases(
         mediumName="Air",
         final substanceNames={"water", "air"},
         final reducedX=true,
         final singleState = false,
         reference_X={0.01,0.99},
         final fluidConstants = {Modelica.Media.IdealGases.Common.FluidData.H2O,
                                 Modelica.Media.IdealGases.Common.FluidData.N2},
         reference_T=273.15,
         reference_p=101325,
         AbsolutePressure(start=p_default),
         Temperature(start=T_default));
      extends Modelica.Icons.Package;

      constant Integer Water=1
        "Index of water (in substanceNames, massFractions X, etc.)";
      constant Integer Air=2
        "Index of air (in substanceNames, massFractions X, etc.)";

      constant AbsolutePressure pStp = reference_p
        "Pressure for which fluid density is defined";
      constant Density dStp = 1.2 "Fluid density at pressure pStp";

      // Redeclare ThermodynamicState to avoid the warning
      // "Base class ThermodynamicState is replaceable"
      // during model check
      redeclare record extends ThermodynamicState
        "ThermodynamicState record for moist air"
      end ThermodynamicState;
      // There must not be any stateSelect=StateSelect.prefer for
      // the pressure.
      // Otherwise, translateModel("Buildings.Fluid.FMI.ExportContainers.Examples.FMUs.ResistanceVolume")
      // will fail as Dymola does an index reduction and outputs
      //   Differentiated the equation
      //   vol.dynBal.medium.p+res.dp-inlet.p = 0.0;
      //   giving
      //   der(vol.dynBal.medium.p)+der(res.dp) = der(inlet.p);
      //
      //   The model requires derivatives of some inputs as listed below:
      //   1 inlet.m_flow
      //   1 inlet.p
      // Therefore, the statement
      //   p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)
      // has been removed.
      redeclare replaceable model extends BaseProperties(
        Xi(each stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
        T(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default),
        final standardOrderComponents=true) "Base properties"

    protected
        constant Modelica.SIunits.MolarMass[2] MMX = {steam.MM,dryair.MM}
          "Molar masses of components";

        MassFraction X_steam "Mass fraction of steam water";
        MassFraction X_air "Mass fraction of air";
        Modelica.SIunits.TemperatureDifference dT(start=T_default-reference_T)
          "Temperature difference used to compute enthalpy";
      equation
        assert(T >= 200.0, "
In "       + getInstanceName() + ": Temperature T exceeded its minimum allowed value of -73.15 degC (200 Kelvin)
as required from medium model \""     + mediumName + "\".");
        assert(T <= 423.15, "
In "       + getInstanceName() + ": Temperature T exceeded its maximum allowed value of 150 degC (423.15 Kelvin)
as required from medium model \""     + mediumName + "\".");

        MM = 1/(Xi[Water]/MMX[Water]+(1.0-Xi[Water])/MMX[Air]);

        X_steam  = Xi[Water]; // There is no liquid in this medium model
        X_air    = 1-Xi[Water];

        dT = T - reference_T;
        h = dT*dryair.cp * X_air +
           (dT * steam.cp + h_fg) * X_steam;
        R = dryair.R*X_air + steam.R*X_steam;

        // Equation for ideal gas, from h=u+p*v and R*T=p*v, from which follows that  u = h-R*T.
        // u = h-R*T;
        // However, in this medium, the gas law is d/dStp=p/pStp, from which follows using h=u+pv that
        // u= h-p*v = h-p/d = h-pStp/dStp
        u = h-pStp/dStp;

        // In this medium model, the density depends only
        // on temperature, but not on pressure.
        //  d = p/(R*T);
        d/dStp = p/pStp;

        state.p = p;
        state.T = T;
        state.X = X;
      end BaseProperties;

    redeclare function density "Gas density"
      extends Modelica.Icons.Function;
      input ThermodynamicState state;
      output Density d "Density";
    algorithm
      d :=state.p*dStp/pStp;
      annotation(smoothOrder=5,
      Inline=true,
      Documentation(info="<html>
Density is computed from pressure, temperature and composition in the thermodynamic state record applying the ideal gas law.
</html>"));
    end density;

    redeclare function extends dynamicViscosity
        "Return the dynamic viscosity of dry air"
    algorithm
      eta := 4.89493640395e-08 * state.T + 3.88335940547e-06;
      annotation (
      smoothOrder=99,
      Inline=true,
    Documentation(info="<html>
<p>
This function returns the dynamic viscosity.
</p>
<h4>Implementation</h4>
<p>
The function is based on the 5th order polynomial
of
<a href=\"modelica://Modelica.Media.Air.MoistAir.dynamicViscosity\">
Modelica.Media.Air.MoistAir.dynamicViscosity</a>.
However, for the typical range of temperatures encountered
in building applications, a linear function sufficies.
This implementation is therefore the above 5th order polynomial,
linearized around <i>20</i>&deg;C.
The relative error of this linearization is
<i>0.4</i>% at <i>-20</i>&deg;C,
and less then
<i>0.2</i>% between  <i>-5</i>&deg;C and  <i>+50</i>&deg;C.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 19, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end dynamicViscosity;

    redeclare function enthalpyOfCondensingGas
        "Enthalpy of steam per unit mass of steam"
      extends Modelica.Icons.Function;

      input Temperature T "temperature";
      output SpecificEnthalpy h "steam enthalpy";
    algorithm
      h := (T-reference_T) * steam.cp + h_fg;
      annotation(smoothOrder=5,
      Inline=true,
      derivative=der_enthalpyOfCondensingGas);
    end enthalpyOfCondensingGas;

    redeclare replaceable function extends enthalpyOfGas
        "Enthalpy of gas mixture per unit mass of gas mixture"
    algorithm
      h := enthalpyOfCondensingGas(T)*X[Water]
           + enthalpyOfDryAir(T)*(1.0-X[Water]);
    annotation (
      Inline=true);
    end enthalpyOfGas;

    redeclare replaceable function extends enthalpyOfLiquid
        "Enthalpy of liquid (per unit mass of liquid) which is linear in the temperature"
    algorithm
      h := (T - reference_T)*cpWatLiq;
      annotation (
        smoothOrder=5,
        Inline=true,
        derivative=der_enthalpyOfLiquid);
    end enthalpyOfLiquid;

    redeclare function enthalpyOfNonCondensingGas
        "Enthalpy of non-condensing gas per unit mass of steam"
      extends Modelica.Icons.Function;

      input Temperature T "temperature";
      output SpecificEnthalpy h "enthalpy";
    algorithm
      h := enthalpyOfDryAir(T);
      annotation (
      smoothOrder=5,
      Inline=true,
      derivative=der_enthalpyOfNonCondensingGas);
    end enthalpyOfNonCondensingGas;

    redeclare function extends enthalpyOfVaporization
        "Enthalpy of vaporization of water"
    algorithm
      r0 := h_fg;
      annotation (
        Inline=true);
    end enthalpyOfVaporization;

    redeclare function extends gasConstant
        "Return ideal gas constant as a function from thermodynamic state, only valid for phi<1"

    algorithm
        R := dryair.R*(1 - state.X[Water]) + steam.R*state.X[Water];
      annotation (
        smoothOrder=2,
        Inline=true,
        Documentation(info="<html>
The ideal gas constant for moist air is computed from <a href=\"modelica://Modelica.Media.Air.MoistAir.ThermodynamicState\">thermodynamic state</a> assuming that all water is in the gas phase.
</html>"));
    end gasConstant;

    redeclare function extends pressure
        "Returns pressure of ideal gas as a function of the thermodynamic state record"

    algorithm
      p := state.p;
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
Pressure is returned from the thermodynamic state record input as a simple assignment.
</html>"));
    end pressure;

    redeclare function extends isobaricExpansionCoefficient
        "Isobaric expansion coefficient beta"
    algorithm
      beta := 0;
      annotation (
        smoothOrder=5,
        Inline=true,
    Documentation(info="<html>
<p>
This function returns the isobaric expansion coefficient at constant pressure,
which is zero for this medium.
The isobaric expansion coefficient at constant pressure is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&beta;<sub>p</sub> = - 1 &frasl; v &nbsp; (&part; v &frasl; &part; T)<sub>p</sub> = 0,
</p>
<p>
where
<i>v</i> is the specific volume,
<i>T</i> is the temperature and
<i>p</i> is the pressure.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isobaricExpansionCoefficient;

    redeclare function extends isothermalCompressibility
        "Isothermal compressibility factor"
    algorithm
      kappa := -1/state.p;
      annotation (
        smoothOrder=5,
        Inline=true,
        Documentation(info="<html>
<p>
This function returns the isothermal compressibility coefficient.
The isothermal compressibility is
</p>
<p align=\"center\" style=\"font-style:italic;\">
&kappa;<sub>T</sub> = -1 &frasl; v &nbsp; (&part; v &frasl; &part; p)<sub>T</sub>
  = -1 &frasl; p,
</p>
<p>
where
<i>v</i> is the specific volume,
<i>T</i> is the temperature and
<i>p</i> is the pressure.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isothermalCompressibility;

    redeclare function extends saturationPressure
        "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"

    algorithm
      psat := IDEAS.Utilities.Psychrometrics.Functions.saturationPressure(Tsat);
      annotation (
      smoothOrder=5,
      Inline=true);
    end saturationPressure;

    redeclare function extends specificEntropy
        "Return the specific entropy, only valid for phi<1"

    protected
        Modelica.SIunits.MoleFraction[2] Y "Molar fraction";
    algorithm
        Y := massToMoleFractions(
             state.X, {steam.MM,dryair.MM});
        s := specificHeatCapacityCp(state) * Modelica.Math.log(state.T/reference_T)
             - Modelica.Constants.R *
             sum(state.X[i]/MMX[i]*
                 Modelica.Math.log(max(Y[i], Modelica.Constants.eps)*state.p/reference_p) for i in 1:2);
      annotation (
      Inline=true,
        Documentation(info="<html>
<p>
This function computes the specific entropy.
</p>
<p>
The specific entropy of the mixture is obtained from
</p>
<p align=\"center\" style=\"font-style:italic;\">
s = s<sub>s</sub> + s<sub>m</sub>,
</p>
<p>
where
<i>s<sub>s</sub></i> is the entropy change due to the state change
(relative to the reference temperature) and
<i>s<sub>m</sub></i> is the entropy change due to mixing
of the dry air and water vapor.
</p>
<p>
The entropy change due to change in state is obtained from
</p>
<p align=\"center\" style=\"font-style:italic;\">
s<sub>s</sub> = c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(v/v<sub>0</sub>) <br/>
= c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(&rho;<sub>0</sub>/&rho;)
</p>
<p>If we assume <i>&rho; = p<sub>0</sub>/(R T)</i>,
and because <i>c<sub>p</sub> = c<sub>v</sub> + R</i>,
we can write
</p>
<p align=\"center\" style=\"font-style:italic;\">
s<sub>s</sub> = c<sub>v</sub> ln(T/T<sub>0</sub>) + R ln(T/T<sub>0</sub>) <br/>
=c<sub>p</sub> ln(T/T<sub>0</sub>).
</p>
<p>
Next, the entropy of mixing is obtained from a reversible isothermal
expansion process. Hence,
</p>
<p align=\"center\" style=\"font-style:italic;\">
  s<sub>m</sub> = -R &sum;<sub>i</sub>( X<sub>i</sub> &frasl; M<sub>i</sub>
  ln(Y<sub>i</sub> p/p<sub>0</sub>)),
</p>
<p>
where <i>R</i> is the gas constant,
<i>X</i> is the mass fraction,
<i>M</i> is the molar mass, and
<i>Y</i> is the mole fraction.
</p>
<p>
To obtain the state for a given pressure, entropy and mass fraction, use
<a href=\"modelica://IDEAS.Media.Air.setState_psX\">
IDEAS.Media.Air.setState_psX</a>.
</p>
<h4>Limitations</h4>
<p>
This function is only valid for a relative humidity below 100%.
</p>
</html>",     revisions="<html>
<ul>
<li>
November 27, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end specificEntropy;

    redeclare function extends density_derp_T
        "Return the partial derivative of density with respect to pressure at constant temperature"
    algorithm
      ddpT := dStp/pStp;
      annotation (
      Inline=true,
    Documentation(info="<html>
<p>
This function returns the partial derivative of density
with respect to pressure at constant temperature.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derp_T;

    redeclare function extends density_derT_p
        "Return the partial derivative of density with respect to temperature at constant pressure"
    algorithm
      ddTp := 0;

      annotation (
      smoothOrder=99,
      Inline=true,
      Documentation(info=
    "<html>
<p>
This function computes the derivative of density with respect to temperature
at constant pressure.
</p>
</html>",     revisions=
    "<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derT_p;

    redeclare function extends density_derX
        "Return the partial derivative of density with respect to mass fractions at constant pressure and temperature"
    algorithm
      dddX := fill(0, nX);
    annotation (
      smoothOrder=99,
      Inline=true,
      Documentation(info="<html>
<p>
This function returns the partial derivative of density
with respect to mass fraction.
This value is zero because in this medium, density is proportional
to pressure, but independent of the species concentration.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end density_derX;

    redeclare replaceable function extends specificHeatCapacityCp
        "Specific heat capacity of gas mixture at constant pressure"
    algorithm
      cp := dryair.cp*(1-state.X[Water]) +steam.cp*state.X[Water];
        annotation (
      smoothOrder=99,
      Inline=true,
      derivative=der_specificHeatCapacityCp);
    end specificHeatCapacityCp;

    redeclare replaceable function extends specificHeatCapacityCv
        "Specific heat capacity of gas mixture at constant volume"
    algorithm
      cv:= dryair.cv*(1-state.X[Water]) +steam.cv*state.X[Water];
      annotation (
        smoothOrder=99,
        Inline=true,
        derivative=der_specificHeatCapacityCv);
    end specificHeatCapacityCv;

    redeclare function setState_dTX
        "Return thermodynamic state as function of density d, temperature T and composition X"
      extends Modelica.Icons.Function;
      input Density d "Density";
      input Temperature T "Temperature";
      input MassFraction X[:]=reference_X "Mass fractions";
      output ThermodynamicState state "Thermodynamic state";

    algorithm
        // Note that d/dStp = p/pStp, hence p = d*pStp/dStp
        state := if size(X, 1) == nX then
                   ThermodynamicState(p=d*pStp/dStp, T=T, X=X)
                 else
                   ThermodynamicState(p=d*pStp/dStp,
                                      T=T,
                                      X=cat(1, X, {1 - sum(X)}));
        annotation (
        smoothOrder=2,
        Inline=true,
        Documentation(info="<html>
<p>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">thermodynamic state record</a>
    is computed from density <code>d</code>, temperature <code>T</code> and composition <code>X</code>.
</p>
</html>"));
    end setState_dTX;

    redeclare function extends setState_phX
        "Return thermodynamic state as function of pressure p, specific enthalpy h and composition X"
    algorithm
      state := if size(X, 1) == nX then
        ThermodynamicState(p=p, T=temperature_phX(p, h, X), X=X)
     else
        ThermodynamicState(p=p, T=temperature_phX(p, h, X), X=cat(1, X, {1 - sum(X)}));
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">
thermodynamic state record</a> is computed from pressure p, specific enthalpy h and composition X.
</html>"));
    end setState_phX;

    redeclare function extends setState_pTX
        "Return thermodynamic state as function of p, T and composition X or Xi"
    algorithm
        state := if size(X, 1) == nX then
                    ThermodynamicState(p=p, T=T, X=X)
                 else
                    ThermodynamicState(p=p, T=T, X=cat(1, X, {1 - sum(X)}));
        annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
The <a href=\"modelica://Modelica.Media.Interfaces.PartialMixtureMedium.ThermodynamicState\">
thermodynamic state record</a> is computed from pressure p, temperature T and composition X.
</html>"));
    end setState_pTX;

    redeclare function extends setState_psX
        "Return the thermodynamic state as function of p, s and composition X or Xi"
    protected
        Modelica.SIunits.MassFraction[2] X_int "Mass fraction";
        Modelica.SIunits.MoleFraction[2] Y "Molar fraction";
        Modelica.SIunits.Temperature T "Temperature";
    algorithm
        if size(X, 1) == nX then
          X_int:=X;
        else
          X_int :=cat(
            1,
            X,
            {1 - sum(X)});
        end if;
       Y := massToMoleFractions(
             X_int, {steam.MM,dryair.MM});
        // The next line is obtained from symbolic solving the
        // specificEntropy function for T.
        // In this formulation, we can set T to any value when calling
        // specificHeatCapacityCp as cp does not depend on T.
        T := 273.15 * Modelica.Math.exp((s + Modelica.Constants.R *
               sum(X_int[i]/MMX[i]*
                 Modelica.Math.log(max(Y[i], Modelica.Constants.eps)) for i in 1:2))
                 / specificHeatCapacityCp(setState_pTX(p=p,
                                                       T=273.15,
                                                       X=X_int)));

        state := ThermodynamicState(p=p,
                                    T=T,
                                    X=X_int);

    annotation (
    Inline=true,
    Documentation(info="<html>
<p>
This function returns the thermodynamic state based on pressure,
specific entropy and mass fraction.
</p>
<p>
The state is computed by symbolically solving
<a href=\"modelica://IDEAS.Media.Air.specificEntropy\">
IDEAS.Media.Air.specificEntropy</a>
for temperature.
</p>
</html>",     revisions="<html>
<ul>
<li>
November 27, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end setState_psX;

    redeclare replaceable function extends specificEnthalpy
        "Compute specific enthalpy from pressure, temperature and mass fraction"
    algorithm
      h := (state.T - reference_T)*dryair.cp * (1 - state.X[Water]) +
           ((state.T-reference_T) * steam.cp + h_fg) * state.X[Water];
      annotation (
       smoothOrder=5,
       Inline=true);
    end specificEnthalpy;

    redeclare replaceable function specificEnthalpy_pTX "Specific enthalpy"
      extends Modelica.Icons.Function;
      input Modelica.SIunits.Pressure p "Pressure";
      input Modelica.SIunits.Temperature T "Temperature";
      input Modelica.SIunits.MassFraction X[:] "Mass fractions of moist air";
      output Modelica.SIunits.SpecificEnthalpy h "Specific enthalpy at p, T, X";

    algorithm
      h := specificEnthalpy(setState_pTX(p, T, X));
      annotation(smoothOrder=5,
                 Inline=true,
                 inverse(T=temperature_phX(p, h, X)),
                 Documentation(info="<html>
Specific enthalpy as a function of temperature and species concentration.
The pressure is input for compatibility with the medium models, but the specific enthalpy
is independent of the pressure.
</html>",
    revisions="<html>
<ul>
<li>
April 30, 2015, by Filip Jorissen and Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
</ul>
</html>"));
    end specificEnthalpy_pTX;

    redeclare replaceable function extends specificGibbsEnergy
        "Specific Gibbs energy"
    algorithm
      g := specificEnthalpy(state) - state.T*specificEntropy(state);
      annotation (
        Inline=true);
    end specificGibbsEnergy;

    redeclare replaceable function extends specificHelmholtzEnergy
        "Specific Helmholtz energy"
    algorithm
      f := specificEnthalpy(state) - gasConstant(state)*state.T - state.T*specificEntropy(state);
      annotation (
        Inline=true);
    end specificHelmholtzEnergy;

    redeclare function extends isentropicEnthalpy "Return the isentropic enthalpy"
    algorithm
      h_is := specificEnthalpy(setState_psX(
                p=p_downstream,
                s=specificEntropy(refState),
                X=refState.X));
    annotation (
      Inline=true,
      Documentation(info="<html>
<p>
This function computes the specific enthalpy for
an isentropic state change from the temperature
that corresponds to the state <code>refState</code>
to <code>reference_T</code>.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end isentropicEnthalpy;

    redeclare function extends specificInternalEnergy "Specific internal energy"
      extends Modelica.Icons.Function;
    algorithm
      u := specificEnthalpy(state) - pStp/dStp;
      annotation (
        Inline=true);
    end specificInternalEnergy;

    redeclare function extends temperature
        "Return temperature of ideal gas as a function of the thermodynamic state record"
    algorithm
      T := state.T;
      annotation (
      smoothOrder=2,
      Inline=true,
      Documentation(info="<html>
Temperature is returned from the thermodynamic state record input as a simple assignment.
</html>"));
    end temperature;

    redeclare function extends molarMass "Return the molar mass"
    algorithm
        MM := 1/(state.X[Water]/MMX[Water]+(1.0-state.X[Water])/MMX[Air]);
        annotation (
    Inline=true,
    smoothOrder=99,
    Documentation(info="<html>
<p>
This function returns the molar mass.
</p>
</html>",
    revisions="<html>
<ul>
<li>
December 18, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end molarMass;

    redeclare replaceable function temperature_phX
        "Compute temperature from specific enthalpy and mass fraction"
        extends Modelica.Icons.Function;
      input AbsolutePressure p "Pressure";
      input SpecificEnthalpy h "specific enthalpy";
      input MassFraction[:] X "mass fractions of composition";
      output Temperature T "temperature";
    algorithm
      T := reference_T + (h - h_fg * X[Water])
           /((1 - X[Water])*dryair.cp + X[Water] * steam.cp);
      annotation(smoothOrder=5,
                 Inline=true,
                 inverse(h=specificEnthalpy_pTX(p, T, X)),
                 Documentation(info="<html>
Temperature as a function of specific enthalpy and species concentration.
The pressure is input for compatibility with the medium models, but the temperature
is independent of the pressure.
</html>",
    revisions="<html>
<ul>
<li>
April 30, 2015, by Filip Jorissen and Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
</ul>
</html>"));
    end temperature_phX;

    redeclare function extends thermalConductivity
        "Thermal conductivity of dry air as a polynomial in the temperature"
    algorithm
      lambda := Modelica.Media.Incompressible.TableBased.Polynomials_Temp.evaluate(
          {(-4.8737307422969E-008), 7.67803133753502E-005, 0.0241814385504202},
       Modelica.SIunits.Conversions.to_degC(state.T));
    annotation(LateInline=true);
    end thermalConductivity;
    //////////////////////////////////////////////////////////////////////
    // Protected classes.
    // These classes are only of use within this medium model.
    // Models generally have no need to access them.
    // Therefore, they are made protected. This also allows to redeclare the
    // medium model with another medium model that does not provide an
    // implementation of these classes.
  protected
      record GasProperties
        "Coefficient data record for properties of perfect gases"
        extends Modelica.Icons.Record;

        Modelica.SIunits.MolarMass MM "Molar mass";
        Modelica.SIunits.SpecificHeatCapacity R "Gas constant";
        Modelica.SIunits.SpecificHeatCapacity cp
          "Specific heat capacity at constant pressure";
        Modelica.SIunits.SpecificHeatCapacity cv = cp-R
          "Specific heat capacity at constant volume";
        annotation (
          preferredView="info",
          defaultComponentName="gas",
          Documentation(info="<html>
<p>
This data record contains the coefficients for perfect gases.
</p>
</html>",     revisions="<html>
<ul>
<li>
September 12, 2014, by Michael Wetter:<br/>
Corrected the wrong location of the <code>preferredView</code>
and the <code>revisions</code> annotation.
</li>
<li>
November 21, 2013, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end GasProperties;
      // In the assignments below, we compute cv as OpenModelica
      // cannot evaluate cv=cp-R as defined in GasProperties.
      constant GasProperties dryair(
        R =    Modelica.Media.IdealGases.Common.SingleGasesData.Air.R,
        MM =   Modelica.Media.IdealGases.Common.SingleGasesData.Air.MM,
        cp =   IDEAS.Utilities.Psychrometrics.Constants.cpAir,
        cv =   IDEAS.Utilities.Psychrometrics.Constants.cpAir
                 -Modelica.Media.IdealGases.Common.SingleGasesData.Air.R)
        "Dry air properties";
      constant GasProperties steam(
        R =    Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R,
        MM =   Modelica.Media.IdealGases.Common.SingleGasesData.H2O.MM,
        cp =   IDEAS.Utilities.Psychrometrics.Constants.cpSte,
        cv =   IDEAS.Utilities.Psychrometrics.Constants.cpSte
                 -Modelica.Media.IdealGases.Common.SingleGasesData.H2O.R)
        "Steam properties";

      constant Real k_mair =  steam.MM/dryair.MM "Ratio of molar weights";

      constant Modelica.SIunits.MolarMass[2] MMX={steam.MM,dryair.MM}
        "Molar masses of components";

      constant Modelica.SIunits.SpecificEnergy h_fg=
        IDEAS.Utilities.Psychrometrics.Constants.h_fg
        "Latent heat of evaporation of water";
      constant Modelica.SIunits.SpecificHeatCapacity cpWatLiq=
        IDEAS.Utilities.Psychrometrics.Constants.cpWatLiq
        "Specific heat capacity of liquid water";

    replaceable function der_enthalpyOfLiquid
        "Temperature derivative of enthalpy of liquid per unit mass of liquid"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of liquid enthalpy";
    algorithm
      der_h := cpWatLiq*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfLiquid;

    function der_enthalpyOfCondensingGas
        "Derivative of enthalpy of steam per unit mass of steam"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of steam enthalpy";
    algorithm
      der_h := steam.cp*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfCondensingGas;

    replaceable function enthalpyOfDryAir
        "Enthalpy of dry air per unit mass of dry air"
      extends Modelica.Icons.Function;

      input Temperature T "Temperature";
      output SpecificEnthalpy h "Dry air enthalpy";
    algorithm
      h := (T - reference_T)*dryair.cp;
      annotation (
        smoothOrder=5,
        Inline=true,
        derivative=der_enthalpyOfDryAir);
    end enthalpyOfDryAir;

    replaceable function der_enthalpyOfDryAir
        "Derivative of enthalpy of dry air per unit mass of dry air"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of dry air enthalpy";
    algorithm
      der_h := dryair.cp*der_T;
      annotation (
        Inline=true);
    end der_enthalpyOfDryAir;

    replaceable function der_enthalpyOfNonCondensingGas
        "Derivative of enthalpy of non-condensing gas per unit mass of steam"
      extends Modelica.Icons.Function;
      input Temperature T "Temperature";
      input Real der_T "Temperature derivative";
      output Real der_h "Derivative of steam enthalpy";
    algorithm
      der_h := der_enthalpyOfDryAir(T, der_T);
      annotation (
        Inline=true);
    end der_enthalpyOfNonCondensingGas;

    replaceable function der_specificHeatCapacityCp
        "Derivative of specific heat capacity of gas mixture at constant pressure"
      extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        input ThermodynamicState der_state "Derivative of thermodynamic state";
        output Real der_cp(unit="J/(kg.K.s)")
          "Derivative of specific heat capacity";
    algorithm
      der_cp := (steam.cp-dryair.cp)*der_state.X[Water];
      annotation (
        Inline=true);
    end der_specificHeatCapacityCp;

    replaceable function der_specificHeatCapacityCv
        "Derivative of specific heat capacity of gas mixture at constant volume"
      extends Modelica.Icons.Function;
        input ThermodynamicState state "Thermodynamic state";
        input ThermodynamicState der_state "Derivative of thermodynamic state";
        output Real der_cv(unit="J/(kg.K.s)")
          "Derivative of specific heat capacity";
    algorithm
      der_cv := (steam.cv-dryair.cv)*der_state.X[Water];
      annotation (
        Inline=true);
    end der_specificHeatCapacityCv;
      annotation(preferredView="info", Documentation(info="<html>
<p>
This medium package models moist air using a gas law in which pressure and temperature
are independent, which often leads to significantly faster and more robust computations.
The specific heat capacities at constant pressure and at constant volume are constant.
The air is assumed to be not saturated.
</p>
<p>
This medium uses the gas law
</p>
<p align=\"center\" style=\"font-style:italic;\">
&rho;/&rho;<sub>stp</sub> = p/p<sub>stp</sub>,
</p>
<p>
where
<i>p<sub>std</sub></i> and <i>&rho;<sub>stp</sub></i> are constant reference
temperature and density, rathern than the ideal gas law
</p>
<p align=\"center\" style=\"font-style:italic;\">
&rho; = p &frasl;(R T),
</p>
<p>
where <i>R</i> is the gas constant and <i>T</i> is the temperature.
</p>
<p>
This formulation often leads to smaller systems of nonlinear equations
because equations for pressure and temperature are decoupled.
Therefore, if air inside a control volume such as room air is heated, it
does not increase its specific volume. Consequently, merely heating or cooling
a control volume does not affect the air flow calculations in a duct network
that may be connected to that volume.
Note that multizone air exchange simulation in which buoyancy drives the
air flow is still possible as the models in
<a href=\"modelica://IDEAS.Airflow.Multizone\">
IDEAS.Airflow.Multizone</a> compute the mass density using the function
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Functions.density_pTX\">
IDEAS.Utilities.Psychrometrics.Functions.density_pTX</a> in which density
is a function of temperature.
</p>
<p>
Note that models in this package implement the equation for the internal energy as
</p>
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p<sub>stp</sub> &frasl; &rho;<sub>stp</sub>,
</p>
<p>
where
<i>u</i> is the internal energy per unit mass,
<i>h</i> is the enthalpy per unit mass,
<i>p<sub>stp</sub></i> is the static pressure and
<i>&rho;<sub>stp</sub></i> is the mass density at standard pressure and temperature.
The reason for this implementation is that in general,
</p>
<p align=\"center\" style=\"font-style:italic;\">
  h = u + p v,
</p>
<p>
from which follows that
</p>
<p align=\"center\" style=\"font-style:italic;\">
  u = h - p v = h - p &frasl; &rho; = h - p<sub>stp</sub> &frasl; &rho;<sub>std</sub>,
</p>
<p>
because <i>p &frasl; &rho; = p<sub>stp</sub> &frasl; &rho;<sub>stp</sub></i> in this medium model.
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C and no water vapor is present.
</p>
</html>",     revisions="<html>
<ul>
<li>
January 11, 2019 by Michael Wetter:<br/>
Reforulated assignment of <code>X_int</code> in <code>setState_psX</code>.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1079\">#1079</a>.
</li>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
November 4, 2016, by Michael Wetter:<br/>
Set default value for <code>dT.start</code> in base properties.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/575\">#575</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Set <code>AbsolutePressure(start=p_default)</code> to avoid
a translation error if
<a href=\"modelica://IDEAS.Fluid.Sources.Examples.TraceSubstancesFlowSource\">
IDEAS.Fluid.Sources.Examples.TraceSubstancesFlowSource</a>
is translated in pedantic mode in Dymola 2016.
The reason is that pressures use <code>Medium.p_default</code> as start values,
but
<a href=\"modelica://Modelica.Media.Interfaces.Types\">
Modelica.Media.Interfaces.Types</a>
sets a default value of <i>1E-5</i>.
A similar change has been done for pressure.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Added <code>stateSelect</code> attribute in <code>BaseProperties.T</code>
to allow correct use of <code>preferredMediumState</code> as
described in
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">
Modelica.Media.Interfaces.PartialMedium</a>.
Note that the default is <code>preferredMediumState=false</code>
and hence the same states are used as were used before.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
May 11, 2015, by Michael Wetter:<br/>
Removed
<code>p(stateSelect=if preferredMediumStates then StateSelect.prefer else StateSelect.default)</code>
in declaration of <code>BaseProperties</code>.
Otherwise, when models that contain a fluid volume
are exported as an FMU, their pressure would be
differentiated with respect to time. This would require
the time derivative of the inlet pressure, which is not available,
causing the translation to stop with an error.
</li>
<li>
May 1, 2015, by Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
<li>
March 20, 2015, by Michael Wetter:<br/>
Added missing term <code>state.p/reference_p</code> in function
<code>specificEntropy</code>.
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/193\">#193</a>.
</li>
<li>
February 3, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect.prefer</code> for temperature.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/160\">#160</a>.
</li>
<li>
July 24, 2014, by Michael Wetter:<br/>
Changed implementation to use
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Constants\">
IDEAS.Utilities.Psychrometrics.Constants</a>.
This was done to use consistent values throughout the library.
</li>
<li>
November 16, 2013, by Michael Wetter:<br/>
Revised and simplified the implementation.
</li>
<li>
November 14, 2013, by Michael Wetter:<br/>
Removed function
<code>HeatCapacityOfWater</code>
which is neither needed nor implemented in the
Modelica Standard Library.
</li>
<li>
November 13, 2013, by Michael Wetter:<br/>
Removed non-used computations in <code>specificEnthalpy_pTX</code> and
in <code>temperature_phX</code>.
</li>
<li>
March 29, 2013, by Michael Wetter:<br/>
Added <code>final standardOrderComponents=true</code> in the
<code>BaseProperties</code> declaration. This avoids an error
when models are checked in Dymola 2014 in the pedenatic mode.
</li>
<li>
April 12, 2012, by Michael Wetter:<br/>
Added keyword <code>each</code> to <code>Xi(stateSelect=...)</code>.
</li>
<li>
April 4, 2012, by Michael Wetter:<br/>
Added redeclaration of <code>ThermodynamicState</code> to avoid a warning
during model check and translation.
</li>
<li>
August 3, 2011, by Michael Wetter:<br/>
Fixed bug in <code>u=h-R*T</code>, which is only valid for ideal gases.
For this medium, the function is <code>u=h-pStd/dStp</code>.
</li>
<li>
January 27, 2010, by Michael Wetter:<br/>
Fixed bug in <code>else</code> branch of function <code>setState_phX</code>
that lead to a run-time error when the constructor of this function was called.
</li>
<li>
January 22, 2010, by Michael Wetter:<br/>
Added implementation of function
<a href=\"modelica://IDEAS.Media.GasesPTDecoupled.MoistAirUnsaturated.enthalpyOfNonCondensingGas\">
enthalpyOfNonCondensingGas</a> and its derivative.
</li>
<li>
January 13, 2010, by Michael Wetter:<br/>
Fixed implementation of derivative functions.
</li>
<li>
August 28, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),
        Icon(graphics={
            Ellipse(
              extent={{-78,78},{-34,34}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-18,86},{26,42}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{48,58},{92,14}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-22,32},{22,-12}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{36,-32},{80,-76}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-36,-30},{8,-74}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120}),
            Ellipse(
              extent={{-90,-6},{-46,-50}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={120,120,120})}));
    end Air;

    package Water "Package with model for liquid water with constant density"
       extends Modelica.Media.Water.ConstantPropertyLiquidWater(
         final cv_const=cp_const,
         p_default=300000,
         reference_p=300000,
         reference_T=273.15,
         reference_X={1},
         AbsolutePressure(start=p_default),
         Temperature(start=T_default),
         Density(start=d_const));
      // cp_const and cv_const have been made final because the model sets u=h.
      extends Modelica.Icons.Package;

      redeclare model BaseProperties "Base properties"
        Temperature T(stateSelect=
          if preferredMediumStates then StateSelect.prefer else StateSelect.default)
          "Temperature of medium";
        InputAbsolutePressure p "Absolute pressure of medium";
        InputMassFraction[nXi] Xi=fill(0, 0)
          "Structurally independent mass fractions";
        InputSpecificEnthalpy h "Specific enthalpy of medium";
        Modelica.SIunits.SpecificInternalEnergy u
          "Specific internal energy of medium";
        Modelica.SIunits.Density d=d_const "Density of medium";
        Modelica.SIunits.MassFraction[nX] X={1}
          "Mass fractions (= (component mass)/total mass  m_i/m)";
        final Modelica.SIunits.SpecificHeatCapacity R=0
          "Gas constant (of mixture if applicable)";
        final Modelica.SIunits.MolarMass MM=MM_const
          "Molar mass (of mixture or single fluid)";
        ThermodynamicState state
          "Thermodynamic state record for optional functions";
        parameter Boolean preferredMediumStates=false
          "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
          annotation(Evaluate=true, Dialog(tab="Advanced"));
        final parameter Boolean standardOrderComponents=true
          "If true, and reducedX = true, the last element of X will be computed from the other ones";
        Modelica.SIunits.Conversions.NonSIunits.Temperature_degC T_degC=
            Modelica.SIunits.Conversions.to_degC(T)
          "Temperature of medium in [degC]";
        Modelica.SIunits.Conversions.NonSIunits.Pressure_bar p_bar=
            Modelica.SIunits.Conversions.to_bar(p)
          "Absolute pressure of medium in [bar]";

        // Local connector definition, used for equation balancing check
        connector InputAbsolutePressure = input
          Modelica.SIunits.AbsolutePressure
          "Pressure as input signal connector";
        connector InputSpecificEnthalpy = input
          Modelica.SIunits.SpecificEnthalpy
          "Specific enthalpy as input signal connector";
        connector InputMassFraction = input Modelica.SIunits.MassFraction
          "Mass fraction as input signal connector";

      equation
      assert(T >= T_min, "
In "       + getInstanceName() + ": Temperature T exceeded its minimum allowed value of " + String(T_min-273.15)
        + " degC (" + String(T_min) + " Kelvin)
as required from medium model \""     + mediumName + "\".");
      assert(T <= T_max, "
In "       + getInstanceName() + ": Temperature T exceeded its maximum allowed value of " + String(T_max-273.15)
        + " degC (" + String(T_max) + " Kelvin)
as required from medium model \""     + mediumName + "\".");

        h = cp_const*(T-reference_T);
        u = h;
        state.T = T;
        state.p = p;
        annotation(Documentation(info="<html>
    <p>
    This base properties model is identical to
    <a href=\"modelica://Modelica.Media.Water.ConstantPropertyLiquidWater\">
    Modelica.Media.Water.ConstantPropertyLiquidWater</a>,
    except that the equation
    <code>u = cv_const*(T - reference_T)</code>
    has been replaced by <code>u=h</code> because
    <code>cp_const=cv_const</code>.
    </p>
</html>"));
      end BaseProperties;

    function enthalpyOfLiquid "Return the specific enthalpy of liquid"
      extends Modelica.Icons.Function;
      input Modelica.SIunits.Temperature T "Temperature";
      output Modelica.SIunits.SpecificEnthalpy h "Specific enthalpy";
    algorithm
      h := cp_const*(T-reference_T);
    annotation (
      smoothOrder=5,
      Inline=true,
    Documentation(info="<html>
<p>
Enthalpy of the water.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 16, 2014 by Michael Wetter:<br/>
First implementation.
This function is used by
<a href=\"modelica://IDEAS.Fluid.MixingVolumes.MixingVolumeMoistAir\">
IDEAS.Fluid.MixingVolumes.MixingVolumeMoistAir</a>.
</li>
</ul>
</html>"));
    end enthalpyOfLiquid;
      annotation(preferredView="info", Documentation(info="<html>
<p>
This medium package models liquid water.
</p>
<p>
The mass density is computed using a constant value of <i>995.586</i> kg/s.
For a medium model in which the density is a function of temperature, use
<a href=\"modelica://IDEAS.Media.Specialized.Water.TemperatureDependentDensity\">
IDEAS.Media.Specialized.Water.TemperatureDependentDensity</a> which may have considerably higher computing time.
</p>
<p>
For the specific heat capacities at constant pressure and at constant volume,
a constant value of <i>4184</i> J/(kg K), which corresponds to <i>20</i>&deg;C
is used.
The figure below shows the relative error of the specific heat capacity that
is introduced by this simplification.
</p>
<p align=\"center\">
<img src=\"modelica://IDEAS/Resources/Images/Media/Water/plotCp.png\" border=\"1\"
alt=\"Relative variation of specific heat capacity with temperature\"/>
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C.
</p>
<h4>Limitations</h4>
<p>
Density, specific heat capacity, thermal conductivity and viscosity are constant.
Water is modeled as an incompressible liquid.
There are no phase changes.
</p>
</html>",     revisions="<html>
<ul>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Set <code>AbsolutePressure(start=p_default)</code> to avoid
a translation error if
<a href=\"modelica://IDEAS.Fluid.Sources.Examples.TraceSubstancesFlowSource\">
IDEAS.Fluid.Sources.Examples.TraceSubstancesFlowSource</a>
(if used with water instead of air)
is translated in pedantic mode in Dymola 2016.
The reason is that pressures use <code>Medium.p_default</code> as start values,
but
<a href=\"modelica://Modelica.Media.Interfaces.Types\">
Modelica.Media.Interfaces.Types</a>
sets a default value of <i>1E-5</i>.
A similar change has been done for pressure and density.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 6, 2015, by Michael Wetter:<br/>
Changed type of <code>BaseProperties.T</code> from
<code>Modelica.SIunits.Temperature</code> to <code>Temperature</code>.
Otherwise, it has a different start value than <code>Medium.T</code>, which
causes an error if
<a href=\"IDEAS.Media.Examples.WaterProperties\">
IDEAS.Media.Examples.WaterProperties</a>
is translated in pedantic mode.
This fixes
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/266\">#266</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Added <code>stateSelect</code> attribute in <code>BaseProperties.T</code>
to allow correct use of <code>preferredMediumState</code> as
described in
<a href=\"modelica://Modelica.Media.Interfaces.PartialMedium\">
Modelica.Media.Interfaces.PartialMedium</a>,
and set <code>preferredMediumState=false</code>
to keep the same states as were used before.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/260\">#260</a>.
</li>
<li>
June 5, 2015, by Michael Wetter:<br/>
Removed <code>ThermodynamicState</code> declaration as this lead to
the error
\"Attempting to redeclare record ThermodynamicState when the original was not replaceable.\"
in Dymola 2016 using the pedantic model check.
</li>
<li>
May 1, 2015, by Michael Wetter:<br/>
Added <code>Inline=true</code> for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/227\">
issue 227</a>.
</li>
<li>
February 25, 2015, by Michael Wetter:<br/>
Removed <code>stateSelect</code> attribute on pressure as this caused
<a href=\"modelica://IDEAS.Examples.Tutorial.SpaceCooling.System3\">
IDEAS.Examples.Tutorial.SpaceCooling.System3</a>
to fail with the error message
\"differentiated if-then-else was not continuous\".
</li>
<li>
October 15, 2014, by Michael Wetter:<br/>
Reimplemented media based on
<a href=\"https://github.com/ibpsa/modelica-ibpsa/blob/446aa83720884052476ad6d6d4f90a6a29bb8ec9/IDEAS/Media/Water.mo\">446aa83</a>.
</li>
<li>
November 15, 2013, by Michael Wetter:<br/>
Complete new reimplementation because the previous version
had the option to add a compressibility to the medium, which
has never been used.
</li>
</ul>
</html>"),
        Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
            graphics={
            Polygon(
              points={{16,-28},{32,-42},{26,-48},{10,-36},{16,-28}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Polygon(
              points={{10,34},{26,44},{30,36},{14,26},{10,34}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Ellipse(
              extent={{-82,52},{24,-54}},
              lineColor={95,95,95},
              fillPattern=FillPattern.Sphere,
              fillColor={0,0,0}),
            Ellipse(
              extent={{22,82},{80,24}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95}),
            Ellipse(
              extent={{20,-30},{78,-88}},
              lineColor={0,0,0},
              fillPattern=FillPattern.Sphere,
              fillColor={95,95,95})}));
    end Water;

    package Antifreeze "Medium packages of secondary working fluids"
      extends Modelica.Icons.Package;

      package PropyleneGlycolWater
      "Package with model for propylene glycol - water with constant properties"
        extends Modelica.Media.Interfaces.PartialSimpleMedium(
          mediumName="PropyleneGlycolWater(X_a = "
            + String(X_a) + ", property_T = "
            + String(property_T) + ")",
          final cp_const=specificHeatCapacityCp_TX_a(T = property_T, X_a = X_a),
          final cv_const=cp_const,
          final d_const=density_TX_a(T = property_T, X_a = X_a),
          final eta_const=dynamicViscosity_TX_a(T = property_T, X_a = X_a),
          final lambda_const=thermalConductivity_TX_a(T = property_T, X_a = X_a),
          a_const=1484,
          final T_min=fusionTemperature_TX_a(T = property_T, X_a = X_a),
          T_max=Modelica.SIunits.Conversions.from_degC(100),
          T0=273.15,
          MM_const=(X_a/simplePropyleneGlycolWaterConstants[1].molarMass + (1
               - X_a)/0.018015268)^(-1),
          fluidConstants=simplePropyleneGlycolWaterConstants,
          p_default=300000,
          reference_p=300000,
          reference_T=273.15,
          reference_X={1},
          AbsolutePressure(start=p_default),
          Temperature(start=T_default),
          Density(start=d_const));

        constant Modelica.SIunits.Temperature property_T
          "Temperature for evaluation of constant fluid properties";

        constant Modelica.SIunits.MassFraction X_a
          "Mass fraction of propylene glycol in water";

        redeclare model BaseProperties "Base properties"
          Temperature T(stateSelect=
            if preferredMediumStates then StateSelect.prefer else StateSelect.default)
            "Temperature of medium";

          InputAbsolutePressure p "Absolute pressure of medium";
          InputMassFraction[nXi] Xi=fill(0, 0)
            "Structurally independent mass fractions";
          InputSpecificEnthalpy h "Specific enthalpy of medium";
          Modelica.SIunits.SpecificInternalEnergy u
            "Specific internal energy of medium";
          Modelica.SIunits.Density d=d_const "Density of medium";
          Modelica.SIunits.MassFraction[nX] X={1}
            "Mass fractions (= (component mass)/total mass  m_i/m)";
          final Modelica.SIunits.SpecificHeatCapacity R=0
            "Gas constant (of mixture if applicable)";
          final Modelica.SIunits.MolarMass MM=MM_const
            "Molar mass (of mixture or single fluid)";
          ThermodynamicState state
            "Thermodynamic state record for optional functions";
          parameter Boolean preferredMediumStates=false
            "= true if StateSelect.prefer shall be used for the independent property variables of the medium"
            annotation(Evaluate=true, Dialog(tab="Advanced"));
          final parameter Boolean standardOrderComponents=true
            "If true, and reducedX = true, the last element of X will be computed from the other ones";
          Modelica.SIunits.Conversions.NonSIunits.Temperature_degC T_degC=
              Modelica.SIunits.Conversions.to_degC(T)
            "Temperature of medium in [degC]";
          Modelica.SIunits.Conversions.NonSIunits.Pressure_bar p_bar=
              Modelica.SIunits.Conversions.to_bar(p)
            "Absolute pressure of medium in [bar]";

          // Local connector definition, used for equation balancing check
          connector InputAbsolutePressure = input
            Modelica.SIunits.AbsolutePressure
            "Pressure as input signal connector";
          connector InputSpecificEnthalpy = input
            Modelica.SIunits.SpecificEnthalpy
            "Specific enthalpy as input signal connector";
          connector InputMassFraction = input Modelica.SIunits.MassFraction
            "Mass fraction as input signal connector";

        equation
        assert(T >= T_min, "
In "         + getInstanceName() + ": Temperature T exceeded its minimum allowed value of " + String(T_min-273.15)
          + " degC (" + String(T_min) + " Kelvin)
as required from medium model \""       + mediumName + "\".");
        assert(T <= T_max, "
In "         + getInstanceName() + ": Temperature T exceeded its maximum allowed value of " + String(T_max-273.15)
          + " degC (" + String(T_max) + " Kelvin)
as required from medium model \""       + mediumName + "\".");

        assert(X_a >= X_a_min, "
In "         + getInstanceName() + ": Mass fraction x_a exceeded its minimum allowed value of " + String(X_a_min) + "
as required from medium model \""       + mediumName + "\".");
        assert(X_a <= X_a_max, "
In "         + getInstanceName() + ": Mass fraction x_a exceeded its maximum allowed value of " + String(X_a_max) + "
as required from medium model \""       + mediumName + "\".");

          h = cp_const*(T-reference_T);
          u = h;
          state.T = T;
          state.p = p;

          annotation(Documentation(info="<html>
    <p>
    This base properties model is identical to
    <a href=\"modelica://Modelica.Media.Water.ConstantPropertyLiquidWater\">
    Modelica.Media.Water.ConstantPropertyLiquidWater</a>,
    except that the equation
    <code>u = cv_const*(T - reference_T)</code>
    has been replaced by <code>u=h</code> because
    <code>cp_const=cv_const</code>.
    Also, the model checks if the mass fraction of the mixture is within the
    allowed limits.
    </p>
</html>"));
        end BaseProperties;

        constant Modelica.SIunits.MassFraction X_a_min=0.
          "Minimum allowed mass fraction of propylene glycol in water";

        constant Modelica.SIunits.MassFraction X_a_max=0.6
          "Maximum allowed mass fraction of propylene glycol in water";

        constant Modelica.Media.Interfaces.Types.Basic.FluidConstants[1]
          simplePropyleneGlycolWaterConstants(
          each chemicalFormula="C3H8O2",
          each structureFormula="CH3CH(OH)CH2OH",
          each casRegistryNumber="57-55-6",
          each iupacName="1,2-Propylene glycol",
          each molarMass=0.07609);

        constant IDEAS.Media.Antifreeze.BaseClasses.PropertyCoefficients
          proCoe(
          X_a_ref=0.307031,
          T_ref=Modelica.SIunits.Conversions.from_degC(32.7083),
          nX_a=6,
          nT={4,4,4,3,2,1},
          nTot=18,
          a_d={1.018e3,-5.406e-1,-2.666e-3,1.347e-5,7.604e-1,-9.450e-3,5.541e-5,-1.343e-7,
              -2.498e-3,2.700e-5,-4.018e-7,3.376e-9,-1.550e-4,2.829e-6,-7.175e-9,-1.131e-6,
              -2.221e-8,2.342e-8},
          a_eta={6.837e-1,-3.045e-2,2.525e-4,-1.399e-6,3.328e-2,-3.984e-4,4.332e-6,-1.860e-8,
              5.453e-5,-8.600e-8,-1.593e-8,-4.465e-11,-3.900e-6,1.054e-7,-1.589e-9,-1.587e-8,
              4.475e-10,3.564e-9},
          a_Tf={-1.325e1,-3.820e-5,7.865e-7,-1.733e-9,-6.631e-1,6.774e-6,-6.242e-8,-7.819e-10,
              -1.094e-2,5.332e-8,-4.169e-9,3.288e-11,-2.283e-4,-1.131e-8,1.918e-10,-3.409e-6,
              8.035e-11,1.465e-8},
          a_cp={3.882e3,2.699e0,-1.659e-3,-1.032e-5,-1.304e1,5.070e-2,-4.752e-5,
              1.522e-6,-1.598e-1,9.534e-5,1.167e-5,-4.870e-8,3.539e-4,3.102e-5,-2.950e-7,
              5.000e-5,-7.135e-7,-4.959e-7},
          a_lambda={4.513e-1,7.955e-4,3.482e-8,-5.966e-9,-4.795e-3,-1.678e-5,8.941e-8,
              1.493e-10,2.076e-5,1.563e-7,-4.615e-9,9.897e-12,-9.083e-8,-2.518e-9,
              6.543e-11,-5.952e-10,-3.605e-11,2.104e-11})
          "Coefficients for evaluation of thermo-physical properties";

        replaceable function density_TX_a
          "Evaluate density of antifreeze-water mixture"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature T "Temperature of antifreeze-water mixture";
          input Modelica.SIunits.MassFraction X_a "Mass fraction of antifreeze";
          output Modelica.SIunits.Density d "Density of antifreeze-water mixture";
        algorithm
          d :=polynomialProperty(
              X_a,
              T,
              proCoe.a_d)
          annotation (
          Documentation(info="<html>
  <p>
  Density of propylene antifreeze-water mixture at specified mass fraction
  and temperature, based on Melinder (2010).
  </p>
  <h4>References</h4>
  <p>
  Melinder, &#197;ke. 2010. Properties of Secondary Working Fluids (Secondary
  Refrigerants or Coolants, Heat Transfer Fluids) for Indirect Systems. Paris:
  IIR/IIF.
  </p>
  </html>",
        revisions="<html>
  <ul>
  <li>
  May 2, 2018 by Massimo Cimmino:<br/>
  First implementation.
  This function is used by
  <a href=\"modelica://IDEAS.Media.Antifreeze.PropyleneGlycolWater\">
  IDEAS.Media.Antifreeze.PropyleneGlycolWater</a>.
  </li>
  </ul>
  </html>"));

        end density_TX_a;

        replaceable function dynamicViscosity_TX_a
          "Evaluate dynamic viscosity of antifreeze-water mixture"
            extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature T "Temperature of antifreeze-water mixture";
          input Modelica.SIunits.MassFraction X_a "Mass fraction of antifreeze";
          output Modelica.SIunits.DynamicViscosity eta "Dynamic Viscosity of antifreeze-water mixture";
        algorithm
          eta :=1e-3*exp(polynomialProperty(
              X_a,
              T,
              proCoe.a_eta));

        annotation (
        Documentation(info="<html>
<p>
Dynamic viscosity of antifreeze-water mixture at specified mass fraction and
temperature, based on Melinder (2010).
</p>
<h4>References</h4>
<p>
Melinder, &#197;ke. 2010. Properties of Secondary Working Fluids (Secondary
Refrigerants or Coolants, Heat Transfer Fluids) for Indirect Systems. Paris:
IIR/IIF.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 2, 2018 by Massimo Cimmino:<br/>
First implementation.
This function is used by
<a href=\"modelica://IDEAS.Media.Antifreeze.PropyleneGlycolWater\">
IDEAS.Media.Antifreeze.PropyleneGlycolWater</a>.
</li>
</ul>
</html>"));
        end dynamicViscosity_TX_a;

        replaceable function fusionTemperature_TX_a
          "Evaluate temperature of fusion of antifreeze-water mixture"
            extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature T "Temperature of antifreeze-water mixture";
          input Modelica.SIunits.MassFraction X_a "Mass fraction of antifreeze";
          output Modelica.SIunits.Temperature Tf "Temperature of fusion of antifreeze-water mixture";
        algorithm
          Tf :=Modelica.SIunits.Conversions.from_degC(polynomialProperty(
              X_a,
              T,
              proCoe.a_Tf));

        annotation (
        Documentation(info="<html>
<p>
Fusion temperature of antifreeze-water mixture at specified mass fraction and
temperature, based on Melinder (2010).
</p>
<h4>References</h4>
<p>
Melinder, &#197;ke. 2010. Properties of Secondary Working Fluids (Secondary
Refrigerants or Coolants, Heat Transfer Fluids) for Indirect Systems. Paris:
IIR/IIF.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 2, 2018 by Massimo Cimmino:<br/>
First implementation.
This function is used by
<a href=\"modelica://IDEAS.Media.Antifreeze.PropyleneGlycolWater\">
IDEAS.Media.Antifreeze.PropyleneGlycolWater</a>.
</li>
</ul>
</html>"));
        end fusionTemperature_TX_a;

        replaceable function polynomialProperty
          "Evaluates thermophysical property from 2-variable polynomial"
          extends Modelica.Icons.Function;

          input Real x "First independent variable";
          input Real y "Second independent variable";
          input Real a[sum(proCoe.nT)] "Polynomial coefficients";

          output Real f "Value of thermophysical property";

      protected
          Real dx;
          Real dy;
          Integer n;
        algorithm
          dx := 100*(x - proCoe.X_a_ref);
          dy := y - proCoe.T_ref;

          f := 0;
          n := 0;
          for i in 0:proCoe.nX_a - 1 loop
            for j in 0:proCoe.nT[i+1] - 1 loop
              n := n + 1;
              f := f + a[n]*dx^i*dy^j;
            end for;
          end for;
        annotation (
        Documentation(info="<html>
<p>
Evaluates a thermophysical property of a mixture, based on correlations proposed
by Melinder (2010).
</p>
<p>
The polynomial has the form
</p>
<p align=\"center\" style=\"font-style:italic;\">
f = a<sub>1</sub> (x-xm)<sup>0</sup>(y-ym)<sup>0</sup>
+ a<sub>2</sub> (x-xm)<sup>0</sup>(y-ym)<sup>1</sup>
+ ... +
a<sub>ny[1]</sub> (x-xm)<sup>0</sup>(y-ym)<sup>ny[1]-1</sup>
+ ... +
a<sub>ny[1])+1</sub> (x-xm)<sup>1</sup>(y-ym)<sup>0</sup>
+ ... +
a<sub>ny[1]+ny[2]</sub> (x-xm)<sup>1</sup>(y-ym)<sup>ny[2]-1</sup>
+ ...
</p>
<h4>References</h4>
<p>
Melinder, &#197;ke. 2010. Properties of Secondary Working Fluids (Secondary
Refrigerants or Coolants, Heat Transfer Fluids) for Indirect Systems. Paris:
IIR/IIF.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 16, 2018 by Massimo Cimmino:<br/>
First implementation.
This function is used models in
<a href=\"modelica://IDEAS.Media.Antifreeze\">
IDEAS.Media.Antifreeze</a>.
</li>
</ul>
</html>"));
        end polynomialProperty;

        replaceable function specificHeatCapacityCp_TX_a
          "Evaluate specific heat capacity of antifreeze-water mixture"
            extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature T "Temperature of antifreeze-water mixture";
          input Modelica.SIunits.MassFraction X_a "Mass fraction of antifreeze";
          output Modelica.SIunits.SpecificHeatCapacity cp "Specific heat capacity of antifreeze-water mixture";
        algorithm
          cp :=polynomialProperty(
              X_a,
              T,
              proCoe.a_cp);

        annotation (
        Documentation(info="<html>
<p>
Specific heat capacity of antifreeze-water mixture at specified mass fraction
and temperature, based on Melinder (2010).
</p>
<h4>References</h4>
<p>
Melinder, &#197;ke. 2010. Properties of Secondary Working Fluids (Secondary
Refrigerants or Coolants, Heat Transfer Fluids) for Indirect Systems. Paris:
IIR/IIF.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 16, 2018 by Massimo Cimmino:<br/>
First implementation.
This function is used by
<a href=\"modelica://IDEAS.Media.Antifreeze.PropyleneGlycolWater\">
IDEAS.Media.Antifreeze.PropyleneGlycolWater</a>.
</li>
</ul>
</html>"));
        end specificHeatCapacityCp_TX_a;

        replaceable function thermalConductivity_TX_a
          "Evaluate thermal conductivity of antifreeze-water mixture"
            extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature T "Temperature of antifreeze-water mixture";
          input Modelica.SIunits.MassFraction X_a "Mass fraction of antifreeze";
          output Modelica.SIunits.ThermalConductivity lambda "Thermal conductivity of antifreeze-water mixture";
        algorithm
          lambda :=polynomialProperty(
              X_a,
              T,
              proCoe.a_lambda);

        annotation (
        Documentation(info="<html>
<p>
Thermal conductivity of antifreeze-water mixture at specified mass fraction and
temperature, based on Melinder (2010).
</p>
<h4>References</h4>
<p>
Melinder, &#197;ke. 2010. Properties of Secondary Working Fluids (Secondary
Refrigerants or Coolants, Heat Transfer Fluids) for Indirect Systems. Paris:
IIR/IIF.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 16, 2018 by Massimo Cimmino:<br/>
First implementation.
This function is used by
<a href=\"modelica://IDEAS.Media.Antifreeze.PropyleneGlycolWater\">
IDEAS.Media.Antifreeze.PropyleneGlycolWater</a>.
</li>
</ul>
</html>"));
        end thermalConductivity_TX_a;
      annotation(preferredView="info", Documentation(info="<html>
<p>
This medium package models propylene glycol - water mixtures.
</p>
<p>
The mass density, specific heat capacity, thermal conductivity and viscosity
are assumed constant and evaluated at a set temperature and mass fraction of
propylene glycol within the mixture. The dependence of the four properties
are shown on the figure below.
</p>
<p align=\"center\">
<img src=\"modelica://IDEAS/Resources/Images/Media/Antifreeze/PropyleneGlycolWaterProperties.png\" border=\"1\"
alt=\"Relative variation of specific heat capacity with temperature\"/>
</p>
<p>
The accuracy of the thermophysical properties is dependent on the temperature
variations encountered during simulations.
The figure below shows the relative error of the the four properties over a
<i>10</i> &deg;C range around the temperature used to evaluate the constant
properties. The maximum errors are <i>0.8</i> % for mass density, <i>1.5</i> %
for specific heat capacity, <i>3.2</i> % for thermal conductivity and <i>250</i>
% for dynamic viscosity.
</p>
<p align=\"center\">
<img src=\"modelica://IDEAS/Resources/Images/Media/Antifreeze/PropyleneGlycolWaterError10degC.png\" border=\"1\"
alt=\"Relative variation of specific heat capacity with temperature\"/>
</p>
<p>
The figure below shows the relative error of the the four properties over a
<i>20</i> &deg;C range around the temperature used to evaluate the constant
proepties. The maximum errors are <i>1.6</i> % for mass density, <i>3.0</i> %
for specific heat capacity, <i>6.2</i> % for thermal conductivity and <i>950</i>
% for dynamic viscosity.
</p>
<p align=\"center\">
<img src=\"modelica://IDEAS/Resources/Images/Media/Antifreeze/PropyleneGlycolWaterError20degC.png\" border=\"1\"
alt=\"Relative variation of specific heat capacity with temperature\"/>
</p>
<p>
The enthalpy is computed using the convention that <i>h=0</i>
if <i>T=0</i> &deg;C.
</p>
<h4>Limitations</h4>
<p>
Density, specific heat capacity, thermal conductivity and viscosity are constant.
The propylene glycol/water mixture is modeled as an incompressible liquid.
There are no phase changes. The medium is limited to temperatures below
<i>100</i> &deg;C and mass fractions below <i>0.60</i>.
As is the case for IDEAS.Media.Water, this medium package should not be used if
the simulation relies on the dynamic viscosity.
</p>
<h4>Typical use and important parameters</h4>
<p>
The temperature and mass fraction must be specified for the evaluation of the
constant thermophysical properties. A typical use of the package is (e.g. for
a temperature of <i>20</i> &deg;C and a mass fraction of <i>0.40</i>):
</p>
<p>
<code>Medium = IDEAS.Media.Antifreeze.PropyleneGlycolWater(property_T=293.15, X_a=0.40)</code>
</p>
</html>",       revisions="<html>
<ul>
<li>
October 26, 2018, by Filip Jorissen and Michael Wetter:<br/>
Now printing different messages if temperature or mass fraction is above or below its limit,
and adding instance name as JModelica does not print the full instance name in the assertion.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1045\">#1045</a>.
</li>
<li>
March 16, 2018, by Massimo Cimmino:<br/>
First implementation.
</li>
</ul>
</html>"));
      end PropyleneGlycolWater;

      package Validation "Validation cases for fluid property evaluations"
      extends Modelica.Icons.ExamplesPackage;

        package BaseClasses
        "Package with base classes for IDEAS.Media.Antifreeze.Validation"
        extends Modelica.Icons.BasesPackage;

          package PropyleneGlycolWater
            "PropyleneGlycolWater with publicly accessible medium functions"
            extends IDEAS.Media.Antifreeze.PropyleneGlycolWater;

              replaceable function testDensity_TX_a
              "Evaluate density of antifreeze-water mixture"
              extends Modelica.Icons.Function;
              input Modelica.SIunits.Temperature T "Temperature of antifreeze-water mixture";
              input Modelica.SIunits.MassFraction X_a "Mass fraction of antifreeze";
              output Modelica.SIunits.Density d "Density of antifreeze-water mixture";
              algorithm
              d := density_TX_a(T = T, X_a = X_a);

              annotation (Documentation(info="<html>
<p>
Function that makes
<a href=\"modelica://IDEAS.Media.Antifreeze.PropyleneGlycolWater.density_TX_a\">
IDEAS.Media.Antifreeze.PropyleneGlycolWater.density_TX_a</a>
publicly accessible as needed for the validation model
<a href=\"modelica://IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties\">
IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 14, 2018 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
              end testDensity_TX_a;

            function testDynamicViscosity_TX_a
              "Evaluate dynamic viscosity of antifreeze-water mixture"
                extends Modelica.Icons.Function;
              input Modelica.SIunits.Temperature T "Temperature of antifreeze-water mixture";
              input Modelica.SIunits.MassFraction X_a "Mass fraction of antifreeze";
              output Modelica.SIunits.DynamicViscosity eta "Dynamic Viscosity of antifreeze-water mixture";
            algorithm
              eta := dynamicViscosity_TX_a(T = T, X_a = X_a);

              annotation (Documentation(info="<html>
<p>
Function that makes
<a href=\"modelica://IDEAS.Media.Antifreeze.PropyleneGlycolWater.dynamicViscosity_TX_a\">
IDEAS.Media.Antifreeze.PropyleneGlycolWater.dynamicViscosity_TX_a</a>
publicly accessible as needed for the validation model
<a href=\"modelica://IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties\">
IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 14, 2018 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end testDynamicViscosity_TX_a;

            function testFusionTemperature_TX_a
              "Evaluate temperature of fusion of antifreeze-water mixture"
                extends Modelica.Icons.Function;
              input Modelica.SIunits.Temperature T "Temperature of antifreeze-water mixture";
              input Modelica.SIunits.MassFraction X_a "Mass fraction of antifreeze";
              output Modelica.SIunits.Temperature Tf "Temperature of fusion of antifreeze-water mixture";
            algorithm
              Tf := fusionTemperature_TX_a(T = T, X_a = X_a);

              annotation (Documentation(info="<html>
<p>
Function that makes
<a href=\"modelica://IDEAS.Media.Antifreeze.PropyleneGlycolWater.fusionTemperature_TX_a\">
IDEAS.Media.Antifreeze.PropyleneGlycolWater.fusionTemperature_TX_a</a>
publicly accessible as needed for the validation model
<a href=\"modelica://IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties\">
IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 14, 2018 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end testFusionTemperature_TX_a;

            function testSpecificHeatCapacityCp_TX_a
              "Evaluate specific heat capacity of antifreeze-water mixture"
                extends Modelica.Icons.Function;
              input Modelica.SIunits.Temperature T "Temperature of antifreeze-water mixture";
              input Modelica.SIunits.MassFraction X_a "Mass fraction of antifreeze";
              output Modelica.SIunits.SpecificHeatCapacity cp "Specific heat capacity of antifreeze-water mixture";
            algorithm
              cp := specificHeatCapacityCp_TX_a(T = T, X_a = X_a);

              annotation (Documentation(info="<html>
<p>
Function that makes
<a href=\"modelica://IDEAS.Media.Antifreeze.PropyleneGlycolWater.specificHeatCapacityCp_TX_a\">
IDEAS.Media.Antifreeze.PropyleneGlycolWater.specificHeatCapacityCp_TX_a</a>
publicly accessible as needed for the validation model
<a href=\"modelica://IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties\">
IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 14, 2018 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end testSpecificHeatCapacityCp_TX_a;

            function testThermalConductivity_TX_a
              "Evaluate thermal conductivity of antifreeze-water mixture"
                extends Modelica.Icons.Function;
              input Modelica.SIunits.Temperature T "Temperature of antifreeze-water mixture";
              input Modelica.SIunits.MassFraction X_a "Mass fraction of antifreeze";
              output Modelica.SIunits.ThermalConductivity lambda "Thermal conductivity of antifreeze-water mixture";
            algorithm
              lambda := thermalConductivity_TX_a(T = T, X_a = X_a);

              annotation (Documentation(info="<html>
<p>
Function that makes
<a href=\"modelica://IDEAS.Media.Antifreeze.PropyleneGlycolWater.thermalConductivity_TX_a\">
IDEAS.Media.Antifreeze.PropyleneGlycolWater.thermalConductivity_TX_a</a>
publicly accessible as needed for the validation model
<a href=\"modelica://IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties\">
IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
May 14, 2018 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
            end testThermalConductivity_TX_a;
          annotation (Documentation(info="<html>
<p>
Media implementation that extends
<a href=\"modelica://IDEAS.Media.Antifreeze\">
IDEAS.Media.Antifreeze</a>
in order to make its thermophysical property functions
publicly accessible as needed for the validation model
<a href=\"modelica://IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties\">
IDEAS.Media.Antifreeze.Validation.BaseClasses.FluidProperties</a>.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 14, 2018 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end PropyleneGlycolWater;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Media.Antifreeze.Validation\">
IDEAS.Media.Antifreeze.Validation</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains validation cases that test the media packages in
<a href=\"modelica://IDEAS.Media.Antifreeze\">
IDEAS.Media.Antifreeze</a>.
</p>
</html>"));
      end Validation;

      package BaseClasses
      "Base classes for secondary working fluid media packages"
      extends Modelica.Icons.BasesPackage;

        record PropertyCoefficients
          "Polynomial coefficients to evaluate fluid properties"
          extends Modelica.Icons.Record;
          Modelica.SIunits.MassFraction X_a_ref "Reference mass fraction";
          Modelica.SIunits.Temperature T_ref "Reference temperature";
          Integer nX_a "Order of polynomial in x";
          Integer nT[nX_a] "Order of polynomial in y";
          Integer nTot "Total number of coefficients";
          Real a_d[nTot] "Polynomial coefficients for density";
          Real a_eta[nTot] "Polynomial coefficients for dynamic viscosity";
          Real a_Tf[nTot] "Polynomial coefficients for fusion temperature";
          Real a_cp[nTot] "Polynomial coefficients for specific heat capacity";
          Real a_lambda[nTot] "Polynomial coefficients for thermal conductivity";
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<p>
Record that is used by media packages in 
<a href=\"modelica://IDEAS.Media.Antifreeze\">
IDEAS.Media.Antifreeze</a> to implement the thermophysical properties
based on Melinder (2010).
</p>
<h4>References</h4>
<p>
Melinder, &#197;ke. 2010. Properties of Secondary Working Fluids (Secondary
Refrigerants or Coolants, Heat Transfer Fluids) for Indirect Systems. Paris:
IIR/IIF.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 11, 2018, by Michael Wetter:
Added documentation.
</li>
</ul>
</html>"));
        end PropertyCoefficients;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Media.Antifreeze\">
IDEAS.Media.Antifreeze</a>.
</p>
</html>"));
      end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains media models for liquid mixtures used in HVAC
applications. The media models evaluate the thermophysical
properties at a user-specifiable temperature <code>property_T</code>,
and the thermophysical properties are then kept constant during the simulation.
</p>
</html>"));
    end Antifreeze;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains media models for water and moist air.
The media models in this package are
compatible with
<a href=\"modelica://Modelica.Media\">
Modelica.Media</a>
but the implementation is in general simpler, which often
leads to more efficient simulation.
Due to the simplifications, the media model of this package
are generally accurate for a smaller temperature range than the
models in <a href=\"modelica://Modelica.Media\">
Modelica.Media</a>, but the smaller temperature range may often be
sufficient for building HVAC applications.
</p>
</html>"),
  Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}}),
          graphics={
          Line(
            points = {{-76,-80},{-62,-30},{-32,40},{4,66},{48,66},{73,45},{62,-8},{48,-50},{38,-80}},
            color={64,64,64},
            smooth=Smooth.Bezier),
          Line(
            points={{-40,20},{68,20}},
            color={175,175,175}),
          Line(
            points={{-40,20},{-44,88},{-44,88}},
            color={175,175,175}),
          Line(
            points={{68,20},{86,-58}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{56,-28}},
            color={175,175,175}),
          Line(
            points={{-60,-28},{-74,84},{-74,84}},
            color={175,175,175}),
          Line(
            points={{56,-28},{70,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{38,-80}},
            color={175,175,175}),
          Line(
            points={{-76,-80},{-94,-16},{-94,-16}},
            color={175,175,175})}));
  end Media;

  package Templates "Template models on different level"
  extends Modelica.Icons.Package;

    package Interfaces "Partials"
    extends Modelica.Icons.InterfacesPackage;
    import SI = Modelica.SIunits;

      package BaseClasses
      extends Modelica.Icons.BasesPackage;

        partial model Occupant
          extends IDEAS.Templates.Interfaces.BaseClasses.PartialSystem;
          parameter Integer nZones(min=1) "number of conditioned thermal zones";
          parameter Integer id=1 "id-number on extern data references";
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nZones] heatPortCon
            "Nodes for convective heat gains" annotation (Placement(transformation(
                  extent={{-210,10},{-190,30}}),iconTransformation(extent={{-210,10},{
                    -190,30}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[nZones] heatPortRad
            "Nodes for radiative heat gains" annotation (Placement(transformation(
                  extent={{-210,-30},{-190,-10}}),iconTransformation(extent={{-210,-30},
                    {-190,-10}})));
          Modelica.Blocks.Interfaces.RealOutput[nZones] TSet(
            final quantity="ThermodynamicTemperature",
            unit="K",
            displayUnit="degC",
            min=0) "Setpoint temperature for the zones" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,100}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={0,100})));
          Modelica.Blocks.Interfaces.RealOutput mDHW60C
            "mFlow for domestic hot water, at 60 degC" annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={60,100}), iconTransformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={60,100})));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-200,
                    -100},{200,100}}),
                                 graphics={
                Rectangle(
                  extent={{-200,100},{200,-100}},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid,
                  lineColor={191,0,0}),
                Line(
                  points={{200,100},{200,-100}},
                  color={85,170,255},
                  smooth=Smooth.None),
                Polygon(
                  points={{-10,-38},{-10,42},{50,2},{-10,-38}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Rectangle(
                  extent={{70,42},{50,-38}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Text(
                  extent={{-28,32},{34,-28}},
                  lineColor={0,0,0},
                  fillColor={95,95,95},
                  fillPattern=FillPattern.Solid,
                  textStyle={TextStyle.Italic},
                  fontName="Bookman Old Style",
                  textString="?"),
                Line(
                  points={{-200,20},{-20,20}},
                  color={127,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{-200,-20},{-20,-20}},
                  color={127,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{0,100},{0,52}},
                  color={0,0,127},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{60,100},{60,52}},
                  color={0,0,127},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Line(
                  points={{210,0},{80,0}},
                  color={85,170,255},
                  smooth=Smooth.None)}), Diagram(coordinateSystem(preserveAspectRatio=false,
                  extent={{-200,-100},{200,100}}), graphics));
        end Occupant;

        partial model PartialSystem "General partial for electricity-based systems"
          outer IDEAS.BoundaryConditions.SimInfoManager sim
            "Simulation information manager for climate data"
            annotation (Placement(transformation(extent={{-200,80},{-180,100}})));
          parameter Integer nZones(min=1)
            "Number of conditioned thermal zones in the building";
          // --- Electrical
          parameter Integer nLoads(min=0) = 0
            "Number of electric loads. If zero, all electric equations disappear.";
          Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.PositivePlug
            plugLoad(m=1) if
               hasElectric
              "Electricity connection to the Inhome feeder"
            annotation (Placement(transformation(extent={{190,-10},{210,10}})));
          IDEAS.Experimental.Electric.BaseClasses.AC.WattsLawPlug wattsLawPlug(
            each numPha=1,
            final nLoads=nLoads) if hasElectric
            annotation (Placement(transformation(extent={{170,-10},{190,10}})));
      protected
          final parameter Boolean hasElectric = nLoads>0
            "Removes electric equations when false";
          final parameter Integer nLoads_min=max(1, nLoads);
          Modelica.SIunits.Power[nLoads_min] P = zeros(nLoads_min)
            "Active power for each of the loads";
          Modelica.SIunits.Power[nLoads_min] Q = zeros(nLoads_min)
            "Passive power for each of the loads";
          Modelica.Blocks.Sources.RealExpression[nLoads_min] P_val(y=P)
            "Active power"
            annotation (Placement(transformation(extent={{140,7},{160,27}})));
          Modelica.Blocks.Sources.RealExpression[nLoads_min] Q_val(y=Q)
            "Reactive power"
            annotation (Placement(transformation(extent={{140,-20},{160,0}})));
        equation
          connect(wattsLawPlug.vi, plugLoad) annotation (Line(
                points={{190,0},{200,0}},
                color={85,170,255},
                smooth=Smooth.None));
          connect(P_val.y, wattsLawPlug.P) annotation (Line(
              points={{161,17},{168,17},{168,5},{174,5}},
              color={0,0,127},
              smooth=Smooth.None));
          connect(Q_val.y, wattsLawPlug.Q) annotation (Line(
              points={{161,-10},{170,-10},{170,1},{173,1}},
              color={0,0,127},
              smooth=Smooth.None));
          annotation (
            Icon(coordinateSystem(preserveAspectRatio=false, extent={{-200,-100},{200,
                    100}}), graphics),
            Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-200,-100},{200,
                    100}}),     graphics),
            Documentation(info="<html>
<p>
This documentation is outdated.
</p>
<p><b>Description</b> </p>
<p>Interface model for a complete multi-zone heating system (with our without domestic hot water and solar system).</p>
<p>This model defines the ports used to link a heating system with a building, and the basic parameters that most heating systems will need to have. The model is modular as a function of the number of zones <i>nZones. </i></p>
<p>Two sets of heatPorts are defined:</p>
<ol>
<li><i>heatPortCon[nZones]</i> and <i>heatPortRad[nZones]</i> for convective respectively radiative heat transfer to the building. </li>
<li><i>heatPortEmb[nZones]</i> for heat transfer to TABS elements in the building. </li>
</ol>
<p>The model also defines <i>TSensor[nZones]</i> and <i>TSet[nZones]</i> for the control, and a nominal power <i>QNom[nZones].</i></p>
<p>There is also an input for the DHW flow rate, <i>mDHW60C</i>, but this can be unconnected if the system only includes heating and no DHW.</p>
<h4>Assumptions and limitations </h4>
<ol>
<li>See the different extensions of this model in <a href=\"modelica://IDEAS.Thermal.HeatingSystems\">IDEAS.Thermal.HeatingSystems</a></li>
</ol>
<h4>Model use</h4>
<ol>
<li>Connect the heating system to the corresponding heatPorts of a <a href=\"modelica://IDEAS.Templates.Interfaces.BaseClasses.Structure\">structure</a>. </li>
<li>Connect <i>TSet</i> and <i>TSensor</i> and <i>plugLoad. </i></li>
<li>Connect <i>plugLoad </i> to an inhome grid.  A<a href=\"modelica://IDEAS.Templates.Interfaces.BaseClasses.CausalInhomeFeeder\"> dummy inhome grid like this</a> has to be used if no inhome grid is to be modelled. </li>
<li>Set all parameters that are required, depending on which implementation of this interface is used. </li>
</ol>
<h4>Validation </h4>
<p>No validation performed.</p>
<h4>Example </h4>
<p>See the <a href=\"modelica://IDEAS.Thermal.HeatingSystems.Examples\">heating system examples</a>. </p>
</html>",         revisions="<html>
<ul>
<li>
June 5, 2018 by Filip Jorissen:<br/>
Cleaned up implementation for
<a href=\"https://github.com/open-ideas/IDEAS/issues/821\">#821</a>.
</li>
</ul>
</html>"));
        end PartialSystem;
      end BaseClasses;
    end Interfaces;
  end Templates;

  package Utilities "Package with utility functions such as for I/O"
    extends Modelica.Icons.Package;

    package Math "Library with functions such as for smoothing"
      extends Modelica.Icons.Package;

      block Average "Average of a vector"
        extends Modelica.Blocks.Interfaces.MISO;
      equation
       y = IDEAS.Utilities.Math.Functions.average(u=u, nin=nin);
      annotation (defaultComponentName="ave",
      Documentation(info="<html>
<p>This block outputs the average of the vector. </p>
</html>",
      revisions="<html>
<ul>
<li>November 28, 2013, by Marcus Fuchs:<br/>
Changed block to use function average.
</li>
<li>
April 3, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={Text(
                extent={{-74,46},{66,-58}},
                lineColor={0,0,255},
                textString="ave")}));
      end Average;

      block IntegratorWithReset "Output the integral of the input signal"
        extends Modelica.Blocks.Interfaces.SISO(y(start=y_start));
        parameter Real k(unit="1")=1 "Integrator gain";
        /* InitialState is the default, because it was the default in Modelica 2.2
     and therefore this setting is backward compatible
  */
        parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.InitialState
          "Type of initialization (1: no init, 2: steady state, 3,4: initial output)"
          annotation(Evaluate=true,
            Dialog(group="Initialization"));
        parameter Real y_start=0 "Initial or guess value of output (= state)"
          annotation (Dialog(group="Initialization"));
        parameter IDEAS.Types.Reset reset = IDEAS.Types.Reset.Disabled
          "Type of integrator reset";
        parameter Real y_reset = 0
          "Value to which integrator is reset, used if reset = IDEAS.Types.Reset.Parameter"
          annotation(Evaluate=true,
                     Dialog(
                       enable=reset == IDEAS.Types.Reset.Parameter,
                       group="Integrator reset"));
        Modelica.Blocks.Interfaces.RealInput y_reset_in if
             reset == IDEAS.Types.Reset.Input
          "Input signal for state to which integrator is reset, enabled if reset = IDEAS.Types.Reset.Input"
          annotation (Placement(transformation(extent={{-140,-100},{-100,-60}})));
        Modelica.Blocks.Interfaces.BooleanInput trigger if
             reset <> IDEAS.Types.Reset.Disabled
          "Resets the integrator output when trigger becomes true"
          annotation (Placement(transformation(extent={{-20,-20},{20,20}}, rotation=90,
              origin={0,-120}), iconTransformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={0,-120})));
    protected
        Modelica.Blocks.Interfaces.RealInput y_reset_internal
         "Internal connector for integrator reset"
         annotation(Evaluate=true);
        Modelica.Blocks.Interfaces.BooleanInput trigger_internal
          "Needed to use conditional connector trigger";
      initial equation
        if initType == Modelica.Blocks.Types.Init.SteadyState then
           der(y) = 0;
        elseif initType == Modelica.Blocks.Types.Init.InitialState or
               initType == Modelica.Blocks.Types.Init.InitialOutput then
          y = y_start;
        end if;
      equation
        der(y) = k*u;
        // Equations for integrator reset
        connect(trigger, trigger_internal);
        connect(y_reset_in, y_reset_internal);
        if reset <> IDEAS.Types.Reset.Input then
          y_reset_internal = y_reset;
        end if;
        if reset == IDEAS.Types.Reset.Disabled then
          trigger_internal = false;
        else
          when trigger_internal then
            reinit(y, y_reset_internal);
          end when;
        end if;
        annotation (
      defaultComponentName="intWitRes",
          Documentation(info="<html>
<p>
This model is similar to
<a href=\"modelica://Modelica.Blocks.Continuous.Integrator\">
Modelica.Blocks.Continuous.Integrator</a>
except that it optionally allows to reset the output <code>y</code>
of the integrator.
</p>
<p>
The output of the integrator can be reset as follows:
</p>
<ul>
<li>
If <code>reset = IDEAS.Types.Reset.Disabled</code>, which is the default,
then the integrator is never reset.
</li>
<li>
If <code>reset = IDEAS.Types.Reset.Parameter</code>, then a boolean
input signal <code>trigger</code> is enabled. Whenever the value of
this input changes from <code>false</code> to <code>true</code>,
the integrator is reset by setting <code>y</code>
to the value of the parameter <code>y_reset</code>.
</li>
<li>
If <code>reset = IDEAS.Types.Reset.Input</code>, then a boolean
input signal <code>trigger</code> is enabled. Whenever the value of
this input changes from <code>false</code> to <code>true</code>,
the integrator is reset by setting <code>y</code>
to the value of the input signal <code>y_reset_in</code>.
</li>
</ul>
<p>
See <a href=\"modelica://IDEAS.Utilities.Math.Examples.IntegratorWithReset\">
IDEAS.Utilities.Math.Examples.IntegratorWithReset</a> for an example.
</p>
<h4>Implementation</h4>
<p>
To adjust the icon layer, the code of
<a href=\"modelica://Modelica.Blocks.Continuous.Integrator\">
Modelica.Blocks.Continuous.Integrator</a>
has been copied into this model rather than extended.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 1, 2016, by Michael Wetter:<br/>
Corrected wrong annotation for <code>y_reset</code>,
and made rendering of <code>y_reset_in</code> conditional.<br/>
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/562\">#562</a>.
</li>
<li>
September 29, 2016, by Michael Wetter:<br/>
Refactored model to use a <code>type</code> for configuration
of the integrator reset.
</li>
<li>
August 9, 2016, by Michael Wetter:<br/>
Reformulated model using a conditional connector to use the same
design pattern as is used in other models.
</li>
<li>
August 9, 2016, by Michael Wetter:<br/>
Revised model.
</li>
<li>
July 18, 2016, by Philipp Mehrfeld:<br/>
First implementation.
</li>
</ul>
</html>"),
      Icon(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100.0,-100.0},{100.0,100.0}}),
              graphics={
                Text(
                  extent={{-88,-94},{212,-54}},
                lineColor={0,0,0},
                textString="y_reset_in",
                visible=reset == IDEAS.Types.Reset.Input,
                horizontalAlignment=TextAlignment.Left),
              Bitmap(extent={{-54,-50},{60,50}}, fileName=
                    "modelica://IDEAS/Resources/Images/Utilities/Math/int.png"),
                Text(
                  extent={{-88,56},{206,92}},
                lineColor={0,0,0},
                textString="k=%k",
                horizontalAlignment=TextAlignment.Left),
                Text(
                  extent={{-92,-12},{208,28}},
                lineColor={0,0,0},
                horizontalAlignment=TextAlignment.Left,
                textString="u"),
                Text(
                  extent={{70,-14},{370,26}},
                lineColor={0,0,0},
                horizontalAlignment=TextAlignment.Left,
                textString="y")}));
      end IntegratorWithReset;

      block Max "Maximum element of a vector"
        extends Modelica.Blocks.Interfaces.MISO;
      equation
       y = max(u);
      annotation (defaultComponentName="max",
      Documentation(info="<html>
<p>
Outputs the maximum of the vector.
</p>
</html>",
      revisions="<html>
<ul>
<li>
April 3, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={Text(
                extent={{-74,90},{70,-70}},
                lineColor={0,0,255},
                textString="max")}));
      end Max;

      package Functions "Package with mathematical functions"
        extends Modelica.Icons.VariantsPackage;

        function average "Average of a vector"
          extends Modelica.Icons.Function;
          input Integer nin "Number of inputs";
          input Real u[nin] "Input vector";
          output Real y "Result";
        algorithm
          y := sum(u)/nin;
          annotation (Documentation(info="<html>
<p>This function outputs the average of the vector. </p>
</html>",         revisions="<html>
<ul>
<li>November 28, 2013, by Marcus Fuchs:<br/>
Implementation based on Michael Wetter&apos;s block
<a href=\"modelica://IDEAS.Utilities.Math.Average\">
IDEAS.Utilities.Math.Average</a>.
</li>
</ul>
</html>"));
        end average;

        function cubicHermiteLinearExtrapolation
          "Interpolate using a cubic Hermite spline with linear extrapolation"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real x1 "Lower abscissa value";
          input Real x2 "Upper abscissa value";
          input Real y1 "Lower ordinate value";
          input Real y2 "Upper ordinate value";
          input Real y1d "Lower gradient";
          input Real y2d "Upper gradient";
          output Real y "Interpolated ordinate value";
        algorithm
          if (x > x1 and x < x2) then
            y:=Modelica.Fluid.Utilities.cubicHermite(
              x=x,
              x1=x1,
              x2=x2,
              y1=y1,
              y2=y2,
              y1d=y1d,
              y2d=y2d);
          elseif x <= x1 then
            // linear extrapolation
            y:=y1 + (x - x1)*y1d;
          else
            y:=y2 + (x - x2)*y2d;
          end if;
          annotation(smoothOrder=1,
              Documentation(info="<html>
<p>
For <i>x<sub>1</sub> &lt; x &lt; x<sub>2</sub></i>, this function interpolates
using cubic hermite spline. For <i>x</i> outside this interval, the function
linearly extrapolates.
</p>
<p>
For how to use this function, see
<a href=\"modelica://IDEAS.Utilities.Math.Functions.Examples.CubicHermite\">
IDEAS.Utilities.Math.Functions.Examples.CubicHermite</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end cubicHermiteLinearExtrapolation;

        function inverseXRegularized
          "Function that approximates 1/x by a twice continuously differentiable function"
          extends Modelica.Icons.Function;
         input Real x "Abscissa value";
         input Real delta(min=Modelica.Constants.eps)
            "Abscissa value below which approximation occurs";
         input Real deltaInv = 1/delta "Inverse value of delta";
         input Real a = -15*deltaInv "Polynomial coefficient";
         input Real b = 119*deltaInv^2 "Polynomial coefficient";
         input Real c = -361*deltaInv^3 "Polynomial coefficient";
         input Real d = 534*deltaInv^4 "Polynomial coefficient";
         input Real e = -380*deltaInv^5 "Polynomial coefficient";
         input Real f = 104*deltaInv^6 "Polynomial coefficient";
         output Real y "Function value";
        algorithm
          y :=if (x > delta or x < -delta) then 1/x elseif (x < delta/2 and x > -delta/2) then x/(delta*delta) else
            IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition(
               x=x,
               delta=delta, deltaInv=deltaInv,
               a=a, b=b, c=c, d=d, e=e, f=f);
          annotation (smoothOrder=2,
          derivative(order=1,
                  zeroDerivative=delta,
                  zeroDerivative=deltaInv,
                  zeroDerivative=a,
                  zeroDerivative=b,
                  zeroDerivative=c,
                  zeroDerivative=d,
                  zeroDerivative=e,
                  zeroDerivative=f)=IDEAS.Utilities.Math.Functions.BaseClasses.der_inverseXRegularized,
                      Inline=true,
        Documentation(info="<html>
<p>
Function that approximates <i>y=1 &frasl; x</i>
inside the interval <i>-&delta; &le; x &le; &delta;</i>.
The approximation is twice continuously differentiable with a bounded derivative on the whole
real line.
</p>
<p>
See the plot of
<a href=\"modelica://IDEAS.Utilities.Math.Functions.Examples.InverseXRegularized\">
IDEAS.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for the graph.
</p>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Typically, these coefficients only depend on parameters and hence
can be computed once.
They must be equal to their default values, otherwise the function
is not twice continuously differentiable.
By exposing these coefficients as function arguments, models
that call this function can compute them as parameters, and
assign these parameter values in the function call.
This avoids that the coefficients are evaluated for each time step,
as they would otherwise be if they were to be computed inside the
body of the function. However, assigning the values is optional
as otherwise, at the expense of efficiency, the values will be
computed each time the function is invoked.
See
<a href=\"modelica://IDEAS.Utilities.Math.Functions.Examples.InverseXRegularized\">
IDEAS.Utilities.Math.Functions.Examples.InverseXRegularized</a>
for how to efficiently call this function.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 10, 2015, by Michael Wetter:<br/>
Removed dublicate entry <code>smoothOrder = 1</code>
and reimplmented the function so it is twice continuously differentiable.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/302\">issue 302</a>.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 18, 2011, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end inverseXRegularized;

        function isAngle
          "Return true if angles are mathematically equivalent up to a certain precision"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Angle ang1;
          input Modelica.SIunits.Angle ang2;
          input Real precision = 0.01;
          output Boolean result;
        algorithm
          result :=abs(mod(ang1, 2*Modelica.Constants.pi) - mod(ang2, 2*Modelica.Constants.pi)) < precision;
          annotation(Inline=true, Documentation(revisions="<html>
<ul>
<li>
August 9, 2018, by Filip Jorissen:<br/>
Revised implementation to be more intuitive.
</li>
</ul>
</html>"));
        end isAngle;

        function isMonotonic "Returns true if the argument is a monotonic sequence"
          extends Modelica.Icons.Function;
          input Real x[:] "Sequence to be tested";
          input Boolean strict=false "Set to true to test for strict monotonicity";
          output Boolean monotonic "True if x is monotonic increasing or decreasing";
      protected
          Integer n=size(x, 1) "Number of data points";
        algorithm
          if n == 1 then
            monotonic := true;
          else
            monotonic := true;
            if strict then
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] > x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] < x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            else
              // not strict
              if (x[1] >= x[n]) then
                for i in 1:n - 1 loop
                  if (not x[i] >= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              else
                for i in 1:n - 1 loop
                  if (not x[i] <= x[i + 1]) then
                    monotonic := false;
                  end if;
                end for;
              end if;
            end if;
            // strict
          end if;
          annotation (Documentation(info="<html>
<p>
This function returns <code>true</code> if its argument is
monotonic increasing or decreasing, and <code>false</code> otherwise.
If <code>strict=true</code>, then strict monotonicity is tested,
otherwise weak monotonicity is tested.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 28, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end isMonotonic;

        function quinticHermite
          "Quintic Hermite spline function for interpolation between two functions with a continuous second derivative"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real x1 "Lower abscissa value";
          input Real x2 "Upper abscissa value";
          input Real y1 "Lower ordinate value";
          input Real y2 "Upper ordinate value";
          input Real y1d "Lower derivative";
          input Real y2d "Upper derivative";
          input Real y1dd "Lower second derivative";
          input Real y2dd "Upper second derivative";
          output Real y "Interpolated ordinate value";
      protected
          Real h = x2 - x1;
          Real hpow2 = h*h;
          Real t = (x - x1)/h;
          Real tpow2 = t*t;
          Real tpow3 = tpow2*t;
          Real tpow4 = tpow3*t;
          Real tpow5 = tpow4*t;
          Real H0 = 1 - 10*tpow3 + 15*tpow4 - 6*tpow5;
          Real H1 = t -  6*tpow3 +  8*tpow4 - 3*tpow5;
          Real H2 = 0.5*(tpow2 - 3*tpow3 + 3 *tpow4 - tpow5);
          Real H3 = 0.5*tpow3 - tpow4 + 0.5*tpow5;
          Real H4 = -4*tpow3 +7*tpow4 -3*tpow5;
          Real H5 = 1-H0;
        algorithm
          y :=H0*y1 + H1*y1d*h  + H2*y1dd*hpow2 + H3*y2dd*hpow2 + H4*y2d*h + H5*y2;
        annotation (smoothOrder=99,
        Documentation(revisions="<html>
<ul>
<li>
April 19, 2017, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",         info="<html>
<p>
Returns the result y of a quintic Hermite spline,
which is a C<sup>2</sup> continuous interpolation between two functions.
The abscissa value <code>x</code> has to be between <code>x1</code> and <code>x2</code>.
Variables <code>y1</code>, <code>y1d</code>, <code>y1dd</code> are the ordinate,
ordinate derivative and ordinate second derivative of the function at <code>x1</code>.
Variables <code>y2</code>, <code>y2d</code>, <code>y2dd</code> are respectively the ordinate,
ordinate derivative and ordinate second derivative of the function at <code>x2</code>.
</p>
</html>"));
        end quinticHermite;

        function regStep
          "Approximation of a general step, such that the approximation is continuous and differentiable"
          extends Modelica.Icons.Function;
          input Real x "Abscissa value";
          input Real y1 "Ordinate value for x > 0";
          input Real y2 "Ordinate value for x < 0";
          input Real x_small(min=0) = 1e-5
            "Approximation of step for -x_small <= x <= x_small; x_small >= 0 required";
          output Real y "Ordinate value to approximate y = if x > 0 then y1 else y2";
        algorithm
          y := smooth(1, if x >  x_small then y1 else
                         if x < -x_small then y2 else
                         if x_small > 0 then (x/x_small)*((x/x_small)^2 - 3)*(y2-y1)/4 + (y1+y2)/2 else (y1+y2)/2);
          annotation(Inline=true,
          Documentation(revisions="<html>
<ul>
<li><i>February 18, 2016</i>
    by Marcus Fuchs:<br/>
    Add function with <code>Inline = true</code> in annotations to package for better performance,
    as suggested in <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">#300</a> .</li>
<li><i>April 29, 2008</i>
    by <a href=\"mailto:Martin.Otter@DLR.de\">Martin Otter</a>:<br/>
    Designed and implemented.</li>
<li><i>August 12, 2008</i>
    by <a href=\"mailto:Michael.Sielemann@dlr.de\">Michael Sielemann</a>:<br/>
    Minor modification to cover the limit case <code>x_small -> 0</code> without division by zero.</li>
</ul>
</html>",         info="<html>
<p>
This function is used to approximate the equation
</p>
<pre>
    y = <b>if</b> x &gt; 0 <b>then</b> y1 <b>else</b> y2;
</pre>

<p>
by a smooth characteristic, so that the expression is continuous and differentiable:
</p>

<pre>
   y = <b>smooth</b>(1, <b>if</b> x &gt;  x_small <b>then</b> y1 <b>else</b>
                 <b>if</b> x &lt; -x_small <b>then</b> y2 <b>else</b> f(y1, y2));
</pre>

<p>
In the region <code>-x_small &lt; x &lt; x_small</code> a 2nd order polynomial is used
for a smooth transition from <code>y1</code> to <code>y2</code>.
</p>
</html>"));
        end regStep;

        function smoothLimit
          "Once continuously differentiable approximation to the limit function"
          extends Modelica.Icons.Function;
          input Real x "Variable";
          input Real l "Low limit";
          input Real u "Upper limit";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
      protected
          Real cor;
        algorithm
          cor :=deltaX/10;
          y := IDEAS.Utilities.Math.Functions.smoothMax(x,l+deltaX,cor);
          y := IDEAS.Utilities.Math.Functions.smoothMin(y,u-deltaX,cor);
          annotation (smoothOrder = 1,
          Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>limit(.,.)</code> function.
The output is bounded to be in <i>[l, u]</i>.
</p>
<p>
Note that the limit need not be respected, such as illustrated in
<a href=\"modelica://IDEAS.Utilities.Math.Examples.SmoothMin\">
IDEAS.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",         revisions="<html>
<ul>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
Sept 1, 2010, by Michael Wetter:<br/>
Changed scaling to make sure that bounds are never violated.
</li>
<li>
July 14, 2010, by Wangda Zuo, Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothLimit;

        function smoothMax
          "Once continuously differentiable approximation to the maximum function"
          extends Modelica.Icons.Function;
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := IDEAS.Utilities.Math.Functions.regStep(
                 y1=x1, y2=x2, x=x1-x2, x_small=deltaX);
          annotation (
          Inline=true,
          smoothOrder=1,
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>max(.,.)</code> function.
</p>
<p>
Note that the maximum need not be respected, such as illustrated in
<a href=\"modelica://IDEAS.Utilities.Math.Examples.SmoothMin\">
IDEAS.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMax;

        function smoothMin
          "Once continuously differentiable approximation to the minimum function"
          extends Modelica.Icons.Function;
          input Real x1 "First argument";
          input Real x2 "Second argument";
          input Real deltaX "Width of transition interval";
          output Real y "Result";
        algorithm
          y := IDEAS.Utilities.Math.Functions.regStep(
                 y1=x1, y2=x2, x=x2-x1, x_small=deltaX);
          annotation (
          Inline=true,
          smoothOrder=1,
        Documentation(info="<html>
<p>
Once continuously differentiable approximation to the <code>min(.,.)</code> function.
</p>
<p>
Note that the minimum need not be respected, such as illustrated in
<a href=\"modelica://IDEAS.Utilities.Math.Examples.SmoothMin\">
IDEAS.Utilities.Math.Examples.SmoothMin</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
March 12, 2015, by Filip Jorissen:<br/>
Added documentation reference demonstrating overshoot.
</li>
<li>
February 5, 2015, by Filip Jorissen:<br/>
Added <code>smoothOrder = 1</code>.
</li>
<li>
August 15, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end smoothMin;

        function spliceFunction
          extends Modelica.Icons.Function;
            input Real pos "Argument of x > 0";
            input Real neg "Argument of x < 0";
            input Real x "Independent value";
            input Real deltax "Half width of transition interval";
            output Real out "Smoothed value";
      protected
            Real scaledX1;
            Real y;
            constant Real asin1 = Modelica.Math.asin(1);
        algorithm
            scaledX1 := x/deltax;
            if scaledX1 <= -0.999999999 then
              out := neg;
            elseif scaledX1 >= 0.999999999 then
              out := pos;
            else
              y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX1*asin1)) + 1)/2;
              out := pos*y + (1 - y)*neg;
            end if;
            annotation (
        smoothOrder=1,
        derivative=BaseClasses.der_spliceFunction,
        Documentation(info="<html>
<p>
Function to provide a once continuously differentiable transition between
to arguments.
</p><p>
The function is adapted from
<a href=\"modelica://Modelica.Media.Air.MoistAir.Utilities.spliceFunction\">
Modelica.Media.Air.MoistAir.Utilities.spliceFunction</a> and provided here
for easier accessability to model developers.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
May 11, 2010, by Michael Wetter:<br/>
Removed default value for transition interval as this is problem dependent.
</li>
<li>
May 20, 2008, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end spliceFunction;

        function splineDerivatives
          "Function to compute the derivatives for cubic hermite spline interpolation"
          extends Modelica.Icons.Function;
          input Real x[:] "Support point, strict monotone increasing";
          input Real y[size(x, 1)] "Function values at x";
          input Boolean ensureMonotonicity=isMonotonic(y, strict=false)
            "Set to true to ensure monotonicity of the cubic hermite";
          output Real d[size(x, 1)] "Derivative at the support points";
      protected
          Integer n=size(x, 1) "Number of data points";
          Real delta[n - 1] "Slope of secant line between data points";
          Real alpha "Coefficient to ensure monotonicity";
          Real beta "Coefficient to ensure monotonicity";
          Real tau "Coefficient to ensure monotonicity";
        algorithm
          if (n>1) then
            assert(x[1] < x[n], "x must be strictly increasing.
  Received x[1] = "         + String(x[1]) + "
           x["         + String(n) + "] = " + String(x[n]));
          // Check data
            assert(isMonotonic(x, strict=true),
              "x-values must be strictly monontone increasing or decreasing.");
            if ensureMonotonicity then
              assert(isMonotonic(y, strict=false),
                "If ensureMonotonicity=true, y-values must be monontone increasing or decreasing.");
            end if;
          end if;
          // Compute derivatives at the support points
          if n == 1 then
            // only one data point
            d[1] :=0;
          elseif n == 2 then
            // linear function
            d[1] := (y[2] - y[1])/(x[2] - x[1]);
            d[2] := d[1];
          else
            // Slopes of the secant lines between i and i+1
            for i in 1:n - 1 loop
              delta[i] := (y[i + 1] - y[i])/(x[i + 1] - x[i]);
            end for;
            // Initial values for tangents at the support points.
            // End points use one-sided derivatives
            d[1] := delta[1];
            d[n] := delta[n - 1];
            for i in 2:n - 1 loop
              d[i] := (delta[i - 1] + delta[i])/2;
            end for;
          end if;
          // Ensure monotonicity
          if n > 2 and ensureMonotonicity then
            for i in 1:n - 1 loop
              if (abs(delta[i]) < Modelica.Constants.small) then
                d[i] := 0;
                d[i + 1] := 0;
              else
                alpha := d[i]/delta[i];
                beta := d[i + 1]/delta[i];
                // Constrain derivative to ensure monotonicity in this interval
                if (alpha^2 + beta^2) > 9 then
                  tau := 3/(alpha^2 + beta^2)^(1/2);
                  d[i] := delta[i]*alpha*tau;
                  d[i + 1] := delta[i]*beta*tau;
                end if;
              end if;
            end for;
          end if;
          annotation (Documentation(info="<html>
<p>
This function computes the derivatives at the support points <i>x<sub>i</sub></i>
that can be used as input for evaluating a cubic hermite spline.
</p>
<p>
If <code>ensureMonotonicity=true</code>, then the support points <i>y<sub>i</sub></i>
need to be monotone increasing (or increasing), and the computed derivatives
<i>d<sub>i</sub></i> are such that the cubic hermite is monotone increasing (or decreasing).
The algorithm to ensure monotonicity is based on the method described in Fritsch and Carlson (1980) for
<i>&rho; = &rho;<sub>2</sub></i>.
</p>
<p>
This function is typically used with
<a href=\"modelica://IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation\">
IDEAS.Utilities.Math.Functions.cubicHermiteLinearExtrapolation</a>
which is used to evaluate the cubic spline.
Because in many applications, the shape of the spline depends on parameters,
this function has been implemented in such a way that all derivatives can be
computed at once and then stored for use during the time stepping,
in which the above function may be called.
</p>
<h4>References</h4>
<p>
F.N. Fritsch and R.E. Carlson, <a href=\"http://dx.doi.org/10.1137/0717021\">Monotone piecewise cubic interpolation</a>.
<i>SIAM J. Numer. Anal.</i>, 17 (1980), pp. 238-246.
</p>
</html>",         revisions="<html>
<ul>
<li>
January 26, 2016 by Michael Wetter:<br/>
Corrected documentation.
</li>
<li>
September 29, 2011 by Michael Wetter:<br/>
Added special case for one data point and two data points.
</li>
<li>
September 27, 2011 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end splineDerivatives;

        package BaseClasses
        "Package with base classes for IDEAS.Utilities.Math.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_2_smoothTransition
            "Second order derivative of smoothTransition with respect to x"
            extends Modelica.Icons.Function;
            input Real x "Abscissa value";
            input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
            input Real deltaInv "Inverse value of delta";
            input Real a "Polynomial coefficient";
            input Real b "Polynomial coefficient";
            input Real c "Polynomial coefficient";
            input Real d "Polynomial coefficient";
            input Real e "Polynomial coefficient";
            input Real f "Polynomial coefficient";
            input Real x_der "Derivative of x";
            input Real x_der2 "Second order derivative of x";
            output Real y_der2 "Second order derivative of function value";
        protected
            Real aX "Absolute value of x";
            Real ex "Intermediate expression";
          algorithm
           aX:= abs(x);
           ex     := 2*c + aX*(6*d + aX*(12*e + aX*20*f));
           y_der2 := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der2
                   + x_der*x_der*( if x > 0 then ex else -ex);
          annotation (
          Documentation(info="<html>
<p>
This function is the 2nd order derivative of
<a href=\"modelica://IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition\">
IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_2_smoothTransition;

          function der_inverseXRegularized "Derivative of inverseXRegularised function"
            extends Modelica.Icons.Function;
           input Real x "Abscissa value";
           input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
           input Real deltaInv = 1/delta "Inverse value of delta";
           input Real a = -15*deltaInv "Polynomial coefficient";
           input Real b = 119*deltaInv^2 "Polynomial coefficient";
           input Real c = -361*deltaInv^3 "Polynomial coefficient";
           input Real d = 534*deltaInv^4 "Polynomial coefficient";
           input Real e = -380*deltaInv^5 "Polynomial coefficient";
           input Real f = 104*deltaInv^6 "Polynomial coefficient";
           input Real x_der "Abscissa value";
           output Real y_der "Function value";
          algorithm
            y_der :=if (x > delta or x < -delta) then -x_der/x/x elseif (x < delta/2 and x > -delta/2) then x_der/(delta*delta) else
              IDEAS.Utilities.Math.Functions.BaseClasses.der_smoothTransition(
                 x=x,
                 x_der=x_der,
                 delta=delta,
                 deltaInv=deltaInv,
                 a=a, b=b, c=c, d=d, e=e, f=f);
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://IDEAS.Utilities.Math.Functions.inverseXRegularized\">
IDEAS.Utilities.Math.Functions.inverseXRegularized</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
June 22, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_inverseXRegularized;

          function der_smoothTransition
            "First order derivative of smoothTransition with respect to x"
            extends Modelica.Icons.Function;
            input Real x "Abscissa value";
            input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
            input Real deltaInv "Inverse value of delta";
            input Real a "Polynomial coefficient";
            input Real b "Polynomial coefficient";
            input Real c "Polynomial coefficient";
            input Real d "Polynomial coefficient";
            input Real e "Polynomial coefficient";
            input Real f "Polynomial coefficient";
            input Real x_der "Derivative of x";
            output Real y_der "Derivative of function value";
        protected
            Real aX "Absolute value of x";
          algorithm
           aX:= abs(x);
           y_der := (b + aX*(2*c + aX*(3*d + aX*(4*e + aX*5*f))))*x_der;
           annotation(smoothOrder=1,
                    derivative(order=2,
                    zeroDerivative=delta,
                    zeroDerivative=deltaInv,
                    zeroDerivative=a,
                    zeroDerivative=b,
                    zeroDerivative=c,
                    zeroDerivative=d,
                    zeroDerivative=e,
                    zeroDerivative=f)=IDEAS.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition,
          Documentation(info="<html>
<p>
This function is the 1st order derivative of
<a href=\"modelica://IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition\">
IDEAS.Utilities.Math.Functions.BaseClasses.smoothTransition</a>.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
its derivative is provided in
<a href=\"modelica://IDEAS.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
IDEAS.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_smoothTransition;

          function der_spliceFunction "Derivative of splice function"
            extends Modelica.Icons.Function;
              input Real pos;
              input Real neg;
              input Real x;
              input Real deltax=1;
              input Real dpos;
              input Real dneg;
              input Real dx;
              input Real ddeltax=0;
              output Real out;
        protected
              Real scaledX;
              Real scaledX1;
              Real dscaledX1;
              Real y;
              constant Real asin1 = Modelica.Math.asin(1);
          algorithm
              scaledX1 := x/deltax;
              if scaledX1 <= -0.99999999999 then
                out := dneg;
              elseif scaledX1 >= 0.9999999999 then
                out := dpos;
              else
                scaledX := scaledX1*asin1;
                dscaledX1 := (dx - scaledX1*ddeltax)/deltax;
                y := (Modelica.Math.tanh(Modelica.Math.tan(scaledX)) + 1)/2;
                out := dpos*y + (1 - y)*dneg;
                out := out + (pos - neg)*dscaledX1*asin1/2/(
                  Modelica.Math.cosh(Modelica.Math.tan(scaledX))*Modelica.Math.cos(
                  scaledX))^2;
              end if;
          annotation (
          Documentation(
          info="<html>
<p>
Implementation of the first derivative of the function
<a href=\"modelica://IDEAS.Utilities.Math.Functions.spliceFunction\">
IDEAS.Utilities.Math.Functions.spliceFunction</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
May 10, 2013, by Michael Wetter:<br/>
Reformulated implementation to avoid unrequired computations.
</li>
<li>
April 7, 2009, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end der_spliceFunction;

          function smoothTransition
            "Twice continuously differentiable transition between the regions"
            extends Modelica.Icons.Function;
            // The function that transitions between the regions is implemented
            // using its own function. This allows Dymola 2016 to inline the function
            // inverseXRegularized.
          input Real x "Abscissa value";
          input Real delta(min=Modelica.Constants.eps)
              "Abscissa value below which approximation occurs";
          input Real deltaInv = 1/delta "Inverse value of delta";
          input Real a = -15*deltaInv "Polynomial coefficient";
          input Real b = 119*deltaInv^2 "Polynomial coefficient";
          input Real c = -361*deltaInv^3 "Polynomial coefficient";
          input Real d = 534*deltaInv^4 "Polynomial coefficient";
          input Real e = -380*deltaInv^5 "Polynomial coefficient";
          input Real f = 104*deltaInv^6 "Polynomial coefficient";
          output Real y "Function value";
        protected
            Real aX "Absolute value of x";
          algorithm
           aX:= abs(x);
           y := (if x >= 0 then 1 else -1) * (a + aX*(b + aX*(c + aX*(d + aX*(e + aX*f)))));
          annotation(smoothOrder=2,
            derivative(order=1,
                    zeroDerivative=delta,
                    zeroDerivative=deltaInv,
                    zeroDerivative=a,
                    zeroDerivative=b,
                    zeroDerivative=c,
                    zeroDerivative=d,
                    zeroDerivative=e,
                    zeroDerivative=f)=IDEAS.Utilities.Math.Functions.BaseClasses.der_smoothTransition,
              Documentation(info="<html>
<p>
This function is used by
<a href=\"modelica://IDEAS.Utilities.Math.Functions.inverseXRegularized\">
IDEAS.Utilities.Math.Functions.inverseXRegularized</a>
to provide a twice continuously differentiable transition between
the different regions.
The code has been implemented in a function as this allows
to implement the function
<a href=\"modelica://IDEAS.Utilities.Math.Functions.inverseXRegularized\">
IDEAS.Utilities.Math.Functions.inverseXRegularized</a>
in such a way that Dymola inlines it.
However, this function will not be inlined as its body is too large.
</p>
<h4>Implementation</h4>
<p>
For efficiency, the polynomial coefficients
<code>a, b, c, d, e, f</code> and
the inverse of the smoothing parameter <code>deltaInv</code>
are exposed as arguments to this function.
Also,
derivatives are provided in
<a href=\"modelica://IDEAS.Utilities.Math.Functions.BaseClasses.der_smoothTransition\">
IDEAS.Utilities.Math.Functions.BaseClasses.der_smoothTransition</a>
and in
<a href=\"modelica://IDEAS.Utilities.Math.Functions.BaseClasses.der_2_smoothTransition\">
IDEAS.Utilities.Math.Functions.BaseClasses.der_2__smoothTransition</a>.
</p>
</html>",           revisions="<html>
<ul>
<li>
September 12, 2018, by David Blum:<br/>
Change if-statement to if-expression.  
For issue <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1019\">#1019</a>.
</li>
<li>
August 11, 2015, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
          end smoothTransition;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Utilities.Math.Functions\">IDEAS.Utilities.Math.Functions</a>.
</p>
</html>"));
        end BaseClasses;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for commonly used
mathematical operations. The functions are used in
the blocks
<a href=\"modelica://IDEAS.Utilities.Math\">
IDEAS.Utilities.Math</a>.
</p>
</html>"));
      end Functions;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for commonly used
mathematical operations.
The classes in this package augment the classes
<a href=\"modelica://Modelica.Blocks\">
Modelica.Blocks</a>.
</p>
</html>"),
    Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},
              {100,100}}), graphics={Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},
                {-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{
                -26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,
                -50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},
                {51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}}, color={
                0,0,0}, smooth=Smooth.Bezier)}));
    end Math;

    package Psychrometrics "Library with psychrometric functions"
      extends Modelica.Icons.VariantsPackage;

      package Constants "Library of constants for psychometric functions"
        extends Modelica.Icons.Package;

        constant Modelica.SIunits.Temperature T_ref = 273.15
          "Reference temperature for psychrometric calculations";

        constant Modelica.SIunits.SpecificHeatCapacity cpAir=1006
          "Specific heat capacity of air";

        constant Modelica.SIunits.SpecificHeatCapacity cpSte=1860
          "Specific heat capacity of water vapor";

        constant Modelica.SIunits.SpecificHeatCapacity cpWatLiq = 4184
          "Specific heat capacity of liquid water";

        constant Modelica.SIunits.SpecificEnthalpy h_fg = 2501014.5
          "Enthalpy of evaporation of water at the reference temperature";

        constant Real k_mair = 0.6219647130774989 "Ratio of molar weights";
        annotation (
          Documentation(info="<html>
<p>
This package provides constants for functions used
in the calculation of thermodynamic properties of moist air.
</p>
</html>",       revisions="<html>
<ul>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Added reference temperature.
</li>
<li>
July 24, 2014, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
            Polygon(
              origin={-9.2597,25.6673},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{48.017,11.336},{48.017,11.336},{10.766,11.336},{-25.684,10.95},{-34.944,-15.111},{-34.944,-15.111},{-32.298,-15.244},{-32.298,-15.244},{-22.112,0.168},{11.292,0.234},{48.267,-0.097},{48.267,-0.097}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={-19.9923,-8.3993},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{3.239,37.343},{3.305,37.343},{-0.399,2.683},{-16.936,-20.071},{-7.808,-28.604},{6.811,-22.519},{9.986,37.145},{9.986,37.145}},
              smooth=Smooth.Bezier),
            Polygon(
              origin={23.753,-11.5422},
              fillColor={102,102,102},
              pattern=LinePattern.None,
              fillPattern=FillPattern.Solid,
              points={{-10.873,41.478},{-10.873,41.478},{-14.048,-4.162},{-9.352,-24.8},{7.912,-24.469},{16.247,0.27},{16.247,0.27},{13.336,0.071},{13.336,0.071},{7.515,-9.983},{-3.134,-7.271},{-2.671,41.214},{-2.671,41.214}},
              smooth=Smooth.Bezier)}));
      end Constants;

      block TWetBul_TDryBulPhi
        "Model to compute the wet bulb temperature based on relative humidity"
        extends Modelica.Blocks.Icons.Block;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialCondensingGases "Medium model"
          annotation (choicesAllMatching = true);
        parameter Boolean approximateWetBulb=false
          "Set to true to approximate wet bulb temperature" annotation (Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          start=Medium.T_default,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Dry bulb temperature"
          annotation (Placement(transformation(extent={{-120,70},{-100,90}})));
        Modelica.Blocks.Interfaces.RealInput phi(min=0, max=1)
          "Relative air humidity"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));
        Modelica.Blocks.Interfaces.RealInput p(final quantity="Pressure",
                                               final unit="Pa",
                                               min = 0) "Pressure"
          annotation (Placement(transformation(extent={{-120,-90},{-100,-70}})));
        Modelica.Blocks.Interfaces.RealOutput TWetBul(
          start=Medium.T_default-2,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Wet bulb temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
        Modelica.SIunits.Conversions.NonSIunits.Temperature_degC TDryBul_degC
          "Dry bulb temperature in degree Celsius";
        Real rh_per(min=0) "Relative humidity in percentage";
        Modelica.SIunits.MassFraction XiDryBul
          "Water vapor mass fraction at dry bulb state";
        Modelica.SIunits.MassFraction XiSat "Water vapor mass fraction at saturation";
        Modelica.SIunits.MassFraction XiSatRefIn
          "Water vapor mass fraction at saturation, referenced to inlet mass flow rate";
      equation
        if approximateWetBulb then
          TDryBul_degC = TDryBul - 273.15;
          rh_per       = 100*phi;
          TWetBul      = 273.15 + TDryBul_degC
             * Modelica.Math.atan(0.151977 * sqrt(rh_per + 8.313659))
             + Modelica.Math.atan(TDryBul_degC + rh_per)
             - Modelica.Math.atan(rh_per-1.676331)
             + 0.00391838 * rh_per^(1.5) * Modelica.Math.atan( 0.023101 * rh_per)  - 4.686035;
          XiSat    = 0;
          XiDryBul = 0;
          XiSatRefIn=0;
        else
          XiSatRefIn=(1-XiDryBul)*XiSat/(1-XiSat);
          XiSat  = IDEAS.Utilities.Psychrometrics.Functions.X_pSatpphi(
            pSat = IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TWetBul),
            p =    p,
            phi =  1);
          XiDryBul =IDEAS.Utilities.Psychrometrics.Functions.X_pSatpphi(
            p =    p,
            pSat = IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TDryBul),
            phi =  phi);
          (TWetBul-IDEAS.Utilities.Psychrometrics.Constants.T_ref) * (
                    (1-XiDryBul) * IDEAS.Utilities.Psychrometrics.Constants.cpAir +
                    XiSatRefIn * IDEAS.Utilities.Psychrometrics.Constants.cpSte +
                    (XiDryBul-XiSatRefIn) * IDEAS.Utilities.Psychrometrics.Constants.cpWatLiq)
          =
          (TDryBul-IDEAS.Utilities.Psychrometrics.Constants.T_ref) * (
                    (1-XiDryBul) * IDEAS.Utilities.Psychrometrics.Constants.cpAir +
                    XiDryBul * IDEAS.Utilities.Psychrometrics.Constants.cpSte)  +
          (XiDryBul-XiSatRefIn) * IDEAS.Utilities.Psychrometrics.Constants.h_fg;
          TDryBul_degC = 0;
          rh_per       = 0;
        end if;
      annotation (
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-92,100},{-62,56}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                extent={{-92,14},{-72,-12}},
                lineColor={0,0,127},
                textString="phi"),
              Text(
                extent={{-90,-72},{-72,-90}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                extent={{62,22},{92,-22}},
                lineColor={0,0,127},
                textString="TWetBul"),
              Line(points={{78,-74},{-48,-74}}),
              Text(
                extent={{76,-78},{86,-94}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="T"),
              Line(
                points={{76,-46},{26,-4}},
                color={255,0,0},
                thickness=0.5),
              Line(points={{-48,-48},{-2,-30},{28,-4},{48,32},{52,72}},
                color={0,0,0},
                smooth=Smooth.Bezier),
              Line(points={{-48,84},{-48,-74}}),
              Text(
                extent={{-44,82},{-22,64}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="X"),
              Polygon(
                points={{86,-74},{76,-72},{76,-76},{86,-74}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-48,88},{-46,74},{-50,74},{-48,88}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
          defaultComponentName="wetBul",
          Documentation(info="<html>
<p>
This block computes the wet bulb temperature for a given dry bulb temperature, relative air humidity
and atmospheric pressure.
</p>
<p>
If the constant <code>approximateWetBulb</code> is <code>true</code>,
then the block uses the approximation of Stull (2011) to compute
the wet bulb temperature without requiring a nonlinear equation.
Otherwise, the model will introduce one nonlinear equation.
The approximation by Stull is valid for a relative humidity of <i>5%</i> to <i>99%</i>,
a temperature range from <i>-20</i>&deg;C to <i>50</i>&deg;C
and standard sea level pressure.
For this range of data, the approximation error is <i>-1</i> Kelvin to <i>+0.65</i> Kelvin,
with a mean error of less than <i>0.3</i> Kelvin.
</p>
<p>
Otherwise a calculation based on an energy balance is used.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/474\">#474</a> for a discussion.
The model is validated in
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Examples.TWetBul_TDryBulPhi\">
IDEAS.Utilities.Psychrometrics.Examples.TWetBul_TDryBulPhi</a>.
</p>
<p>
For a model that takes the mass fraction instead of the relative humidity as an input, see
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.TWetBul_TDryBulXi\">
IDEAS.Utilities.Psychrometrics.TWetBul_TDryBulXi</a>.
</p>
<h4>References</h4>
<p>
Stull, Roland.
<i><a href=\"http://dx.doi.org/10.1175/JAMC-D-11-0143.1\">
Wet-Bulb Temperature from Relative Humidity and Air Temperature
Roland Stull.</a></i>
Journal of Applied Meteorology and Climatology.
Volume 50, Issue 11, pp. 2267-2269. November 2011
DOI: 10.1175/JAMC-D-11-0143.1
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 3, 2016, by Michael Wetter:<br/>
Changed icon.
</li>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Corrected exact implementation.
See  <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/474\">#474</a>
for a discussion.
</li>
<li>
October 3, 2014, by Michael Wetter:<br/>
Changed assignment of nominal value to avoid in OpenModelica the warning
alias set with different nominal values.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
Updated model to use
<code>IDEAS.Utilities.Psychrometrics.Functions.saturationPressure()</code>
and
<code>IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid()</code>
as these functions have been moved from the medium to the psychrometrics package.
</li>
<li>
October 1, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TWetBul_TDryBulPhi;

      block TWetBul_TDryBulXi
        "Model to compute the wet bulb temperature based on mass fraction"
        extends Modelica.Blocks.Icons.Block;
        replaceable package Medium =
          Modelica.Media.Interfaces.PartialCondensingGases "Medium model"                          annotation (
            choicesAllMatching = true);
        parameter Boolean approximateWetBulb=false
          "Set to true to approximate wet bulb temperature" annotation (Evaluate=true);
        Modelica.Blocks.Interfaces.RealInput TDryBul(
          start=303,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Dry bulb temperature"
          annotation (Placement(transformation(extent={{-120,70},{-100,90}})));
        Modelica.Blocks.Interfaces.RealInput p(  final quantity="Pressure",
                                                 final unit="Pa",
                                                 min = 0) "Pressure"
          annotation (Placement(transformation(extent={{-120,-90},{-100,-70}})));
        Modelica.Blocks.Interfaces.RealOutput TWetBul(
          start=293,
          final quantity="ThermodynamicTemperature",
          final unit="K",
          min=0) "Wet bulb temperature"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
        Modelica.Blocks.Interfaces.RealInput Xi[Medium.nXi]
          "Species concentration at dry bulb temperature"
          annotation (Placement(transformation(extent={{-120,-10},{-100,10}})));
    protected
        Modelica.SIunits.Conversions.NonSIunits.Temperature_degC TDryBul_degC
          "Dry bulb temperature in degree Celsius";
        Real rh_per(min=0) "Relative humidity in percentage";
        Modelica.SIunits.MassFraction XiSat(start=0.01,
                                            nominal=0.01)
          "Water vapor mass fraction at saturation";
        Modelica.SIunits.MassFraction XiSatRefIn
          "Water vapor mass fraction at saturation, referenced to inlet mass flow rate";
       parameter Integer iWat = sum({(
         if Modelica.Utilities.Strings.isEqual(string1=Medium.substanceNames[i], string2="Water", caseSensitive=false)
         then i else 0) for i in 1:Medium.nX})
           "Index of water in medium composition vector";
      initial equation
        assert(iWat > 0, "Did not find medium species 'water' in the medium model. Change medium model.");
      equation
        if approximateWetBulb then
          TDryBul_degC = TDryBul - 273.15;
          rh_per       = 100 * p/
               IDEAS.Utilities.Psychrometrics.Functions.saturationPressure(TDryBul)
               *Xi[iWat]/(Xi[iWat] +
               IDEAS.Utilities.Psychrometrics.Constants.k_mair*(1-Xi[iWat]));
          TWetBul      = 273.15 + TDryBul_degC
             * Modelica.Math.atan(0.151977 * sqrt(rh_per + 8.313659))
             + Modelica.Math.atan(TDryBul_degC + rh_per)
             - Modelica.Math.atan(rh_per-1.676331)
             + 0.00391838 * rh_per^(1.5) * Modelica.Math.atan( 0.023101 * rh_per)  - 4.686035;
          XiSat = 0;
          XiSatRefIn=0;
        else
          XiSatRefIn=(1-Xi[iWat])*XiSat/(1-XiSat);
          XiSat  = IDEAS.Utilities.Psychrometrics.Functions.X_pSatpphi(
            pSat = IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TWetBul),
            p =    p,
            phi =  1);
          (TWetBul-IDEAS.Utilities.Psychrometrics.Constants.T_ref) * (
                    (1-Xi[iWat]) * IDEAS.Utilities.Psychrometrics.Constants.cpAir +
                    XiSatRefIn * IDEAS.Utilities.Psychrometrics.Constants.cpSte +
                    (Xi[iWat]-XiSatRefIn) * IDEAS.Utilities.Psychrometrics.Constants.cpWatLiq)
          =
          (TDryBul-IDEAS.Utilities.Psychrometrics.Constants.T_ref) * (
                    (1-Xi[iWat]) * IDEAS.Utilities.Psychrometrics.Constants.cpAir +
                    Xi[iWat] * IDEAS.Utilities.Psychrometrics.Constants.cpSte)  +
          (Xi[iWat]-XiSatRefIn) * IDEAS.Utilities.Psychrometrics.Constants.h_fg;
          TDryBul_degC = 0;
          rh_per       = 0;
        end if;
      annotation (
          Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                  100}}), graphics={
              Text(
                extent={{-92,100},{-62,56}},
                lineColor={0,0,127},
                textString="TDryBul"),
              Text(
                extent={{-86,14},{-72,-6}},
                lineColor={0,0,127},
                textString="Xi"),
              Text(
                extent={{-90,-72},{-72,-90}},
                lineColor={0,0,127},
                textString="p"),
              Text(
                extent={{62,22},{92,-22}},
                lineColor={0,0,127},
                textString="TWetBul"),
              Line(points={{78,-74},{-48,-74}}),
              Text(
                extent={{76,-78},{86,-94}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="T"),
              Line(
                points={{76,-46},{26,-4}},
                color={255,0,0},
                thickness=0.5),
              Line(points={{-48,-48},{-2,-30},{28,-4},{48,32},{52,72}},
                color={0,0,0},
                smooth=Smooth.Bezier),
              Line(points={{-48,84},{-48,-74}}),
              Text(
                extent={{-44,82},{-22,64}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                textString="X"),
              Polygon(
                points={{86,-74},{76,-72},{76,-76},{86,-74}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-48,88},{-46,74},{-50,74},{-48,88}},
                lineColor={0,0,0},
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid)}),
          defaultComponentName="wetBul",
          Documentation(info="<html>
<p>
This block computes the wet bulb temperature for a given dry bulb temperature, mass fraction
and atmospheric pressure.
</p>
<p>
If the constant <code>approximateWetBulb</code> is <code>true</code>,
then the block uses the approximation of Stull (2011) to compute
the wet bulb temperature without requiring a nonlinear equation.
Otherwise, the model will introduce one nonlinear equation.
The approximation by Stull is valid for a relative humidity of <i>5%</i> to <i>99%</i>,
a temperature range from <i>-20&circ;C</i> to <i>50&circ;C</i>
and standard sea level pressure.
For this range of data, the approximation error is <i>-1</i> Kelvin to <i>+0.65</i> Kelvin,
with a mean error of less than <i>0.3</i> Kelvin.
</p>
<p>
Otherwise a calculation based on an energy balance is used.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/474\">#474</a> for a discussion.
</p>
<p>
For a model that takes the relative humidity instead of the mass fraction as an input, see
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.TWetBul_TDryBulPhi\">
IDEAS.Utilities.Psychrometrics.TWetBul_TDryBulPhi</a>.
</p>
<h4>References</h4>
<p>
Stull, Roland.
<i><a href=\"http://dx.doi.org/10.1175/JAMC-D-11-0143.1\">
Wet-Bulb Temperature from Relative Humidity and Air Temperature
Roland Stull.</a></i>
Journal of Applied Meteorology and Climatology.
Volume 50, Issue 11, pp. 2267-2269. November 2011
DOI: 10.1175/JAMC-D-11-0143.1
</p>
</html>",
      revisions="<html>
<ul>
<li>
May 1, 2017, by Filip Jorissen:<br/>
Revised computation of <code>iWat</code>
such that it does not require an initial algorithm.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/759\">#759</a>.
</li>
<li>
November 3, 2016, by Michael Wetter:<br/>
Changed icon.
</li>
<li>
May 24, 2016, by Filip Jorissen:<br/>
Corrected exact implementation.
See  <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/474\">#474</a>
for a discussion.
</li>
<li>
April 11, 2016 by Michael Wetter:<br/>
Corrected wrong hyperlink in documentation for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/450\">issue 450</a>.
</li>
<li>
November 17, 2014, by Michael Wetter:<br/>
Removed test on saturation pressure that avoids it to be larger than
<code>p</code>.
This test is not needed as it is only active near or above the boiling temperature,
and the result is only used in the computation of <code>rh_per</code>.
I do not see any negative impact from removing this test.
</li>
<li>
July 24, 2014 by Michael Wetter:<br/>
Revised computation of <code>rh_per</code> to use
<a href=\"modelica://IDEAS.Utilities.Math.Functions.smoothMin\">
IDEAS.Utilities.Math.Functions.smoothMin</a> rather
than <code>min</code>.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
Updated model to use
<code>IDEAS.Utilities.Psychrometrics.Functions.saturationPressure()</code>
and
<code>IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid()</code>
as these functions have been moved from the medium to the psychrometrics package.
</li>
<li>
September 10, 2013 by Michael Wetter:<br/>
Added start value and nominal value for <code>XiSat</code> as this is an iteration
variable in OpenModelica.
</li>
<li>
October 1, 2012 by Michael Wetter:<br/>
Revised implementation to change the dimension of the nonlinear
system of equations from two to one.
Added option to compute wet bulb temperature explicitly.
</li>
<li>
February 22, 2011 by Michael Wetter:<br/>
Changed the code sections that obtain the water concentration. The old version accessed
the water concentration using the index of the vector <code>X</code>.
However, Dymola 7.4 cannot differentiate the function if vector elements are accessed
using their index. In the new implementation, an inner product is used to access the vector element.
In addition, the medium substance name is searched using a case insensitive search.
</li>
<li>
February 17, 2010 by Michael Wetter:<br/>
Renamed block from <code>WetBulbTemperature</code> to <code>TWetBul_TDryBulXi</code>
and changed obsolete real connectors to input and output connectors.
</li>
<li>
May 19, 2008 by Michael Wetter:<br/>
Added relative humidity as a port.
</li>
<li>
May 7, 2008 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
      end TWetBul_TDryBulXi;

      block X_pTphi
        "Return steam mass fraction as a function of relative humidity phi and temperature T"
        extends
        IDEAS.Utilities.Psychrometrics.BaseClasses.HumidityRatioVaporPressure;
        package Medium = IDEAS.Media.Air "Medium model";
        Modelica.Blocks.Interfaces.RealInput T(final unit="K",
                                                 displayUnit="degC",
                                                 min = 0) "Temperature"
          annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));
        Modelica.Blocks.Interfaces.RealInput phi(min = 0, max=1)
          "Relative humidity (0...1)"
          annotation (Placement(transformation(extent={{-140,-80},{-100,-40}})));
        Modelica.Blocks.Interfaces.RealOutput X[Medium.nX](each min=0, each max=1)
          "Steam mass fraction"
          annotation (Placement(transformation(extent={{100,-10},{120,10}})));
    protected
        Modelica.SIunits.AbsolutePressure pSat "Saturation pressure";
        parameter Integer i_w=
         sum({(
           if Modelica.Utilities.Strings.isEqual(
             string1=Medium.substanceNames[i],
             string2="Water",
             caseSensitive=false)
           then i else 0)
           for i in 1:Medium.nX});
        parameter Integer i_nw = if i_w == 1 then 2 else 1 "Index for non-water substance";
        parameter Boolean found = i_w > 0 "Flag, used for error checking";
      initial equation
        assert(Medium.nX==2, "The implementation is only valid if Medium.nX=2.");
        assert(found, "Did not find medium species 'water' in the medium model. Change medium model.");
      equation
        pSat =  IDEAS.Media.Air.saturationPressure(T);
        X[i_w] =  IDEAS.Utilities.Psychrometrics.Functions.X_pSatpphi(
           pSat=pSat,
           p=p_in_internal,
           phi=phi);
        //sum(X[:]) = 1; // The formulation with a sum in an equation section leads to a nonlinear equation system
        X[i_nw] =  1 - X[i_w];
        annotation (Documentation(info="<html>
<p>
Block to compute the water vapor concentration based on
pressure, temperature and relative humidity.
</p>
<p>
If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as atmospheric pressure,
and the <code>p_in</code> input connector is disabled;
if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored,
and the value provided by the input connector is used instead.
</p>
</html>",       revisions="<html>
<ul>
<li>November 3, 2017 by Filip Jorissen:<br/>
Converted (initial) algorithm section into (initial) equation section.
See <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/847\">#847</a>.
</li>
<li>July 24, 2014 by Michael Wetter:<br/>
Added <code>assert</code> to verify that <code>Medium.nX==2</code>
as the implementation is only valid for such media.
</li>
<li>April 26, 2013 by Michael Wetter:<br/>
Set the medium model to <code>IDEAS.Media.Air</code>.
This was required to allow a pedantic model check in Dymola 2014.
</li>
<li>August 21, 2012 by Michael Wetter:<br/>
Added function call to compute water vapor content.
</li>
<li>
February 22, 2010 by Michael Wetter:<br/>
Improved the code that searches for the index of 'water' in the medium model.
</li>
<li>
February 17, 2010 by Michael Wetter:<br/>
Renamed block from <code>MassFraction_pTphi</code> to <code>X_pTphi</code>
</li>
<li>
February 4, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),       Icon(graphics={
              Text(
                extent={{-96,16},{-54,-22}},
                lineColor={0,0,0},
                textString="T"),
              Text(
                extent={{-86,-18},{-36,-100}},
                lineColor={0,0,0},
                textString="phi"),
              Text(
                extent={{26,56},{90,-54}},
                lineColor={0,0,0},
                textString="X_steam")}));
      end X_pTphi;

      package Functions "Package with psychrometric functions"
        extends Modelica.Icons.Package;

        function X_pSatpphi "Humidity ratio for given water vapor pressure"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.AbsolutePressure pSat "Saturation pressure";
          input Modelica.SIunits.Pressure p "Pressure of the fluid";
          input Real phi(min=0, max=1) "Relative humidity";
          output Modelica.SIunits.MassFraction X_w(
            min=0,
            max=1,
            nominal=0.01) "Water vapor concentration per total mass of air";
      protected
          constant Real k = 0.621964713077499 "Ratio of molar masses";
        algorithm
          X_w := phi*k/(k*phi+p/pSat-phi);
          annotation (
            smoothOrder=99,
            Inline=true,
            Documentation(info="<html>
<p>
Function to compute the water vapor concentration based on
saturation pressure, absolute pressure and relative humidity.
</p>
</html>",         revisions="<html>
<ul>
<li>
August 21, 2012 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end X_pSatpphi;

        function X_pTphi
          "Absolute humidity for given pressure, dry bulb temperature and relative humidity"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Pressure p "Absolute pressure of the medium";
          input Modelica.SIunits.Temperature T "Dry bulb temperature";
          input Real phi(unit="1") "Relative humidity";
          output Modelica.SIunits.MassFraction X_w
            "Water vapor mass fraction per unit mass total air";

        algorithm
          X_w:=phi/((p/saturationPressure(T)-phi) / IDEAS.Utilities.Psychrometrics.Constants.k_mair + phi);
          annotation (
            inverse(phi=phi_pTX(p,T,X_w)),
            smoothOrder=1,
            Documentation(info="<html>
<p>
Absolute humidity of air for given
pressure, temperature and relative humidity.
</p>
<p>
Note that the absolute humidity is in <i>kg/kg</i>
total air, and not dry air.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 4, 2019 by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
        end X_pTphi;

        function phi_pTX
          "Relative humidity for given pressure, dry bulb temperature and moisture mass fraction"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Pressure p "Absolute pressure of the medium";
          input Modelica.SIunits.Temperature T "Dry bulb temperature";
          input Modelica.SIunits.MassFraction X_w
            "Water vapor mass fraction per unit mass total air";
          output Real phi(unit="1") "Relative humidity";
        algorithm
          phi :=p/saturationPressure(T)*X_w/(X_w +
            IDEAS.Utilities.Psychrometrics.Constants.k_mair*(1-X_w));
          annotation (
            inverse(X_w=X_pTphi(p,T,phi)),
            smoothOrder=1,
            Documentation(info="<html>
<p>
Relative humidity of air for given
pressure, temperature and water vapor mass fraction.
</p>
<p>
Note that the water vapor mass fraction must be in <i>kg/kg</i>
total air, and not dry air.
</p>
</html>",
        revisions="<html>
<ul>
<li>
April 4, 2019 by Filip Jorissen:<br/>
Added inverse annotation
for <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1110\">#1110</a>.
</li>
<li>
November 17, 2014 by Michael Wetter:<br/>
Removed test that constrains the saturation pressure to be
lower than <code>p</code>.
I do not see any numerical problems without this test.
</li>
<li>
November 13, 2014 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
        end phi_pTX;

        function saturationPressure
          "Saturation curve valid for 223.16 <= T <= 373.16 (and slightly outside with less accuracy)"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                  nominal=300) "Saturation temperature";
          output Modelica.SIunits.AbsolutePressure pSat(
                                                  displayUnit="Pa",
                                                  nominal=1000) "Saturation pressure";

        algorithm
          pSat := IDEAS.Utilities.Math.Functions.regStep(
                     y1=IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid(TSat),
                     y2=IDEAS.Utilities.Psychrometrics.Functions.sublimationPressureIce(TSat),
                     x=TSat-273.16,
                     x_small=1.0);
          annotation(Inline=true,
            smoothOrder=1,
            Documentation(info="<html>
<p>
Saturation pressure of water, computed from temperature,
according to Wagner <i>et al.</i> (1993).
The range of validity is between
<i>190</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
March 15, 2016, by Michael Wetter:<br/>
Replaced <code>spliceFunction</code> with <code>regStep</code>.
This is for
<a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/300\">issue 300</a>.
</li>
<li>
August 19, 2015 by Michael Wetter:<br/>
Changed <code>smoothOrder</code> from <i>5</i> to <i>1</i> as
<a href=\"modelica://IDEAS.Utilities.Math.Functions.spliceFunction\">
IDEAS.Utilities.Math.Functions.spliceFunction</a> is only once
continuously differentiable.
Inlined the function.
</li>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IDEAS.Media</code>.
</li>
</ul>
</html>"));
        end saturationPressure;

        function saturationPressureLiquid
          "Return saturation pressure of water as a function of temperature T in the range of 273.16 to 373.16 K"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                  nominal=300) "Saturation temperature";
          output Modelica.SIunits.AbsolutePressure pSat(
                                              displayUnit="Pa",
                                              nominal=1000) "Saturation pressure";
        algorithm
          pSat := 611.657*Modelica.Math.exp(17.2799 - 4102.99/(TSat - 35.719));

          annotation (
            smoothOrder=99,
            derivative=IDEAS.Utilities.Psychrometrics.Functions.BaseClasses.der_saturationPressureLiquid,
            Inline=true,
            Documentation(info="<html>
<p>
Saturation pressure of water above the triple point temperature computed from temperature
according to Wagner <i>et al.</i> (1993). The range of validity is between
<i>273.16</i> and <i>373.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IDEAS.Media</code>.
</li>
</ul>
</html>"));
        end saturationPressureLiquid;

        function sublimationPressureIce
          "Return sublimation pressure of water as a function of temperature T between 190 and 273.16 K"
          extends Modelica.Icons.Function;
          input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                  nominal=300) "Saturation temperature";
          output Modelica.SIunits.AbsolutePressure pSat(
                                              displayUnit="Pa",
                                              nominal=1000) "Saturation pressure";
      protected
          Modelica.SIunits.Temperature TTriple=273.16 "Triple point temperature";
          Modelica.SIunits.AbsolutePressure pTriple=611.657 "Triple point pressure";
          Real r1=TSat/TTriple "Common subexpression";
          Real a[2]={-13.9281690,34.7078238} "Coefficients a[:]";
          Real n[2]={-1.5,-1.25} "Coefficients n[:]";
        algorithm
          pSat := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*pTriple;
          annotation (
            Inline=false,
            smoothOrder=5,
            derivative=IDEAS.Utilities.Psychrometrics.Functions.BaseClasses.der_sublimationPressureIce,
            Documentation(info="<html>
<p>
Sublimation pressure of water below the triple point temperature, computed from temperature,
according to Wagner <i>et al.</i> (1993).
The range of validity is between
<i>190</i> and <i>273.16</i> Kelvin.
</p>
<h4>References</h4>
<p>
Wagner W., A. Saul, A. Pruss.
 <i>International equations for the pressure along the melting and along the sublimation curve of ordinary water substance</i>,
equation 3.5. 1993.
<a href=\"http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf\">
http://aip.scitation.org/doi/pdf/10.1063/1.555947?class=pdf</a>.
</p>
</html>",
        revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IDEAS.Media</code>.
</li>
</ul>
</html>"));
        end sublimationPressureIce;

        package BaseClasses
        "Package with base classes for IDEAS.Utilities.Psychrometrics.Functions"
          extends Modelica.Icons.BasesPackage;

          function der_saturationPressureLiquid
            "Derivative of the function saturationPressureLiquid"
            extends Modelica.Icons.Function;
            input Modelica.SIunits.Temperature Tsat "Saturation temperature";
            input Real dTsat(unit="K/s") "Saturation temperature derivative";
            output Real psat_der(unit="Pa/s") "Differential of saturation pressure";
          algorithm
            psat_der:=611.657*Modelica.Math.exp(17.2799 - 4102.99
                      /(Tsat - 35.719))*4102.99*dTsat/(Tsat - 35.719)^2;
            annotation(Inline=false,
              smoothOrder=5,
              Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid\">
IDEAS.Utilities.Psychrometrics.Functions.saturationPressureLiquid</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IDEAS.Media</code>.
</li>
</ul>
</html>"));
          end der_saturationPressureLiquid;

          function der_sublimationPressureIce
            "Derivative of function sublimationPressureIce"
              extends Modelica.Icons.Function;
              input Modelica.SIunits.Temperature TSat(displayUnit="degC",
                                                      nominal=300)
              "Saturation temperature";
              input Real dTsat(unit="K/s") "Sublimation temperature derivative";
              output Real psat_der(unit="Pa/s") "Sublimation pressure derivative";
        protected
              Modelica.SIunits.Temperature TTriple=273.16 "Triple point temperature";
              Modelica.SIunits.AbsolutePressure pTriple=611.657 "Triple point pressure";
              Real r1=TSat/TTriple "Common subexpression 1";
              Real r1_der=dTsat/TTriple "Derivative of common subexpression 1";
              Real a[2]={-13.9281690,34.7078238} "Coefficients a[:]";
              Real n[2]={-1.5,-1.25} "Coefficients n[:]";
          algorithm
              psat_der := exp(a[1] - a[1]*r1^n[1] + a[2] - a[2]*r1^n[2])*pTriple*(-(a[1]
                *(r1^(n[1] - 1)*n[1]*r1_der)) - (a[2]*(r1^(n[2] - 1)*n[2]*r1_der)));
              annotation (
                Inline=false,
                smoothOrder=5,
                Documentation(info="<html>
<p>
Derivative of function
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Functions.sublimationPressureIce\">
IDEAS.Utilities.Psychrometrics.Functions.sublimationPressureIce</a>.
</p>
</html>", revisions="<html>
<ul>
<li>
November 20, 2013 by Michael Wetter:<br/>
First implementation, moved from <code>IDEAS.Media</code>.
</li>
</ul>
</html>"));
          end der_sublimationPressureIce;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Utilities.Psychrometrics.Functions\">IDEAS.Utilities.Psychrometrics.Functions</a>.
</p>
</html>"));
        end BaseClasses;
        annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains functions for psychrometric calculations.
</p>

The nomenclature used in this package is described at
<a href=\"modelica://IDEAS.UsersGuide.Conventions\">
IDEAS.UsersGuide.Conventions</a>.
</html>"));
      end Functions;

      package BaseClasses
      "Package with base classes for IDEAS.Utilities.Psychrometrics"
        extends Modelica.Icons.BasesPackage;

        partial block HumidityRatioVaporPressure
          "Humidity ratio for given water vapor pressure"
          extends Modelica.Blocks.Icons.Block;
          parameter Boolean use_p_in = true "Get the pressure from the input connector"
            annotation(Evaluate=true, HideResult=true);
          parameter Modelica.SIunits.Pressure p = 101325 "Fixed value of pressure"
            annotation (Dialog(enable = not use_p_in));
          Modelica.Blocks.Interfaces.RealInput p_in(final quantity="Pressure",
                                                 final unit="Pa",
                                                 displayUnit="Pa",
                                                 min = 0) if  use_p_in
            "Atmospheric Pressure"
            annotation (Placement(transformation(extent={{-140,40},{-100,80}})));
      protected
          Modelica.Blocks.Interfaces.RealInput p_in_internal
            "Needed to connect to conditional connector";
        equation
          connect(p_in, p_in_internal);
          if not use_p_in then
            p_in_internal = p;
          end if;
          annotation (
            Documentation(info="<html>
<p>
Partial Block to compute the relation between humidity ratio and water vapor partial pressure.
</p>
<p>If <code>use_p_in</code> is false (default option), the <code>p</code> parameter
is used as atmospheric pressure,
and the <code>p_in</code> input connector is disabled;
if <code>use_p_in</code> is true, then the <code>p</code> parameter is ignored,
and the value provided by the input connector is used instead.
</p>
</html>",         revisions="<html>
<ul>
<li>
May 29, 2014, by Michael Wetter:<br/>
Removed undesirable annotation <code>Evaluate=true</code>.
</li>
<li>
April 14, 2009 by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"),  Icon(coordinateSystem(preserveAspectRatio=true,  extent={{-100,-100},{100,
                    100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{-96,96},{96,-96}},
                  fillPattern=FillPattern.Sphere,
                  pattern=LinePattern.None,
                  lineColor={255,255,255},
                  fillColor={170,213,255}),
                Text(
                  visible=use_p_in,
                  extent={{-90,108},{-34,16}},
                  lineColor={0,0,0},
                  textString="p_in")}));
        end HumidityRatioVaporPressure;
      annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains base classes that are used to construct the models in
<a href=\"modelica://IDEAS.Utilities.Psychrometrics\">IDEAS.Utilities.Psychrometrics</a>.
</p>
</html>"));
      end BaseClasses;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains blocks and functions for psychrometric calculations.
</p>
<p>
The nomenclature used in this package is described at
<a href=\"modelica://IDEAS.UsersGuide.Conventions\">
IDEAS.UsersGuide.Conventions</a>.
</p>
</html>"));
    end Psychrometrics;

    package Time "Package with models for time"
      extends Modelica.Icons.Package;

      model CalendarTime
        "Computes the unix time stamp and calendar time from the simulation time"
        extends Modelica.Blocks.Icons.DiscreteBlock;
        parameter IDEAS.Utilities.Time.Types.ZeroTime zerTim
          "Enumeration for choosing how reference time (time = 0) should be defined";
        parameter Integer yearRef(min=firstYear, max=lastYear) = 2016
          "Year when time = 0, used if zerTim=Custom"
          annotation(Dialog(enable=zerTim==IDEAS.Utilities.Time.Types.ZeroTime.Custom));
        parameter Modelica.SIunits.Time offset = 0
          "Offset that is added to 'time', may be used for computing time in different time zone"
          annotation(Dialog(tab="Advanced"));

        Modelica.Blocks.Interfaces.RealOutput unixTimeStamp(final unit="s")
          "Unix time stamp at local time"
              annotation (Placement(transformation(extent={{100,-90},{120,-70}}),
              iconTransformation(extent={{100,-90},{120,-70}})));
        discrete Modelica.Blocks.Interfaces.IntegerOutput year(start=2010) "Year"
          annotation (Placement(transformation(extent={{100,-32},{120,-12}}),
              iconTransformation(extent={{100,-32},{120,-12}})));
        discrete Modelica.Blocks.Interfaces.IntegerOutput month(start=1) "Month of the year"
          annotation (Placement(transformation(extent={{100,-4},{120,16}}),
              iconTransformation(extent={{100,-4},{120,16}})));
        Modelica.Blocks.Interfaces.IntegerOutput day(fixed=false) "Day of the month"
          annotation (Placement(transformation(extent={{100,24},{120,44}}),
              iconTransformation(extent={{100,24},{120,44}})));
        Modelica.Blocks.Interfaces.IntegerOutput hour(fixed=false) "Hour of the day"
          annotation (Placement(transformation(extent={{100,52},{120,72}}),
              iconTransformation(extent={{100,52},{120,72}})));
        Modelica.Blocks.Interfaces.RealOutput minute "Minute of the hour"
          annotation (Placement(transformation(extent={{100,80},{120,100}}),
              iconTransformation(extent={{100,80},{120,100}})));
        Modelica.Blocks.Interfaces.IntegerOutput weekDay(fixed=false)
          "Integer output representing week day (monday = 1, sunday = 7)"
          annotation (Placement(transformation(extent={{100,-60},{120,-40}}),
              iconTransformation(extent={{100,-60},{120,-40}})));

    protected
        final constant Integer firstYear = 2010
          "First year that is supported, i.e. the first year in timeStampsNewYear[:]";
        final constant Integer lastYear = firstYear + size(timeStampsNewYear,1) - 1;
        constant Modelica.SIunits.Time timeStampsNewYear[12] = {
          1262304000.0, 1293840000.0, 1325376000.0,
          1356998400.0, 1388534400.0, 1420070400.0,
          1451606400.0, 1483228800.0, 1514764800.0,
          1546300800.0, 1577836800.0, 1609459200.0}
          "Epoch time stamps for new years day 2010 to 2021";
        constant Boolean isLeapYear[11] = {
          false, false, true, false,
          false, false, true, false,
          false, false, true}
          "List of leap years starting from firstYear (2010), up to and including 2020";
        final constant Integer dayInMonth[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
          "Number of days in each month";
        parameter Modelica.SIunits.Time timOff(fixed=false) "Time offset";
        // final parameters since the user may wrongly assume that this model shifts the
        // actual time of the simulation
        final constant Integer monthRef(min=1, max=12) = 1 "Month when time = 0"
          annotation(Dialog(enable=zerTim==IDEAS.Utilities.Time.Types.ZeroTime.Custom));
        final constant Integer dayRef(min=1, max=31) = 1 "Day when time = 0"
          annotation(Dialog(enable=zerTim==IDEAS.Utilities.Time.Types.ZeroTime.Custom));
        Integer daysSinceEpoch(fixed=false) "Number of days that passed since 1st of January 1970";
        discrete Integer yearIndex "Index of the current year in timeStampsNewYear";
        discrete Real epochLastMonth
          "Unix time stamp of the beginning of the current month";

        final parameter Modelica.SIunits.Time hourSampleStart(fixed=false)
          "Time when the sampling every hour starts";
        final parameter Modelica.SIunits.Time daySampleStart(fixed=false)
          "Time when the sampling every day starts";


        Boolean hourSampleTrigger "True, if hourly sample time instant";
        Boolean daySampleTrigger "True, if daily sample time instant";

        Boolean firstHourSampling(fixed=true, start=true)
          "=true if the hour is sampled the first time";
        Boolean firstDaySampling(fixed=true, start=true)
          "=true if the day is sampled the first time";
      initial equation
        hourSampleStart = integer(time/3600)*3600 - offset;
        daySampleStart  = integer(time/(3600*24))*3600*24 - offset;

        hour = integer(floor(rem(unixTimeStamp,3600*24)/3600));
        daysSinceEpoch = integer(floor(unixTimeStamp/3600/24));

        day = integer(1+floor((unixTimeStamp-epochLastMonth)/3600/24));
        weekDay = integer(rem(4+daysSinceEpoch-1,7)+1);
      initial algorithm
        // check if yearRef is in the valid range
        assert(not zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom
               or yearRef>=firstYear and yearRef<=lastYear,
          "The value you chose for yearRef (=" + String(yearRef) + ") is outside of
   the validity range of "       + String(firstYear) + " to " + String(lastYear) + ".");

        // check if the day number exists for the chosen month and year
        assert(not zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom
               or dayInMonth[monthRef] + (if monthRef==2 and isLeapYear[yearRef-firstYear + 1] then 1 else 0) >=dayRef,
          "The day number you chose is larger than the number of days contained by the month you chose.");

        // compute the offset to be added to time based on the parameters specified by the user
        if zerTim == IDEAS.Utilities.Time.Types.ZeroTime.UnixTimeStamp then
          timOff :=0;
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2010 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2010 then
            timOff :=timeStampsNewYear[1];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2011 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2011 then
            timOff :=timeStampsNewYear[2];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2012 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2012 then
            timOff :=timeStampsNewYear[3];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2013 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2013 then
            timOff :=timeStampsNewYear[4];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2014 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2014 then
            timOff :=timeStampsNewYear[5];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2015 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2015 then
            timOff :=timeStampsNewYear[6];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2016 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2016 then
            timOff :=timeStampsNewYear[7];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2017 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2017 then
            timOff :=timeStampsNewYear[8];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2018 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2018 then
            timOff :=timeStampsNewYear[9];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2019 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2019 then
            timOff :=timeStampsNewYear[10];
        elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.NY2020 or
          zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef == 2020 then
            timOff :=timeStampsNewYear[11];
        else
          timOff :=0;
          // this code should not be reachable
          assert(false, "No valid ZeroTime could be identified.
   This is a bug, please submit a bug report.");
        end if;

        // add additional offset when using a custom date and time
        if zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom then
          timOff :=timOff + ((dayRef - 1) + sum({dayInMonth[i] for i in 1:(monthRef - 1)})
           + (if monthRef > 2 and isLeapYear[yearRef - firstYear + 1] then 1 else 0))*3600*24;
        end if;

         // input data range checks at initial time
        assert(time + offset + timOff >= timeStampsNewYear[1],
          if zerTim == IDEAS.Utilities.Time.Types.ZeroTime.UnixTimeStamp then
            "Could not initialize date in the CalendarTime block.
   You selected 1970 as the time=0 reference.
   Therefore the simulation startTime must be at least "       + String(timeStampsNewYear[1]) + "."
          elseif zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom then
            if yearRef <firstYear then
              "Could not initialize date in the CalendarTime block.
   You selected a custom time=0 reference.
   The minimum value for yearRef is then "       + String(firstYear) + " but your value is " + String(yearRef) + "."
            else
              "Could not initialize date in the CalendarTime block.
   You selected a custom time=0 reference.
   Possibly your startTime is too small."
            else
              "Could not initialize date in the CalendarTime block.
   Possibly your startTime is negative?");

        assert(time + offset + timOff < timeStampsNewYear[size(timeStampsNewYear,1)],
          if zerTim == IDEAS.Utilities.Time.Types.ZeroTime.Custom and yearRef >= lastYear then
            "Could not initialize date in the CalendarTime block.
   You selected a custom time=0 reference.
   The maximum value for yearRef is then "       + String(lastYear) +
         " but your value is " + String(yearRef) + "."
          else
             "Could not initialize date in the CalendarTime block.
       Possibly your startTime is too large.");

        // iterate to find the year at initialization
      initial algorithm
        year :=0;
        for i in 1:size(timeStampsNewYear,1) loop
          // may be reformulated using break if JModelica fixes bug
          if unixTimeStamp < timeStampsNewYear[i]
            and (if i == 1 then true else unixTimeStamp >= timeStampsNewYear[i-1]) then
            yearIndex :=i - 1;
            year :=firstYear + i - 2;
          end if;
        end for;

        // iterate to find the month at initialization
        epochLastMonth := timeStampsNewYear[yearIndex];
        month:=13;
        for i in 1:12 loop
          if (unixTimeStamp-epochLastMonth)/3600/24 <
            (if i==2 and isLeapYear[yearIndex] then 1 + dayInMonth[i] else dayInMonth[i]) then
            // construction below avoids the need of a break, which bugs out JModelica
            month :=min(i,month);
          else
            epochLastMonth :=epochLastMonth + (if i == 2 and isLeapYear[yearIndex]
               then 1 + dayInMonth[i] else dayInMonth[i])*3600*24;
          end if;
        end for;

      equation
        // compute unix time step based on found offset
        unixTimeStamp = time + offset + timOff;

        // update the year when passing the epoch time stamp of the next year
        when unixTimeStamp >= timeStampsNewYear[pre(yearIndex)+1] then
          yearIndex=pre(yearIndex)+1;
          assert(yearIndex<=size(timeStampsNewYear,1),
            "Index out of range for epoch vector: timeStampsNewYear needs to be extended beyond the year "
              + String(firstYear+size(timeStampsNewYear,1)));
          year = pre(year) + 1;
        end when;

        // update the month when passing the last day of the current month
        when unixTimeStamp >= pre(epochLastMonth) +
            (if pre(month)==2 and isLeapYear[yearIndex]
              then 1 + dayInMonth[pre(month)] else dayInMonth[pre(month)])*3600*24 then
          month = if pre(month) == 12 then 1 else pre(month) + 1;
          epochLastMonth = pre(epochLastMonth) +
            (if pre(month)==2 and isLeapYear[yearIndex]
              then 1 + dayInMonth[pre(month)] else dayInMonth[pre(month)])*3600*24;
        end when;

        // compute other variables that can be computed without using when() statements
        hourSampleTrigger =sample(hourSampleStart, 3600);
        when hourSampleTrigger then
          if pre(firstHourSampling) then
            hour = integer(floor(rem(unixTimeStamp,3600*24)/3600));
          else
            hour = if (pre(hour) == 23) then 0 else (pre(hour) + 1);
          end if;
          firstHourSampling = false;
        end when;

        daySampleTrigger =sample(daySampleStart, 86400);
        when daySampleTrigger then
          if pre(firstDaySampling) then
            daysSinceEpoch = integer(floor(unixTimeStamp/3600/24));
            weekDay=integer(rem(4+daysSinceEpoch-1,7)+1);

          else
            daysSinceEpoch = pre(daysSinceEpoch) + 1;
            weekDay = if (pre(weekDay) == 7) then 1 else (pre(weekDay) + 1);
          end if;
          day = integer(1+floor((unixTimeStamp-epochLastMonth)/3600/24));

          firstDaySampling = false;
        end when;

        // using Real variables and operations for minutes since otherwise too many events are generated
        minute = (unixTimeStamp/60-daysSinceEpoch*60*24-hour*60);

        annotation (
          defaultComponentName="calTim",
        Documentation(revisions="<html>
<ul>
<li>
February 14, 2019, by Damien Picard:<br/>
Fix bug when non-zero offset by substracting the offset from hourSampleStart and daySampleStart
(see <a href=\"https://github.com/ibpsa/modelica-ibpsa/issues/1099\">#1099</a>).
</li>
<li>
August 3, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>",       info="<html>
<p>
This blocks computes the unix time stamp, date and time
and the day of the week based on the Modelica
variable <code>time</code>.
</p>
<h4>Main equations</h4>
<p>
First the unix time stamp corresponding to the current time is computed.
From this variables the corresponding, year, date and time are computed using functions
such as <code>floor()</code> and <code>ceil()</code>.
</p>
<h4>Assumption and limitations</h4>
<p>
The implementation only supports date computations from year 2010 up to and including 2020.
Daylight saving and time zones are not supported.
</p>
<h4>Typical use and important parameters</h4>
<p>
The user must define which time and date correspond to <code>time = 0</code>
using the model parameters <code>zerTim</code>, and, if
<code>zerTim==IDEAS.Utilities.Time.Types.ZeroTime.Custom</code>,
the parameter <code>yearRef</code>.

The user can choose from new year, midnight for a number of years:
2010 to 2020 and also 1970.
The latter corresponds to a unix stamp of <i>0</i>.
(Note that when choosing the reference time equal to 0 at 1970,
the actual simulation time must be within the 2010-2020 range.
For instance <code>startTime = 1262304000</code> corresponds
to the simulation starting on the 1st of January 2010
when setting <code>zerTim = ZeroTime.UnixTimeStamp</code>.
This is within the 2010-2020 range and is therefore allowed.)
</p>
<h4>Implementation</h4>
<p>
The model was implemented such that no events are being generated for computing the minute of the day.
The model also contains an implementation for setting <code>time=0</code>
for any day and month other than January first.
This is however not activated in the current model since these options may wrongly give the impression
that it changes the time based on which the solar position is computed and TMY3 data are read.
</p>
</html>"),Icon(graphics={
              Text(
                extent={{-34,90},{96,80}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Minute"),
              Text(
                extent={{-28,66},{96,56}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Hour"),
              Text(
                extent={{-38,40},{96,28}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Day"),
              Text(
                extent={{-50,12},{96,2}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Month"),
              Text(
                extent={{-70,-16},{96,-26}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Year"),
              Text(
                extent={{-68,-40},{96,-52}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Weekday"),
              Text(
                extent={{-102,-72},{94,-84}},
                lineColor={28,108,200},
                horizontalAlignment=TextAlignment.Right,
                textString="Unix timestamp"),
              Ellipse(
                extent={{-94,94},{16,-16}},
                lineColor={160,160,164},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Line(
                points={{-40,38},{-64,62}},
                thickness=0.5),
              Line(
                points={{-40,38},{-14,38}},
                thickness=0.5)}));
      end CalendarTime;

      block ModelTime "Model time"
        extends Modelica.Blocks.Interfaces.SO;
      equation
        y = time;
        annotation (
          defaultComponentName="modTim",
          Icon(coordinateSystem(
              preserveAspectRatio=true,
              extent={{-100,-100},{100,100}},
              grid={1,1}), graphics={
              Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Line(points={{0,80},{0,60}}, color={160,160,164}),
              Line(points={{80,0},{60,0}}, color={160,160,164}),
              Line(points={{0,-80},{0,-60}}, color={160,160,164}),
              Line(points={{-80,0},{-60,0}}, color={160,160,164}),
              Line(points={{37,70},{26,50}}, color={160,160,164}),
              Line(points={{70,38},{49,26}}, color={160,160,164}),
              Line(points={{71,-37},{52,-27}}, color={160,160,164}),
              Line(points={{39,-70},{29,-51}}, color={160,160,164}),
              Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
              Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
              Line(points={{-71,37},{-54,28}}, color={160,160,164}),
              Line(points={{-38,70},{-28,51}}, color={160,160,164}),
              Line(
                points={{0,0},{-50,50}},
                thickness=0.5),
              Line(
                points={{0,0},{40,0}},
                thickness=0.5)}),
          Documentation(info="<html>
<p>This component outputs the model time, which starts at the value at which the simulation starts. For example, if a simulation starts at <i>t=-1</i>, then this block outputs first <i>t=-1</i>, and its output is advanced at the same rate as the simulation time. </p>
<p>The model is used to allow the simulation to start from any time without having to set the parameters for the clock, as would be necessary for the model <a href=\"modelica://Modelica.Blocks.Sources.Clock\">Modelica.Blocks.Sources.Clock</a>. </p>
</html>",       revisions="<html>
<ul>
<li>
January 16, 2015, by Michael Wetter:<br/>
Moved block from
<code>IDEAS.Utilities.SimulationTime</code>
to
<code>IDEAS.Utilities.Time.ModelTime</code>.
</li>
<li>
May 18, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end ModelTime;

      package Types "Package with type definitions"
       extends Modelica.Icons.TypesPackage;

        type ZeroTime = enumeration(
          UnixTimeStamp   "Thu, 01 Jan 1970 00:00:00 local time",
          Custom   "User specified local time",
          NY2010   "New year 2010, 00:00:00 local time",
          NY2011   "New year 2011, 00:00:00 local time",
          NY2012   "New year 2012, 00:00:00 local time",
          NY2013   "New year 2013, 00:00:00 local time",
          NY2014   "New year 2014, 00:00:00 local time",
          NY2015   "New year 2015, 00:00:00 local time",
          NY2016   "New year 2016, 00:00:00 local time",
          NY2017   "New year 2017, 00:00:00 local time",
          NY2018   "New year 2018, 00:00:00 local time",
          NY2019   "New year 2019, 00:00:00 local time",
          NY2020   "New year 2020, 00:00:00 local time")
          "Use this to set the date corresponding to time = 0"
          annotation (Documentation(info="<html>
<p>
Type for choosing how to set the reference time in
<a href=\"modelica://IDEAS.Utilities.Time.CalendarTime\">
IDEAS.Utilities.Time.CalendarTime</a>.
</p>
<p>
For example, <code>IDEAS.Utilities.Time.Types.TimeReference.NY2016</code>
means that if the Modelica built-in variable <code>time=0</code>, it is
January 1, 2016, 0:00:00 local time.
</p>
</html>",         revisions="<html>
<ul>
<li>
September 10, 2016, by Michael Wetter:<br/>
Revised implementation and moved to new package
<a href=\"modelica://IDEAS.Utilities.Time.CalendarTime.Types\">
IDEAS.Utilities.Time.CalendarTime.Types</a>.
</li>
<li>
August 3, 2016, by Filip Jorissen:<br/>
First implementation.
</li>
</ul>
</html>"));
      annotation (preferredView="info", Documentation(info="<html>
This package contains type definitions.
</html>"));
      end Types;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models for time.
</p>
</html>"),
      Icon(graphics={
            Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
              fillColor={215,215,215},
              fillPattern=FillPattern.Solid),
            Line(points={{0,80},{0,60}}, color={160,160,164}),
            Line(points={{80,0},{60,0}}, color={160,160,164}),
            Line(points={{0,-80},{0,-60}}, color={160,160,164}),
            Line(points={{-80,0},{-60,0}}, color={160,160,164}),
            Line(points={{37,70},{26,50}}, color={160,160,164}),
            Line(points={{70,38},{49,26}}, color={160,160,164}),
            Line(points={{71,-37},{52,-27}}, color={160,160,164}),
            Line(points={{39,-70},{29,-51}}, color={160,160,164}),
            Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
            Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
            Line(points={{-71,37},{-54,28}}, color={160,160,164}),
            Line(points={{-38,70},{-28,51}}, color={160,160,164}),
            Line(
              points={{0,0},{-50,50}},
              thickness=0.5),
            Line(
              points={{0,0},{40,0}},
              thickness=0.5)}));
    end Time;
  annotation (
  preferredView="info", Documentation(info="<html>
<p>
This package contains utility models such as for thermal comfort calculation, input/output, co-simulation, psychrometric calculations and various functions that are used throughout the library.
</p>
</html>"),
  Icon(coordinateSystem(extent={{-100.0,-100.0},{100.0,100.0}}), graphics={
      Polygon(
        origin={1.3835,-4.1418},
        rotation=45.0,
        fillColor={64,64,64},
        pattern=LinePattern.None,
        fillPattern=FillPattern.Solid,
        points={{-15.0,93.333},{-15.0,68.333},{0.0,58.333},{15.0,68.333},{15.0,93.333},{20.0,93.333},{25.0,83.333},{25.0,58.333},{10.0,43.333},{10.0,-41.667},{25.0,-56.667},{25.0,-76.667},{10.0,-91.667},{0.0,-91.667},{0.0,-81.667},{5.0,-81.667},{15.0,-71.667},{15.0,-61.667},{5.0,-51.667},{-5.0,-51.667},{-15.0,-61.667},{-15.0,-71.667},{-5.0,-81.667},{0.0,-81.667},{0.0,-91.667},{-10.0,-91.667},{-25.0,-76.667},{-25.0,-56.667},{-10.0,-41.667},{-10.0,43.333},{-25.0,58.333},{-25.0,83.333},{-20.0,93.333}}),
      Polygon(
        origin={10.1018,5.218},
        rotation=-45.0,
        fillColor={255,255,255},
        fillPattern=FillPattern.Solid,
        points={{-15.0,87.273},{15.0,87.273},{20.0,82.273},{20.0,27.273},{10.0,17.273},{10.0,7.273},{20.0,2.273},{20.0,-2.727},{5.0,-2.727},{5.0,-77.727},{10.0,-87.727},{5.0,-112.727},{-5.0,-112.727},{-10.0,-87.727},{-5.0,-77.727},{-5.0,-2.727},{-20.0,-2.727},{-20.0,2.273},{-10.0,7.273},{-10.0,17.273},{-20.0,27.273},{-20.0,82.273}})}));
  end Utilities;

  package Types "Package with type definitions"
    extends Modelica.Icons.TypesPackage;

    package Azimuth "List of possible constant values for surface azimuth"
       extends Modelica.Icons.TypesPackage;

       constant Modelica.SIunits.Angle E = -Modelica.Constants.pi/2
      "Azimuth for an exterior wall whose outer surface faces east";

       constant Modelica.SIunits.Angle N = Modelica.Constants.pi
      "Azimuth for an exterior wall whose outer surface faces north";

       constant Modelica.SIunits.Angle S = 0
      "Azimuth for an exterior wall whose outer surface faces south";

       constant Modelica.SIunits.Angle W = +Modelica.Constants.pi/2
      "Azimuth for an exterior wall whose outer surface faces west";
      annotation(preferredView="info",
    Documentation(info="<html>
<p>
Possible constant values to define the azimuth of a surface.
For example, if an exterior wall is South oriented, i.e., its outside-facing
surface is towards South, use
 <code>IDEAS.Types.Azimuth.S</code>.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end Azimuth;

    package Tilt "List of possible constant values for surface tilt"
      extends Modelica.Icons.TypesPackage;

      constant Modelica.SIunits.Angle Ceiling = 0 "Tilt for ceiling";

      constant Modelica.SIunits.Angle Floor =   Modelica.Constants.pi
      "Tilt for floor";

      constant Modelica.SIunits.Angle Other=10e6 "Dummy tilt for unspecified cases";

      constant Modelica.SIunits.Angle Wall =    Modelica.Constants.pi/2
      "Tilt for wall";
    annotation(preferredView="info", Documentation(info="<html>
<p>
Possible constant values to define the tilt of a surface.
For example, for a construction that is a floor, use
<code>IDEAS.Types.Tilt.Floor</code>.
</p>
<p>
Note that a ceiling has a tilt of <i>0</i>, and also the solar collector models
in
<a href=\"IDEAS.Fluid.SolarCollectors\">IDEAS.Fluid.SolarCollectors</a>
require a tilt of <i>0</i> if they are facing straight upwards.
This is correct because
the solar irradiation on a ceiling construction is on the other-side surface,
which faces upwards toward the sky. Hence, a construction is considered
a ceiling from the view point of a person standing inside a room.
</p>
</html>",
      revisions="<html>
<ul>
<li>
November 30, 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
    end Tilt;

    type Reset = enumeration(
      Disabled   "Disabled",
      Parameter   "Use parameter value",
      Input   "Use input signal")
      "Options for integrator reset"
      annotation (
      Documentation(info="<html>
<p>
Enumeration to define the choice of integrator reset
(to be selected via choices menu):
</p>
<table border=\"1\" summary=\"Explanation of the enumeration\">
<tr>
<th>Enumeration</th>
<th>Description</th></tr>
<tr><td>Disabled</td>
<td>
Use this setting to disable the integrator reset.
</td></tr>
<tr><td>Parameter</td>
<td>
Use this setting to use reset the integrator to the value of the parameter.
</td></tr>
<tr><td>Input</td>
<td>Use this setting to reset the integrator to the value obtained
from the input signal.
</td></tr>
 </table>
</html>",   revisions="<html>
<ul>
<li>
September 29, 2016, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
  annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains type definitions.
</p>
</html>",   revisions="<html>
<ul>
<li>
November 30 2010, by Michael Wetter:<br/>
First implementation.
</li>
</ul>
</html>"));
  end Types;

  package Examples "IDEAS Examples"
  extends Modelica.Icons.ExamplesPackage;

    package TwinHouses
    "Models for validation on Twin house test cases IEA EBC Annex 58"
      extends Modelica.Icons.ExamplesPackage;

      package BaseClasses
        extends Modelica.Icons.BasesPackage;

        package Data
        extends Modelica.Icons.Package;

          package Materials
          extends Modelica.Icons.MaterialPropertiesPackage;

            record Glazing =IDEAS.Buildings.Data.Interfaces.Glazing (
                final nLay=3,
                final mats={IDEAS.Buildings.Data.Materials.Glass(
                                            d=0.004,
                                            epsLw_b=0.837),
                            IDEAS.Buildings.Data.Materials.Argon(
                                            d=0.016),
                            IDEAS.Buildings.Data.Materials.Glass(
                                            d=0.004,
                                            epsLw_b=0.04,
                                            epsLw_a=0.837)},
                final SwTrans=[0, 0.543;
                              10, 0.546;
                              20, 0.538;
                              30, 0.528;
                              40, 0.514;
                              50, 0.486;
                              60, 0.426;
                              70, 0.310;
                              80, 0.145;
                              90, 0.000],
                final SwAbs=[0, 0.107, 0.0, 0.085;
                            10, 0.108, 0.0, 0.087;
                            20, 0.109, 0.0, 0.094;
                            30, 0.112, 0.0, 0.1;
                            40, 0.116, 0.0, 0.102;
                            50, 0.121, 0.0, 0.106;
                            60, 0.126, 0.0, 0.119;
                            70, 0.130, 0.0, 0.127;
                            80, 0.124, 0.0, 0.091;
                            90, 0.000, 0.0, 0.000],
                final SwTransDif=0.427,
                final SwAbsDif={0.118,0.0,0.104},
                final U_value=1.1,
                final g_value=0.525)
              "Glass properties as specified by EN410 spectrum (U = 1.1 W/m2K, g = 0.525)"
              annotation (Documentation(revisions="<html>
<ul>
<li>
September 2, 2015, by Filip Jorissen:<br/>
Moved epsLw definition to solid layer to be consistent 
with changed implementation of MultiLayerLucent.
</li>
</ul>
</html>"));
          end Materials;
        end Data;
      end BaseClasses;
    end TwinHouses;
  end Examples;

  package Experimental "Package with experimental models"
    extends Modelica.Icons.Package;

    package Electric "Electrical in-home and feeder systems"
    import MCM = Modelica.ComplexMath;
    extends Modelica.Icons.Package;

      package BaseClasses
      extends Modelica.Icons.BasesPackage;

        package AC
        extends Modelica.Icons.Package;

          model WattsLawPlug "For use  with loads."
            parameter Integer numPha=1 "Choose the number of phases" annotation (choices(
                  choice=1 "single phase", choice=3 "symmetrical 3 phase"));
            parameter Integer nLoads=1;
            Modelica.Electrical.QuasiStationary.MultiPhase.Interfaces.NegativePlug vi(m=
                  numPha) annotation (Placement(transformation(extent={{90,-10},{110,10}},
                    rotation=0)));
            Modelica.Blocks.Interfaces.RealInput[nLoads] P annotation (Placement(
                  transformation(extent={{-90,20},{-50,60}}),  iconTransformation(extent={{-70,40},
                      {-50,60}})));
            Modelica.Blocks.Interfaces.RealInput[nLoads] Q annotation (Placement(
                  transformation(extent={{-100,-20},{-60,20}}), iconTransformation(extent={{-80,0},
                      {-60,20}})));
            Modelica.Blocks.Math.Sum sum_P(final nin=nLoads)
              annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
            Modelica.Blocks.Math.Sum sum_Q(final nin=nLoads)
              annotation (Placement(transformation(extent={{-40,0},{-20,20}})));
          equation
            for i in 1:numPha loop
              sum_P.y/numPha = Modelica.ComplexMath.real(vi.pin[i].v*
                Modelica.ComplexMath.conj(vi.pin[i].i));
              sum_Q.y/numPha = Modelica.ComplexMath.imag(vi.pin[i].v*
                Modelica.ComplexMath.conj(vi.pin[i].i));
            end for;
            connect(P, sum_P.u) annotation (Line(
                points={{-70,40},{-48,40},{-48,50},{-42,50}},
                color={0,0,127},
                smooth=Smooth.None));
            connect(Q, sum_Q.u) annotation (Line(
                points={{-80,0},{-48,0},{-48,10},{-42,10}},
                color={0,0,127},
                smooth=Smooth.None));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}}),
                             graphics={
                  Ellipse(
                    extent={{-50,50},{50,-50}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(points={{50,0},{90,0}}, color={0,0,0}),
                  Line(
                    points={{0,50},{0,-50}},
                    color={175,175,175},
                    smooth=Smooth.None),
                  Text(
                    extent={{-38,42},{42,-38}},
                    lineColor={0,0,0},
                    fontName="Symbol",
                    textString="W")}),     Diagram(graphics),Documentation(info="<html>
<p>
This model converts the apparent power to a nodal voltage and current. It can be used for single-phase (numPha=1) loads or three-phase (numPha=3) loads (symmetrically divided over all phases)
</p>
</html>",           revisions="<html>
<ul>
<li>
January 22, 2015 by Juan Van Roy:<br/>
Documentation added.
</li>
</ul>
</html>"));
          end WattsLawPlug;
        annotation (Icon(graphics={
                Line(
                  origin={10,20},
                  points = {{-90,-20},{-78.7,14.2},{-71.5,33.1},{-65.1,46.4},{-59.4,54.6},{-53.8,59.1},{-48.2,59.8},{-42.6,56.6},{-36.9,49.7},{-31.3,39.4},{-24.9,24.1},{-16.83,1.2},{0.1,-50.8},{7.3,-70.2},{13.7,-84.2},{19.3,-93.1},{25,-98.4},{30.6,-100},{36.2,-97.6},{41.9,-91.5},{47.5,-81.9},{53.9,-67.2},{62,-44.8},{70,-20}},
                  smooth = Smooth.Bezier)}));
        end AC;
      end BaseClasses;
    end Electric;
    annotation (preferredView="info", Documentation(info="<html>
<p>
This package contains models that are experimental. 
They may be included in the <code>IDEAS</code> library
if they have been shown to be useful.
For example, this package may include new media models
so that numerical benchmarks can be conducted easily in order
to evaluate whether addition of the media is desirable or not.
</p>
<p>
Models in the Electric package have been developed in the past,
but are currently not maintained. 
We welcome contributions that fix broken models and add unit tests.
</p>
</html>"));
  end Experimental;
annotation (
  uses(Modelica(version="3.2.3")),
  Icon(graphics),
  version="2.1.0",
  versionDate="2019-02-28",
  dateModified = "2019-02-28",
  conversion(
 from(version={"0.2"},
      script="modelica://IDEAS/Resources/Scripts/convertIdeas030to100.mos")),
  Documentation(info="<html>
<p>Licensed by KU Leuven and 3E</p>
<p>Copyright &copy; 2013-2023, KU Leuven and 3E. </p>
<p>
This Modelica package is <u>free</u> software and the use is completely at <u>your own risk</u>;
For license information, view our <a href=\"https://github.com/open-ideas/IDEAS\">github page</a>.
</p>
</html>"));
end IDEAS;

package INFRAX

  model Main
    inner IDEAS.BoundaryConditions.SimInfoManager sim
      "Model that handles time and weather data"
      annotation (Placement(transformation(extent={{-100,80},{-80,100}})));

     replaceable SubSystems.BuildingEnvelope.Envelope buiEnv(T_start=295.65)
      "Envelope of the building"
      annotation (Placement(transformation(extent={{-50,56},{-8,86}})));

    replaceable SubSystems.HeatingSystem.HeatingSystem heaSys
      "Heating system of the building"
      annotation (Placement(transformation(extent={{18,14},{60,40}})));
    replaceable SubSystems.Controllers.RBCbaseline buiCon "Building controller"
      annotation (Placement(transformation(extent={{-40,20},{-20,40}})));
    replaceable SubSystems.VentilationSystem.VentilationSystem venSys
      "Ventilation system of the building"
      annotation (Placement(transformation(extent={{60,68},{98,88}})));
    replaceable SubSystems.Occupancy.OccupantwithCalendar buiOcc(
      nLoads=0,
      profileType={9,0,8,0,0,7,7,6,6,0,5,5,5,4,4,0,0,0,0,1,2,3,0,0,0,0,0},
      nZones=27,
      startDay=2,
      filenameTables=Modelica.Utilities.Files.loadResource(
      "modelica://INFRAX/SubSystems//Occupancy/Data/Tables/TablesOccupancyInfraxBaseline.txt"))
      "Occupancy model of the building"
      annotation (Placement(transformation(extent={{20,-22},{60,-2}})));
    replaceable SubSystems.Occupancy.Appliances buiApp
      "Model computing internal gains from appliances"
      annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
    Modelica.Blocks.Sources.RealExpression fanToi(y=if ((clock.hour >= 5 and
          clock.hour < 20) and (clock.weekDay) < 6) or buiCon.nightVent.NightVentilation
           == true then 200 else 0) "setpoit for toilet fans"
      annotation (Placement(transformation(extent={{-94,30},{-72,50}})));
    SubSystems.Controllers.Components.Clock
                               clock
      annotation (Placement(transformation(extent={{-100,0},{-80,20}})));
protected
    Modelica.Thermal.HeatTransfer.Sources.FixedTemperature[27] preTem(each T=297.15)
      "Prescribed temperature, needed by the occupancy model" annotation (
        Placement(transformation(
          extent={{-10,-10},{10,10}},
          rotation=90,
          origin={-2,-64})));
  equation
    connect(buiCon.signalBus, heaSys.signalBus) annotation (Line(
        points={{-20,30},{-2,30},{-2,27},{18,27}},
        color={255,204,51},
        thickness=0.5));
    connect(heaSys.dataBus, buiCon.dataBus) annotation (Line(
        points={{18,29.7625},{2,29.7625},{2,46},{-52,46},{-52,30},{-40,30}},
        color={255,204,51},
        thickness=0.5));
    connect(buiEnv.dataBus, buiCon.dataBus) annotation (Line(
        points={{-44,71},{-58,71},{-58,70},{-58,30},{-40,30}},
        color={255,204,51},
        thickness=0.5));
    connect(heaSys.port_emb, buiEnv.cca)    annotation (Line(points={{47.4,40},{47.4,71},{-8,71}}, color={191,0,0}));
    connect(heaSys.dataBus, buiEnv.dataBus) annotation (Line(
        points={{18,29.7625},{10,29.7625},{10,32},{2,32},{2,46},{-52,46},{-52,71},
            {-44,71}},
        color={255,204,51},
        thickness=0.5));
    connect(heaSys.HeaCoi_b, venSys.HeaCoi_b) annotation (Line(points={{52,40},{52,
            40},{52,60},{92,60},{92,68}}, color={0,127,255}));
    connect(heaSys.HeaCoi_a, venSys.HeaCoi_a) annotation (Line(points={{50,40},{50,
            40},{50,62},{96,62},{96,68}}, color={0,127,255}));
    connect(venSys.AHUHeaCoi_b, heaSys.AHUHeaCoi_b)    annotation (Line(points={{60,74},{56,74},{56,40}}, color={0,127,255}));
    connect(heaSys.AHUHeaCoi_a, venSys.AHUHeaCoi_a) annotation (Line(points={{54,40},
            {54,40},{54,70},{54,72},{60,72}}, color={0,127,255}));
    connect(heaSys.AHUCooCoi_a, venSys.AHUCooCoi_a)    annotation (Line(points={{38,40},{38,68.4},{60,68.4}}, color={0,127,255}));
    connect(heaSys.AHUCooCoi_b, venSys.AHUCooCoi_b) annotation (Line(points={{40,40},
            {40,40},{40,70},{40,70.4},{60,70.4}}, color={0,127,255}));
    connect(venSys.dataBus, buiCon.dataBus) annotation (Line(
        points={{60,79.4},{32,79.4},{32,80},{6,80},{6,90},{-60,90},{-60,24},{-40,24},
            {-40,30}},
        color={255,204,51},
        thickness=0.5));
    connect(venSys.signalBus, buiCon.signalBus) annotation (Line(
        points={{60,76},{2,76},{2,24},{-20,24},{-20,30}},
        color={255,204,51},
        thickness=0.5));
    connect(buiEnv.airInlet, venSys.airSupply) annotation (Line(points={{-8,83},{-8,
            83},{-8,98},{-8,100},{95.6,100},{95.6,88}}, color={0,127,255}));
    connect(buiEnv.airOutlet, venSys.airReturn) annotation (Line(points={{-8,77},{
            24,77},{24,96},{91.6,96},{91.6,88}}, color={0,127,255}));
    connect(buiOcc.nOcc, buiEnv.nOcc) annotation (Line(points={{34.4,-1},{34.4,8},
            {-17,8},{-17,56}}, color={0,0,127}));
    connect(preTem.port, buiOcc.heatPortRad) annotation (Line(points={{-2,-54},{-2,
            -54},{-2,-14},{20,-14}}, color={191,0,0}));
    connect(preTem.port, buiOcc.heatPortCon) annotation (Line(points={{-2,-54},{-2,
            -54},{-2,-10},{20,-10}}, color={191,0,0}));
    connect(fanToi.y, buiEnv.dp_toilet) annotation (Line(points={{-70.9,40},{-64,40},
            {-64,59},{-53,59}}, color={0,0,127}));
    connect(buiOcc.nOcc, buiApp.nOcc) annotation (Line(points={{34.4,-1},{34.4,8},
            {-47,8},{-47,0}}, color={0,0,127}));
    connect(buiApp.conv, buiEnv.conv) annotation (Line(points={{-40,-8},{-4,-8},{-4,
            65},{-8,65}}, color={191,0,0}));
    connect(buiApp.rad, buiEnv.rad) annotation (Line(points={{-40,-12},{-4,-12},{-4,
            59},{-8,59}}, color={191,0,0}));
     annotation (
      Icon(coordinateSystem(preserveAspectRatio=false)),
      Diagram(coordinateSystem(preserveAspectRatio=false)),
      experiment(
        StopTime=3.1536e+007,
        __Dymola_NumberOfIntervals=15000,
        Tolerance=1e-006,
        __Dymola_fixedstepsize=20,
        __Dymola_Algorithm="Euler"),
      __Dymola_experimentSetupOutput(events=false),
      __Dymola_experimentFlags(
        Advanced(
          GenerateVariableDependencies=false,
          OutputModelicaCode=true,
          InlineMethod=0,
          InlineOrder=2,
          InlineFixedStep=0.001),
        Evaluate=true,
        OutputCPUtime=true,
        OutputFlatModelica=true));
  end Main;

  model IBPSA_BOPTEST
    extends Main(redeclare SubSystems.VentilationSystem.VentilationSystemSim
        venSys, redeclare SubSystems.BuildingEnvelope.EnvelopeSim buiEnv);
    annotation (
      experiment(
        StartTime=1262304000,
        StopTime=1293840000,
        Interval=1800,
        Tolerance=1e-06,
        __Dymola_fixedstepsize=15,
        __Dymola_Algorithm="Euler"),
      __Dymola_experimentSetupOutput(events=false),
      __Dymola_experimentFlags(
        Advanced(
          EvaluateAlsoTop=true,
          GenerateVariableDependencies=false,
          OutputModelicaCode=true,
          InlineMethod=0,
          InlineOrder=2,
          InlineFixedStep=0.001),
        Evaluate=true,
        OutputCPUtime=true,
        OutputFlatModelica=false),
      Documentation(info="<html>
General model description.
<h3>Building Design and Use</h3>
<h4>Architecture</h4>
<p>
The Infrax building is a 2232 m&sup2; conditioned space four-story office building 
located in Dilbeek, Brussels, Belgium. This office building contains open-plan offices, cellular 
offices and meeting rooms. The building envelope model is composed of 27 zones, of which 
21 are conditioned. The 1<sup>st</sup>, 2<sup>nd</sup> and 3<sup>rd</sup> floors are mainly 
open offices and separate zones exist for the north and south spaces, the individual meeting 
rooms and the bathrooms (which are not conditioned). The ground floor includes individual 
conference rooms and several facilities (first aid room, canteen, storage and server rooms).
The zoning strategy of the building is done according to the air distribution design of the building 
and it can be seen in the plan below. 
</p>
<p>
The access to the building is through the ground floor hall. 
The main activity of the ground floor occurs in the two big conference rooms and the 
canteen, which have a better fine-tuning control with dedicated VAV boxes. Most of the 
other spaces in the ground floor are normally empty. Two rooms are lumped together 
within the storage room. The server room has a dedicated cooling server unit which is 
not modeled as in reality it is not being used.
<br />
Within the first floor, there is an empty glazing space from where the ground floor 
can be observed.
The first floor north zone is lumping three small individual offices which share 
the same ventilation duct, therefore it is not possible to individually control them.
<br />
The second floor and third floors are smaller.  
Access to the outside is possible in the second floor through the roof on the first floor.
In the third floor, a small storage room is lumped into the individual small room and the 
two rooms which include the copy machines are also lumped.
</p>
<p align=\"center\">
<img  alt=\"image\" src=\"modelica://INFRAX/Resources/svg/building_architecture.png\" border=\"1\"/>
</p>
<h4>Constructions</h4>
<p>
The U-values for the outer walls and roof are between 0.18-0.25 and 0.14-0.15 W/(m&sup2;.K) 
respectively. The windows have double glazing with a U-value of 1.0 W/(m&sup2;.K) and 
g-values between 0.45-0.49. The air-tightness of the building is measured with a n<sub>50</sub> 
value of 1.3 ACH. 
<ul>
<li>
Outer walls: 2.2cm Fiberboard + 18cm Glasswool + 20cm Sandstone + 1.5cm Gypsum
</li>
<li>
Roof: 6cm Grind + 16cm PIR + 27-33cm Concrete (depending on side) + 1cm Gypsum
</li>
<li>
Roof 1st floor: 2cm Perliet + 14cm PIR + 37cm Concrete + 1cm Gypsum
</li>
<li>
Floor ground floor: 2cm Woodwool + 8cm PIR + 32cm Holed Concrete + 5cm Screed + 55cm Air + 3.8cm Silicate + 1.2cm Tile
</li>
<li>
Floor other floors: 37cm Concrete + 45cm Air + 3cm Board
</li>
<li>
Slab on basement: 35cm Concrete + 10cm Screed
</li>
</ul>
</p>
<h4>Occupancy schedules</h4>
<p>
The occupancy schedules are calculated based on historical CO<sub>2</sub> data.
The source tables include the number of occupants per hour for one complete week, 
then the table is repeated indefinitely. 
The source tables differentiate between the canteen, the ground floor conference rooms,
the meeting rooms at the different floors and the open-space offices.
The model also includes a holiday schedule for which there is no occupants.  
The model assumes a constant-segment interpolation between the different hourly 
occupancy values.
</p>
<h4>Internal loads and schedules</h4>
<p>
Based on the number of occupants described before, the IDEAS zone model can compute 
their heat gains radiative-convective contribution depending on the activity performed 
(office work in this case). The model can also compute the amount of CO<sub>2</sub> 
exhaled by each occupant to the zone air model.
</p>
<p>
The model uses the lighting feature integrated within the IDEAS zone model.
Based on the room type lighting requirements and the luminous efficacy, 
the lighting internal gains are computed and distributed between radiative and convective heat. 
Zone lighting is assumed to be on whenever there is at least one occupant within the zone.
</p>
<p>
The model also includes a appliances sub-component, based on ASHRAE appliances data 
(see tables in Chapter 29: Residential Cooling and Heating Load Calculations -- 
Appliances Section of ASHRAE Fundamentals Handbook).
The appliances are all assumed to have a 30%-70% radiative-convective heating load split.
The appliances include monitors, laptops, copy machines, printers, coffee machines, water coolers 
and several microwaves and soup heaters in the canteen.
For the computer appliances at the office zones, they are assummed to be on/idle depending 
on the current number of occupants of the zone.
</p>
<h4>Climate data</h4>
<p>
Climate data corresponds to a TMY file measured in Uccle, Belgium. 
</p>
<h3>HVAC System Design</h3>
<h4>Primary and secondary system designs</h4>
<p>
The supply heating system is composed of 2 ground source heat pumps.
The source-side of the heat pumps is connected to an array of vertical ground heat exchangers. 
The sink-side of the heat pumps is connected to a water storage tank and to the manifold, 
from where heat is distributed to multiple emission loops. 
Cooling is provided by means of two heat exchangers connected to the vertical ground heat exchanger 
array and to a cooling tower. 
</p>
<p>
The emission system of the building is hybrid, with TABS as the slow-reacting system which 
provides the main load. To provide a fast-reacting peak load, the system relies on conditioning the 
air from the air handling unit (AHU). 
<br />
The AHU takes and conditions the air from outside and distributes it to the different building zones 
through the ventilation ducts. Within the ducts there exist VAV boxes and small re-heating coils for 
the fine-tuning of the building. Nevertheless, not all zone ducts are equipped with the VAV boxes.
</p>
<p>
From the heating manifold, the building can supply heat to the TABS and the heating coils located 
within the AHU and the ventilation ducts. The manifold is also connected to the cooling tower in case 
heat needs to be dissipated.
<br />
The two cooling heat exchangers can remove heat from the TABS and the AHU respectively.
One of the two cooling heat exchangers is also connected to a server cooling unit, but 
this feature is not modeled since it is offline in the building.
</p>
<p align=\"center\">
<img  alt=\"image\" src=\"modelica://INFRAX/Resources/svg/hydraulic.png\" border=\"1\"/>
</p>
<h4>Equipment specifications and performance maps</h4>
<p>
The ground source heat pumps correspond to the brand DYNACIAT model 200LG/LGP of 70 kW<sub>th</sub> each 
and a nominal COP of 5.4.
The heat pump works with refrigerant R410A.
Each heat pump has a two-stage compressor that allows to modulate the system capacity.
On the sink side, the system media is water, while in the source side a 30% proylene glycol-water mixture is used.
</p>
<p>
The ground heat exchanger is composed of an array of 37 vertical boreholes with double-U configuration.
The ground composition is mainly sandstone with an average conductivity of 1.4 W/(m.K). 
</p>
<p>
Concrete core activation (CCA) pipes of TABS are made of PEX 20x2.3 mm and they are placed 6 cm from the ceiling surface.
</p>
<p>
The volume of the storage tank is 2.5 m&sup3;
</p>
<p>
The cooling tower is a Balticare model VFL 242-HX whose capacity is 150 kW<sub>th</sub> and a variable-speed fan.
</p>
<p>
The AHU is a centralized double flux mechanical ventilation unit with heat recovery and free cooling bypass.
The AHU fans are controlled by providing a prescribed pressure difference between the inlet and the outlet of the unit.
The nominal supply air flow is 10000 m&sup3;/h while the nominal extract air flow is 8850 m&sup3;/h. An air flow of 1150 m&sup3;/h 
is evacuated through the toilet extraction system.
It is important to note that the heat recovery unit is placed between the heating coil (inlet) and the cooling coil (outlet).
</p>
<p>
The nominal powers of the different heat exchangers are: 
<ul>
<li>
TABS passive cooling exchanger: 90 kW<sub>th</sub>.
</li>
<li>
Air cooling exchanger (includes server units): 106 kW<sub>th</sub>.
</li>
<li>
AHU cooling coil: 59.3 kW<sub>th</sub>.
</li>
<li>
AHU heating coil: 34 kW<sub>th</sub>.
</li>
<li>
Ventilation ducts heating coils (sum): 45.4 kW<sub>th</sub>.
</li>
<li>
Cooling tower dissipation exchanger: 150 kW<sub>th</sub>.
</li>
</ul>
</p>
<p>
The circulation pumps correspond to the WILO brand. The models are as follow:
<ul>
<li>
P1/P2 Borefield pumps: IP-E 50/150-4/2 | 38 m&sup3;/h nominal flow | speed controlled
</li>
<li>
P3 Heat pump condenser pump: Stratos 65/1-12 CAN PN 6/10 | 24 m&sup3;/h nominal flow | pressure difference controlled
</li>
<li>
P4 Air+server cooling pump: Stratos 80/1-12 CAN PN 6 | 28.3 m&sup3;/h nominal flow | on/off controlled
</li>
<li>
P5 TABS cooling pump: Stratos 65/1-12 CAN PN 6/10 | 21 m&sup3;/h nominal flow | speed controlled
</li>
<li>
P6 Ventilation duct heating coils pump: Stratos 40/1-12 CAN PN 6/10 | 9.8 m&sup3;/h nominal flow | on/off controlled
</li>
<li>
P7 TABS pump: IP-E 40/130-2,2/2 | 19.4 m&sup3;/h nominal flow | on/off controlled
</li>
<li>
P8 AHU secondary heating coil pump: Stratos 30/1-12 CAN PN 10 | 7.3 m&sup3;/h nominal flow | on/off controlled
</li>
<li>
P9 AHU primary heating coil pump: IP-E 32/160-1,1/2 | 7.95 m&sup3;/h nominal flow | on/off controlled
</li>
<li>
P10 Cooling tower heating pump: Stratos 65/1-12 CAN PN 6/10 | 24 m&sup3;/h nominal flow | on/off controlled
</li>
<li>
P11 Cooling tower cooling pump: Stratos 80/1-12 CAN PN 6 | 30 m&sup3;/h nominal flow | on/off controlled
</li>
<li>
P13 AHU cooling coil pump: IP-E 40/120-1,5/2 | 17 m&sup3;/h nominal flow | pressure drop controlled
</li>
<li>
P12/P14 Server unit cooling pump (not modelled): IP-E 32/160-1,1/2 | 5.73 m&sup3;/h nominal flow
</li>
</ul>
</p>
<p>
The air distribution ducts can be observed in the building schematic. The nominal air flows per zone are as follow:
<br /><br />
Floor 0:
<ul>
<li>
Hall: CAV | Supply 600 m&sup3;/h / Extract 250 m&sup3;/h
</li>
<li>
Server local room: CAV | Supply 100 m&sup3;/h / Extract 100 m&sup3;/h
</li>
<li>
First aid room: CAV | Supply 50 m&sup3;/h / Extract 50 m&sup3;/h
</li>
<li>
Canteen: VAV | Supply Min/Max 200/3200 m&sup3;/h / Extract Min/Max 0/3000 m&sup3;/h
</li>
<li>
Conference room 1: VAV | Supply Min/Max 0/1600 m&sup3;/h / Extract Min/Max 0/1600 m&sup3;/h
</li>
<li>
Conference room 2: VAV | Supply Min/Max 0/900 m&sup3;/h / Extract Min/Max 0/900 m&sup3;/h
</li>
<li>
Storage room: CAV | Extract 250 m&sup3;/h
</li>
<li>
Western stair block: CAV | Supply 90 m&sup3;/h / Extract 90 m&sup3;/h
</li>
<li>
Eastern stair block: CAV | Supply 70 m&sup3;/h / Extract 70 m&sup3;/h
</li>
<li>
Toilet: CAV | Extract 300 m&sup3;/h
</li>
</ul>
<br />
Floor 1:
<br />
<ul>
<li>
North zone: VAV | Supply Min/Max 0/550 m&sup3;/h / Extract Min/Max 0/550 m&sup3;/h
</li>
<li>
South zone 1: VAV | Supply Min/Max 0/400 m&sup3;/h 
</li>
<li>
South zone 2: VAV | Supply Min/Max 650/800 m&sup3;/h / Extract Min/Max 300/800 m&sup3;/h
</li>
<li>
Meeting room 1: VAV | Supply Min/Max 0/300 m&sup3;/h / Extract Min/Max 0/300 m&sup3;/h
</li>
<li>
Meeting room 2: VAV | Supply Min/Max 0/300 m&sup3;/h / Extract Min/Max 0/300 m&sup3;/h
</li>
<li>
Storage room: CAV | Extract 50 m&sup3;/h
</li>
<li>
Toilet: CAV | Extract 350 m&sup3;/h
</li>
</ul>
<br />
Floor 2:
<br />
<ul>
<li>
North zone: VAV | Supply Min/Max 0/350 m&sup3;/h / Extract Min/Max 0/350 m&sup3;/h
</li>
<li>
South zone: VAV | Supply Min/Max 550/1400 m&sup3;/h / Extract Min/Max 300/1150 m&sup3;/h
</li>
<li>
Meeting room 1: VAV | Supply Min/Max 0/300 m&sup3;/h / Extract Min/Max 0/300 m&sup3;/h
</li>
<li>
Meeting room 2: VAV | Supply Min/Max 0/300 m&sup3;/h / Extract Min/Max 0/300 m&sup3;/h
</li>
<li>
Toilet: CAV | Extract 250 m&sup3;/h
</li>
</ul>
<br />
Floor 3:
<br />
<ul>
<li>
South zone: VAV | Supply Min/Max 650/1600 m&sup3;/h / Extract Min/Max 0/950 m&sup3;/h
</li>
<li>
Copy machine room: VAV | Supply Min/Max 0/300 m&sup3;/h / Extract Min/Max 0/300 m&sup3;/h + 200 m&sup3;/h CAV
</li>
<li>
Meeting room: CAV | Supply 150 m&sup3;/h / Extract 150 m&sup3;/h
</li>
<li>
Individual small office room: VAV | Supply Min/Max 0/300 m&sup3;/h / Extract Min/Max 0/300 m&sup3;/h + 200 m&sup3;/h CAV
</li>
<li>
Toilet: CAV | Extract 250 m&sup3;/h
</li>
</ul>
</p>
<h4>Rule-based or local-loop controllers (if included)</h4>
<p>
The building control of the office establishes an independent work schedule between the TABS primary system and 
the fast-reacting secondary system. Whereas the TABS system works according to the building climate mode, the 
secondary system is dominated by the individual demand of each zone. A base set-point for the building is calculated 
as the average of the comfort bounds determined by the RMOT. The comfort bounds also include a night set-back of 5 K.
</p>
<p>
The building can operate in 3 different climate modes: heating, cooling or neutral. Climate mode switch evaluation occurs 
once per day at 18h00. A switch would be effective based on the RMOT at that time. If the RMOT is higher/lower than a 
established transition temperature, the building will switch its mode.
<br />
Climate Mode switching can occur between Heating-Neutral and Cooling-Neutral modes, but NOT between Heating-Cooling modes 
(dead-band principle). In order to switch between Heating-Cooling, the building must spend at least one day in the Neutral mode.
<br />
Climate mode determines the TABS control behavior 
<p>
</p>
During heating mode, water supply temperature is computed following a heating curve based on a 3-point RMOT and achieved 
through mixing with a 3-way valve controlled by a PI-controller. For each floor, TABS mass flow rate is regulated with a two-way 
valve controlled by a PI-controller as a function of the TABS temperature difference set-point in the floor. The TABS temperature 
difference set-point in the floor is computed from the temperature difference between the base set-point and the current floor average.
<br />
During cooling mode, water supply temperature is also calculated from a cooling corve based on a 3-point RMOT. 
However, this temperature is achieved by modulating pump P05 in the passive cooling heat exchanger. The water supply temperature set-point 
is subjected to a compensation factor and ceiling condensing protection afterwards. The mass flow rate control is analog to the heating mode.
<br />
In neutral mode, the TABS loop is continuously working in closed-loop and the two-way valves are 20% opened.
</p>
<p>
The building secondary system is air-based and it is dependent on the individual demands of each zone. 
The ventilation system is working on weekdays from 7h00 to 18h00, with a flush feature from 6h00 to 7h00, i.e. ventilation is 
working at 100% for that hour.
<br />
The AHU fans work to keep a constant pressure difference between its inlet and outlet pressure. 
The AHU supply air temperature set-point is computed based on the instant outdoor temperature 
to provide a temperature between 16-19 degC. The air can be by-passed from the heat recovery if the temperature difference 
between the supply and the extract is not harnessable.  
<br />
When the difference between the measured and the desired temperature of an individual zone is too low (hysteresis), the 
heat coils within the duct system will act to heat the supply air. Each heat coil is regulated with an individual 3-way valve 
controlled with a PI-controller based on the supply air temperature set-point, which is limited to 24 degC
<br />
Several zones are equipped with VAV boxes. These VAV boxes will regulate the air mass flow rate supplied to the zone based on 
the heating/cooling and ventilation needs.
Concerning the heating/cooling needs, the VAV will be more or less opened based on the temperature difference between the zone and its 
set-point. A PI-controller controls the VAV damper opening.
Similarly, regarding the ventilation needs, the VAV will be more or less opened based on the CO<sub>2</sub> concentration of the zone. 
A PI-controller tracks a CO<sub>2</sub> concentration set-point of 850ppm.
The maximum of the two set-points is used in the VAV box.
</p>
<p>
The cooling tower is connected to the manifold through a heat exchanger and the tower only works to dissipate heat in some scenarios. 
These scenarios include an excessive water storage temperature (due to active cooling), an excessive borefield temperature, or the 
possibility to harness the ambient air temperature.
The cooling tower works with a PI-controller to keep its outlet temperature at 29 degC.
</p>
<p>
Under adequate circumstances, the building can activate night ventilation during hot summer days and automated shading for the 
west, east and south facade to avoid overheating of the building.
</p>
<h3>Model IO's</h3>
<h4>Inputs</h4>
The model inputs are:
<ul>
<li>
<code>Input1</code> [UNIT1]: 
</li>
</ul>
<h4>Outputs</h4>
The model outputs are:
<ul>
<li>
<code>Output1</code> [UNIT1]: 
</li>
<li>
<code>Output2</code> [UNIT2]: 
</li>
</ul>
<h3>Additional System Design</h3>
<h4>Lighting</h4>
<p>
Despite lighting internal heat gains are modeled, the model has not controllable lighting inputs.
</p>
<h4>Shading</h4>
<p>
The building can control solar gains by means of movvable horizontal 
fin shading on the 3<sup>rd</sup> and 2<sup>nd</sup> floors. 
<br/>
Fixed horizontal fin shading combined with overhangs is installed 
on the 1<sup>st</sup> and ground floors.
</p>
<h4>Onsite Generation and Storage</h4>
<p>
No onsite generation and storage is modeled in this building, 
despite 61 PV-panels of 136 W<sub>p</sub> are installed and 
connected to the grid.
</p>
<h3>Model Implementation Details</h3>
<h4>Moist vs. dry air</h4>
<p>
The model uses the IDEAS water package, for which moisture and CO<sub>2</sub> concentration can be computed.
</p>
<h4>Pressure-flow models</h4>
<p>
This model uses the pressure-flow models included in the IBPSA/IDEAS library (FlowControlled_dp and FlowControlled_y). Pressure drops are defined.
</p>
<h4>Infiltration models</h4>
<p>
As the building is composed of open space offices, inter-zone air flow is modelled by connecting the interacting zones with energy and mass balance equations.
This assumption is done based on the fact that the building works with forced ventilation.
For each set of inter-connected zones, there has to be one zone with a fixed air volume determined by a prescribed pressure.
The other zones air leakage is modeled by means of the n<sub>50</sub> factor.
(see IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure and IDEAS.Buildings.Components.InterzonalAirFlow.n50Tight).
</p>
<h3>Scenario Information</h3>
<h4>Energy Pricing</h4>
<p>
…
</p>
<h4>Emission Factors</h4>
<p>
…
</p>
</html>"));
  end IBPSA_BOPTEST;

  package SubSystems

    package BuildingEnvelope

      model Envelope "Envelope of INFRAX"

        replaceable package Medium = IDEAS.Media.Air(extraPropertiesNames={"CO2"}) constrainedby
        Modelica.Media.Interfaces.PartialMedium;
        outer IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Floor,
              0},{IDEAS.Types.Tilt.Ceiling,0},{IDEAS.Types.Tilt.Wall,0},{IDEAS.Types.Tilt.Wall,
              INFRAX.Data.Orientations.E},{IDEAS.Types.Tilt.Wall,INFRAX.Data.Orientations.W},
              {IDEAS.Types.Tilt.Wall,INFRAX.Data.Orientations.N}})
        "Data reader, includes all the orientations in the building"
          annotation (Placement(transformation(extent={{-140,80},{-120,100}})));

        INFRAX.Data.Parameters.Structure structure
        "Record with general data from the building"
          annotation (Placement(transformation(extent={{120,-100},{140,-80}})));
        INFRAX.Data.Parameters.Str3rdFlr str3rdFlr
        "Record with 3rd floor data"
          annotation (Placement(transformation(extent={{120,-60},{140,-40}})));
        INFRAX.Data.Parameters.Str2ndFlr str2ndFlr
        "Record with 2nd floor data"
          annotation (Placement(transformation(extent={{120,-80},{140,-60}})));
        INFRAX.Data.Parameters.Str1stFlr str1stFlr
        "Record with 1st floor data"
          annotation (Placement(transformation(extent={{98,-80},{118,-60}})));
        INFRAX.Data.Parameters.StrGndFlr strGndFlr
        "Record with ground floor data"
          annotation (Placement(transformation(extent={{98,-100},{118,-80}})));
        IDEAS.Buildings.Components.Zone westStairs(
          nSurf=17,
          V=structure.Vol_westStair,
          hZone=structure.h,
          n50=1.3,
           redeclare replaceable IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
            interzonalAirFlow,
          redeclare package Medium = Medium,
          mSenFac=mSenFac,
          T_start=T_start,
          redeclare IDEAS.Buildings.Components.RoomType.Generic rooTyp,
          redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased ligCtr,
          redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp)
        "Western stairs block"
          annotation (Placement(transformation(extent={{-80,34},{-60,54}})));

        IDEAS.Buildings.Components.OuterWall westStairs_OW(
          azi=INFRAX.Data.Orientations.N,
          inc=IDEAS.Types.Tilt.Wall,
          redeclare INFRAX.Data.Constructions.OuterWalls constructionType,
          A=structure.h*4.85 - structure.AWindows_westStair,
          T_start=T_start)
         "North wall of western stairs"
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=-90,
              origin={-70,88})));
        IDEAS.Buildings.Components.Window windowStaW(
          inc=IDEAS.Types.Tilt.Wall,
          azi=INFRAX.Data.Orientations.N,
          frac=1 - structure.GlazingD/structure.WindowD,
          redeclare IDEAS.Buildings.Components.Shading.None shaType,
          redeclare INFRAX.Data.Frames.INFRAXWood fraType,
          A=structure.AWindows_westStair,
          redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
          T_start=T_start)
         "Windows from western stairs"
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=-90,
              origin={-90,88})));
        IDEAS.Buildings.Components.Zone eastStairs(
          nSurf=14,
          V=structure.Vol_eastStair,
          hZone=structure.h,
          n50=1.3,
           redeclare replaceable IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
            interzonalAirFlow,
          redeclare package Medium = Medium,
          mSenFac=mSenFac,
          T_start=T_start,
          redeclare IDEAS.Buildings.Components.RoomType.Generic rooTyp,
          redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased ligCtr,
          redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp)
          "Eastern stairs block"
         annotation (Placement(transformation(extent={{60,34},{80,54}})));

        IDEAS.Buildings.Components.OuterWall[2] eastStairs_OW(
          each inc=IDEAS.Types.Tilt.Wall,
          azi={INFRAX.Data.Orientations.N,INFRAX.Data.Orientations.E},
          redeclare INFRAX.Data.Constructions.OuterWalls constructionType,
          A=structure.h*{2.55,5} - {structure.AWindows_eastStair,0},
          T_start=T_start)
         "Array of outer walls for eastern stairs"
         annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=-90,
              origin={90,88})));
        IDEAS.Buildings.Components.Window windowStaE(
          inc=IDEAS.Types.Tilt.Wall,
          azi=INFRAX.Data.Orientations.N,
          redeclare IDEAS.Buildings.Components.Shading.None shaType,
          redeclare INFRAX.Data.Frames.INFRAXWood fraType,
          A=structure.AWindows_eastStair,
          redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
          T_start=T_start)
        "Windows from eastern stairs"
         annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=-90,
              origin={70,88})));
        replaceable INFRAX.SubSystems.BuildingEnvelope.Floor3.Floor3 floor3(energyDynamicsAir=energyDynamicsAir, redeclare
          package Medium =
                     Medium,
          mSenFac=mSenFac,
          allowFlowReversal=allowFlowReversal,
          T_start=T_start)
        "Third floor component"
          annotation (Placement(transformation(extent={{-12,50},{16,70}})));
        replaceable INFRAX.SubSystems.BuildingEnvelope.Floor2.Floor2 floor2(energyDynamicsAir=energyDynamicsAir, redeclare
          package Medium =
                     Medium,
          mSenFac=mSenFac,
          allowFlowReversal=allowFlowReversal,
          T_start=T_start)
        "Second floor component"
          annotation (Placement(transformation(extent={{-12,8},{16,28}})));
       replaceable INFRAX.SubSystems.BuildingEnvelope.Floor1.Floor1 floor1(energyDynamicsAir=energyDynamicsAir, redeclare
          package Medium =
                     Medium,
          mSenFac=mSenFac,
          allowFlowReversal=allowFlowReversal,
          T_start=T_start)
        "First floor component"
          annotation (Placement(transformation(extent={{-12,-38},{16,-18}})));
        replaceable INFRAX.SubSystems.BuildingEnvelope.Floor0.Floor0 floor0(energyDynamicsAir=energyDynamicsAir, redeclare
          package Medium =
                     Medium,
          mSenFac=mSenFac,
          allowFlowReversal=allowFlowReversal,
          T_start=T_start)
        "Ground floor component"
          annotation (Placement(transformation(extent={{-12,-74},{16,-54}})));
        IDEAS.Buildings.Components.InternalWall[8] floor_0_garage(
          redeclare INFRAX.Data.Constructions.Floor constructionType,
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=strGndFlr.Areas_GndFlr,
          T_start=T_start)
        "Floor wall between ground floor and garage/parking"
         annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-84})));
        IDEAS.Buildings.Components.Zone basement(
          V=structure.HeightFlr*structure.A_Grg,
          hZone=structure.HeightFlr,
          nSurf=14,
          n50=1.3,
          redeclare replaceable IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
          interzonalAirFlow,
          redeclare package Medium = Medium,
          mSenFac=mSenFac,
          T_start=T_start)
        "Parking/garage of INFRAX"
          annotation (Placement(transformation(extent={{-40,-92},{-20,-72}})));
        IDEAS.Buildings.Components.SlabOnGround slabOnGround(redeclare
            INFRAX.Data.Constructions.Slab constructionType,
            A=structure.A_Grg,
            T_start=T_start)
          "Concrete slab on the ground of the infrastructure"
          annotation (Placement(transformation(extent={{-60,-98},{-48,-78}})));
        IDEAS.Buildings.Components.BoundaryWall boundaryWall(
          inc=IDEAS.Types.Tilt.Wall,
          azi=0,
          use_T_in=true,
          redeclare INFRAX.Data.Constructions.GarageWall constructionType,
          A=structure.AWall_Grg_Soil,
          T_start=T_start)
          "Wall of the parking/garage in contact with the soil"
          annotation (Placement(transformation(extent={{-58,-70},{-46,-50}})));
        Modelica.Blocks.Sources.Constant soiltemp(k=273.15 + 10.8)
        "Constant temperature of soil for the boundary wall in contact with the garage"
         annotation (Placement(transformation(extent={{-100,-68},{-86,-54}})));
        IDEAS.Buildings.Components.InternalWall eastStairs_garage(
          redeclare INFRAX.Data.Constructions.Floor constructionType,
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_eastStair,
          T_start=T_start)
        "Floor wall between garage and eastern stairs"
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={94,22})));
        IDEAS.Buildings.Components.InternalWall westStairs_garage(
          redeclare INFRAX.Data.Constructions.Floor constructionType,
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_westStair,
          T_start=T_start)
        "Floor wall between garage and western stairs"
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={-102,26})));
        IDEAS.Buildings.Components.OuterWall roof_westStairs(
          redeclare INFRAX.Data.Constructions.Roof constructionType,
          inc=IDEAS.Types.Tilt.Ceiling,
          azi=0,
          A=structure.A_westStair,
          T_start=T_start)
        "Roof of western stairs"
         annotation (Placement(
              transformation(
              extent={{-6,-10},{6,10}},
              rotation=-90,
              origin={-106,64})));
        IDEAS.Buildings.Components.OuterWall roof_eastStairs(
          redeclare INFRAX.Data.Constructions.Roof constructionType,
          inc=IDEAS.Types.Tilt.Ceiling,
          azi=0,
          A=structure.A_eastStair,
          T_start=T_start)
        "Roof of east stairs"
         annotation (Placement(
              transformation(
              extent={{-6,-10},{6,10}},
              rotation=-90,
              origin={100,60})));
        IDEAS.Buildings.Components.InternalWall Floor_0_2(
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_hall_2SZ,
          T_start=T_start)
        "Floor between ground floor and second floor (glass hollow)"
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={-34,-16})));
        IDEAS.Buildings.Components.Window[2] brandkoepels(
          redeclare IDEAS.Buildings.Components.Shading.None shaType,
          inc=IDEAS.Types.Tilt.Ceiling,
          azi=0,
          frac=0,
          A=structure.A_stairs_koepel,
          redeclare IDEAS.Buildings.Data.Frames.None fraType,
          T_start=T_start,
          redeclare IDEAS.Examples.TwinHouses.BaseClasses.Data.Materials.Glazing
            glazing) "domes from stairs (cupulas)" annotation (Placement(
              transformation(
              extent={{-6,-10},{6,10}},
              rotation=-90,
              origin={0,88})));
        IDEAS.Buildings.Components.OuterWall[2] Grg_OuterWalls(
          redeclare INFRAX.Data.Constructions.GarageWallWithIns constructionType,
          inc={IDEAS.Types.Tilt.Wall,IDEAS.Types.Tilt.Ceiling},
          azi={INFRAX.Data.Orientations.W,0},
          A={structure.AWall_Grg_Out,structure.A_Grg_OutRoof},
          T_start=T_start)
          "Garage outer walls, on west and roof side"
          annotation (Placement(transformation(extent={{-90,-96},{-78,-76}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[35] cca
        "Embedded heat port for CCA"
          annotation (Placement(transformation(extent={{130,-10},{150,10}})));
        INFRAX.SubSystems.Controllers.DataBus dataBus
        "Data bus containing information of sensors"
          annotation (Placement(transformation(extent={{-160,-20},{-120,
                  20}}),
              iconTransformation(extent={{-110,-10},{-90,10}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[27] conv
        "Heat port for convective heat transfer"
          annotation (Placement(transformation(extent={{130,-50},{150,-30}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[27] rad
        "Heat port for radiative heat transfer"
          annotation (Placement(transformation(extent={{130,-90},{150,-70}})));
        parameter Modelica.Fluid.Types.Dynamics energyDynamicsTABS=Modelica.Fluid.Types.Dynamics.FixedInitial
          "Type of energy balance for air model: dynamic (3 initialization options) or steady state";
        parameter Modelica.Fluid.Types.Dynamics energyDynamicsAir=Modelica.Fluid.Types.Dynamics.FixedInitial
          "Type of energy balance for air model: dynamic (3 initialization options) or steady state";
        parameter Boolean allowFlowReversal = true
          "= false to simplify equations, assuming, but not enforcing, no flow reversal"
          annotation(Dialog(tab="Assumptions"), Evaluate=true);
        parameter Modelica.SIunits.Area[15] ATabs0 = {Floor_0_1_1.A, Floor_0_1_2.A,
        Floor_0_1_3.A, Floor_0_1_4.A, Floor_0_1_5.A, Floor_0_1_6.A, Floor_0_1_7.A,
        Floor_0_1_8.A, Floor_0_1_9.A, Floor_0_1_10.A, Floor_0_1_11.A, Floor_0_1_12.A,
        Floor_0_1_13.A, Floor_0_1_14.A, Floor_0_1_15.A}
        "TABS areas for ground floor";
        parameter Modelica.SIunits.Area[4] ATabs3 = floor3.ATabs;
        parameter Modelica.SIunits.Area[7] ATabs2 = {Floor_2_3_1.A, Floor_2_3_2.A,
        Floor_2_3_3.A, Floor_2_3_4.A, Floor_2_3_6.A, Floor_2_3_7.A, Floor_2_3_8.A}
        "TABS areas for second floor";
        parameter Modelica.SIunits.Area[9] ATabs1 = {Floor_1_2_1.A, Floor_1_2_2.A,
        Floor_1_2_3.A, Floor_1_2_4.A, Floor_1_2_5.A, Floor_1_2_7.A, Floor_0_2.A,
        floor1.roof1stFlr[1].A,floor1.roof1stFlr[2].A}
        "TABS areas for first floor";
        Modelica.Fluid.Interfaces.FluidPort_b[21] airOutlet(
           each m_flow(max=if allowFlowReversal then Modelica.Constants.inf else 0),
           redeclare package Medium = Medium)
        "Air outlet port of all the zones"
          annotation (Placement(transformation(extent={{130,30},{150,50}})));
        Modelica.Fluid.Interfaces.FluidPort_a[21] airInlet(
           each m_flow(min=if allowFlowReversal then -Modelica.Constants.inf else 0),
           redeclare package Medium = Medium)
        "Air inlet port of all the zones"
          annotation (Placement(transformation(extent={{130,70},{150,90}})));
      //Floor walls between different floors, they had to be split and not in an
      //array due to MPC compilation problems with JModelica
        IDEAS.Buildings.Components.InternalWall Floor_2_3_1(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_2Flr_3Flr[1],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)        annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,38})));
        IDEAS.Buildings.Components.InternalWall Floor_2_3_2(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_2Flr_3Flr[2],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)         annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,38})));
        IDEAS.Buildings.Components.InternalWall Floor_2_3_3(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_2Flr_3Flr[3],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)         annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,38})));
        IDEAS.Buildings.Components.InternalWall Floor_2_3_4(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_2Flr_3Flr[4],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)         annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,38})));
        IDEAS.Buildings.Components.InternalWall Floor_2_3_5(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_2Flr_3Flr[5],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)         annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,38})));
        IDEAS.Buildings.Components.InternalWall Floor_2_3_6(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_2Flr_3Flr[6],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)         annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,38})));
        IDEAS.Buildings.Components.InternalWall Floor_2_3_7(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_2Flr_3Flr[7],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)         annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,38})));
        IDEAS.Buildings.Components.InternalWall Floor_2_3_8(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_2Flr_3Flr[8],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)         annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,38})));
            IDEAS.Buildings.Components.InternalWall Floor_0_1_1(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[1],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_2(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[2],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_3(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[3],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_4(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[4],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_5(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[5],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_6(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[6],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_7(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[7],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_8(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[8],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_9(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[9],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_10(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[10],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_11(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[11],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_12(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[12],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_13(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[13],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_14(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[14],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_0_1_15(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[15],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
         IDEAS.Buildings.Components.InternalWall Floor_0_1_16(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          A=structure.A_GndFlr_1stFlr[16],
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-46})));
        IDEAS.Buildings.Components.InternalWall Floor_1_2_1(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_1Flr_2Flr[1],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-4})));
        IDEAS.Buildings.Components.InternalWall Floor_1_2_2(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_1Flr_2Flr[2],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-4})));
        IDEAS.Buildings.Components.InternalWall Floor_1_2_3(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_1Flr_2Flr[3],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-4})));
        IDEAS.Buildings.Components.InternalWall Floor_1_2_4(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_1Flr_2Flr[4],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-4})));
        IDEAS.Buildings.Components.InternalWall Floor_1_2_5(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_1Flr_2Flr[5],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-4})));
        IDEAS.Buildings.Components.InternalWall Floor_1_2_6(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_1Flr_2Flr[6],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-4})));
        IDEAS.Buildings.Components.InternalWall Floor_1_2_7(
          inc=IDEAS.Types.Tilt.Floor,
          azi=0,
          A=structure.A_1Flr_2Flr[7],
          redeclare INFRAX.Data.Constructions.InnerFloor constructionType,
          energyDynamics=energyDynamicsTABS,
          T_start=T_start)
          annotation (Placement(transformation(
              extent={{-6,-10},{6,10}},
              rotation=90,
              origin={4,-4})));
        parameter Real mSenFac=5
          "Correction factor for thermal capacity of zone air.";
        replaceable IDEAS.Fluid.Movers.FlowControlled_dp   toiletExtract(
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          addPowerToMedium=false,
          use_inputFilter=false,
          allowFlowReversal=false,
          tau=60,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          dp_start=180,
          m_flow_nominal=1150*1.225/3600,
          dp_nominal(displayUnit="Pa") = 225,
          redeclare package Medium = Medium,
          constantHead=225,
          inputType=IDEAS.Fluid.Types.InputType.Continuous)
        "Extraction fan unit for the toilets"
          annotation (Placement(transformation(
              extent={{-6,6},{6,-6}},
              rotation=180,
              origin={-92,-28})));
        IDEAS.Fluid.Sources.Boundary_pT bouAmb(nPorts=1, redeclare package
          Medium =
              Medium)
        "Boundary with ambient air conditions"
          annotation (Placement(transformation(extent={{-138,-36},{-122,-20}})));
        Modelica.Blocks.Interfaces.RealInput[27] nOcc
        "Occupant number input for different zones"
          annotation (Placement(
              transformation(
              extent={{-20,-20},{20,20}},
              rotation=90,
              origin={80,-100})));
        parameter Modelica.Media.Interfaces.Types.Temperature T_start=293.15
          "Start value of temperature";
        Modelica.Blocks.Interfaces.RealInput dp_toilet
         "Input pressure drop signal for the extracting fan unit of toilets"
          annotation (Placement(transformation(extent={{-180,-100},{-140,-60}})));
      equation
      //Stairs connections
          //Connection to outer walls and windows
        connect(westStairs.propsBus[1],westStairs_OW. propsBus_a) annotation (Line(
            points={{-80,49.8824},{-84,49.8824},{-84,70},{-68,70},{-68,83}},
            color={255,204,51},
            thickness=0.5));
        connect(westStairs.propsBus[2], windowStaW.propsBus_a) annotation (Line(
            points={{-80,49.6471},{-84,49.6471},{-84,70},{-88,70},{-88,83}},
            color={255,204,51},
            thickness=0.5));
        connect(eastStairs.propsBus[1], eastStairs_OW[1].propsBus_a) annotation (Line(
            points={{60,49.8571},{60,49.8571},{60,74},{92,74},{92,83}},
            color={255,204,51},
            thickness=0.5));
        connect(eastStairs.propsBus[2], eastStairs_OW[2].propsBus_a) annotation (Line(
            points={{60,49.5714},{60,49.5714},{60,74},{92,74},{92,83}},
            color={255,204,51},
            thickness=0.5));
        connect(eastStairs.propsBus[3], windowStaE.propsBus_a) annotation (Line(
            points={{60,49.2857},{60,49.2857},{60,83},{72,83}},
            color={255,204,51},
            thickness=0.5));
          //Connection to floors
              //Floor 3
        connect(floor3.staW[1], westStairs.propsBus[3]) annotation (Line(
            points={{-12,61.7333},{-46,61.7333},{-46,62},{-80,62},{-80,49.4118}},
            color={255,204,51},
            thickness=0.5));
        connect(floor3.staW[2], westStairs.propsBus[4]);
        connect(floor3.staW[3], westStairs.propsBus[5]);
        connect(floor3.staE[1], eastStairs.propsBus[4]) annotation (Line(
            points={{17,60},{38,60},{38,49},{60,49}},
            color={255,204,51},
            thickness=0.5));
        connect(floor3.staE[2], eastStairs.propsBus[5]);
              //Floor 2
        connect(floor2.staW[1], westStairs.propsBus[6]) annotation (Line(
            points={{-12,19.7333},{-24,19.7333},{-24,20},{-40,20},{-80,20},{-80,
                48.7059}},
            color={255,204,51},
            thickness=0.5));
        connect(floor2.staW[2], westStairs.propsBus[7]);
        connect(floor2.staW[3], westStairs.propsBus[8]);
        connect(floor2.staE[1], eastStairs.propsBus[6]) annotation (Line(
            points={{17,18},{22,18},{30,18},{30,48.4286},{60,48.4286}},
            color={255,204,51},
            thickness=0.5));
        connect(floor2.staE[2], eastStairs.propsBus[7]);
              //Floor 1
        connect(floor1.staW[1], westStairs.propsBus[9]) annotation (Line(
            points={{-12,-26.2667},{-46,-26.2667},{-46,-26},{-80,-26},{-80,48}},
            color={255,204,51},
            thickness=0.5));
        connect(floor1.staW[2], westStairs.propsBus[10]);
        connect(floor1.staW[3], westStairs.propsBus[11]);
        connect(floor1.staE[1], eastStairs.propsBus[8]) annotation (Line(
            points={{17,-28},{17,-28},{60,-28},{60,47.8571}},
            color={255,204,51},
            thickness=0.5));
        connect(floor1.staE[2], eastStairs.propsBus[9]);
               //Floor 0
        connect(floor0.staW[1], westStairs.propsBus[12]) annotation (Line(
            points={{-12,-62.2667},{-12,-40.8},{-80,-40.8},{-80,47.2941}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.staW[2], westStairs.propsBus[13]);
        connect(floor0.staW[3], westStairs.propsBus[14]);
        connect(floor0.staE[1], eastStairs.propsBus[10]) annotation (Line(
            points={{17,-64},{17,-62},{60,-62},{60,47.2857}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.staE[2], eastStairs.propsBus[11]);
        //Roofs and floors of different stages
        //Floor 3 to 2
        connect(floor3.flo[1], Floor_2_3_1.propsBus_a) annotation (Line(
            points={{2,48.25},{2,48.25},{2,43}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_2_3_1.propsBus_b, floor2.cei[1]) annotation (Line(
            points={{2,33},{2,29.75}},
            color={255,204,51},
            thickness=0.5));
        connect(floor3.flo[2], Floor_2_3_2.propsBus_a) annotation (Line(
            points={{2,48.75},{2,48.75},{2,43}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_2_3_2.propsBus_b, floor2.cei[2]) annotation (Line(
            points={{2,33},{2,29.25}},
            color={255,204,51},
            thickness=0.5));
        connect(floor3.flo[3], Floor_2_3_3.propsBus_a) annotation (Line(
            points={{2,49.25},{2,49.25},{2,43}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_2_3_3.propsBus_b, floor2.cei[3]) annotation (Line(
            points={{2,33},{2,28.75}},
            color={255,204,51},
            thickness=0.5));
        connect(floor3.flo[4], Floor_2_3_4.propsBus_a) annotation (Line(
            points={{2,49.75},{2,49.75},{2,43}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_2_3_4.propsBus_b, floor2.cei[4]) annotation (Line(
            points={{2,33},{2,28.25}},
            color={255,204,51},
            thickness=0.5));
        connect(floor3.flo[5], Floor_2_3_5.propsBus_a) annotation (Line(
            points={{2,50.25},{2,50.25},{2,43}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_2_3_5.propsBus_b, floor2.cei[5]) annotation (Line(
            points={{2,33},{2,27.75}},
            color={255,204,51},
            thickness=0.5));
        connect(floor3.flo[6], Floor_2_3_6.propsBus_a) annotation (Line(
            points={{2,50.75},{2,50.75},{2,43}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_2_3_6.propsBus_b, floor2.cei[6]) annotation (Line(
            points={{2,33},{2,27.25}},
            color={255,204,51},
            thickness=0.5));
        connect(floor3.flo[7], Floor_2_3_7.propsBus_a) annotation (Line(
            points={{2,51.25},{2,51.25},{2,43}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_2_3_7.propsBus_b, floor2.cei[7]) annotation (Line(
            points={{2,33},{2,26.75}},
            color={255,204,51},
            thickness=0.5));
        connect(floor3.flo[8], Floor_2_3_8.propsBus_a) annotation (Line(
            points={{2,51.75},{2,51.75},{2,43}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_2_3_8.propsBus_b, floor2.cei[8]) annotation (Line(
            points={{2,33},{2,26.25}},
            color={255,204,51},
            thickness=0.5));
        //Floor 2 to 1
        connect(floor1.cei[1], Floor_1_2_1.propsBus_b) annotation (Line(
            points={{2,-16.2857},{2,-9}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_1_2_1.propsBus_a, floor2.flo[1]) annotation (Line(
            points={{2,1},{2,6.28571}},
            color={255,204,51},
            thickness=0.5));
        connect(floor1.cei[2], Floor_1_2_2.propsBus_b) annotation (Line(
            points={{2,-16.8571},{2,-9}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_1_2_2.propsBus_a, floor2.flo[2]) annotation (Line(
            points={{2,1},{2,6.85714}},
            color={255,204,51},
            thickness=0.5));
        connect(floor1.cei[3], Floor_1_2_3.propsBus_b) annotation (Line(
            points={{2,-17.4286},{2,-9}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_1_2_3.propsBus_a, floor2.flo[3]) annotation (Line(
            points={{2,1},{2,7.42857}},
            color={255,204,51},
            thickness=0.5));
        connect(floor1.cei[4], Floor_1_2_4.propsBus_b) annotation (Line(
            points={{2,-18},{2,-9}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_1_2_4.propsBus_a, floor2.flo[4]) annotation (Line(
            points={{2,1},{2,4.5},{2,8}},
            color={255,204,51},
            thickness=0.5));
        connect(floor1.cei[5], Floor_1_2_5.propsBus_b) annotation (Line(
            points={{2,-18.5714},{2,-9}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_1_2_5.propsBus_a, floor2.flo[5]) annotation (Line(
            points={{2,1},{2,8.57143}},
            color={255,204,51},
            thickness=0.5));
        connect(floor1.cei[6], Floor_1_2_6.propsBus_b) annotation (Line(
            points={{2,-19.1429},{2,-9}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_1_2_6.propsBus_a, floor2.flo[6]) annotation (Line(
            points={{2,1},{2,9.14286}},
            color={255,204,51},
            thickness=0.5));
        connect(floor1.cei[7], Floor_1_2_7.propsBus_b) annotation (Line(
            points={{2,-19.7143},{2,-9}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_1_2_7.propsBus_a, floor2.flo[7]) annotation (Line(
            points={{2,1},{2,9.71429}},
            color={255,204,51},
            thickness=0.5));
        //Floor 1 to 0
        connect(floor0.cei[1], Floor_0_1_1.propsBus_b) annotation (Line(
            points={{2,-52.125},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_1.propsBus_a, floor1.flo[1]) annotation (Line(
            points={{2,-41},{2,-39.875}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[2], Floor_0_1_2.propsBus_b) annotation (Line(
            points={{2,-52.375},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_2.propsBus_a, floor1.flo[2]) annotation (Line(
            points={{2,-41},{2,-39.625}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[3], Floor_0_1_3.propsBus_b) annotation (Line(
            points={{2,-52.625},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_3.propsBus_a, floor1.flo[3]) annotation (Line(
            points={{2,-41},{2,-39.375}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[4], Floor_0_1_4.propsBus_b) annotation (Line(
            points={{2,-52.875},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_4.propsBus_a, floor1.flo[4]) annotation (Line(
            points={{2,-41},{2,-39.125}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[5], Floor_0_1_5.propsBus_b) annotation (Line(
            points={{2,-53.125},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_5.propsBus_a, floor1.flo[5]) annotation (Line(
            points={{2,-41},{2,-38.875}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[6], Floor_0_1_6.propsBus_b) annotation (Line(
            points={{2,-53.375},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_6.propsBus_a, floor1.flo[6]) annotation (Line(
            points={{2,-41},{2,-38.625}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[7], Floor_0_1_7.propsBus_b) annotation (Line(
            points={{2,-53.625},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_7.propsBus_a, floor1.flo[7]) annotation (Line(
            points={{2,-41},{2,-38.375}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[8], Floor_0_1_8.propsBus_b) annotation (Line(
            points={{2,-53.875},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_8.propsBus_a, floor1.flo[8]) annotation (Line(
            points={{2,-41},{2,-38.125}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[9], Floor_0_1_9.propsBus_b) annotation (Line(
            points={{2,-54.125},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_9.propsBus_a, floor1.flo[9]) annotation (Line(
            points={{2,-41},{2,-37.875}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[10], Floor_0_1_10.propsBus_b) annotation (Line(
            points={{2,-54.375},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_10.propsBus_a, floor1.flo[10]) annotation (Line(
            points={{2,-41},{2,-37.625}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[11], Floor_0_1_11.propsBus_b) annotation (Line(
            points={{2,-54.625},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_11.propsBus_a, floor1.flo[11]) annotation (Line(
            points={{2,-41},{2,-37.375}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[12], Floor_0_1_12.propsBus_b) annotation (Line(
            points={{2,-54.875},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_12.propsBus_a, floor1.flo[12]) annotation (Line(
            points={{2,-41},{2,-37.125}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[13], Floor_0_1_13.propsBus_b) annotation (Line(
            points={{2,-55.125},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_13.propsBus_a, floor1.flo[13]) annotation (Line(
            points={{2,-41},{2,-36.875}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[14], Floor_0_1_14.propsBus_b) annotation (Line(
            points={{2,-55.375},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_14.propsBus_a, floor1.flo[14]) annotation (Line(
            points={{2,-41},{2,-36.625}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[15], Floor_0_1_15.propsBus_b) annotation (Line(
            points={{2,-55.625},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_15.propsBus_a, floor1.flo[15]) annotation (Line(
            points={{2,-41},{2,-36.375}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.cei[16], Floor_0_1_16.propsBus_b) annotation (Line(
            points={{2,-55.875},{2,-51}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_1_16.propsBus_a, floor1.flo[16]) annotation (Line(
            points={{2,-41},{2,-36.125}},
            color={255,204,51},
            thickness=0.5));
        //Floor 0 to -1 (garage)
        connect(floor_0_garage.propsBus_a, floor0.flo) annotation (Line(
            points={{2,-79},{2,-74}},
            color={255,204,51},
            thickness=0.5));
        connect(floor_0_garage[1].propsBus_b, basement.propsBus[1]) annotation (Line(
            points={{2,-89},{2,-89},{2,-96},{-40,-96},{-40,-76.1429}},
            color={255,204,51},
            thickness=0.5));
        connect(basement.propsBus[2], floor_0_garage[2].propsBus_b);
        connect(basement.propsBus[3], floor_0_garage[3].propsBus_b);
        connect(basement.propsBus[4], floor_0_garage[4].propsBus_b);
        connect(basement.propsBus[5], floor_0_garage[5].propsBus_b);
        connect(basement.propsBus[6], floor_0_garage[6].propsBus_b);
        connect(basement.propsBus[7], floor_0_garage[7].propsBus_b);
        connect(basement.propsBus[8], floor_0_garage[8].propsBus_b);
        //Floor and walls of garage
        connect(basement.propsBus[9], slabOnGround.propsBus_a) annotation (Line(
            points={{-40,-78.4286},{-44,-78.4286},{-44,-86},{-49,-86}},
            color={255,204,51},
            thickness=0.5));
        connect(basement.propsBus[10], boundaryWall.propsBus_a) annotation (Line(
            points={{-40,-78.7143},{-40,-58},{-47,-58}},
            color={255,204,51},
            thickness=0.5));
        connect(boundaryWall.T, soiltemp.y) annotation (Line(points={{-63,-58},{-68,
                -58},{-68,-61},{-85.3,-61}},
                                   color={0,0,127}));
        connect(westStairs.propsBus[15], roof_westStairs.propsBus_a) annotation (Line(
            points={{-80,46.5882},{-92,46.5882},{-104,46.5882},{-104,59}},
            color={255,204,51},
            thickness=0.5));
        connect(westStairs.propsBus[16], westStairs_garage.propsBus_a) annotation (
            Line(
            points={{-80,46.3529},{-104,46.3529},{-104,31}},
            color={255,204,51},
            thickness=0.5));
        connect(eastStairs.propsBus[12], roof_eastStairs.propsBus_a) annotation (Line(
            points={{60,46.7143},{60,55},{102,55}},
            color={255,204,51},
            thickness=0.5));
        connect(eastStairs.propsBus[13], eastStairs_garage.propsBus_a) annotation (
            Line(
            points={{60,46.4286},{60,46.4286},{60,24},{60,27},{92,27}},
            color={255,204,51},
            thickness=0.5));
        connect(westStairs_garage.propsBus_b, basement.propsBus[11]) annotation (Line(
            points={{-104,21},{-104,-46},{-40,-46},{-40,-79}},
            color={255,204,51},
            thickness=0.5));
        connect(eastStairs_garage.propsBus_b, basement.propsBus[12]) annotation (Line(
            points={{92,17},{60,17},{60,20},{60,-96},{-40,-96},{-40,-79.2857}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.sndcei, Floor_0_2.propsBus_b) annotation (Line(
            points={{-4,-54},{-4,-54},{-36,-54},{-36,-21}},
            color={255,204,51},
            thickness=0.5));
        connect(Floor_0_2.propsBus_a, floor2.gflo) annotation (Line(
            points={{-36,-11},{-36,8},{-2,8}},
            color={255,204,51},
            thickness=0.5));
        connect(floor0.glasswall, floor1.glasswall) annotation (Line(
            points={{-8,-54},{-10,-54},{-10,-38}},
            color={255,204,51},
            thickness=0.5));
        connect(brandkoepels[1].propsBus_a, westStairs.propsBus[17]) annotation (
            Line(
            points={{2,83},{2,76},{-54,76},{-54,62},{-80,62},{-80,46.1176}},
            color={255,204,51},
            thickness=0.5));
        connect(brandkoepels[2].propsBus_a, eastStairs.propsBus[14]) annotation (
            Line(
            points={{2,83},{2,76},{60,76},{60,46.1429}},
            color={255,204,51},
            thickness=0.5));
        connect(Grg_OuterWalls[1].propsBus_a, basement.propsBus[13]) annotation (
            Line(
            points={{-79,-84},{-76,-84},{-76,-76},{-40,-76},{-40,-79.5714}},
            color={255,204,51},
            thickness=0.5));
        connect(Grg_OuterWalls[2].propsBus_a, basement.propsBus[14]) annotation (
            Line(
            points={{-79,-84},{-76,-84},{-76,-76},{-74,-76},{-40,-76},{-40,-79.8571}},
            color={255,204,51},
            thickness=0.5));
        //Connections to CCA
          //3rd floor roof
        connect(floor3.port_emb[1], cca[1]);
        connect(floor3.port_emb[2], cca[2]);
        connect(floor3.port_emb[3], cca[3]);
        connect(floor3.port_emb[4], cca[4]);
          //2nd floor roof
        connect(cca[5], Floor_2_3_1.port_emb[1]);
        connect(cca[6], Floor_2_3_2.port_emb[1]);
        connect(cca[7], Floor_2_3_3.port_emb[1]);
        connect(cca[8], Floor_2_3_4.port_emb[1]);
        connect(cca[9], Floor_2_3_6.port_emb[1]);
        connect(cca[10], Floor_2_3_7.port_emb[1]);
        connect(cca[11], Floor_2_3_8.port_emb[1]);
         //1st floor roof
        connect(cca[12], Floor_1_2_1.port_emb[1]);
        connect(cca[13], Floor_1_2_2.port_emb[1]);
        connect(cca[14], Floor_1_2_3.port_emb[1]);
        connect(cca[15], Floor_1_2_4.port_emb[1]);
        connect(cca[16], Floor_1_2_5.port_emb[1]);
        connect(cca[17], Floor_1_2_7.port_emb[1]);
        connect(cca[18], Floor_0_2.port_emb[1]);
        connect(cca[19], floor1.port_emb[1]);
        connect(cca[20], floor1.port_emb[2]);
         //Gnd floor roof
        connect(cca[21], Floor_0_1_1.port_emb[1]);
        connect(cca[22], Floor_0_1_2.port_emb[1]);
        connect(cca[23], Floor_0_1_3.port_emb[1]);
        connect(cca[24], Floor_0_1_4.port_emb[1]);
        connect(cca[25], Floor_0_1_5.port_emb[1]);
        connect(cca[26], Floor_0_1_6.port_emb[1]);
        connect(cca[27], Floor_0_1_7.port_emb[1]);
        connect(cca[28], Floor_0_1_8.port_emb[1]);
        connect(cca[29], Floor_0_1_9.port_emb[1]);
        connect(cca[30], Floor_0_1_10.port_emb[1]);
        connect(cca[31], Floor_0_1_11.port_emb[1]);
        connect(cca[32], Floor_0_1_12.port_emb[1]);
        connect(cca[33], Floor_0_1_13.port_emb[1]);
        connect(cca[34], Floor_0_1_14.port_emb[1]);
        connect(cca[35], Floor_0_1_15.port_emb[1]);
      //Connections of data bus
        connect(floor3.dataBus, dataBus) annotation (Line(
            points={{-8,60},{-76,60},{-76,0},{-140,0}},
            color={255,204,51},
            thickness=0.5,
            visible=false), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(floor2.dataBus, dataBus) annotation (Line(
            points={{-8,18},{-76,18},{-76,0},{-140,0}},
            color={255,204,51},
            thickness=0.5,
            visible=false), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(floor1.dataBus, dataBus) annotation (Line(
            points={{-8,-28},{-74,-28},{-74,0},{-140,0}},
            color={255,204,51},
            thickness=0.5,
            visible=false), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(floor0.dataBus, dataBus) annotation (Line(
            points={{-8,-64},{-74,-64},{-74,0},{-140,0}},
            color={255,204,51},
            thickness=0.5,
            visible=false), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(westStairs.TSensor, dataBus.TGndFlr_WStairs) annotation (Line(
            points={{-59,46},{-98,46},{-98,42},{-139.9,42},{-139.9,0.1}},
            color={0,0,127},
            visible=false), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(eastStairs.TSensor, dataBus.TGndFlr_EStairs) annotation (Line(
            points={{81,46},{-28,46},{-28,0.1},{-139.9,0.1}},
            color={0,0,127},
            visible=false), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
      //Convective heat port connections
        connect(floor3.gainCon[1], conv[1]);
        connect(floor3.gainCon[2], conv[2]);
        connect(floor3.gainCon[3], conv[3]);
        connect(floor3.gainCon[4], conv[4]);
        connect(floor3.gainCon[5], conv[5]);
        connect(floor2.gainCon[1], conv[6]);
        connect(floor2.gainCon[2], conv[7]);
        connect(floor2.gainCon[3], conv[8]);
        connect(floor2.gainCon[4], conv[9]);
        connect(floor2.gainCon[5], conv[10]);
        connect(floor1.gainCon[1], conv[11]);
        connect(floor1.gainCon[2], conv[12]);
        connect(floor1.gainCon[3], conv[13]);
        connect(floor1.gainCon[4], conv[14]);
        connect(floor1.gainCon[5], conv[15]);
        connect(floor1.gainCon[6], conv[16]);
        connect(floor1.gainCon[7], conv[17]);
        connect(floor0.gainCon[1], conv[18]);
        connect(floor0.gainCon[2], conv[19]);
        connect(floor0.gainCon[3], conv[20]);
        connect(floor0.gainCon[4], conv[21]);
        connect(floor0.gainCon[5], conv[22]);
        connect(floor0.gainCon[6], conv[23]);
        connect(floor0.gainCon[7], conv[24]);
        connect(floor0.gainCon[8], conv[25]);
      //Radiative heat port connections
        connect(floor3.gainRad[1], rad[1]);
        connect(floor3.gainRad[2], rad[2]);
        connect(floor3.gainRad[3], rad[3]);
        connect(floor3.gainRad[4], rad[4]);
        connect(floor3.gainRad[5], rad[5]);
        connect(floor2.gainRad[1], rad[6]);
        connect(floor2.gainRad[2], rad[7]);
        connect(floor2.gainRad[3], rad[8]);
        connect(floor2.gainRad[4], rad[9]);
        connect(floor2.gainRad[5], rad[10]);
        connect(floor1.gainRad[1], rad[11]);
        connect(floor1.gainRad[2], rad[12]);
        connect(floor1.gainRad[3], rad[13]);
        connect(floor1.gainRad[4], rad[14]);
        connect(floor1.gainRad[5], rad[15]);
        connect(floor1.gainRad[6], rad[16]);
        connect(floor1.gainRad[7], rad[17]);
        connect(floor0.gainRad[1], rad[18]);
        connect(floor0.gainRad[2], rad[19]);
        connect(floor0.gainRad[3], rad[20]);
        connect(floor0.gainRad[4], rad[21]);
        connect(floor0.gainRad[5], rad[22]);
        connect(floor0.gainRad[6], rad[23]);
        connect(floor0.gainRad[7], rad[24]);
        connect(floor0.gainRad[8], rad[25]);
        connect(westStairs.gainCon, conv[26]);
        connect(westStairs.gainRad, rad[26]);
        connect(eastStairs.gainCon, conv[27]);
        connect(eastStairs.gainRad, rad[27]);
      //Inlet ventilation air connections
        connect(floor3.airInlet[1], airInlet[1]) annotation (Line(points={{5.6,69.25},
                {6,69.25},{6,78},{140,78},{140,70.4762}}, color={0,127,255},
            visible=false));
        connect(floor3.airInlet[2], airInlet[2]);
        connect(floor3.airInlet[3], airInlet[3]);
        connect(floor3.airInlet[4], airInlet[4]);
        connect(floor2.airInlet[1], airInlet[5]);
        connect(floor2.airInlet[2], airInlet[6]);
        connect(floor2.airInlet[3], airInlet[7]);
        connect(floor2.airInlet[4], airInlet[8]);
        connect(floor1.airInlet[1], airInlet[9]);
        connect(floor1.airInlet[2], airInlet[10]);
        connect(floor1.airInlet[3], airInlet[11]);
        connect(floor1.airInlet[4], airInlet[12]);
        connect(floor1.airInlet[5], airInlet[13]);
        connect(floor0.airInlet[1], airInlet[14]);
        connect(floor0.airInlet[2], airInlet[15]);
        connect(floor0.airInlet[3], airInlet[16]);
        connect(floor0.airInlet[4], airInlet[17]);
        connect(floor0.airInlet[5], airInlet[18]);
        connect(floor0.airInlet[6], airInlet[19]);
      //Outlet ventilation air connections
        connect(floor3.airOutlet[1], airOutlet[1]) annotation (Line(points={{-2.4,
                69.25},{-2,69.25},{-2,76},{-2,74},{130,74},{130,30.4762},{140,30.4762}},
              color={0,127,255},
            visible=false));
        connect(floor3.airOutlet[2], airOutlet[2]);
        connect(floor3.airOutlet[3], airOutlet[3]);
        connect(floor3.airOutlet[4], airOutlet[4]);
        connect(floor2.airOutlet[1], airOutlet[5]);
        connect(floor2.airOutlet[2], airOutlet[6]);
        connect(floor2.airOutlet[3], airOutlet[7]);
        connect(floor2.airOutlet[4], airOutlet[8]);
        connect(floor1.airOutlet[1], airOutlet[9]);
        connect(floor1.airOutlet[2], airOutlet[11]);
        connect(floor1.airOutlet[3], airOutlet[12]);
        connect(floor1.airOutlet[4], airOutlet[13]);
        connect(floor0.airOutlet[1], airOutlet[14]);
        connect(floor0.airOutlet[2], airOutlet[15]);
        connect(floor0.airOutlet[3], airOutlet[16]);
        connect(floor0.airOutlet[4], airOutlet[17]);
        connect(floor0.airOutlet[5], airOutlet[18]);
        connect(floor0.airOutlet[6], airOutlet[19]);
        connect(floor0.airOutlet[7], airOutlet[10]);
      //Air inlet and outlets of stair blocks
        connect(westStairs.port_a, airInlet[20]) annotation (Line(points={{-68,54},{
                -68,54},{-68,76},{140,76},{140,88.5714}}, color={0,127,255},
            visible=false));
        connect(westStairs.port_b, airOutlet[20]) annotation (Line(points={{-72,54},{
                -42,54},{-42,48.5714},{140,48.5714}}, color={0,127,255},
            visible=false));
        connect(eastStairs.port_a, airInlet[21]) annotation (Line(points={{72,54},{72,
                89.5238},{140,89.5238}}, color={0,127,255},
            visible=false));
        connect(eastStairs.port_b, airOutlet[21]) annotation (Line(points={{68,54},{
                68,52},{140,52},{140,49.5238}}, color={0,127,255},
            visible=false));
      //Extraction fan of the toilets
        connect(toiletExtract.port_b, bouAmb.ports[1]) annotation (Line(points={{-98,
                -28},{-98,-28},{-122,-28}}, color={0,127,255}));
        connect(floor3.bathExtract, toiletExtract.port_a) annotation (Line(points={{
                -12,66.6},{-50,66.6},{-50,-28},{-86,-28}}, color={0,127,255}));
        connect(floor2.bathExtract, toiletExtract.port_a) annotation (Line(points={{
                -12,24.8},{-50,24.8},{-50,-28},{-86,-28}}, color={0,127,255}));
        connect(floor1.bathExtract, toiletExtract.port_a) annotation (Line(points={{
                -12,-21.2},{-50,-21.2},{-50,-28},{-86,-28}}, color={0,127,255}));
        connect(floor0.bathExtract, toiletExtract.port_a) annotation (Line(points={{
                -12,-57.2},{-50,-57.2},{-50,-28},{-86,-28}}, color={0,127,255}));
        connect(toiletExtract.dp_in, dp_toilet) annotation (Line(points={{-92,-20.8},
                {-92,-10},{-120,-10},{-120,-80},{-160,-80}}, color={0,0,127}));
      //No of occupant connections
        connect(nOcc[1], floor3.nOcc[1]) annotation (Line(points={{80,-119.259},{80,
                -119.259},{80,-20},{80,0},{40,0},{40,46},{10,46},{10,49}}, color={0,0,
                127}));
        connect(nOcc[3], floor3.nOcc[2]) annotation (Line(points={{80,-116.296},{80,0},
                {40,0},{40,46},{10,46},{10,51}}, color={0,0,127}));
        connect(nOcc[6], floor2.nOcc[1]) annotation (Line(points={{80,-111.852},{80,
                -111.852},{80,-10},{80,0},{20,0},{20,4},{9,4},{9,6.5}}, color={0,0,
                127}));
        connect(nOcc[7], floor2.nOcc[2]) annotation (Line(points={{80,-110.37},{80,
                -110.37},{80,0},{20,0},{20,7.5},{9,7.5}}, color={0,0,127}));
        connect(nOcc[8], floor2.nOcc[3]) annotation (Line(points={{80,-108.889},{80,
                -108.889},{80,0},{20,0},{20,4},{9,4},{9,8.5}}, color={0,0,127}));
        connect(nOcc[9], floor2.nOcc[4]) annotation (Line(points={{80,-107.407},{80,
                -107.407},{80,-2},{80,0},{20,0},{20,4},{9,4},{9,9.5}}, color={0,0,127}));
        connect(nOcc[11], floor1.nOcc[1]) annotation (Line(points={{80,-104.444},{80,
                -39.6},{11,-39.6}}, color={0,0,127}));
        connect(nOcc[12], floor1.nOcc[2]) annotation (Line(points={{80,-102.963},{80,
                -102.963},{80,-42},{11,-42},{11,-38.8}}, color={0,0,127}));
        connect(nOcc[13], floor1.nOcc[3]) annotation (Line(points={{80,-101.481},{80,
                -101.481},{80,-42},{80,-38},{11,-38}}, color={0,0,127}));
        connect(nOcc[14], floor1.nOcc[4]) annotation (Line(points={{80,-100},{80,
                -37.2},{11,-37.2}}, color={0,0,127}));
        connect(nOcc[15], floor1.nOcc[5]) annotation (Line(points={{80,-98.5185},{80,
                -98.5185},{80,-40},{11,-40},{11,-36.4}}, color={0,0,127}));
        connect(nOcc[20], floor0.nOcc[1]) annotation (Line(points={{80,-91.1111},{80,
                -75.3333},{7,-75.3333}}, color={0,0,127}));
        connect(nOcc[21], floor0.nOcc[2]) annotation (Line(points={{80,-89.6296},{80,
                -74},{7,-74}}, color={0,0,127}));
        connect(nOcc[22], floor0.nOcc[3]) annotation (Line(points={{80,-88.1481},{80,
                -72.6667},{7,-72.6667}}, color={0,0,127}));
        connect(westStairs.ppm, dataBus.CO2_GndFlr_WStairs) annotation (Line(points={
                {-59,44},{-54,44},{-54,18},{-139.9,18},{-139.9,0.1}}, color={0,0,127}),
            Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(eastStairs.ppm, dataBus.CO2_GndFlr_EStairs) annotation (Line(points={
                {81,44},{84,44},{84,0.1},{-139.9,0.1}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-140,-100},
                  {140,100}}), graphics={
              Rectangle(
                extent={{-140,100},{140,-100}},
                lineColor={28,108,200},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-100,68},{112,-66}},
                lineColor={28,108,200},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Line(points={{-100,16},{112,16}}, color={28,108,200}),
              Line(points={{-36,16},{-36,-66}}, color={28,108,200}),
              Text(
                extent={{-10,68},{112,42}},
                lineColor={28,108,200},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                textString="i n f r a x",
                fontName="Broadway")}),                                Diagram(
              coordinateSystem(preserveAspectRatio=false, extent={{-140,-100},{140,100}})),
          experiment(
            StopTime=86400,
            __Dymola_NumberOfIntervals=15000,
            Tolerance=1e-006,
            __Dymola_fixedstepsize=30,
            __Dymola_Algorithm="Euler"));
      end Envelope;

      model EnvelopeSim
        extends Envelope(
          redeclare Floor3.Floor3Sim floor3,
          redeclare Floor2.Floor2Sim floor2,
          redeclare Floor1.Floor1Sim floor1,
          redeclare Floor0.Floor0Sim floor0);
      end EnvelopeSim;

      package Floor0

        model Floor0
          extends Floor0_noVent(
            FirstAid(redeclare
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.Fixed ligCtr),
            servers(redeclare replaceable
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.Fixed ligCtr),
            MT2(redeclare replaceable
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow, redeclare IDEAS.Buildings.Components.Occupants.Input
                occNum,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            MT1(redeclare replaceable
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow, redeclare IDEAS.Buildings.Components.Occupants.Input
                occNum,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            hall(redeclare
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.Fixed ligCtr),
            kitchen(redeclare
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow, redeclare IDEAS.Buildings.Components.Occupants.Input
                occNum,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            storage(
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            bathroomZone(
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr));
          parameter Boolean allowFlowReversal = true
            "= false to simplify equations, assuming, but not enforcing, no flow reversal"
            annotation(Dialog(tab="Assumptions"), Evaluate=true);

          Modelica.Fluid.Interfaces.FluidPort_b[7] airOutlet(
            each m_flow(max=if allowFlowReversal then Modelica.Constants.inf else 0),
            redeclare each package Medium = Medium)
           "Air outlet port of the zones"
            annotation (Placement(transformation(extent={{22,90},{42,110}})));
          Modelica.Fluid.Interfaces.FluidPort_a[6] airInlet(
            each m_flow(min=if allowFlowReversal then -Modelica.Constants.inf else 0),
            redeclare each package Medium = Medium)
           "Air outlet port of the zones"
            annotation (Placement(transformation(extent={{102,90},{122,110}})));
          Modelica.Fluid.Interfaces.FluidPort_b bathExtract(redeclare package
            Medium =
                Medium)
           "Extraction port of the toilets"
            annotation (Placement(transformation(extent={{-150,58},{-130,78}})));
          replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface bath_duct
            "Duct of the bathroom extraction (it does not have VAV)"
         annotation (Placement(transformation(
                extent={{-7,-7},{7,7}},
                rotation=180,
                origin={-111,75})));
        equation

          //Air inlet connections
          connect(airInlet[1], servers.port_a) annotation (Line(points={{112,91.6667},{
                  61.6,91.6667},{61.6,68}},
                              color={0,127,255}));
          connect(airInlet[2], FirstAid.port_a) annotation (Line(points={{112,95},{114,
                  95},{114,92},{114,76},{16,76},{16,60},{12,60}},
                                                              color={0,127,255}));
          connect(airInlet[3], kitchen.port_a) annotation (Line(points={{112,98.3333},{
                  112,60},{104,60},{104,20}},
                                      color={0,127,255}));
          connect(airInlet[4], MT2.port_a) annotation (Line(points={{112,101.667},{140,
                  101.667},{140,-100},{-72,-100},{-72,-58},{-87.6,-58}}, color={0,127,255}));
          connect(airInlet[5], MT1.port_a) annotation (Line(points={{112,105},
                  {140,105},{140,-100},{28,-100},{28,-18},{12.4,-18}},     color={0,127,
                  255}));
          connect(airInlet[6], hall.port_a) annotation (Line(points={{112,108.333},{130,
                  108.333},{150,108.333},{150,-100},{-28,-100},{-28,0},{-50.8,0}},
                color={0,127,255}));
          //Air outlet connections
          connect(airOutlet[1], servers.port_b) annotation (Line(points={{32,91.4286},{
                  56.4,91.4286},{56.4,68}},
                                    color={0,127,255}));
          connect(airOutlet[2], FirstAid.port_b) annotation (Line(points={{32,94.2857},
                  {20,94.2857},{8,94.2857},{8,98},{8,60}},
                                                        color={0,127,255}));
          connect(airOutlet[3], kitchen.port_b) annotation (Line(points={{32,97.1429},{
                  32,97.1429},{32,20},{96,20}},
                                           color={0,127,255}));
          connect(airOutlet[4], MT2.port_b) annotation (Line(points={{32,100},
                  {84,100},{140,100},{140,-100},{-68,-100},{-68,-58},{-92.4,-58}},
                color={0,127,255}));
          connect(airOutlet[5], MT1.port_b) annotation (Line(points={{32,102.857},{88,
                  102.857},{142,102.857},{142,-100},{32,-100},{32,-12},{7.6,-12},{7.6,
                  -18}}, color={0,127,255}));
          connect(airOutlet[6], hall.port_b) annotation (Line(points={{32,105.714},{94,
                  105.714},{94,102},{158,102},{158,-100},{-18,-100},{-18,10},{-59.2,10},
                  {-59.2,0}}, color={0,127,255}));
         //Air exchange between zones
          connect(hall.port_b, bathroomZone.port_a) annotation (Line(points={{-59.2,0},{
                  -60,0},{-60,80},{-88,80}}, color={0,127,255}));
          connect(kitchen.port_b, storage.port_a) annotation (Line(points={{96,20},{96,44},
                  {136,44},{136,68},{120,68}}, color={0,127,255}));
          connect(storage.port_b, airOutlet[7]) annotation (Line(points={{116,68},{116,
                  68},{116,86},{116,94},{32,94},{32,108.571}}, color={0,127,255}));
          connect(bathroomZone.port_b, bath_duct.port_a) annotation (Line(points={{-92,
                  80},{-100,80},{-100,75},{-104,75}}, color={0,127,255}));
          connect(bath_duct.port_b, bathExtract) annotation (Line(points={{-118,75},{
                  -130,75},{-130,68},{-140,68}}, color={0,127,255}));
          connect(MT1.ppm, dataBus.CO2_GndFlr_MT1) annotation (Line(points={{23.2,-30},
                  {30,-30},{30,-26},{36,-26},{36,40.1},{-139.9,40.1}}, color={0,0,127}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(MT2.ppm, dataBus.CO2_GndFlr_MT2) annotation (Line(points={{-76.8,-70},
                  {-54,-70},{-54,40.1},{-139.9,40.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(kitchen.ppm, dataBus.CO2_GndFlr_KTR) annotation (Line(points={{122,0},
                  {-78,0},{-78,40.1},{-139.9,40.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
        end Floor0;

        model Floor0Sim
          extends Floor0(redeclare IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent
                                                                           bath_duct(
            allowFlowReversal=false,
            m_flow_nominal=300*1.225/3600,
            redeclare package Medium = Medium,
            from_dp=true,
              dpValve_nominal=50,
              use_inputFilter=false));
          Buildings.Controls.OBC.CDL.Continuous.Sources.Constant cav(k=1)
            annotation (Placement(transformation(extent={{-136,56},{-128,64}})));
        equation
          connect(cav.y, bath_duct.y) annotation (Line(points={{-127.6,60},{-120,60},{
                  -120,58},{-111,58},{-111,66.6}}, color={0,0,127}));
        end Floor0Sim;

        model Floor0_noVent

          replaceable package Medium = IDEAS.Media.Air constrainedby
          Modelica.Media.Interfaces.PartialMedium;
          //CHANGE MEETING ROOM 2 FACES B (WOOD WALL) AND C
          //REARRANGE HALL AND MEETING ROOM1; ENTRANCE AS A PART OF THE HALL
          //MEETINGROOM1 simpleglass, same frame ratio as window1st floor
          //HALL west window same frame ratio as window1st floor

          IDEAS.Buildings.Components.Zone kitchen(
            V=strGndFlr.Vol_GndFlr_KT,
            hZone=strGndFlr.HeightGndFlr,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp,
            T_start=T_start,
            nSurf=12,
            redeclare IDEAS.Buildings.Components.Occupants.Fixed occNum)
           "Kitchen lunch room zone"
            annotation (Placement(transformation(extent={{80,-20},{120,20}})));
          INFRAX.Data.Parameters.StrGndFlr strGndFlr "Record with ground floor data"
            annotation (Placement(transformation(extent={{120,-100},{140,-80}})));
          IDEAS.Buildings.Components.OuterWall[2] KTouterWalls(
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            each inc=IDEAS.Types.Tilt.Wall,
            azi={INFRAX.Data.Orientations.E,INFRAX.Data.Orientations.S},
            A=strGndFlr.AWall_GndFlr_KT,
            T_start=T_start)
            "Kitchen/lunchroom outer walls"
            annotation (Placement(transformation(extent={{100,-46},{88,-26}})));

          outer IDEAS.BoundaryConditions.SimInfoManager sim "Data reader"
            annotation (Placement(transformation(extent={{-140,80},{-120,100}})));
          IDEAS.Buildings.Components.RectangularZoneTemplate MT1(
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            redeclare INFRAX.Data.Constructions.PlasterWall conTypB,
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            redeclare INFRAX.Data.Constructions.PlasterWall conTypA,
            redeclare INFRAX.Data.Constructions.PlasterWall conTypD,
            redeclare INFRAX.Data.Constructions.Roof conTypCei,
            redeclare INFRAX.Data.Constructions.Floor conTypFlo,
            aziA=INFRAX.Data.Orientations.N,
            h=strGndFlr.HeightGndFlr,
            l=strGndFlr.l_GndFlr_MT2,
            w=strGndFlr.w_GndFlr_MT2,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            hasWinC=true,
            redeclare INFRAX.Data.Constructions.GlasswoolWall conTypC,
            A_winC=strGndFlr.AWindows_GndFlr_MT2,
            redeclare INFRAX.Data.Frames.INFRAXWood fraTypC,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            shaTypC(
              controlled=false,
              shaType=IDEAS.Buildings.Components.Shading.Interfaces.ShadingType.OverhangAndHorizontalFins,
              hWin=strGndFlr.WindowGndHeight,
              wWin=2.7 + 1.35,
              wLeft=1.35/2,
              wRight=1.35/2,
              ovDep=5.7,
              ovGap=8.17 - strGndFlr.WindowGndHeight,
              s=0.175,
              w=0.17,
              t=0.032,
              beta=0.5235987755983),
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Fixed occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp,
            redeclare IDEAS.Examples.TwinHouses.BaseClasses.Data.Materials.Glazing
              glazingC)
            "Big meeting room 1, placed on right just when entering the building"
            annotation (Placement(transformation(extent={{-2,-42},{22,-18}})));


          IDEAS.Buildings.Components.Zone hall(
            hZone=strGndFlr.HeightGndFlr,
            V=strGndFlr.Vol_GndFlr_HR,
            A=strGndFlr.A_GndFlr_HR,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            nSurf=22)
            "Entrance hall of the building"
            annotation (Placement(transformation(extent={{-76,-42},{-34,0}})));
          IDEAS.Buildings.Components.RectangularZoneTemplate FirstAid(
            redeclare INFRAX.Data.Constructions.Floor conTypFlo,
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            aziA=INFRAX.Data.Orientations.N,
            h=strGndFlr.HeightGndFlr,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypA,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypB,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypC,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypD,
            redeclare INFRAX.Data.Constructions.Roof conTypCei,
            l=strGndFlr.l_GndFlr_1stAid,
            w=strGndFlr.w_GndFlr_1stAid,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            nSurfExt=1,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start)
            "First aid room"
            annotation (Placement(transformation(extent={{0,40},{20,60}})));
          IDEAS.Buildings.Components.Zone servers(
            V=strGndFlr.Vol_GndFlr_SV,
            hZone=strGndFlr.HeightGndFlr,
            nSurf=9,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start)
            "Room with servers"
            annotation (Placement(transformation(extent={{46,44},{72,68}})));
          IDEAS.Buildings.Components.OuterWall northWall_SV(
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=strGndFlr.AWall_GndFlr_SV,
            T_start=T_start)
            "Outer wall in servers room, facing north"
            annotation (
              Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={30,86})));
          IDEAS.Buildings.Components.InternalWall internalWall_HR_SV(
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=strGndFlr.AinternalWall_HRSV,
            T_start=T_start)
           "Internal wall between hall and server rooms"
            annotation (Placement(
                transformation(
                extent={{-6,-10},{6,10}},
                rotation=90,
                origin={40,28})));
          IDEAS.Buildings.Components.RectangularZoneTemplate bathroomZone(
            aziA=INFRAX.Data.Orientations.N,
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls conTypA,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypB,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypC,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls conTypD,
            redeclare INFRAX.Data.Constructions.Roof conTypCei,
            redeclare INFRAX.Data.Constructions.Floor conTypFlo,
            l=strGndFlr.l_GndFlr_BRZ,
            w=strGndFlr.w_GndFlr_BRZ,
            h=strGndFlr.HeightGndFlr,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start)
          "Bathroom zone, not conditioned with air extraction"
            annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
          IDEAS.Buildings.Components.Zone storage(
            V=strGndFlr.Vol_GndFlr_Sto,
            hZone=strGndFlr.HeightGndFlr,
            nSurf=7,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start)
          "Storage rooms in ground floor"
            annotation (Placement(transformation(extent={{108,48},{128,68}})));
          IDEAS.Buildings.Components.OuterWall northWall_sto(
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=strGndFlr.AWall_GndFlr_Sto,
            T_start=T_start)
          "Outer wall in storage rooms, facing north" annotation (
              Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={90,86})));
          IDEAS.Buildings.Components.InternalWall internalWall_KT_Sto(
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=strGndFlr.AinternalWall_KTSto,
            T_start=T_start)
          "Internal wall between kitchen and storage" annotation (Placement(
                transformation(
                extent={{-6,-10},{6,10}},
                rotation=90,
                origin={102,34})));
          IDEAS.Buildings.Components.InternalWall internalWall_SV_Sto(
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.W,
            A=strGndFlr.AinternalWall_SVSto,
            T_start=T_start)
          "Internal wall between servers and storage" annotation (Placement(
                transformation(
                extent={{-6,-10},{6,10}},
                rotation=0,
                origin={82,60})));
          IDEAS.Buildings.Components.Zone MT2(
            V=strGndFlr.Vol_GndFlr_MT1,
            hZone=strGndFlr.HeightGndFlr,
            nSurf=8,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
          "Smaller meeting room, placed just left of the buildings entrance"
            annotation (Placement(transformation(extent={{-102,-82},{-78,-58}})));
          IDEAS.Buildings.Components.OuterWall[3] outerWall_MT1(
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            each inc=IDEAS.Types.Tilt.Wall,
            A=strGndFlr.AWall_GndFlr_MT1,
            azi={INFRAX.Data.Orientations.E,INFRAX.Data.Orientations.S,INFRAX.Data.Orientations.inc},
            T_start=T_start)
          "Array of outer walls for the big meeting room"
            annotation (Placement(transformation(extent={{-132,-76},{-120,-56}})));
          IDEAS.Buildings.Components.OuterWall outerWall_HR(
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.inc,
            A=strGndFlr.AWalls_GndFlr_HR,
            T_start=T_start)
          "Outer wall of the building hall (on the west side)"
            annotation (Placement(transformation(extent={{-132,-52},{-120,-32}})));
          IDEAS.Buildings.Components.InternalWall internalWall_HR_MT1(
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=strGndFlr.AinternalWall_HRMT1,
            T_start=T_start)
          "Internal wall between hall and the big meeting room" annotation (Placement(
                transformation(
                extent={{-6,-10},{6,10}},
                rotation=90,
                origin={-90,-40})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[8] flo(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
          "Bus to connect the floor zones to the floor-walls in the outer level"
            annotation (Placement(transformation(extent={{-20,-120},{20,-80}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[3] staW(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
          "Bus to connect the floor zones to the western stairs in the outer level"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-140,4})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[2] staE(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
          "Bus to connect the floor zones to the eastern stairs in the outer level"
            annotation (
              Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={140,0})));
          IDEAS.Buildings.Components.InternalWall staW_wallC(
            redeclare INFRAX.Data.Constructions.ConcreteWall constructionType,
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=4.85*strGndFlr.HeightGndFlr,
            T_start=T_start)
         "Southern internal wall towards the west stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=180,
                origin={-132,-20})));
          IDEAS.Buildings.Components.InternalWall staW_wallB(
            redeclare INFRAX.Data.Constructions.ConcreteWall constructionType,
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.E,
            A=4.3*strGndFlr.HeightGndFlr,
            T_start=T_start)
         "Eastern internal wall towards the west stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=180,
                origin={-110,56})));
          IDEAS.Buildings.Components.InternalWall staE_wallD(
            inc=IDEAS.Types.Tilt.Wall,
            A=4.15*strGndFlr.HeightGndFlr,
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            azi=INFRAX.Data.Orientations.W,
            T_start=T_start)
         "Western internal wall towards the east stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{6,-10},{-6,10}},
                rotation=180,
                origin={130,34})));
          IDEAS.Buildings.Components.InternalWall staE_wallC(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=2.7*strGndFlr.HeightGndFlr,
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            T_start=T_start)
         "Southern internal wall towards the east stair zone in the outer level"
             annotation (Placement(
                transformation(
                extent={{6,-10},{-6,10}},
                rotation=180,
                origin={130,-38})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[16] cei(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
          "Bus to connect the floor zones to the ceiling-walls in the outer level"
            annotation (Placement(transformation(extent={{-20,120},{20,80}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus sndcei(each
              numIncAndAziInBus=sim.numIncAndAziInBus)
          "Bus to connect the floor zones to the second floor floor in the outer level
  (hollow of glass)"
            annotation (Placement(transformation(extent={{-80,120},{-40,80}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[4] glasswall(each
              numIncAndAziInBus=sim.numIncAndAziInBus)
          "Bus to connect the hall to the glass walls of the second floor"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=180,
                origin={-100,100})));
          IDEAS.Buildings.Components.Window meetingRoom1Window_west(
              inc=IDEAS.Types.Tilt.Wall,
              redeclare INFRAX.Data.Frames.INFRAXWood fraType,
              redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
              A=strGndFlr.AWindows_GndFlr_MT1[2],
              azi=INFRAX.Data.Orientations.inc,
              redeclare IDEAS.Buildings.Components.Shading.BuildingShade shaType(
              hWin=strGndFlr.WindowHeight,
              L=5.0,
              dh=10.0 - 2.04),
              T_start=T_start)
          "Small meeting room western window"
            annotation (Placement(transformation(extent={{-132,-100},{-120,-80}})));
          IDEAS.Buildings.Components.Window window_KT1(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            A=strGndFlr.AWindows_GndFlr_KT[1],
            frac=strGndFlr.FrameRatio_GndFlr_KT[1],
            azi=INFRAX.Data.Orientations.E,
            redeclare IDEAS.Buildings.Components.Shading.OverhangAndHorizontalFins
              shaType(
              dep=1.80,
              hWin=strGndFlr.WindowGndHeight,
              wWin=2.7 + 1.35,
              wLeft=(2.7 - 1.47)/2,
              wRight=(2.7 - 1.47)/2,
              gap=8.17 - strGndFlr.WindowGndHeight,
              beta=0.5235987755983,
              s=0.175,
              w=0.17,
              t=0.032),
              redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing)
            "Eastern windows in kitchen/lunch room"
            annotation (Placement(transformation(extent={{100,-74},{88,-54}})));
          IDEAS.Buildings.Components.Window window_KT2(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            A=strGndFlr.AWindows_GndFlr_KT[2],
            frac=strGndFlr.FrameRatio_GndFlr_KT[2],
            azi=INFRAX.Data.Orientations.S,
            redeclare IDEAS.Buildings.Components.Shading.OverhangAndHorizontalFins
              shaType(
              dep=5.70,
              hWin=strGndFlr.WindowGndHeight,
              wWin=2.7 + 1.35,
              wLeft=1.35/2,
              wRight=1.35/2,
              gap=8.17 - strGndFlr.WindowGndHeight,
              beta=0.5235987755983,
              s=0.175,
              w=0.17,
              t=0.032),
              redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
              T_start=T_start)
            "Southern windows in kitchen/lunch room"
            annotation (Placement(transformation(extent={{100,-74},{88,-54}})));

          IDEAS.Buildings.Components.Window hallWindows_west(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            A=strGndFlr.AWindows_GndFlr_HR[2],
            azi=INFRAX.Data.Orientations.inc,
            redeclare IDEAS.Buildings.Components.Shading.BuildingShade shaType(
              L=5,
              dh=10 - 2.04,
              hWin=3.18*strGndFlr.WindowGndHeight + strGndFlr.WindowD/strGndFlr.WindowHeight),
              T_start=T_start)
            "Western windows in the hall"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=90,
                origin={-56,-56})));
          INFRAX.SubSystems.Controllers.DataBus dataBus "Bus connecting floor sensors" annotation (Placement(transformation(extent={{-160,20},{-120,
                    60}}),
                iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[8] gainCon
          "Bus to connect convective heat transfer to the zones"
          annotation (Placement(transformation(extent={{130,-60},{150,-40}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[8] gainRad
          "Bus to connect radiative heat transfer to the zones"
           annotation (Placement(transformation(extent={{130,-80},{150,-60}})));
          parameter Modelica.Fluid.Types.Dynamics energyDynamicsAir=Modelica.Fluid.Types.Dynamics.FixedInitial
            "Type of energy balance for air model: dynamic (3 initialization options) or steady state";

          parameter Real mSenFac=5
            "Correction factor for thermal capacity of zone air.";

          Modelica.Blocks.Interfaces.RealInput[3] nOcc
          "Input for number of occupants" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={50,-100})));

          IDEAS.Buildings.Components.Window meetingRoom1Window_east(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare Data.Frames.INFRAXWood fraType,
            redeclare Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            A=strGndFlr.AWindows_GndFlr_MT1[1],
            redeclare IDEAS.Buildings.Components.Shading.OverhangAndHorizontalFins
              shaType(
              wLeft=16.1,
              wRight=0.8 + 5,
              dep=27,
              s=0.175,
              w=0.17,
              t=0.032,
              hWin=5.24 - 0.8,
              wWin=strGndFlr.WindowHeight,
              gap=8.17 - 3.25,
              beta=0.5235987755983),
              azi=INFRAX.Data.Orientations.E,
              T_start=T_start) "Small meeting room eastern window"
             annotation (Placement(transformation(extent={{-118,-100},{-106,-80}})));
          IDEAS.Buildings.Components.Window hallWindows_south(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare Data.Frames.INFRAXWood fraType,
            redeclare Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            A=strGndFlr.AWindows_GndFlr_HR[1],
            azi=INFRAX.Data.Orientations.S,
            redeclare IDEAS.Buildings.Components.Shading.OverhangAndHorizontalFins
              shaType(
              s=0.175,
              w=0.17,
              t=0.032,
              wLeft=1.35/2,
              wRight=1.35/2,
              dep=5.7,
              hWin=strGndFlr.WindowHeight,
              gap=8.17 - strGndFlr.WindowGndHeight,
              wWin=3*2.7,
              beta=0.5235987755983),
              T_start=T_start)
          "Southern windows of the hall zone"
         annotation (
              Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=90,
                origin={-30,-56})));
          parameter Modelica.Media.Interfaces.Types.Temperature T_start=293.15
            "Start value of temperature";
           parameter Real[8] A_Conv = {servers.A, FirstAid.A, kitchen.A, MT2.A, MT1.A,
            hall.A, storage.A, bathroomZone.A} "Convective area of zones";

          IDEAS.Buildings.Components.InternalWall internalWall_HR_MT2(
            redeclare Data.Constructions.SilicateWall constructionType,
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            T_start=T_start,
            A=strGndFlr.AinternalWall_kitchen_hallway,
            hasCavity=true,
            w=2,
            h=strGndFlr.HeightGndFlr)
            "Internwall wall between hall and big meeting room" annotation (Placement(
                transformation(
                extent={{-6,-10},{6,10}},
                rotation=180,
                origin={20,6})));
        equation

          //Kitchen/lunchroom connections
          connect(kitchen.propsBus[1], KTouterWalls[1].propsBus_a) annotation (Line(
              points={{80,11.6667},{70,11.6667},{60,11.6667},{60,-34},{89,-34}},
              color={255,204,51},
              thickness=0.5));
          connect(kitchen.propsBus[2], KTouterWalls[2].propsBus_a);
          connect(kitchen.propsBus[3], window_KT1.propsBus_a) annotation (Line(
              points={{80,10.3333},{70,10.3333},{60,10.3333},{60,-62},{89,-62}},
              color={255,204,51},
              thickness=0.5));
          connect(kitchen.propsBus[4], window_KT2.propsBus_a);
          connect(MT1.proBusB[1], kitchen.propsBus[5]) annotation (Line(
              points={{20.8,-22.8},{40,-22.8},{40,9},{80,9}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWall_KT_Sto.propsBus_b, kitchen.propsBus[6]) annotation (Line(
              points={{100,29},{80,29},{80,8.33333}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWall_HR_MT2.propsBus_b, kitchen.propsBus[12]) annotation (
              Line(
              points={{25,4},{52,4},{52,4.33333},{80,4.33333}},
              color={255,204,51},
              thickness=0.5));
          //Hall connections
          connect(hall.propsBus[1], MT1.proBusA[1]) annotation (Line(
              points={{-76,-8.59091},{-76,-8.59091},{-76,12},{-76,14},{4,14},{4,-19.2},
                  {2.8,-19.2}},
              color={255,204,51},
              thickness=0.5));
          connect(hall.propsBus[2], MT1.proBusD[1]) annotation (Line(
              points={{-76,-8.97273},{-76,-8.97273},{-76,14},{-4,14},{-4,-38.4},{-1.52,
                  -38.4}},
              color={255,204,51},
              thickness=0.5));
          connect(FirstAid.proBusC[1], hall.propsBus[3]) annotation (Line(
              points={{16.8,40.2},{16.8,28},{-76,28},{-76,-9.35455}},
              color={255,204,51},
              thickness=0.5));
          connect(FirstAid.proBusD[1], hall.propsBus[4]) annotation (Line(
              points={{0.4,43},{-38,43},{-76,43},{-76,-9.73636}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWall_HR_SV.propsBus_b, hall.propsBus[5]) annotation (Line(
              points={{38,23},{-20,23},{-20,22},{-76,22},{-76,-10.1182}},
              color={255,204,51},
              thickness=0.5));
          connect(bathroomZone.proBusC[1], hall.propsBus[6]) annotation (Line(
              points={{-83.2,60.2},{-83.2,60.2},{-83.2,-12},{-76,-12},{-76,-10.5}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWall_HR_MT1.propsBus_a, hall.propsBus[7]) annotation (Line(
              points={{-92,-35},{-92,-35},{-92,-12},{-76,-12},{-76,-10.8818}},
              color={255,204,51},
              thickness=0.5));
          connect(hall.propsBus[8], outerWall_HR.propsBus_a) annotation (Line(
              points={{-76,-11.2636},{-121,-11.2636},{-121,-40}},
              color={255,204,51},
              thickness=0.5));
          connect(hall.propsBus[20], hallWindows_west.propsBus_a) annotation (Line(
              points={{-76,-15.8455},{-76,-15.8455},{-76,-48},{-58,-48},{-58,-51}},
              color={255,204,51},
              thickness=0.5));
          connect(hall.propsBus[21], hallWindows_south.propsBus_a) annotation (Line(
              points={{-76,-16.2273},{-76,-48},{-32,-48},{-32,-51}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWall_HR_MT2.propsBus_a, hall.propsBus[22]) annotation (Line(
              points={{15,4},{-6,4},{-6,6},{-76,6},{-76,-16.6091}},
              color={255,204,51},
              thickness=0.5));
          //Server connections
          connect(FirstAid.proBusA[1], servers.propsBus[1]) annotation (Line(
              points={{4,59},{4,62.9333},{46,62.9333}},
              color={255,204,51},
              thickness=0.5));
          connect(FirstAid.proBusB[1], servers.propsBus[2]) annotation (Line(
              points={{19,56},{32,56},{46,56},{46,62.4}},
              color={255,204,51},
              thickness=0.5));
          connect(servers.propsBus[3], northWall_SV.propsBus_a) annotation (Line(
              points={{46,61.8667},{46,60.8},{32,60.8},{32,81}},
              color={255,204,51},
              thickness=0.5));
          connect(servers.propsBus[4], internalWall_HR_SV.propsBus_a) annotation (Line(
              points={{46,61.3333},{42,61.3333},{42,33},{38,33}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWall_SV_Sto.propsBus_b, servers.propsBus[5]) annotation (Line(
              points={{77,62},{76,62},{76,72},{76,74},{46,74},{46,60.8}},
              color={255,204,51},
              thickness=0.5));
          //Storage room connections
          connect(storage.propsBus[1], northWall_sto.propsBus_a) annotation (Line(
              points={{108,63.7143},{92,63.7143},{92,81}},
              color={255,204,51},
              thickness=0.5));
          connect(storage.propsBus[2], internalWall_SV_Sto.propsBus_a) annotation (Line(
              points={{108,63.1429},{98,63.1429},{98,62},{87,62}},
              color={255,204,51},
              thickness=0.5));
          connect(storage.propsBus[3], internalWall_KT_Sto.propsBus_a) annotation (Line(
              points={{108,62.5714},{100,62.5714},{100,39}},
              color={255,204,51},
              thickness=0.5));
          //Small meeting room connections
          connect(MT2.propsBus[1], outerWall_MT1[2].propsBus_a) annotation (Line(
              points={{-102,-63.1},{-112,-63.1},{-112,-64},{-121,-64}},
              color={255,204,51},
              thickness=0.5));
          connect(MT2.propsBus[2], outerWall_MT1[3].propsBus_a) annotation (Line(
              points={{-102,-63.7},{-112,-64},{-121,-64}},
              color={255,204,51},
              thickness=0.5));
          connect(MT2.propsBus[3], internalWall_HR_MT1.propsBus_b) annotation (Line(
              points={{-102,-64.3},{-102,-64.3},{-102,-45},{-92,-45}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom1Window_west.propsBus_a, MT2.propsBus[6]);
          connect(meetingRoom1Window_east.propsBus_a, MT2.propsBus[7]) annotation (Line(
              points={{-107,-88},{-107,-88},{-102,-88},{-102,-66.7}},
              color={255,204,51},
              thickness=0.5));
          connect(outerWall_MT1[1].propsBus_a, MT2.propsBus[8]);
          //Floor connections
          connect(MT1.proBusFlo[1], flo[3]);
          connect(MT2.propsBus[4], flo[2]);
          connect(hall.propsBus[9], flo[1]);
          connect(kitchen.propsBus[7], flo[4]);
          connect(servers.propsBus[6], flo[5]);
          connect(FirstAid.proBusFlo[1], flo[6]);
          connect(bathroomZone.proBusFlo[1], flo[7]);
          connect(storage.propsBus[4], flo[8]);
          //Stairs connections
          connect(bathroomZone.proBusB[1], staW[3]) annotation (Line(
              points={{-81,76},{-82,76},{-82,84},{-120,84},{-120,-9.33333},{-140,
                  -9.33333}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(staW_wallC.propsBus_a, staW[2]) annotation (Line(
              points={{-137,-22},{-140,-22},{-140,4}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(hall.propsBus[10], staW_wallC.propsBus_b) annotation (Line(
              points={{-76,-12.0273},{-76,-22},{-127,-22}},
              color={255,204,51},
              thickness=0.5));
          connect(servers.propsBus[7], staW_wallB.propsBus_b) annotation (Line(
              points={{46,59.7333},{-30,59.7333},{-30,54},{-105,54}},
              color={255,204,51},
              thickness=0.5));
          connect(staW_wallB.propsBus_a, staW[1]) annotation (Line(
              points={{-115,54},{-128,54},{-140,54},{-140,17.3333}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(storage.propsBus[5], staE_wallD.propsBus_b) annotation (Line(
              points={{108,61.4286},{108,61.4286},{108,42},{125,42},{125,32}},
              color={255,204,51},
              thickness=0.5));
          connect(staE_wallD.propsBus_a, staE[2]) annotation (Line(
              points={{135,32},{136,32},{136,0},{130,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(staE_wallC.propsBus_a, staE[1]) annotation (Line(
              points={{135,-40},{136,-40},{136,0},{150,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(kitchen.propsBus[8], staE_wallC.propsBus_b) annotation (Line(
              points={{80,7},{80,7},{80,-24},{124,-24},{124,-40},{125,-40}},
              color={255,204,51},
              thickness=0.5));
          //Ceiling connections
          connect(hall.propsBus[11], cei[1]);
          connect(hall.propsBus[12], cei[2]);
          connect(hall.propsBus[13], cei[3]);
          connect(hall.propsBus[14], cei[4]);
          connect(kitchen.propsBus[9], cei[5]);
          connect(kitchen.propsBus[10], cei[6]);
          connect(kitchen.propsBus[11], cei[7]);
          connect(servers.propsBus[8], cei[8]);
          connect(servers.propsBus[9], cei[9]);
          connect(storage.propsBus[6], cei[10]);
          connect(storage.propsBus[7], cei[11]);
          connect(MT2.propsBus[5], cei[12]);
          connect(MT1.proBusCei[1], cei[13]);
          connect(FirstAid.proBusCei[1], cei[14]);
          connect(bathroomZone.proBusCei[1], cei[16]);
          connect(FirstAid.proBusExt[1], cei[15]) annotation (Line(
              points={{-2,60},{-2,83.75},{0,83.75}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(hall.propsBus[15], sndcei) annotation (Line(
              points={{-76,-13.9364},{-76,-13.9364},{-76,50},{-60,50},{-60,100}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          //Glass wall towards hollow space
          connect(hall.propsBus[16], glasswall[1]) annotation (Line(
              points={{-76,-14.3182},{-84,-14.3182},{-84,-12},{-100,-12},{-100,115}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(hall.propsBus[17], glasswall[2]);
          connect(hall.propsBus[18], glasswall[3]);
          connect(hall.propsBus[19], glasswall[4]);
          //Data bus connections
          connect(hall.TSensor, dataBus.TGndFlr_hall) annotation (Line(
              points={{-31.9,-16.8},{-82.37,-16.8},{-82.37,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(MT1.TSensor, dataBus.TGndFlr_MT1) annotation (Line(
              points={{23.2,-27.6},{-106,-27.6},{-106,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(MT2.TSensor, dataBus.TGndFlr_MT2) annotation (Line(
              points={{-76.8,-67.6},{-60,-67.6},{-60,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(kitchen.TSensor, dataBus.TGndFlr_KTR) annotation (Line(
              points={{122,4},{-10.4,4},{-10.4,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(servers.TSensor, dataBus.TGndFlr_SVR) annotation (Line(
              points={{73.3,58.4},{-34,58.4},{-34,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(FirstAid.TSensor, dataBus.TGndFlr_1stAid) annotation (Line(
              points={{21,52},{-62,52},{-62,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          //Convective and radiative connections
          connect(servers.gainCon, gainCon[1]);
          connect(servers.gainRad, gainRad[1]);
          connect(FirstAid.gainCon, gainCon[2]);
          connect(FirstAid.gainRad, gainRad[2]);
          connect(kitchen.gainCon, gainCon[3]);
          connect(kitchen.gainRad, gainRad[3]);
          connect(MT2.gainCon, gainCon[4]);
          connect(MT2.gainRad, gainRad[4]);
          connect(MT1.gainCon, gainCon[5]);
          connect(MT1.gainRad, gainRad[5]);
          connect(hall.gainCon, gainCon[6]);
          connect(hall.gainRad, gainRad[6]);
          connect(storage.gainCon, gainCon[7]);
          connect(storage.gainRad, gainRad[7]);
          connect(bathroomZone.gainCon, gainCon[8]);
          connect(bathroomZone.gainRad, gainRad[8]);
          //Occupancy connections
          connect(nOcc[1], kitchen.yOcc) annotation (Line(points={{50,-113.333},{50,
                  -113.333},{50,-76},{124,-76},{124,8}},       color={0,0,127}));
          connect(nOcc[2], MT1.yOcc) annotation (Line(points={{50,-100},{50,-25.2},{
                  24.4,-25.2}},
                           color={0,0,127}));
          connect(nOcc[3], MT2.yOcc) annotation (Line(points={{50,-86.6667},{50,
                  -86.6667},{50,-30},{-75.6,-30},{-75.6,-65.2}},
                                                               color={0,0,127}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-140,-100},
                    {140,100}}), graphics={
                  Rectangle(extent={{-140,100},{140,-100}},
                                                        lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                Text(
                  extent={{-70,70},{70,-70}},
                  lineColor={28,108,200},
                  textString="0")}),                                   Diagram(
              coordinateSystem(preserveAspectRatio=false, extent={{-140,-100},{140,100}})));
        end Floor0_noVent;
      end Floor0;

      package Floor1

        model Floor1
          extends INFRAX.SubSystems.BuildingEnvelope.Floor1.Floor1_noVent(
            meetingRoom2(redeclare
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            meetingRoom1(redeclare replaceable
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            northZone(redeclare replaceable
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            southZone2(redeclare
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            hall(
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            bathroomZone(
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            southZone1(
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr));

          parameter Boolean allowFlowReversal = true
            "= false to simplify equations, assuming, but not enforcing, no flow reversal"
            annotation(Dialog(tab="Assumptions"), Evaluate=true);

          Modelica.Fluid.Interfaces.FluidPort_b[4] airOutlet(
            each m_flow(max=if allowFlowReversal then Modelica.Constants.inf else 0),
            redeclare each package Medium = Medium)
            "Air outlet port of the zones"
            annotation (Placement(transformation(extent={{-46,88},{-26,108}})));
          Modelica.Fluid.Interfaces.FluidPort_a[5] airInlet(
            each m_flow(min=if allowFlowReversal then -Modelica.Constants.inf else 0),
            redeclare each package Medium = Medium)
            "Air inlet port of the zones"
            annotation (Placement(transformation(extent={{34,88},{54,108}})));
          Modelica.Fluid.Interfaces.FluidPort_b bathExtract(redeclare package
            Medium =
                Medium)
            "Extraction port of the toilets"
            annotation (Placement(transformation(extent={{-150,58},{-130,78}})));
          replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface bath_duct
            "Duct of the bathroom extraction (it does not have VAV)"
            annotation (Placement(transformation(
                extent={{-7,-7},{7,7}},
                rotation=180,
                origin={-95,81})));
        equation
          //Air inlets
          connect(airInlet[1], northZone.port_a)
            annotation (Line(points={{44,90},{52.8,90},{52.8,82}}, color={0,127,255}));
          connect(southZone2.port_a, airInlet[3]) annotation (Line(points={{54.8,-20},{56,
                  -20},{56,52},{56,54},{20,54},{20,98},{44,98}}, color={0,127,255}));
          connect(southZone1.port_a, airInlet[2]) annotation (Line(points={{-35.2,-44},{
                  32,-44},{32,-84},{70,-84},{70,94},{44,94}}, color={0,127,255}));
          connect(airInlet[4], meetingRoom1.port_a) annotation (Line(points={{44,102},{30,
                  102},{12,102},{12,20}}, color={0,127,255}));
          connect(meetingRoom2.port_a, airInlet[5]) annotation (Line(points={{92,20},{92,
                  20},{92,106},{44,106}}, color={0,127,255}));
          //Air outlets
          connect(northZone.port_b, airOutlet[1]) annotation (Line(points={{47.2,82},{
                  16,82},{-20,82},{-20,90.5},{-36,90.5}},
                                                       color={0,127,255}));
          connect(southZone2.port_b, airOutlet[2]) annotation (Line(points={{47.2,-20},
                  {48,-20},{48,44},{48,50},{-32,50},{-32,95.5},{-36,95.5}},  color={0,127,
                  255}));
          connect(meetingRoom1.port_b, airOutlet[3]) annotation (Line(points={{8,20},{8,
                  20},{8,70},{-22,70},{-22,100.5},{-36,100.5}}, color={0,127,255}));
          connect(meetingRoom2.port_b, airOutlet[4]) annotation (Line(points={{88,20},{88,
                  20},{88,122},{-32,122},{-32,105.5},{-36,105.5}}, color={0,127,255}));
          //Air inter-connections between zones
          connect(southZone1.port_b, southZone2.port_a) annotation (Line(points={{-42.8,
                  -44},{-42,-44},{-42,-28},{54.8,-28},{54.8,-20}}, color={0,127,255}));
          connect(southZone2.port_b, hall.port_a) annotation (Line(points={{47.2,-20},{
                  22,-20},{-8,-20},{-8,44},{-32.4,44}}, color={0,127,255}));
          connect(hall.port_b, bathroomZone.port_a) annotation (Line(points={{-39.6,44},
                  {-39.6,68},{-42,68},{-42,92}}, color={0,127,255}));
          connect(bathroomZone.port_b, bath_duct.port_a) annotation (Line(points={{-46,
                  92},{-60,92},{-86,92},{-86,81},{-88,81}}, color={0,127,255}));
          connect(bath_duct.port_b, bathExtract) annotation (Line(points={{-102,81},{
                  -120,81},{-120,68},{-140,68}}, color={0,127,255}));
          connect(northZone.ppm, dataBus.CO2_1stFlr_NZ) annotation (Line(points={{65.4,
                  68},{68,68},{68,52},{-139.9,52},{-139.9,40.1}}, color={0,0,127}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(southZone1.ppm, dataBus.CO2_1stFlr_SZ1) annotation (Line(points={{
                  -18.1,-64},{-10,-64},{-10,40.1},{-139.9,40.1}}, color={0,0,127}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(southZone2.ppm, dataBus.CO2_1stFlr_SZ2) annotation (Line(points={{
                  71.9,-40},{84,-40},{84,40.1},{-139.9,40.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(meetingRoom1.ppm, dataBus.CO2_1stFlr_MT1) annotation (Line(points={{
                  21,10},{28,10},{28,40.1},{-139.9,40.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(meetingRoom2.ppm, dataBus.CO2_1stFlr_MT2) annotation (Line(points={{
                  101,10},{108,10},{108,40},{-139.9,40},{-139.9,40.1}}, color={0,0,127}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
        end Floor1;

        model Floor1Sim
          extends Floor1(redeclare IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent
                                                                           bath_duct(
            allowFlowReversal=false,
            m_flow_nominal=350*1.225/3600,
            redeclare package Medium = Medium,
            from_dp=true,
              show_T=false,
              dpValve_nominal=50));
          Buildings.Controls.OBC.CDL.Continuous.Sources.Constant cav(k=1)
            annotation (Placement(transformation(extent={{-136,56},{-128,64}})));
        equation
          connect(cav.y, bath_duct.y) annotation (Line(points={{-127.6,60},{-110,60},{
                  -110,62},{-95,62},{-95,72.6}}, color={0,0,127}));
        end Floor1Sim;

        model Floor1_noVent

          replaceable package Medium = IDEAS.Media.Air constrainedby
          Modelica.Media.Interfaces.PartialMedium;
          outer IDEAS.BoundaryConditions.SimInfoManager sim "Data reader"
            annotation (Placement(transformation(extent={{-140,80},{-120,100}})));
          IDEAS.Buildings.Components.RectangularZoneTemplate meetingRoom1(
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall conTypCei,
            aziA=INFRAX.Data.Orientations.N,
            l=str1stFlr.l_1stFlr_MTR1,
            w=str1stFlr.w_1stFlr_CPR,
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            h=str1stFlr.Height1stFlr,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
              conTypFlo,
            redeclare INFRAX.Data.Constructions.ReinforcedGlassWall conTypA,
            redeclare INFRAX.Data.Constructions.PlasterWallCavity conTypB,
            redeclare INFRAX.Data.Constructions.ReinforcedGlassWall conTypC,
            redeclare INFRAX.Data.Constructions.GlassWall conTypD,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            nSurfExt=1,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
            "Meeting room next to 1st floor reception"
            annotation (Placement(transformation(extent={{0,0},{20,20}})));
          IDEAS.Buildings.Components.RectangularZoneTemplate meetingRoom2(
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall conTypCei,
            aziA=INFRAX.Data.Orientations.N,
            l=str1stFlr.l_1stFlr_MTR2,
            w=str1stFlr.w_1stFlr_MTR2,
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            h=str1stFlr.Height1stFlr,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
              conTypFlo,
            redeclare INFRAX.Data.Constructions.ReinforcedGlassWall conTypA,
            redeclare INFRAX.Data.Constructions.GlassWall conTypB,
            redeclare INFRAX.Data.Constructions.ReinforcedGlassWall conTypC,
            redeclare INFRAX.Data.Constructions.PlasterWallCavity conTypD,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
            "Meeting room further to 1st floor reception"
            annotation (Placement(transformation(extent={{80,0},{100,20}})));
          INFRAX.Data.Parameters.Str1stFlr str1stFlr "Record containing 1st floor data"
            annotation (Placement(transformation(extent={{120,-100},{140,-80}})));
          IDEAS.Buildings.Components.Zone northZone(
            V=str1stFlr.Vol_1stFlr_NZ,
            hZone=str1stFlr.Height1stFlr,
            nSurf=16,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
            "Northern landscape office, lumping the three small offices"
            annotation (Placement(transformation(extent={{36,54},{64,82}})));
          IDEAS.Buildings.Components.InternalWall[2] internalWallNZ(
            each inc=IDEAS.Types.Tilt.Wall,
            azi={INFRAX.Data.Orientations.N,INFRAX.Data.Orientations.W},
            A=str1stFlr.AinternalWallsNZ,
            redeclare INFRAX.Data.Constructions.PlasterWall constructionType,
            T_start=T_start)
            "Walls adding thermal mass to the northern landscape zone"
            annotation (Placement(transformation(extent={{84,60},{96,80}})));
          IDEAS.Buildings.Components.OuterWall northWall(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=str1stFlr.AWall_1stFlr_NZ - str1stFlr.AWindows_1stFlr_NZ,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            T_start=T_start)
            "Outer wall connected to the northern landscape zone"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={80,94})));
          IDEAS.Buildings.Components.Window northWindows(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=str1stFlr.AWindows_1stFlr_NZ,
            frac=str1stFlr.FrameRatio_1stFlr_NZ,
            redeclare IDEAS.Buildings.Components.Shading.None shaType,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            T_start=T_start)
            "Windows connected to the northern landscape zone"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={100,94})));
          IDEAS.Buildings.Components.Zone southZone2(
            hZone=str1stFlr.Height1stFlr,
            V=str1stFlr.Vol_1stFlr_SZ2,
            nSurf=22,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
           "Southern landscape office, situated on the eastern side of the building"
            annotation (Placement(transformation(extent={{32,-60},{70,-20}})));
          IDEAS.Buildings.Components.OuterWall[2] SZ2Wall(
            inc=IDEAS.Types.Tilt.Wall,
            A=str1stFlr.AWall_1stFlr_SZ2 - str1stFlr.AWindows_1stFlr_SZ2,
            azi={INFRAX.Data.Orientations.E,INFRAX.Data.Orientations.S},
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            T_start=T_start)
           "Array of outer walls connected to the southern landscape office"
            annotation (Placement(transformation(
                extent={{6,-10},{-6,10}},
                rotation=-90,
                origin={40,-74})));
          IDEAS.Buildings.Components.Window SZ2Windows1(
            inc=IDEAS.Types.Tilt.Wall,
            A=str1stFlr.AWindows_1stFlr_SZ2[1],
            frac=str1stFlr.FrameRatio_1stFlr_SZ2[1],
            azi=INFRAX.Data.Orientations.E,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare IDEAS.Buildings.Components.Shading.OverhangAndHorizontalFins
              shaType(
              wWin=1.47,
              w=0.17,
              s=0.175,
              t=0.032,
              hWin=str1stFlr.WindowHeight,
              gap=8.17 - 7.12,
              wRight=(2.7 - 1.47)/2,
              wLeft=(2.7 - 1.47)/2,
              dep=1.80,
              beta=0.5235987755983),
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing)
          "Eastern windows connected to the southern landscape office"
            annotation (Placement(transformation(
                extent={{6,-10},{-6,10}},
                rotation=-90,
                origin={60,-74})));
          IDEAS.Buildings.Components.Window SZ2Windows2(
            inc=IDEAS.Types.Tilt.Wall,
            A=str1stFlr.AWindows_1stFlr_SZ2[2],
            frac=str1stFlr.FrameRatio_1stFlr_SZ2[2],
            azi=INFRAX.Data.Orientations.S,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare IDEAS.Buildings.Components.Shading.OverhangAndHorizontalFins
              shaType(
              wWin=1.47,
              w=0.17,
              s=0.175,
              t=0.032,
              hWin=str1stFlr.WindowHeight,
              gap=8.17 - 7.12,
              wRight=(2.7 - 1.47)/2,
              wLeft=(2.7 - 1.47)/2,
              dep=5.70,
              beta=0.5235987755983),
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            T_start=T_start)
            "Southern windows connected to the southern landscape office"
            annotation (Placement(transformation(
                extent={{6,-10},{-6,10}},
                rotation=-90,
                origin={60,-88})));
        ///NOTE: Windows are not in array due to different shading parameters
          IDEAS.Buildings.Components.InternalWall[2] internalWallSZ2(
            each inc=IDEAS.Types.Tilt.Wall,
            azi={INFRAX.Data.Orientations.N,INFRAX.Data.Orientations.W},
            A=str1stFlr.AinternalWallsSZ2,
            redeclare INFRAX.Data.Constructions.ReinforcedGlassWall constructionType,
            T_start=T_start)
            "Walls adding thermal mass to the southern landscape office from the copy rooms"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=90,
                origin={50,-4})));
          IDEAS.Buildings.Components.InternalWall internalWallNZSZ2(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=str1stFlr.AinternalWall_NZSZ2,
            redeclare INFRAX.Data.Constructions.ReinforcedGlassWall constructionType,
            T_start=T_start)
            "Internal wall between northern and southern landscape offices"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=90,
                origin={34,30})));
          IDEAS.Buildings.Components.Zone southZone1(
            hZone=str1stFlr.Height1stFlr,
            V=str1stFlr.Vol_1stFlr_SZ1,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            nSurf=13,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
            "Southern extension office, situated in the south-west corner of the building"
            annotation (Placement(transformation(extent={{-58,-84},{-20,-44}})));
          IDEAS.Buildings.Components.OuterWall[3] SZ1Wall(
            inc=IDEAS.Types.Tilt.Wall,
            azi={INFRAX.Data.Orientations.E,INFRAX.Data.Orientations.S,INFRAX.Data.Orientations.inc},
            A={str1stFlr.AWall_1stFlr_SZ1[1] - str1stFlr.AWindows_1stFlr_SZ1[1],
                str1stFlr.AWall_1stFlr_SZ1[2],str1stFlr.AWall_1stFlr_SZ1[3] - str1stFlr.AWindows_1stFlr_SZ1
                [2]},
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            T_start=T_start)
           "Outer walls of the southern extension office"
            annotation (Placement(transformation(
                extent={{6,-10},{-6,10}},
                rotation=-90,
                origin={-90,-84})));
          IDEAS.Buildings.Components.Window SZ1Windows_west(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            A=str1stFlr.AWindows_1stFlr_SZ1[3],
            frac=str1stFlr.FrameRatio_1stFlr_SZ1[3],
            azi=INFRAX.Data.Orientations.inc,
            redeclare IDEAS.Buildings.Components.Shading.BuildingShade shaType(
              L=5,
              dh=10.0 - 6.77,
              hWin=(str1stFlr.WindowF + str1stFlr.WindowG)/str1stFlr.WindowHeight1stFlr),
            T_start=T_start)
           "Western windows connected to the southern extension office"
           annotation (Placement(transformation(
                extent={{6,-10},{-6,10}},
                rotation=-90,
                origin={-70,-72})));
            IDEAS.Buildings.Components.Window SZ1Windows_east(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare Data.Frames.INFRAXWood fraType,
            redeclare Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            A=str1stFlr.AWindows_1stFlr_SZ1[1],
            frac=str1stFlr.FrameRatio_1stFlr_SZ1[1],
            azi=INFRAX.Data.Orientations.E,
            redeclare IDEAS.Buildings.Components.Shading.OverhangAndHorizontalFins
              shaType(
              w=0.17,
              s=0.175,
              t=0.032,
              hWin=str1stFlr.WindowHeight,
              gap=8.17 - 7.12,
              dep=27,
              wWin=(5.7 - 0.8 - 0.41),
              wLeft=16.1,
              wRight=0.8 + 5,
              beta=0.5235987755983),
            T_start=T_start)
          "Southern extension office eastern window"
            annotation (Placement(transformation(
                extent={{6,-10},{-6,10}},
                rotation=-90,
                origin={-70,-84})));
          IDEAS.Buildings.Components.Window SZ1Windows_south(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare Data.Frames.INFRAXWood fraType,
            redeclare Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            azi=INFRAX.Data.Orientations.S,
            A=str1stFlr.AWindows_1stFlr_SZ1[2],
            frac=str1stFlr.FrameRatio_1stFlr_SZ1[2],
            redeclare IDEAS.Buildings.Components.Shading.OverhangAndHorizontalFins
              shaType(
              wWin=1.47,
              w=0.17,
              s=0.175,
              t=0.032,
              hWin=str1stFlr.WindowHeight,
              gap=8.17 - 7.12,
              wLeft=(2.7 - 1.47)/2,
              dep=5.70,
              wRight=2.7*5,
              beta=0.5235987755983),
            T_start=T_start)
            "Southern extension office southern window"
              annotation (Placement(
                transformation(
                extent={{6,-10},{-6,10}},
                rotation=-90,
                origin={-70,-96})));
          IDEAS.Buildings.Components.Zone hall(
            hZone=str1stFlr.Height1stFlr,
            V=str1stFlr.Vol_1stFlr_hall,
            nSurf=13,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start)
           "Entrance hall of the first floor"
            annotation (Placement(transformation(extent={{-54,8},{-18,44}})));
          IDEAS.Buildings.Components.OuterWall[2] hallWalls(
            inc=IDEAS.Types.Tilt.Wall,
            azi={INFRAX.Data.Orientations.N,INFRAX.Data.Orientations.inc},
            A=str1stFlr.AWall_1stFlr_hall - str1stFlr.AWindows_1stFlr_hall,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            T_start=T_start)
           "Array of outer walls connected to the entrance hall"
            annotation (Placement(transformation(
                extent={{6,10},{-6,-10}},
                rotation=180,
                origin={-106,18})));
          IDEAS.Buildings.Components.Window hallWindows_west(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            redeclare IDEAS.Buildings.Components.Shading.BuildingShade shaType(
              L=5,
              hWin=(str1stFlr.WindowF + str1stFlr.WindowG)/str1stFlr.WindowHeight1stFlr,
              dh=10 - 6.77),
            azi=INFRAX.Data.Orientations.inc,
            A=str1stFlr.AWindows_1stFlr_hall[2],
            frac=str1stFlr.FrameRatio_1stFlr_hall[2],
            T_start=T_start)
          "Western windows connected to the entrance hall"
            annotation (Placement(
                transformation(
                extent={{6,10},{-6,-10}},
                rotation=180,
                origin={-106,42})));
            IDEAS.Buildings.Components.Window hallWindows_north(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare Data.Frames.INFRAXWood fraType,
            redeclare Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            redeclare IDEAS.Buildings.Components.Shading.BuildingShade shaType(
              L=5,
              hWin=(str1stFlr.WindowF + str1stFlr.WindowG)/str1stFlr.WindowHeight1stFlr,
              dh=10 - 6.77),
            azi=INFRAX.Data.Orientations.N,
            A=str1stFlr.AWindows_1stFlr_hall[1],
            frac=str1stFlr.FrameRatio_1stFlr_hall[1],
            T_start=T_start)
            "Hall north window (next to bathroom)"
            annotation (Placement(
                transformation(
                extent={{6,10},{-6,-10}},
                rotation=180,
                origin={-92,42})));
          IDEAS.Buildings.Components.InternalWall internalWallhallSZ1(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=str1stFlr.AinternalWall_hallSZ1,
            redeclare INFRAX.Data.Constructions.PlasterWall constructionType,
            T_start=T_start)
          "Wall between the entrance hall and the southern extension hall"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=90,
                origin={-78,-12})));
          IDEAS.Buildings.Components.RectangularZoneTemplate bathroomZone(
            aziA=INFRAX.Data.Orientations.N,
            h=str1stFlr.Height1stFlr,
            l=str1stFlr.l_1stFlr_BRZ,
            w=str1stFlr.w_1stFlr_BRZ,
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall conTypCei,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
              conTypFlo,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls conTypA,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypB,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypC,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypD,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            hasCavityD=true)
          "Bathroom zone, not conditioned and with air extraction"
            annotation (Placement(transformation(extent={{-54,72},{-34,92}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[7] cei(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
           "Bus to connect the floor zones to the ceiling walls in the outer level"
            annotation (Placement(transformation(extent={{-20,120},{20,80}})));
         IDEAS.Buildings.Components.Interfaces.ZoneBus[3] staW(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
           "Bus to connect the floor zones to the stair zones in the outer level"
           annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-140,4})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[2] staE(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
           "Bus to connect the floor zones to the stair zones in the outer level"
           annotation (
              Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={140,0})));
          IDEAS.Buildings.Components.InternalWall staW_WallC(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=4.85*str1stFlr.Height1stFlr,
            redeclare INFRAX.Data.Constructions.ConcreteWall constructionType,
            T_start=T_start)
            "Southern internal wall towards the west stair zone in the outer level"
             annotation (Placement(transformation(
                extent={{6,10},{-6,-10}},
                rotation=90,
                origin={-130,-28})));
          IDEAS.Buildings.Components.InternalWall staW_WallB(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.W,
            A=4.5*str1stFlr.Height1stFlr,
            redeclare INFRAX.Data.Constructions.ConcreteWall constructionType,
            T_start=T_start)
          "Eastern internal wall towards the west stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{-6,10},{6,-10}},
                rotation=0,
                origin={-124,64})));
          IDEAS.Buildings.Components.InternalWall staE_WallC(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=2.55*str1stFlr.Height1stFlr,
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            T_start=T_start)
          "Southern internal wall towards the east stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{6,10},{-6,-10}},
                rotation=90,
                origin={130,-28})));
          IDEAS.Buildings.Components.InternalWall staE_WallD(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.E,
            A=4.5*str1stFlr.Height1stFlr,
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            T_start=T_start)
          "Western internal wall towards the east stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{6,10},{-6,-10}},
                rotation=0,
                origin={114,30})));
          IDEAS.Buildings.Components.OuterWall[2] roof1stFlr(
            inc=IDEAS.Types.Tilt.Ceiling,
            azi=0,
            A=str1stFlr.Roof1stFlr,
            redeclare INFRAX.Data.Constructions.Roof constructionType,
            energyDynamics=energyDynamicsTABS,
            T_start=T_start)
           "Outer roof of the southern extension and hall"
            annotation (Placement(
                transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={-70,76})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[16] flo(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
          "Bus to connect the floor zones to the floor walls in the outer level"
            annotation (Placement(transformation(extent={{-20,-120},{20,-80}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[4] glasswall(each
              numIncAndAziInBus=sim.numIncAndAziInBus)
          "Bus of the hollow walls in the first floor"
            annotation (Placement(transformation(extent={{-140,-120},{-100,-80}})));
          IDEAS.Buildings.Components.InternalWall[4] glassWall(
            inc=IDEAS.Types.Tilt.Wall,
            redeclare INFRAX.Data.Constructions.GlassWall constructionType,
            azi={INFRAX.Data.Orientations.N,INFRAX.Data.Orientations.E,INFRAX.Data.Orientations.S,
                INFRAX.Data.Orientations.W},
            A=str1stFlr.Height1stFlr*{str1stFlr.l_1stFlr_GH,str1stFlr.w_1stFlr_GH,
                str1stFlr.l_1stFlr_GH,str1stFlr.w_1stFlr_GH},
            T_start=T_start)
          "Glass walls of the hollow in the first floor"
            annotation (Placement(
                transformation(
                extent={{-6,-10},{6,10}},
                rotation=90,
                origin={-118,-70})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[2] port_emb
          "Embedded port towards outer walls in the extension roof"
            annotation (Placement(transformation(extent={{130,60},{150,80}})));
          INFRAX.SubSystems.Controllers.DataBus dataBus
          "Bus containing data from different sensors"
            annotation (Placement(transformation(extent={{-160,20},{-120,
                    60}}),
                iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[7] gainRad
          "Bus to connect the radiative heat transfer to the zones"
            annotation (Placement(transformation(extent={{130,-80},{150,-60}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[7] gainCon
          "Bus to connect the convective heat transfer to the zones"
            annotation (Placement(transformation(extent={{130,-60},{150,-40}})));
          parameter Modelica.Fluid.Types.Dynamics energyDynamicsAir=Modelica.Fluid.Types.Dynamics.FixedInitial
            "Type of energy balance for air model: dynamic (3 initialization options) or steady state";
          parameter Modelica.Fluid.Types.Dynamics energyDynamicsTABS=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial
            "Type of energy balance for air model: dynamic (3 initialization options) or steady state";

          parameter Real[7] A_Conv = {northZone.A, southZone1.A, southZone2.A, meetingRoom1.A,
          meetingRoom2.A, hall.A, bathroomZone.A} "Convective area of zones";

          parameter Real mSenFac=5
            "Correction factor for thermal capacity of zone air.";
          Modelica.Blocks.Interfaces.RealInput[5] nOcc
          "Number of occupants input" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={90,-100})));

          parameter Modelica.Media.Interfaces.Types.Temperature T_start=293.15
            "Start value of temperature";
          Modelica.Blocks.Math.Gain gain1(k=1/3) annotation (Placement(transformation(
                extent={{-5,-5},{5,5}},
                rotation=90,
                origin={79,49})));
          Modelica.Blocks.Math.Gain gain2(k=1/3) annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=90,
                origin={0,-74})));
          Modelica.Blocks.Math.Gain gain3(k=1/3) annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=90,
                origin={84,-50})));
        equation
          //North zone connections
          connect(northZone.propsBus[1], northWall.propsBus_a) annotation (Line(
              points={{36,76.225},{22,76.225},{22,89},{82,89}},
              color={255,204,51},
              thickness=0.5));
          connect(northZone.propsBus[2], northWindows.propsBus_a) annotation (Line(
              points={{36,75.875},{22,75.875},{22,89},{102,89}},
              color={255,204,51},
              thickness=0.5));
          connect(northZone.propsBus[3], internalWallNZ[1].propsBus_b) annotation (Line(
              points={{36,75.525},{36,75.525},{36,84},{80,84},{80,72},{85,72}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWallNZ[1].propsBus_a, northZone.propsBus[4]) annotation (Line(
              points={{95,72},{100,72},{100,48},{36,48},{36,75.175}},
              color={255,204,51},
              thickness=0.5));
          connect(northZone.propsBus[5], internalWallNZ[2].propsBus_b) annotation (Line(
              points={{36,74.825},{36,84},{80,84},{80,72},{85,72}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWallNZ[2].propsBus_a, northZone.propsBus[6]) annotation (Line(
              points={{95,72},{100,72},{100,48},{36,48},{36,74.475}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom1.proBusA[1], northZone.propsBus[7]) annotation (Line(
              points={{4,19},{4,74.125},{36,74.125}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom2.proBusA[1], northZone.propsBus[8]) annotation (Line(
              points={{84,19},{84,40},{36,40},{36,73.775}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWallNZSZ2.propsBus_a, northZone.propsBus[9]) annotation (Line(
              points={{32,35},{32,73.425},{36,73.425}},
              color={255,204,51},
              thickness=0.5));
          //Southern landscape office connections
          connect(southZone2.propsBus[1], SZ2Wall[1].propsBus_a) annotation (Line(
              points={{32,-28.1818},{26,-28.1818},{20,-28.1818},{20,-64},{42,-64},{42,
                  -69}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone2.propsBus[2], SZ2Wall[2].propsBus_a) annotation (Line(
              points={{32,-28.5455},{30,-28.5455},{30,-28},{20,-28},{20,-64},{42,-64},{
                  42,-69}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone2.propsBus[3], SZ2Windows1.propsBus_a) annotation (Line(
              points={{32,-28.9091},{26,-28.9091},{20,-28.9091},{20,-62},{62,-62},{62,
                  -69}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone2.propsBus[4], SZ2Windows2.propsBus_a) annotation (Line(
              points={{32,-29.2727},{20,-29.2727},{20,-62},{62,-62},{62,-83}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone2.propsBus[5], internalWallSZ2[1].propsBus_b) annotation (
              Line(
              points={{32,-29.6364},{32,-29.6364},{32,-12},{32,-14},{48,-14},{48,-9}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWallSZ2[1].propsBus_a, southZone2.propsBus[6]) annotation (
              Line(
              points={{48,1},{48,8},{32,8},{32,-30}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone2.propsBus[7], internalWallSZ2[2].propsBus_b) annotation (
              Line(
              points={{32,-30.3636},{32,-14},{48,-14},{48,-9}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWallSZ2[2].propsBus_a, southZone2.propsBus[8]) annotation (
              Line(
              points={{48,1},{48,8},{32,8},{32,-30.7273}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom1.proBusC[1], southZone2.propsBus[9]) annotation (Line(
              points={{16.8,0.2},{16.8,-31.0909},{32,-31.0909}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom1.proBusB[1], southZone2.propsBus[10]) annotation (Line(
              points={{19,16},{32,16},{32,-31.4545}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom2.proBusC[1], southZone2.propsBus[11]) annotation (Line(
              points={{96.8,0.2},{96.8,-14},{32,-14},{32,-31.8182}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom2.proBusD[1], southZone2.propsBus[12]) annotation (Line(
              points={{80.4,3},{32,3},{32,-32.1818}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom2.proBusB[1], southZone2.propsBus[13]) annotation (Line(
              points={{99,16},{106,16},{106,-18},{32,-18},{32,-32.5455}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWallNZSZ2.propsBus_b, southZone2.propsBus[14]) annotation (Line(
              points={{32,25},{32,-32.9091}},
              color={255,204,51},
              thickness=0.5));
          //Extension southern office connections
          connect(SZ1Wall[1].propsBus_a, southZone1.propsBus[1]) annotation (Line(
              points={{-88,-79},{-88,-52.3077},{-58,-52.3077}},
              color={255,204,51},
              thickness=0.5));
          connect(SZ1Wall[2].propsBus_a, southZone1.propsBus[2]) annotation (Line(
              points={{-88,-79},{-88,-52.9231},{-58,-52.9231}},
              color={255,204,51},
              thickness=0.5));
          connect(SZ1Wall[3].propsBus_a, southZone1.propsBus[3]) annotation (Line(
              points={{-88,-79},{-88,-53.5385},{-58,-53.5385}},
              color={255,204,51},
              thickness=0.5));
          connect(SZ1Windows_east.propsBus_a, southZone1.propsBus[4]) annotation (
              Line(
              points={{-68,-79},{-68,-54.1538},{-58,-54.1538}},
              color={255,204,51},
              thickness=0.5));
          connect(SZ1Windows_south.propsBus_a, southZone1.propsBus[5]) annotation (
              Line(
              points={{-68,-91},{-68,-54.7692},{-58,-54.7692}},
              color={255,204,51},
              thickness=0.5));
          connect(SZ1Windows_west.propsBus_a, southZone1.propsBus[6]);
          connect(internalWallhallSZ1.propsBus_b, southZone1.propsBus[7]) annotation (
              Line(
              points={{-80,-17},{-82,-17},{-82,-40},{-82,-56},{-58,-56}},
              color={255,204,51},
              thickness=0.5));
          //Hall zone connections
          connect(hallWalls[1].propsBus_a, hall.propsBus[1]) annotation (Line(
              points={{-101,20},{-54,20},{-54,36.5231}},
              color={255,204,51},
              thickness=0.5));
          connect(hallWalls[2].propsBus_a, hall.propsBus[2]) annotation (Line(
              points={{-101,20},{-54,20},{-54,35.9692}},
              color={255,204,51},
              thickness=0.5));
          connect(hallWindows_west.propsBus_a, hall.propsBus[3]) annotation (Line(
              points={{-101,44},{-54,44},{-54,35.4154}},
              color={255,204,51},
              thickness=0.5));
          connect(hallWindows_north.propsBus_a, hall.propsBus[4]) annotation (Line(
              points={{-87,44},{-54,44},{-54,34.8615}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWallhallSZ1.propsBus_a, hall.propsBus[5]) annotation (Line(
              points={{-80,-7},{-80,-7},{-80,34.3077},{-54,34.3077}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom1.proBusD[1], hall.propsBus[6]) annotation (Line(
              points={{0.4,3},{-2,3},{-2,12},{-4,12},{-4,62},{-54,62},{-54,33.7538}},
              color={255,204,51},
              thickness=0.5));
          connect(bathroomZone.proBusC[1], hall.propsBus[7]) annotation (Line(
              points={{-37.2,72.2},{-46,72.2},{-46,68},{-54,68},{-54,33.2}},
              color={255,204,51},
              thickness=0.5));
          connect(bathroomZone.proBusD[1], hall.propsBus[8]) annotation (Line(
              points={{-53.6,75},{-54,75},{-54,32.6462}},
              color={255,204,51},
              thickness=0.5));
          //Connections to the ceiling
          connect(northZone.propsBus[10], cei[1])  annotation (Line(
              points={{36,73.075},{18,73.075},{18,76},{0,76},{0,117.143}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(southZone1.propsBus[8], cei[2]);
          connect(southZone2.propsBus[15], cei[3]);
          connect(meetingRoom1.proBusCei[1], cei[4]);
          connect(meetingRoom2.proBusCei[1], cei[5]);
          connect(bathroomZone.proBusCei[1], cei[6]);
          connect(hall.propsBus[9], cei[7]);
          connect(hall.propsBus[11], roof1stFlr[1].propsBus_a) annotation (Line(
              points={{-54,30.9846},{-68,30.9846},{-68,71}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone1.propsBus[9], roof1stFlr[2].propsBus_a) annotation (Line(
              points={{-58,-57.2308},{-68,-57.2308},{-68,71}},
              color={255,204,51},
              thickness=0.5));
          //Connections to the stairs
          connect(bathroomZone.proBusB[1], staW[3]) annotation (Line(
              points={{-35,88},{-32,88},{-32,96},{-140,96},{-140,-9.33333}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(northZone.propsBus[11], staW_WallB.propsBus_a) annotation (Line(
              points={{36,72.725},{0,72.725},{0,62},{-8,62},{-119,62}},
              color={255,204,51},
              thickness=0.5));
          connect(staW_WallB.propsBus_b, staW[1]) annotation (Line(
              points={{-129,62},{-132,62},{-132,50},{-140,50},{-140,17.3333}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(hall.propsBus[10], staW_WallC.propsBus_a) annotation (Line(
              points={{-54,31.5385},{-56,31.5385},{-56,-28},{-56,-33},{-128,-33}},
              color={255,204,51},
              thickness=0.5));
          connect(staW_WallC.propsBus_b, staW[2]);
          connect(northZone.propsBus[12], staE_WallD.propsBus_a) annotation (Line(
              points={{36,72.375},{36,40},{109,40},{109,28}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone2.propsBus[16], staE_WallC.propsBus_a) annotation (Line(
              points={{32,-33.6364},{86,-33.6364},{132,-33.6364},{132,-36},{132,-34},{
                  132,-33}},
              color={255,204,51},
              thickness=0.5));
          connect(staE_WallD.propsBus_b, staE[2]) annotation (Line(
              points={{119,28},{128,28},{128,26},{130,26},{130,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(staE_WallC.propsBus_b, staE[1]) annotation (Line(
              points={{132,-23},{132,-14.5},{150,-14.5},{150,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          //Floor connections
          connect(southZone2.propsBus[17], flo[1]);
          connect(hall.propsBus[12], flo[2]);
          connect(meetingRoom1.proBusFlo[1], flo[3]);
          connect(southZone1.propsBus[10], flo[4]);
          connect(southZone2.propsBus[18], flo[5]);
          connect(meetingRoom2.proBusFlo[1], flo[6]);
          connect(northZone.propsBus[16], flo[7]);
          connect(southZone2.propsBus[19], flo[8]);
          connect(northZone.propsBus[13], flo[9]);
          connect(southZone2.propsBus[20], flo[10]);
          connect(northZone.propsBus[14], flo[11]);
          connect(southZone1.propsBus[11], flo[12]);
          connect(southZone2.propsBus[21], flo[13]);
          connect(northZone.propsBus[15], flo[14]);
          connect(meetingRoom1.proBusExt[1], flo[15]);
          connect(bathroomZone.proBusFlo[1], flo[16]);
          //Hollow glass wall connections
          connect(hall.propsBus[13], glassWall[1].propsBus_a) annotation (Line(
              points={{-54,29.8769},{-56,29.8769},{-56,-40},{-56,-44},{-120,-44},{-120,
                  -65}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone2.propsBus[22], glassWall[2].propsBus_a) annotation (Line(
              points={{32,-35.8182},{8,-35.8182},{8,-42},{-118,-42},{-118,-65},{-120,
                  -65}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone1.propsBus[12], glassWall[3].propsBus_a) annotation (Line(
              points={{-58,-59.0769},{-90,-59.0769},{-120,-59.0769},{-120,-65}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone1.propsBus[13], glassWall[4].propsBus_a) annotation (Line(
              points={{-58,-59.6923},{-90,-59.6923},{-90,-58},{-120,-58},{-120,-65}},
              color={255,204,51},
              thickness=0.5));
          connect(glassWall.propsBus_b, glasswall) annotation (Line(
              points={{-120,-75},{-120,-100}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));

          connect(roof1stFlr.port_emb[1], port_emb) annotation (Line(points={{-80,76},{
                  -80,100},{140,100},{140,70}}, color={191,0,0}));
          //NOTE: Hall does not have TABS
          //Data bus connections
          connect(northZone.TSensor, dataBus.T1stFlr_NZ) annotation (Line(
              points={{65.4,70.8},{-35.58,70.8},{-35.58,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(southZone1.TSensor, dataBus.T1stFlr_SZ1) annotation (Line(
              points={{-18.1,-60},{-78,-60},{-78,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(southZone2.TSensor, dataBus.T1stFlr_SZ2) annotation (Line(
              points={{71.9,-36},{-35.43,-36},{-35.43,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(meetingRoom1.TSensor, dataBus.T1stFlr_MT1) annotation (Line(
              points={{21,12},{-61.7,12},{-61.7,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(meetingRoom2.TSensor, dataBus.T1stFlr_MT2) annotation (Line(
              points={{101,12},{-16,12},{-16,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          //Radiative and convective connections
          connect(northZone.gainCon, gainCon[1]);
          connect(northZone.gainRad, gainRad[1]);
          connect(southZone1.gainCon, gainCon[2]);
          connect(southZone1.gainRad, gainRad[2]);
          connect(southZone2.gainCon, gainCon[3]);
          connect(southZone2.gainRad, gainRad[3]);
          connect(meetingRoom1.gainCon, gainCon[4]);
          connect(meetingRoom1.gainRad, gainRad[4]);
          connect(meetingRoom2.gainCon, gainCon[5]);
          connect(meetingRoom2.gainRad, gainRad[5]);
          connect(hall.gainCon, gainCon[6]);
          connect(hall.gainRad, gainRad[6]);
          connect(bathroomZone.gainCon, gainCon[7]);
          connect(bathroomZone.gainRad, gainRad[7]);
          //Occupancy connections
          connect(meetingRoom1.yOcc, nOcc[4]) annotation (Line(points={{22,14},{22,-18},
                  {90,-18},{90,-92}},           color={0,0,127}));
          connect(meetingRoom2.yOcc, nOcc[5]) annotation (Line(points={{102,14},{102,-52},
                  {90,-52},{90,-84}},            color={0,0,127}));
          connect(gain1.y, northZone.yOcc) annotation (Line(points={{79,54.5},{79,73.6},
                  {66.8,73.6}}, color={0,0,127}));
          connect(gain1.u, nOcc[1]) annotation (Line(points={{79,43},{79,-10},{90,-10},
                  {90,-116}}, color={0,0,127}));
          connect(southZone1.yOcc, gain2.y) annotation (Line(points={{-16.2,-56},{-8,
                  -56},{-8,-67.4},{0,-67.4}}, color={0,0,127}));
          connect(gain2.u, nOcc[2]) annotation (Line(points={{-4.44089e-16,-81.2},{
                  -4.44089e-16,-108},{90,-108}}, color={0,0,127}));
          connect(gain3.y, southZone2.yOcc) annotation (Line(points={{84,-43.4},{84,-32},
                  {73.8,-32}}, color={0,0,127}));
          connect(gain3.u, nOcc[3]) annotation (Line(points={{84,-57.2},{84,-100},{90,
                  -100}}, color={0,0,127}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-140,-100},
                    {140,100}}), graphics={
                  Rectangle(extent={{-140,100},{140,-100}},
                                                        lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                Text(
                  extent={{-70,70},{70,-70}},
                  lineColor={28,108,200},
                  textString="1")}),                                   Diagram(
              coordinateSystem(preserveAspectRatio=false, extent={{-140,-100},{140,100}})));
        end Floor1_noVent;
      end Floor1;

      package Floor2

        model Floor2
          extends INFRAX.SubSystems.BuildingEnvelope.Floor2.Floor2_noVent(
            meetingRoom1(redeclare
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            meetingRoom2(redeclare replaceable
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            northZone(redeclare replaceable
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            southZone(redeclare
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            bathroomZone(hasCavityD=true,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr));
            //Zones with fixed n50 are independant from each other
          parameter Boolean allowFlowReversal = true
            "= false to simplify equations, assuming, but not enforcing, no flow reversal"
            annotation(Dialog(tab="Assumptions"), Evaluate=true);

          Modelica.Fluid.Interfaces.FluidPort_b[4] airOutlet(
            each m_flow(max=if allowFlowReversal then Modelica.Constants.inf else 0),
            redeclare each package Medium = Medium)
          "Air outlet port of the zones"
            annotation (Placement(transformation(extent={{-48,90},{-28,110}})));
          Modelica.Fluid.Interfaces.FluidPort_a[4] airInlet(
            each m_flow(min=if allowFlowReversal then
                                                     -Modelica.Constants.inf else 0),
            redeclare each package Medium = Medium)
          "Air inlet port of the zones"
            annotation (Placement(transformation(extent={{32,90},{52,110}})));
          Modelica.Fluid.Interfaces.FluidPort_b bathExtract(redeclare package
            Medium =
                Medium)
          "Extraction port of the toilets"
            annotation (Placement(transformation(extent={{-150,58},{-130,78}})));
          replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface bath_duct
            "Duct of the bathroom extraction (it does not have VAV)"
             annotation (Placement(
                transformation(
                extent={{-7,-7},{7,7}},
                rotation=180,
                origin={-103,81})));
        equation
          //Air exchange between zones
          connect(southZone.port_b, bathroomZone.port_a) annotation (Line(points={{-8,
                  -32},{-40,-32},{-76,-32},{-76,60},{-88,60}}, color={0,127,255}));
          connect(bathroomZone.port_b, bath_duct.port_a) annotation (Line(points={{-92,60},{-92,81},{-96,81}}, color={0,127,255}));
          connect(bath_duct.port_b, bathExtract) annotation (Line(points={{-110,81},{
                  -126,81},{-126,68},{-140,68}}, color={0,127,255}));
          //Air inlet connections
          connect(southZone.port_a, airInlet[2]) annotation (Line(points={{0,-32},{0,
                  -32},{0,82},{0,86},{42,86},{42,97.5}}, color={0,127,255}));
          connect(airInlet[1], northZone.port_a) annotation (Line(points={{42,92.5},{42,
                  86},{44,86},{44,80}}, color={0,127,255}));
          connect(meetingRoom1.port_a, airInlet[3]) annotation (Line(points={{-48,10},{
                  -48,10},{-48,42},{-34,42},{-34,92},{42,92},{42,102.5}}, color={0,127,
                  255}));
          connect(meetingRoom2.port_a, airInlet[4]) annotation (Line(points={{52,10},{
                  52,36},{68,36},{68,107.5},{42,107.5}}, color={0,127,255}));
          //Air outlet connections
          connect(northZone.port_b, airOutlet[1]) annotation (Line(points={{36,80},{2,
                  80},{-38,80},{-38,92.5}}, color={0,127,255}));
          connect(southZone.port_b, airOutlet[2]) annotation (Line(points={{-8,-32},{-8,
                  -32},{-8,56},{-38,56},{-38,97.5}}, color={0,127,255}));
          connect(airOutlet[3], meetingRoom1.port_b) annotation (Line(points={{-38,
                  102.5},{-38,102.5},{-38,54},{-38,46},{-52,46},{-52,10}}, color={0,127,
                  255}));
          connect(meetingRoom2.port_b, airOutlet[4]) annotation (Line(points={{48,10},{
                  48,36},{-38,36},{-38,107.5}}, color={0,127,255}));

          connect(northZone.ppm, dataBus.CO2_2ndFlr_NZ) annotation (Line(points={{62,60},
                  {-38,60},{-38,40.1},{-139.9,40.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(southZone.ppm, dataBus.CO2_2ndFlr_SZ) annotation (Line(points={{18,
                  -52},{28,-52},{28,24},{-139.9,24},{-139.9,40.1}}, color={0,0,127}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(meetingRoom1.ppm, dataBus.CO2_2ndFlr_MT1) annotation (Line(points={{
                  -39,0},{-36,0},{-36,40.1},{-139.9,40.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(meetingRoom2.ppm, dataBus.CO2_2ndFlr_MT2) annotation (Line(points={{
                  61,0},{68,0},{68,40.1},{-139.9,40.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
        end Floor2;

        model Floor2Sim
          extends Floor2(redeclare IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent
                                                                           bath_duct(
            allowFlowReversal=false,
            m_flow_nominal=250*1.225/3600,
            redeclare package Medium = Medium,
            from_dp=true,
              show_T=false,
              dpValve_nominal=50));
          Buildings.Controls.OBC.CDL.Continuous.Sources.Constant cav(k=1)
            annotation (Placement(transformation(extent={{-136,56},{-128,64}})));
        equation
          connect(cav.y, bath_duct.y) annotation (Line(points={{-127.6,60},{-103,60},{
                  -103,72.6}}, color={0,0,127}));
        end Floor2Sim;

        model Floor2_noVent

          replaceable package Medium = IDEAS.Media.Air constrainedby
          Modelica.Media.Interfaces.PartialMedium;
          outer IDEAS.BoundaryConditions.SimInfoManager sim "Data reader"
            annotation (Placement(transformation(extent={{-140,80},{-120,100}})));
          INFRAX.Data.Parameters.Str2ndFlr str2ndFlr "Record with the 2nd floor data"
            annotation (Placement(transformation(extent={{120,-100},{140,-80}})));
          INFRAX.Data.Parameters.Structure structure "General data record of the building"
            annotation (Placement(transformation(extent={{120,-80},{140,-60}})));
          IDEAS.Buildings.Components.Window northWindows(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=str2ndFlr.AWindows_2ndFlr_NZ,
            frac=str2ndFlr.FrameRatio_2ndFlr_NZ,
            redeclare IDEAS.Buildings.Components.Shading.None shaType,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            T_start=T_start)
            "Windows connected to the north landscape office"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={112,92})));
          IDEAS.Buildings.Components.OuterWall northWall(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=str2ndFlr.AWall_2ndFlr_NZ,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            T_start=T_start)
            "Outer wall connected to the north landscape office"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={88,92})));
          IDEAS.Buildings.Components.Zone northZone(
            V=str2ndFlr.Vol_2ndFlr_NZ,
            hZone=str2ndFlr.Height2ndFlr,
            nSurf=12,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
            "Northern landscape office"
            annotation (Placement(transformation(extent={{20,40},{60,80}})));
          IDEAS.Buildings.Components.RectangularZoneTemplate meetingRoom1(
            aziA=INFRAX.Data.Orientations.N,
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            l=str2ndFlr.l_2ndFlr_MTR1,
            w=str2ndFlr.w_2ndFlr_MTR1,
            h=str2ndFlr.Height2ndFlr,
            redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
              conTypFlo,
            nSurfExt=0,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall conTypCei,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            redeclare INFRAX.Data.Constructions.ReinforcedPlasterWall conTypA,
            redeclare INFRAX.Data.Constructions.ReinforcedPlasterWall conTypC,
            A_winA=str2ndFlr.AWindows_2ndFlr_MTR1,
            A_winC=str2ndFlr.AWindows_2ndFlr_MTR1,
            fracA=str2ndFlr.FrameRatio_2ndFlr_MTR1,
            fracC=str2ndFlr.FrameRatio_2ndFlr_MTR1,
            redeclare INFRAX.Data.Constructions.PlasterWallCavity conTypB,
            redeclare INFRAX.Data.Constructions.GlassWall conTypD,
            hasWinA=false,
            hasWinC=false,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
            "Meeting room next to 2nd floor reception"
            annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
          IDEAS.Buildings.Components.RectangularZoneTemplate meetingRoom2(
            aziA=INFRAX.Data.Orientations.N,
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            l=str2ndFlr.l_2ndFlr_MTR2,
            w=str2ndFlr.w_2ndFlr_MTR2,
            h=str2ndFlr.Height2ndFlr,
            redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
              conTypFlo,
            nSurfExt=0,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall conTypCei,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            redeclare INFRAX.Data.Constructions.GlassWall conTypB,
            redeclare INFRAX.Data.Constructions.PlasterWallCavity conTypD,
            redeclare INFRAX.Data.Constructions.ReinforcedPlasterWall conTypA,
            redeclare INFRAX.Data.Constructions.ReinforcedPlasterWall conTypC,
            A_winA=str2ndFlr.AWindows_2ndFlr_MTR2,
            A_winC=str2ndFlr.AWindows_2ndFlr_MTR2,
            fracA=str2ndFlr.FrameRatio_2ndFlr_MTR2,
            fracC=str2ndFlr.FrameRatio_2ndFlr_MTR2,
            redeclare IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
              shaTypA,
            redeclare INFRAX.Data.Frames.INFRAXWood fraTypA,
            hasWinA=false,
            hasWinC=false,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
            "Meeting room far from 2nd floor reception"
            annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          IDEAS.Buildings.Components.Zone southZone(
            hZone=str2ndFlr.Height2ndFlr,
            V=str2ndFlr.Vol_2ndFlr_SZ2,
            nSurf=28,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
            "Big southern landscape office"
            annotation (Placement(transformation(extent={{-24,-72},{16,-32}})));
          IDEAS.Buildings.Components.OuterWall[4] southWall(
            azi=str2ndFlr.azi_2ndFlr_SZ,
            A=str2ndFlr.AWall_2ndFlr_SZ,
            inc=str2ndFlr.inc_2ndFlr_SZ,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            T_start=T_start)
            "Array of walls connected to the southern landscape office"
            annotation (Placement(transformation(extent={{-96,-60},{-84,-40}})));
          IDEAS.Buildings.Components.Window[4] southWindows(
            azi=str2ndFlr.azi_2ndFlr_SZ,
            A=str2ndFlr.AWindows_2ndFlr_SZ,
            frac=str2ndFlr.FrameRatio_2ndFlr_SZ,
            inc=str2ndFlr.inc_2ndFlr_SZ,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            T_start=T_start,
            redeclare Data.Shading.HorizontalFins shaType)
            "Array of windows connected to the sourthern landscape office"
            annotation (Placement(transformation(extent={{-96,-84},{-84,-64}})));
          IDEAS.Buildings.Components.InternalWall[2] internalWalls(
            inc=IDEAS.Types.Tilt.Wall,
            A=str2ndFlr.AinternalWalls,
            azi={INFRAX.Data.Orientations.N,INFRAX.Data.Orientations.W},
            redeclare INFRAX.Data.Constructions.ReinforcedGlassWall constructionType,
            T_start=T_start)
            "Glass wall separating Copy rooms from south zone adding thermal
    mass to the south zone"
            annotation (Placement(
                transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={-28,20})));
          IDEAS.Buildings.Components.RectangularZoneTemplate bathroomZone(
            aziA=INFRAX.Data.Orientations.N,
            l=str2ndFlr.l_2ndFlr_BRZ,
            w=str2ndFlr.w_2ndFlr_BRZ,
            h=str2ndFlr.Height2ndFlr,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall conTypCei,
            redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
              conTypFlo,
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls conTypA,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypB,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypC,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypD,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start)
          "Bathroom zone, not conditioned and with air extraction"
            annotation (Placement(transformation(extent={{-100,40},{-80,60}})));

          IDEAS.Buildings.Components.InternalWall copyWalls(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=str2ndFlr.Awall_NZSZ,
            redeclare INFRAX.Data.Constructions.ReinforcedGlassWall constructionType,
            T_start=T_start,
            hasCavity=true,
            h=2.95,
            w=6)
            "Walls of copy rooms separating north/south zones, cavity lumps the corridor"
            annotation (Placement(
                transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={0,20})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[8] cei(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
           "Bus to connect the floor zones to the ceiling walls in the outer level"
            annotation (Placement(transformation(extent={{-20,120},{20,80}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[7] flo(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
           "Bus to connect the floor zones to the floor walls in the outer level"
            annotation (Placement(transformation(extent={{-20,-120},{20,-80}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[3] staW(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
           "Bus to connect the floor zones to the stair zones in the outer level"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-140,4})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[2] staE(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
           "Bus to connect the floor zones to the stair zones in the outer level"
            annotation (
              Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={140,0})));
          IDEAS.Buildings.Components.InternalWall staW_WallC(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=4.85*str2ndFlr.Height2ndFlr,
            redeclare INFRAX.Data.Constructions.ConcreteWall constructionType,
            T_start=T_start)
          "Southern internal wall towards the western stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{6,10},{-6,-10}},
                rotation=90,
                origin={-130,-28})));
          IDEAS.Buildings.Components.InternalWall staW_WallB(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.W,
            A=4.5*str2ndFlr.Height2ndFlr,
            redeclare INFRAX.Data.Constructions.ConcreteWall constructionType,
            T_start=T_start)
          "Eastern internal wall towards the west stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{-6,10},{6,-10}},
                rotation=0,
                origin={-68,80})));
          IDEAS.Buildings.Components.InternalWall staE_WallC(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=2.55*str2ndFlr.Height2ndFlr,
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            T_start=T_start)
          "Southern internal wall towards the east stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{6,10},{-6,-10}},
                rotation=90,
                origin={130,-28})));
          IDEAS.Buildings.Components.InternalWall staE_WallD(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.E,
            A=4.5*str2ndFlr.Height2ndFlr,
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            T_start=T_start)
          "Western internal wall towards the east stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{6,10},{-6,-10}},
                rotation=0,
                origin={114,30})));
         IDEAS.Buildings.Components.Interfaces.ZoneBus gflo(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
         "Bus to connect the floor zones to the ground floor ceiling walls in the outer
  level due to the glass hollow"
            annotation (Placement(transformation(extent={{-60,-120},{-20,-80}})));
          INFRAX.SubSystems.Controllers.DataBus dataBus
          "Bus containing data from different sensors" annotation (Placement(transformation(extent={{-160,20},{-120,
                    60}}),
                iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[5] gainCon
          "Bus to connect convective heat transfer to the zones"
            annotation (Placement(transformation(extent={{130,-60},{150,-40}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[5] gainRad
          "Bus to connect radiative heat transfer to the zones"
            annotation (Placement(transformation(extent={{130,-80},{150,-60}})));
          parameter Modelica.Fluid.Types.Dynamics energyDynamicsAir=Modelica.Fluid.Types.Dynamics.FixedInitial
          "Type of energy balance for air model: dynamic (3 initialization options) or steady state";
          parameter Real[5] A_Conv = {northZone.A, southZone.A, meetingRoom1.A, meetingRoom2.A, bathroomZone.A}
          "Convective area of zones";
          parameter Real mSenFac=5
          "Correction factor for thermal capacity of zone air.";
          Modelica.Blocks.Interfaces.RealInput[4] nOcc
          "No of occupants input" annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={70,-100})));
          parameter Modelica.SIunits.Temperature T_start=293.15
            "Start temperature for each of the layers";
          Modelica.Blocks.Sources.Constant noShad(k=0)
            "North windows are not controllable, hence signal is zero"
            annotation (Placement(transformation(extent={{-138,-96},{-126,-84}})));
          Modelica.Blocks.Math.Gain gain(k=2/3) annotation (Placement(transformation(
                extent={{-10,10},{10,-10}},
                rotation=180,
                origin={44,-44})));
          Modelica.Blocks.Math.Gain gain1(k=1/3) annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={92,12})));
        equation

          //northZone connections
          connect(northZone.propsBus[1], northWall.propsBus_a) annotation (Line(
              points={{20,71.6667},{20,71.6667},{20,87},{90,87}},
              color={255,204,51},
              thickness=0.5));
          connect(northZone.propsBus[2], northWindows.propsBus_a) annotation (Line(
              points={{20,71},{20,87},{114,87}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom1.proBusA[1], northZone.propsBus[3]) annotation (Line(
              points={{-56,9},{-56,9},{-56,70.3333},{20,70.3333}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom2.proBusA[1], northZone.propsBus[4]) annotation (Line(
              points={{44,9},{20,9},{20,69.6667}},
              color={255,204,51},
              thickness=0.5));
          //southZone connections
          connect(southZone.propsBus[1], southWall[1].propsBus_a) annotation (Line(
              points={{-24,-40.1429},{-48,-40.1429},{-48,-48},{-85,-48}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[2], southWall[2].propsBus_a);
          connect(southZone.propsBus[3], southWall[3].propsBus_a);
          connect(southZone.propsBus[4], southWall[4].propsBus_a);
          connect(southZone.propsBus[5], southWindows[1].propsBus_a) annotation (Line(
              points={{-24,-41.2857},{-24,-41.2857},{-22,-41.2857},{-48,-41.2857},{-48,
                  -72},{-85,-72}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[6], southWindows[2].propsBus_a);
          connect(southZone.propsBus[7], southWindows[3].propsBus_a);
          connect(southZone.propsBus[8], southWindows[4].propsBus_a);
          connect(southZone.propsBus[9], meetingRoom1.proBusC[1]) annotation (Line(
              points={{-24,-42.4286},{-24,-42.4286},{-24,-9.8},{-43.2,-9.8}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[10], meetingRoom2.proBusC[1]) annotation (Line(
              points={{-24,-42.7143},{-24,-42.7143},{-24,-20},{56.8,-20},{56.8,-9.8}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[12], meetingRoom1.proBusD[1]) annotation (Line(
              points={{-24,-43.2857},{-24,-43.2857},{-24,-20},{-66,-20},{-66,-7},{-59.6,
                  -7}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[13], meetingRoom2.proBusB[1]) annotation (Line(
              points={{-24,-43.5714},{-24,-20},{72,-20},{72,6},{59,6}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWalls[1].propsBus_a, southZone.propsBus[14]) annotation (Line(
              points={{-26,15},{-28,15},{-28,-40},{-28,-43.8571},{-24,-43.8571}},
              color={255,204,51},
              thickness=0.5));
          connect(bathroomZone.proBusC[1], southZone.propsBus[16]) annotation (Line(
              points={{-83.2,40.2},{-83.2,-34},{-24,-34},{-24,-44.4286}},
              color={255,204,51},
              thickness=0.5));
          connect(bathroomZone.proBusD[1], southZone.propsBus[17]) annotation (Line(
              points={{-99.6,43},{-100,43},{-100,-34},{-24,-34},{-24,-44.7143}},
              color={255,204,51},
              thickness=0.5));
          //Other connections
          connect(internalWalls[1].propsBus_b, southZone.propsBus[15]) annotation (Line(
              points={{-26,25},{-26,32},{-14,32},{-14,8},{-24,8},{-24,-44.1429}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[11], copyWalls.propsBus_a) annotation (Line(
              points={{-24,-43},{-22,-43},{-22,0},{0,0},{0,15},{2,15}},
              color={255,204,51},
              thickness=0.5));
          connect(copyWalls.propsBus_b, northZone.propsBus[5]) annotation (Line(
              points={{2,25},{2,25},{2,69},{20,69}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom1.proBusB[1], southZone.propsBus[18]) annotation (Line(
              points={{-41,6},{-34,6},{-34,4},{-24,4},{-24,-45}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom2.proBusD[1], southZone.propsBus[19]) annotation (Line(
              points={{40.4,-7},{8,-7},{8,-2},{-24,-2},{-24,-45.2857}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[20], internalWalls[2].propsBus_a) annotation (Line(
              points={{-24,-45.5714},{-26,-45.5714},{-26,-40},{-26,15}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWalls[2].propsBus_b, southZone.propsBus[21]) annotation (Line(
              points={{-26,25},{-26,36},{-12,36},{-12,4},{-24,4},{-24,-45.8571}},
              color={255,204,51},
              thickness=0.5));
          //Connections to the ceiling
          connect(northZone.propsBus[6], cei[1]);
          connect(northZone.propsBus[7], cei[6]);
          connect(northZone.propsBus[8], cei[7]);
          connect(northZone.propsBus[9], cei[8]);
          connect(southZone.propsBus[22], cei[2]);
          connect(meetingRoom1.proBusCei[1], cei[3]);
          connect(meetingRoom2.proBusCei[1], cei[4]);
          connect(bathroomZone.proBusCei[1], cei[5]);
          //Connections to the stairs
          connect(bathroomZone.proBusB[1], staW[3]) annotation (Line(
              points={{-81,56},{-80,56},{-80,68},{-80,70},{-140,70},{-140,-9.33333}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(southZone.propsBus[23], staW_WallC.propsBus_a) annotation (Line(
              points={{-24,-46.4286},{-76,-46.4286},{-128,-46.4286},{-128,-33}},
              color={255,204,51},
              thickness=0.5));
          connect(northZone.propsBus[10], staW_WallB.propsBus_a) annotation (Line(
              points={{20,65.6667},{16,65.6667},{16,78},{-63,78}},
              color={255,204,51},
              thickness=0.5));
          connect(staW_WallC.propsBus_b, staW[2]);
          connect(staW_WallB.propsBus_b, staW[1]);
          connect(southZone.propsBus[24], staE_WallC.propsBus_a) annotation (Line(
              points={{-24,-46.7143},{-20,-46.7143},{-20,-30},{132,-30},{132,-33}},
              color={255,204,51},
              thickness=0.5));
          connect(northZone.propsBus[11], staE_WallD.propsBus_a) annotation (Line(
              points={{20,65},{22,65},{22,40},{22,28},{109,28}},
              color={255,204,51},
              thickness=0.5));
          connect(staE_WallD.propsBus_b, staE[2]);
          connect(staE_WallC.propsBus_b, staE[1]);
          //Floor connections
          connect(northZone.propsBus[12], flo[1]);
          connect(southZone.propsBus[25], flo[2]) annotation (Line(
              points={{-24,-47},{-24,-47},{-24,-94},{-24,-111.429},{0,-111.429}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(southZone.propsBus[26], flo[3]);
          connect(southZone.propsBus[27], flo[7]);
          connect(meetingRoom1.proBusFlo[1], flo[4]);
          connect(meetingRoom2.proBusFlo[1], flo[5]);
          connect(bathroomZone.proBusFlo[1], flo[6]);
          connect(southZone.propsBus[28], gflo) annotation (Line(
              points={{-24,-47.8571},{-40,-47.8571},{-40,-100}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          //Data bus connections
          connect(northZone.TSensor, dataBus.T2ndFlr_NZ) annotation (Line(
              points={{62,64},{-38,64},{-38,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(southZone.TSensor, dataBus.T2ndFlr_SZ) annotation (Line(
              points={{18,-48},{-58,-48},{-58,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(meetingRoom1.TSensor, dataBus.T2ndFlr_MT1) annotation (Line(
              points={{-39,2},{-88,2},{-88,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(meetingRoom2.TSensor, dataBus.T2ndFlr_MT2) annotation (Line(
              points={{61,2},{-39.7,2},{-39.7,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          //Windows control signal
          connect(noShad.y, southWindows[1].Ctrl);
          connect(dataBus.eastShading2nd, southWindows[2].Ctrl);
          connect(dataBus.southShading, southWindows[3].Ctrl);
          connect(dataBus.westShading, southWindows[4].Ctrl);
          //Conective and radiative connections
          connect(northZone.gainCon, gainCon[1]);
          connect(northZone.gainRad, gainRad[1]);
          connect(southZone.gainRad, gainRad[2]);
          connect(southZone.gainCon, gainCon[2]);
          connect(meetingRoom1.gainCon, gainCon[3]);
          connect(meetingRoom1.gainRad, gainRad[3]);
          connect(meetingRoom2.gainCon, gainCon[4]);
          connect(meetingRoom2.gainRad, gainRad[4]);
          connect(bathroomZone.gainCon, gainCon[5]);
          connect(bathroomZone.gainRad, gainRad[5]);
          //Occupancy connections
          connect(nOcc[3], meetingRoom1.yOcc) annotation (Line(points={{70,-95},{70,-95},
                  {70,-26},{-30,-26},{-30,4},{-38,4}},       color={0,0,127}));
          connect(nOcc[4], meetingRoom2.yOcc) annotation (Line(points={{70,-85},{70,-85},
                  {70,2},{70,4},{62,4}},       color={0,0,127}));
          connect(southZone.yOcc, gain.y)
            annotation (Line(points={{20,-44},{33,-44}}, color={0,0,127}));
          connect(gain.u, nOcc[2])
            annotation (Line(points={{56,-44},{70,-44},{70,-105}}, color={0,0,127}));
          connect(nOcc[1], gain1.u) annotation (Line(points={{70,-115},{70,-60},{92,-60},
                  {92,0}}, color={0,0,127}));
          connect(gain1.y, northZone.yOcc)
            annotation (Line(points={{92,23},{92,68},{64,68}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-140,
                    -100},{140,100}}), graphics={
                  Rectangle(extent={{-140,100},{140,-100}},
                                                        lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                Text(
                  extent={{-70,70},{70,-70}},
                  lineColor={28,108,200},
                  textString="2")}), Diagram(coordinateSystem(preserveAspectRatio=false,
                  extent={{-140,-100},{140,100}})));
        end Floor2_noVent;
      end Floor2;

      package Floor3

        model Floor3
          extends INFRAX.SubSystems.BuildingEnvelope.Floor3.Floor3_noVent(
                                    southZone(redeclare
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            bathroomZone(hasCavityC=true,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            copyRoom(hasCavityC=true,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            meetingRoom(redeclare
                IDEAS.Buildings.Components.InterzonalAirFlow.n50FixedPressure
                interzonalAirFlow,
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr),
            smallRoom(
              redeclare IDEAS.Buildings.Components.RoomType.Office rooTyp,
              redeclare IDEAS.Buildings.Components.LightingType.LED ligTyp,
              redeclare IDEAS.Buildings.Components.LightingControl.OccupancyBased
                ligCtr));

          //Meeting Room does not exchange mass with any other zones
          //Bathroom and copy room usually have door open
          parameter Boolean allowFlowReversal = true
            "= false to simplify equations, assuming, but not enforcing, no flow reversal"
            annotation(Dialog(tab="Assumptions"), Evaluate=true);

          Modelica.Fluid.Interfaces.FluidPort_b[4] airOutlet(
            each m_flow(max=if allowFlowReversal then Modelica.Constants.inf else 0),
            redeclare each package Medium = Medium)
            "Air outlet port of the zones"
            annotation (Placement(transformation(extent={{-54,90},{-34,110}})));
          Modelica.Fluid.Interfaces.FluidPort_a[4] airInlet(
            each m_flow(min=if allowFlowReversal then -Modelica.Constants.inf else 0),
            redeclare each package Medium = Medium)
            "Air inlet port of the zones"
            annotation (Placement(transformation(extent={{26,90},{46,110}})));
          Modelica.Fluid.Interfaces.FluidPort_b bathExtract(redeclare package
            Medium =
                Medium)
            "Extraction port of the toilets"
            annotation (Placement(transformation(extent={{-150,56},{-130,76}})));

          replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface bath_duct
            "Duct of the bathroom extraction (it does not have VAV)"
             annotation (Placement(
                transformation(
                extent={{-7,-7},{7,7}},
                rotation=180,
                origin={-97,79})));
          IDEAS.Fluid.FixedResistances.PressureDrop res(
            redeclare package Medium = Medium,
            allowFlowReversal=allowFlowReversal,
            m_flow_nominal=0.1,
            dp_nominal=0)
           "For breaking algebraic loop using allowFlowReversal=false"
            annotation (Placement(transformation(extent={{76,2},{96,22}})));
          IDEAS.Fluid.FixedResistances.PressureDrop res1(
            redeclare package Medium = Medium,
            allowFlowReversal=allowFlowReversal,
            m_flow_nominal=0.1,
            dp_nominal=0)
           "For breaking algebraic loop using allowFlowReversal=false"
            annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={10,26})));

        equation
          //Inlet air connections
          connect(airInlet[1], southZone.port_a) annotation (Line(points={{36,92.5},{32,
                  92.5},{32,66},{18,66},{18,-20},{4,-20}}, color={0,127,255}));
          connect(airInlet[2], copyRoom.port_a) annotation (Line(points={{36,97.5},{32,
                  97.5},{32,66},{-8,66},{-8,60}},         color={0,127,255}));
          connect(airInlet[4], meetingRoom.port_a) annotation (Line(points={{36,107.5},{36,60},{32,60}}, color={0,127,255}));
          connect(airInlet[3], smallRoom.port_a) annotation (Line(points={{36,102.5},{
                  54,102.5},{72,102.5},{72,60}}, color={0,127,255}));
          //Outlet air connections
          connect(southZone.port_b, airOutlet[1]) annotation (Line(points={{-4,-20},{-4,
                  36},{-24,36},{-24,88},{-44,88},{-44,92.5}}, color={0,127,255}));
          connect(copyRoom.port_b, airOutlet[2]) annotation (Line(points={{-12,60},{-12,
                  88},{-44,88},{-44,97.5}}, color={0,127,255}));
          connect(meetingRoom.port_b, airOutlet[4]) annotation (Line(points={{28,60},{
                  28,60},{28,88},{-44,88},{-44,107.5}},             color={0,127,255}));
          connect(smallRoom.port_b, airOutlet[3]) annotation (Line(points={{68,60},{68,
                  60},{68,88},{68,88},{-44,88},{-44,102.5}}, color={0,127,255}));
          //Air exchange between zones
          connect(southZone.port_b, bathroomZone.port_a) annotation (Line(points={{-4,
                  -20},{-4,-4},{-32,-4},{-32,60},{-48,60}}, color={0,127,255}));
          connect(bathroomZone.port_b, bath_duct.port_a) annotation (Line(points={{-52,60},
                  {-70,60},{-70,79},{-90,79}},     color={0,127,255}));
          connect(bath_duct.port_b, bathExtract) annotation (Line(points={{-104,79},{
                  -120,79},{-120,66},{-140,66}}, color={0,127,255}));
          connect(southZone.port_b, res.port_a) annotation (Line(points={{-4,-20},{-4,12},{76,12}}, color={0,127,255}));
          connect(res.port_b, smallRoom.port_a) annotation (Line(points={{96,12},{108,
                  12},{108,60},{72,60}}, color={0,127,255}));
          connect(res1.port_a, southZone.port_b) annotation (Line(points={{10,16},{10,
                  10},{-4,10},{-4,-20}}, color={0,127,255}));
          connect(res1.port_b, copyRoom.port_a) annotation (Line(points={{10,36},{10,60},{-8,60}}, color={0,127,255}));

          connect(southZone.ppm, dataBus.CO2_3rdFlr_SZ) annotation (Line(points={{22,
                  -40},{38,-40},{38,20},{-82,20},{-82,40},{-139.9,40},{-139.9,40.1}},
                color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(copyRoom.ppm, dataBus.CO2_3rdFlr_CPR) annotation (Line(points={{1,50},
                  {6,50},{6,70},{-92,70},{-92,40.1},{-139.9,40.1}}, color={0,0,127}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(meetingRoom.ppm, dataBus.CO2_3rdFlr_MTR) annotation (Line(points={{41,
                  50},{48,50},{48,70},{-92,70},{-92,40.1},{-139.9,40.1}}, color={0,0,
                  127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(smallRoom.ppm, dataBus.CO2_3rdFlr_SmaR) annotation (Line(points={{81,
                  50},{88,50},{88,70},{-92,70},{-92,40.1},{-139.9,40.1}}, color={0,0,
                  127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
        end Floor3;

        model Floor3Sim
          extends Floor3(redeclare IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent
                                                                           bath_duct(
            allowFlowReversal=false,
            m_flow_nominal=250*1.225/3600,
            redeclare package Medium = Medium,
            from_dp=true,
              dpValve_nominal=50,
              use_inputFilter=false));
          Buildings.Controls.OBC.CDL.Continuous.Sources.Constant cav(k=1)
            annotation (Placement(transformation(extent={{-136,56},{-128,64}})));
        equation
          connect(cav.y, bath_duct.y) annotation (Line(points={{-127.6,60},{-97,60},{
                  -97,70.6}}, color={0,0,127}));
        end Floor3Sim;

        model Floor3_noVent

          replaceable package Medium = IDEAS.Media.Air constrainedby
          Modelica.Media.Interfaces.PartialMedium;

          INFRAX.Data.Parameters.Str3rdFlr str3rdFlr "Record with 3rd floor data"
            annotation (Placement(transformation(extent={{120,-100},{140,-80}})));
          outer IDEAS.BoundaryConditions.SimInfoManager sim "Data reader"
            annotation (Placement(transformation(extent={{-140,80},{-120,100}})));
          IDEAS.Buildings.Components.Window southWindow1(
            A=str3rdFlr.AWindows_3rdFlr_SZ[1],
            redeclare IDEAS.Buildings.Components.Shading.None shaType,
            frac=str3rdFlr.FrameRatio_3rdFlr_SZ[1],
            inc=str3rdFlr.inc_3rdFlr_SZ[1],
            azi=str3rdFlr.azi_3rdFlr_SZ[1],
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            T_start=T_start)
          "Windows of the south zone pointing north (just window next to bathroom)"
          annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={-90,-14})));
          IDEAS.Buildings.Components.Window southWindow2(
            A=str3rdFlr.AWindows_3rdFlr_SZ[2],
            frac=str3rdFlr.FrameRatio_3rdFlr_SZ[2],
            inc=str3rdFlr.inc_3rdFlr_SZ[2],
            azi=str3rdFlr.azi_3rdFlr_SZ[2],
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            T_start=T_start,
            redeclare Data.Shading.HorizontalFins shaType)
          "Windows of the south zone pointing east"
          annotation (Placement(transformation(
                extent={{6,-10},{-6,10}},
                rotation=0,
                origin={-72,-30})));
          IDEAS.Buildings.Components.Window southWindow3(
            A=str3rdFlr.AWindows_3rdFlr_SZ[3],
            frac=str3rdFlr.FrameRatio_3rdFlr_SZ[3],
            inc=str3rdFlr.inc_3rdFlr_SZ[3],
            azi=str3rdFlr.azi_3rdFlr_SZ[3],
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            T_start=T_start,
            redeclare Data.Shading.HorizontalFins shaType)
            "Windows of the south zone pointing south"
           annotation (Placement(transformation(
                extent={{6,-10},{-6,10}},
                rotation=-90,
                origin={-90,-54})));
          IDEAS.Buildings.Components.Window southWindow4(
            A=str3rdFlr.AWindows_3rdFlr_SZ[4],
            frac=str3rdFlr.FrameRatio_3rdFlr_SZ[4],
            inc=str3rdFlr.inc_3rdFlr_SZ[4],
            azi=str3rdFlr.azi_3rdFlr_SZ[4],
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            T_start=T_start,
            redeclare Data.Shading.HorizontalFins shaType)
          "Windows of the south zone pointing west"
           annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=0,
                origin={-110,-30})));


          IDEAS.Buildings.Components.OuterWall[4] southWalls(
            A=str3rdFlr.AWall_3rdFlr_SZ,
            inc=str3rdFlr.inc_3rdFlr_SZ,
            azi=str3rdFlr.azi_3rdFlr_SZ,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls constructionType,
            T_start=T_start)
          "Array of walls transferring heat to the south zone"
           annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={-34,-2})));

          IDEAS.Buildings.Components.RectangularZoneTemplate bathroomZone(
            aziA=INFRAX.Data.Orientations.N,
            l=str3rdFlr.l_3rdFlr_BRZ,
            w=str3rdFlr.w_3rdFlr_BRZ,
            h=str3rdFlr.Height3rdFlr,
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
              conTypFlo,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls conTypA,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypB,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypC,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypD,
            redeclare INFRAX.Data.Constructions.Roof conTypCei,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start)
          "Bathroom zone, not conditioned with air extraction"
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          INFRAX.SubSystems.BuildingEnvelope.Floor3.Interfaces.RectangularZoneTABS copyRoom(
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            aziA=INFRAX.Data.Orientations.N,
            l=str3rdFlr.l_3rdFlr_CPR,
            w=str3rdFlr.w_3rdFlr_CPR,
            h=str3rdFlr.Height3rdFlr,
            redeclare IDEAS.Buildings.Data.Constructions.CavityWall conTypB,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
              conTypFlo,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            hasWinA=true,
            A_winA=str3rdFlr.AWindows_3rdFlr_CPR,
            redeclare IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
              shaTypA,
            fracA=str3rdFlr.FrameRatio_3rdFlr_CPR,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls conTypA,
            redeclare INFRAX.Data.Constructions.ConcreteWall conTypD,
            redeclare INFRAX.Data.Constructions.PlasterWall conTypC,
            redeclare INFRAX.Data.Frames.INFRAXWood fraTypA,
            redeclare INFRAX.Data.Constructions.Roof conTypCei,
            hasTABSCei=true,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazingA,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            outCei(energyDynamics=energyDynamicsTABS),
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
          "Open room with the copy machine"
            annotation (Placement(transformation(extent={{-20,40},{0,60}})));
          IDEAS.Buildings.Components.Zone southZone(
            hZone=str3rdFlr.Height3rdFlr,
            V=str3rdFlr.Vol_3rdFlr_SZ,
            nSurf=21,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
          "Big landscape office situated in the south sector of the floor"
            annotation (Placement(transformation(extent={{-20,-60},{20,-20}})));
          INFRAX.SubSystems.BuildingEnvelope.Floor3.Interfaces.RectangularZoneTABS meetingRoom(
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            aziA=INFRAX.Data.Orientations.N,
            l=str3rdFlr.l_3rdFlr_MTR,
            w=str3rdFlr.w_3rdFlr_MTR,
            h=str3rdFlr.Height3rdFlr,
            redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
              conTypFlo,
            hasWinA=true,
            A_winA=str3rdFlr.AWindows_3rdFlr_MTR,
            redeclare IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
              shaTypA,
            fracA=str3rdFlr.FrameRatio_3rdFlr_MTR,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls conTypA,
            redeclare INFRAX.Data.Constructions.PlasterWall conTypB,
            redeclare INFRAX.Data.Constructions.GlassWall conTypC,
            redeclare INFRAX.Data.Constructions.PlasterWall conTypD,
            redeclare INFRAX.Data.Frames.INFRAXWood fraTypA,
            redeclare INFRAX.Data.Constructions.Roof conTypCei,
            hasTABSCei=true,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazingA,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            outCei(energyDynamics=energyDynamicsTABS),
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.Occupants.Input occNum,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
          "Big glazed meeting room situated in the mid-north face of the floor"
            annotation (Placement(transformation(extent={{20,40},{40,60}})));
          INFRAX.SubSystems.BuildingEnvelope.Floor3.Interfaces.RectangularZoneTABS smallRoom(
            bouTypA=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            bouTypC=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            bouTypD=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            hasWinA=true,
            aziA=INFRAX.Data.Orientations.N,
            w=str3rdFlr.w_3rdFlr_SmaR,
            h=str3rdFlr.Height3rdFlr,
            fracA=str3rdFlr.FrameRatio_3rdFlr_SmaR,
            redeclare IDEAS.Buildings.Components.Shading.Interfaces.ShadingProperties
              shaTypA,
            bouTypCei=IDEAS.Buildings.Components.Interfaces.BoundaryType.OuterWall,
            redeclare IDEAS.Buildings.Validation.Data.Constructions.HeavyFloor
              conTypFlo,
            nSurfExt=2,
            A_winA=2*str3rdFlr.AWindows_3rdFlr_SmaR,
            l=str3rdFlr.l_3rdFlr_SmaR + str3rdFlr.l_3rdFlr_StoR + 0.08,
            bouTypFlo=IDEAS.Buildings.Components.Interfaces.BoundaryType.External,
            bouTypB=IDEAS.Buildings.Components.Interfaces.BoundaryType.InternalWall,
            redeclare replaceable INFRAX.Data.Constructions.OuterWalls conTypA,
            redeclare INFRAX.Data.Constructions.SilicateWall conTypB,
            redeclare INFRAX.Data.Constructions.PlasterWall conTypC,
            redeclare INFRAX.Data.Frames.INFRAXWood fraTypA,
            redeclare INFRAX.Data.Constructions.Roof conTypCei,
            hasTABSCei=true,
            energyDynamicsAir=energyDynamicsAir,
            n50=1.3,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazingA,
            redeclare package Medium = Medium,
            mSenFac=mSenFac,
            outCei(energyDynamics=energyDynamicsTABS),
            T_start=T_start,
            redeclare IDEAS.Buildings.Components.OccupancyType.OfficeWork occTyp)
          "Very small lumped office in the north-east of the floor"
            annotation (Placement(transformation(extent={{60,40},{80,60}})));
          IDEAS.Buildings.Components.InternalWall internalWall(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.W,
            A=5*str3rdFlr.Height3rdFlr,
            redeclare INFRAX.Data.Constructions.PlasterWall constructionType,
            T_start=T_start)
          "Internal wall adding thermal mass to the lumped small offices"
            annotation (Placement(transformation(extent={{68,94},{56,74}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[8] flo(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
          "Bus to connect the floor zones to the floor-walls in the outer level"
            annotation (Placement(transformation(extent={{-20,-120},{20,-80}})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[3] staW(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
          "Bus to connect the floor zones to the stair zones in the outer level"
            annotation (Placement(transformation(extent={{-20,-20},{20,20}},
                rotation=-90,
                origin={-140,4})));
          IDEAS.Buildings.Components.Interfaces.ZoneBus[2] staE(each numIncAndAziInBus=
                sim.numIncAndAziInBus)
          "Bus to connect the floor zones to the stair zones in the outer level"
            annotation (
              Placement(transformation(
                extent={{-20,20},{20,-20}},
                rotation=-90,
                origin={140,0})));
          IDEAS.Buildings.Components.InternalWall staW_WallC(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=3.55*str3rdFlr.Height3rdFlr,
            redeclare INFRAX.Data.Constructions.ConcreteWall constructionType,
            T_start=T_start)
          "Southern internal wall towards the west stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{6,10},{-6,-10}},
                rotation=90,
                origin={-130,-28})));
          IDEAS.Buildings.Components.InternalWall staE_WallC(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            A=2.55*str3rdFlr.Height3rdFlr,
            redeclare INFRAX.Data.Constructions.SilicateWall constructionType,
            T_start=T_start)
         "Southern internal wall towards the east stair zone in the outer level"
            annotation (Placement(transformation(
                extent={{6,10},{-6,-10}},
                rotation=90,
                origin={130,-30})));
          IDEAS.Buildings.Components.OuterWall inclinatedRoof(
            redeclare INFRAX.Data.Constructions.StepRoof constructionType,
            azi=0,
            inc=str3rdFlr.inc_roof,
            A=str3rdFlr.A_3rdFlr_SZ,
            energyDynamics=energyDynamicsTABS,
            T_start=T_start)
            "inclinated roof of southzone" annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={-50,-46})));
          IDEAS.Buildings.Components.Window high_windows(
            inc=IDEAS.Types.Tilt.Wall,
            azi=INFRAX.Data.Orientations.N,
            redeclare INFRAX.Data.Frames.INFRAXWood fraType,
            redeclare IDEAS.Buildings.Components.Shading.None shaType,
            A=str3rdFlr.AWindoiws_3rdFlr_HW,
            frac=str3rdFlr.FrameRatio_3rdFlr_HW,
            redeclare INFRAX.Data.Glazing.SGGCLIMAPLUSONE4dash15dash6 glazing,
            T_start=T_start)
           "Small windows of the 3rd floor, placed almost at ceiling level"
            annotation (Placement(transformation(
                extent={{-6,-10},{6,10}},
                rotation=-90,
                origin={-104,-2})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[4] port_emb
          "Embedded port towards outer walls in the roof"
            annotation (Placement(transformation(extent={{-10,90},{10,110}})));
          INFRAX.SubSystems.Controllers.DataBus dataBus
          "Bus containing data from different sensors"
           annotation (Placement(transformation(extent={{-160,20},{-120,
                    60}}),
                iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[5] gainCon
          "Bus to connect convective heat transfer to the zones"
            annotation (Placement(transformation(extent={{130,-60},{150,-40}})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[5] gainRad
          "Bus to connect the radiative heat transfer to the zones"
            annotation (Placement(transformation(extent={{130,-80},{150,-60}})));
          parameter Modelica.Fluid.Types.Dynamics energyDynamicsAir=Modelica.Fluid.Types.Dynamics.FixedInitial
            "Type of energy balance for air model: dynamic (3 initialization options) or steady state";
          parameter Modelica.Fluid.Types.Dynamics energyDynamicsTABS=Modelica.Fluid.Types.Dynamics.FixedInitial
            "Type of energy balance for air model: dynamic (3 initialization options) or steady state";

          parameter Real[5] A_Conv = {southZone.A, copyRoom.A, meetingRoom.A, smallRoom.A,
          bathroomZone.A} "Convective area of zones";
          parameter Modelica.SIunits.Area[4] ATabs = {inclinatedRoof.A,copyRoom.A, meetingRoom.A,
          smallRoom.A} "Area of TABS ceiling";

          parameter Real mSenFac=5
            "Correction factor for thermal capacity of zone air.";
          Modelica.Blocks.Interfaces.RealInput[2] nOcc annotation (Placement(
                transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={80,-100})));
          parameter Modelica.SIunits.Temperature T_start=293.15
            "Start temperature for each of the layers";
        equation
          //Connections to the floor
          connect(southZone.propsBus[14], flo[1])  annotation (Line(
              points={{-20,-33.1429},{-20,-33.1429},{-20,-80},{0,-80},{0,-117.5}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(southZone.propsBus[15], flo[2]);
          connect(southZone.propsBus[16], flo[3]);
          connect(southZone.propsBus[17], flo[4]);
          connect(bathroomZone.proBusFlo[1], flo[5]) annotation (Line(
              points={{-50,44},{-36,44},{-36,-98},{0,-98},{0,-97.5}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(copyRoom.proBusFlo[1], flo[6]);
          connect(meetingRoom.proBusFlo[1], flo[7]);
          connect(smallRoom.proBusFlo[1], flo[8]);

          //External connections of southZone
          connect(southZone.propsBus[1], southWalls[1].propsBus_a) annotation (Line(
              points={{-20,-28.1905},{-38,-28.1905},{-38,-7},{-32,-7}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[2], southWalls[2].propsBus_a);
          connect(southZone.propsBus[3], southWalls[3].propsBus_a);
          connect(southZone.propsBus[4], southWalls[4].propsBus_a);
          connect(southZone.propsBus[5], southWindow1.propsBus_a) annotation (Line(
              points={{-20,-29.7143},{-88,-29.7143},{-88,-19}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[6], southWindow2.propsBus_a) annotation (Line(
              points={{-20,-30.0952},{-77,-30.0952},{-77,-28}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[7], southWindow3.propsBus_a) annotation (Line(
              points={{-20,-30.4762},{-88,-30.4762},{-88,-49}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[8], southWindow4.propsBus_a) annotation (Line(
              points={{-20,-30.8571},{-105,-30.8571},{-105,-28}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[9], bathroomZone.proBusC[1]) annotation (Line(
              points={{-20,-31.2381},{-22,-31.2381},{-22,26},{-43.2,26},{-43.2,40.2}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[10], bathroomZone.proBusD[1]) annotation (Line(
              points={{-20,-31.619},{-22,-31.619},{-22,26},{-68,26},{-68,43},{-59.6,43}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[11], copyRoom.proBusC[1]) annotation (Line(
              points={{-20,-32},{-20,-32},{-20,36},{-3.2,36},{-3.2,40.2}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom.proBusC[1], southZone.propsBus[12]) annotation (Line(
              points={{36.8,40.2},{36.8,24},{-20,24},{-20,-32.381}},
              color={255,204,51},
              thickness=0.5));
          connect(smallRoom.proBusC[1], southZone.propsBus[13]) annotation (Line(
              points={{76.8,40.2},{76.8,2},{-20,2},{-20,-32.7619}},
              color={255,204,51},
              thickness=0.5));
          //14, 15, 16 and 17 go to the floor
          connect(southZone.propsBus[18], staW_WallC.propsBus_a) annotation (Line(
              points={{-20,-34.6667},{-74,-34.6667},{-74,-33},{-128,-33}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[19], staE_WallC.propsBus_a) annotation (Line(
              points={{-20,-35.0476},{-20,-16},{104,-16},{104,-35},{132,-35}},
              color={255,204,51},
              thickness=0.5));
          connect(southZone.propsBus[20], inclinatedRoof.propsBus_a) annotation (Line(
              points={{-20,-35.4286},{-20,-35.4286},{-20,-58},{-20,-60},{-48,-60},{-48,
                  -51}},
              color={255,204,51},
              thickness=0.5));
          connect(high_windows.propsBus_a, southZone.propsBus[21]) annotation (Line(
              points={{-102,-7},{-102,-7},{-102,-35.8095},{-20,-35.8095}},
              color={255,204,51},
              thickness=0.5));

          //External connections of other zones
          connect(meetingRoom.proBusD[1], copyRoom.proBusB[1]) annotation (Line(
              points={{20.4,43},{6,43},{6,56},{-1,56}},
              color={255,204,51},
              thickness=0.5));
          connect(meetingRoom.proBusB[1], smallRoom.proBusD[1]) annotation (Line(
              points={{39,56},{46,56},{46,52},{60.4,52},{60.4,43}},
              color={255,204,51},
              thickness=0.5));
          connect(smallRoom.proBusExt[1], internalWall.propsBus_a) annotation (Line(
              points={{58,59},{58,82},{57,82}},
              color={255,204,51},
              thickness=0.5));
          connect(internalWall.propsBus_b, smallRoom.proBusExt[2]) annotation (Line(
              points={{67,82},{68,82},{68,68},{68,61},{58,61}},
              color={255,204,51},
              thickness=0.5));
          connect(bathroomZone.proBusB[1], staW[3]) annotation (Line(
              points={{-41,56},{-26,56},{-26,66},{-140,66},{-140,-9.33333}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(staW_WallC.propsBus_b, staW[2]);
          connect(copyRoom.proBusD[1], staW[1]) annotation (Line(
              points={{-19.6,43},{-18,43},{-18,66},{-140,66},{-140,17.3333}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(smallRoom.proBusB[1], staE[2]) annotation (Line(
              points={{79,56},{106,56},{130,56},{130,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(staE_WallC.propsBus_b, staE[1]);

          //Embedded port connections
          connect(inclinatedRoof.port_emb[1], port_emb[1]) annotation (Line(points={{
                  -60,-46},{-118,-46},{-118,92.5},{0,92.5}}, color={191,0,0}));
          connect(copyRoom.port_emb, port_emb[2]) annotation (Line(points={{0,41},{12,
                  41},{12,97.5},{0,97.5}}, color={191,0,0}));
          connect(meetingRoom.port_emb, port_emb[3]) annotation (Line(points={{40,41},{
                  44,41},{44,42},{44,102.5},{0,102.5}}, color={191,0,0}));
          connect(smallRoom.port_emb, port_emb[4]) annotation (Line(points={{80,41},{92,
                  41},{92,107.5},{0,107.5}}, color={191,0,0}));

          //Sensors connected to the data bus
          connect(copyRoom.TSensor, dataBus.T3rdFlr_CPR) annotation (Line(
              points={{1,52},{-68,52},{-68,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(meetingRoom.TSensor, dataBus.T3rdFlr_MTR) annotation (Line(
              points={{41,52},{-48,52},{-48,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(smallRoom.TSensor, dataBus.T3rdFlr_SmaR) annotation (Line(
              points={{81,52},{-28,52},{-28,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(southZone.TSensor, dataBus.T3rdFlr_SZ) annotation (Line(
              points={{22,-36},{-60,-36},{-60,40.1},{-139.9,40.1}},
              color={0,0,127},
              visible=false), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));

          //Windows control signals
          connect(dataBus.eastShading3rd, southWindow2.Ctrl);
          connect(dataBus.southShading, southWindow3.Ctrl);
          connect(dataBus.westShading,southWindow4.Ctrl);

          //Convective and radiative connections
          connect(southZone.gainCon, gainCon[1]);
          connect(southZone.gainRad, gainRad[1]);
          connect(copyRoom.gainCon, gainCon[2]);
          connect(copyRoom.gainRad, gainRad[2]);
          connect(meetingRoom.gainCon, gainCon[3]);
          connect(meetingRoom.gainRad, gainRad[3]);
          connect(smallRoom.gainCon, gainCon[4]);
          connect(smallRoom.gainRad, gainRad[4]);
          connect(bathroomZone.gainCon, gainCon[5]);
          connect(bathroomZone.gainRad, gainRad[5]);

          //Occupancy connections
          connect(nOcc[1], southZone.yOcc) annotation (Line(points={{80,-110},{80,-110},
                  {80,-34},{24,-34},{24,-32}},       color={0,0,127}));
          connect(nOcc[2], meetingRoom.yOcc) annotation (Line(points={{80,-90},{82,-90},
                  {82,-4},{50,-4},{50,54},{42,54}},       color={0,0,127}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-140,-100},
                    {140,100}}), graphics={
                  Rectangle(extent={{-140,100},{140,-100}},
                                                        lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                Text(
                  extent={{-70,70},{70,-70}},
                  lineColor={28,108,200},
                  textString="3")}),                                   Diagram(
              coordinateSystem(preserveAspectRatio=false, extent={{-140,-100},{140,100}})));
        end Floor3_noVent;

        package Interfaces

          model RectangularZoneTABS "Rectangular zone with TABS in the ceiling"
            extends IDEAS.Buildings.Components.RectangularZoneTemplate;

            parameter Boolean hasTABSCei = false
            "Activating TABS on Ceiling"
            annotation(Dialog(tab="Ceiling", group="TABS details"));

        public
              Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_emb if hasTABSCei
              "embedded port for TABS"
              annotation (Placement(transformation(extent={{90,-100},{110,-80}})));

          equation
              if hasTABSCei then
                connect(outCei.port_emb[1], port_emb);
              end if;

          end RectangularZoneTABS;
        end Interfaces;
      end Floor3;
    end BuildingEnvelope;

    package HeatingSystem

      model HeatingSystem "detailed heating system for simulation with TACO"

         replaceable package MediumGlycol =
             IDEAS.Media.Antifreeze.Validation.BaseClasses.PropyleneGlycolWater
          (      property_T=273.15,
                 X_a=0.30) constrainedby
        Modelica.Media.Interfaces.PartialMedium;
      //     replaceable package MediumGlycol = IDEAS.Media.Water;

        IDEAS.Fluid.Movers.SpeedControlled_y pump1(
          allowFlowReversal=false,
          addPowerToMedium=false,
          redeclare IDEAS.Fluid.Movers.Data.Pumps.Wilo.VeroLine50slash150dash4slash2
            per,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          y_start=0,
          tau=60,
          riseTime=120,
          use_inputFilter=false,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          redeclare package Medium = MediumGlycol,
          VMachine_flow(start=0.005))
                        annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-150,-52})));
        IDEAS.Fluid.Sources.Boundary_pT boundary(
          nPorts=2,
          redeclare package Medium = MediumGlycol,
          p=200000) annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=-90,
              origin={-28,-164})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t14(redeclare package Medium =
              IDEAS.Media.Water,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p03_m_flow,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15)
          annotation (Placement(transformation(extent={{-4,28},{-20,42}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t1(
          allowFlowReversal=false,
                                 m_flow_nominal=24000/3600,
          tau=hydronic.sensorTau,
          transferHeat=false,
          redeclare package Medium = MediumGlycol,
          T_start=283.15,
          TAmb=291.15)
          annotation (Placement(transformation(extent={{-166,-176},{-178,-162}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t7(
          allowFlowReversal=false,
                                 m_flow_nominal=24000/3600,
          tau=hydronic.sensorTau,
          transferHeat=false,
          redeclare package Medium = MediumGlycol,
          T_start=283.15,
          TAmb=291.15)
          annotation (Placement(transformation(extent={{6,-7},{-6,7}},
              rotation=90,
              origin={-102,-155})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t19(
          redeclare package Medium = IDEAS.Media.Water,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p03_m_flow,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15)
                   annotation (Placement(transformation(extent={{78,-16},{94,-2}})));
        IDEAS.Fluid.Movers.FlowControlled_dp pump3(
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal=hydronic.p03_m_flow,
          allowFlowReversal=false,
          addPowerToMedium=false,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          redeclare
            IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos65slash1to12_CAN_PN6slash10 per,
          y_start=1,
          tau=60,
          riseTime=120,
          use_inputFilter=false,
          dp_nominal(displayUnit="kPa") = 7.4*9804.139432,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
          annotation (Placement(transformation(extent={{-26,26},{-44,44}})));
        Data.Parameters.Hydronic hydronic
          annotation (Placement(transformation(extent={{-200,120},{-180,140}})));
        IDEAS.Fluid.MixingVolumes.MixingVolume buffTank(
          redeclare package Medium = IDEAS.Media.Water,
          nPorts=3,
          V=hydronic.VolTank,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          allowFlowReversal=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
          m_flow_nominal=hydronic.p03_m_flow,
          mSenFac=1)          annotation (Placement(transformation(
              extent={{-10,10},{10,-10}},
              rotation=180,
              origin={6,68})));
        Modelica.Thermal.HeatTransfer.Components.ThermalResistor insulationBuffTank(R=(0.026/
              0.04)*30.13)
          annotation (Placement(transformation(extent={{42,60},{26,76}})));
        Modelica.Thermal.HeatTransfer.Sources.FixedTemperature basementTemperature(T=291.15)
          annotation (Placement(transformation(extent={{66,60},{50,76}})));
        IBPSA.Fluid.HeatPumps.ScrollWaterToWater     heaPum1(
          allowFlowReversal1=false,
          allowFlowReversal2=false,
          show_T=true,
          redeclare package Medium1 = IDEAS.Media.Water,
          T1_start=273.15 + 35,
          redeclare package ref = IBPSA.Media.Refrigerants.R410A,
          datHeaPum=INFRAX.Data.Parameters.DYNACIAT_200_LG_LGP_cissimmo_wetter(),
          dp1_nominal=48400,
          dp2_nominal=55500,
          tau1=200,
          tau2=200,
          energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial,
          m1_flow_nominal=hydronic.p03_m_flow/2,
          m2_flow_nominal=hydronic.p01_m_flow/2,
          enable_variable_speed=false,
          scaling_factor=1,
          redeclare package Medium2 = MediumGlycol,
          T2_start=288.15) "Heat pump 1 " annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=-90,
              origin={-114,72})));
        IDEAS.Fluid.MixingVolumes.MixingVolume supplyCollector(
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal=24000/3600,
          nPorts=5,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          allowFlowReversal=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
          V=0.5)          "supply collector" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={110,-10})));
        IDEAS.Fluid.MixingVolumes.MixingVolume returnCollector(
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal=24000/3600,
          nPorts=5,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          allowFlowReversal=true,
          energyDynamics=Modelica.Fluid.Types.Dynamics.FixedInitial,
          V=0.5)          "return collector" annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=180,
              origin={156,-50})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t10(
          allowFlowReversal=false,
          m_flow_nominal=21000/3600,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(extent={{-112,-66},{-98,-52}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t11(
          allowFlowReversal=false,
          m_flow_nominal=21000/3600,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(extent={{-96,-88},{-110,-76}})));
        IDEAS.Fluid.Movers.SpeedControlled_y     pump5(
          allowFlowReversal=false,
          addPowerToMedium=false,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          redeclare
            IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos65slash1to12_CAN_PN6slash10 per,
          y_start=0,
          tau=60,
          riseTime=120,
          use_inputFilter=false,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          redeclare package Medium = MediumGlycol)
                     "passive cooling pump"
          annotation (Placement(transformation(extent={{-76,-70},{-60,-52}})));
        IBPSA.Fluid.HeatExchangers.DryCoilEffectivenessNTU e004(
          redeclare package Medium1 = IDEAS.Media.Water,
          allowFlowReversal1=false,
          allowFlowReversal2=false,
          configuration=Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow,
          m1_flow_nominal=19400/3600,
          m2_flow_nominal=20200/3600,
          dp1_nominal=40100,
          dp2_nominal=53200,
          Q_flow_nominal(displayUnit="W") = 90000,
          r_nominal=0.465/0.600,
          T_a1_nominal=293.15,
          T_a2_nominal=288.65,
          redeclare package Medium2 = MediumGlycol)
                               "passive cooling heat exchanger" annotation (Placement(
              transformation(
              extent={{-10,10},{10,-10}},
              rotation=90,
              origin={-34,-70})));
        IBPSA.Fluid.HeatExchangers.DryCoilEffectivenessNTU e003(
          redeclare package Medium1 = IDEAS.Media.Water,
          allowFlowReversal1=false,
          allowFlowReversal2=false,
          m1_flow_nominal=30300/3600,
          m2_flow_nominal=27100/3600,
          dp1_nominal=48700,
          dp2_nominal=49300,
          Q_flow_nominal(displayUnit="W") = 106000,
          configuration=Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow,
          r_nominal=0.461/0.593,
          T_a1_nominal=288.15,
          T_a2_nominal=284.15,
          redeclare package Medium2 = MediumGlycol)
                               "cooling heat exchanger" annotation (Placement(
              transformation(
              extent={{-10,10},{10,-10}},
              rotation=90,
              origin={-40,-16})));
        IDEAS.Fluid.Movers.SpeedControlled_y     pump4(
          allowFlowReversal=false,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          redeclare IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos80slash1to12_CAN_PN6
            per,
          tau=60,
          riseTime=120,
          inputType=IDEAS.Fluid.Types.InputType.Stages,
          use_inputFilter=false,
          addPowerToMedium=false,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          redeclare package Medium = MediumGlycol)
                                "active cooling pump"
          annotation (Placement(transformation(extent={{-84,-18},{-64,2}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t9(
          allowFlowReversal=false,
                                 m_flow_nominal=28300/3600,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(extent={{-94,-42},{-108,-28}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t8(
          allowFlowReversal=false,
                                 m_flow_nominal=28300/3600,
          tau=hydronic.sensorTau,
          redeclare package Medium = MediumGlycol,
          transferHeat=false,
          TAmb=291.15)
          annotation (Placement(transformation(extent={{-108,-14},{-96,-2}})));
        IDEAS.Fluid.FixedResistances.Junction jun(
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Bidirectional,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(
              extent={{-6,6},{6,-6}},
              rotation=-90,
              origin={-120,-8})));
        IDEAS.Fluid.FixedResistances.Junction jun1(
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Bidirectional,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Bidirectional,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(
              extent={{-5,5},{5,-5}},
              rotation=-90,
              origin={-121,-35})));
        IDEAS.Fluid.FixedResistances.Junction jun2(
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Bidirectional,
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Bidirectional,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(
              extent={{-5,5},{5,-5}},
              rotation=-90,
              origin={-121,-61})));
        IDEAS.Fluid.FixedResistances.Junction jun3(
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Bidirectional,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Bidirectional,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(
              extent={{-5,5},{5,-5}},
              rotation=-90,
              origin={-121,-85})));
        Components.CoolingTower coolingTower_detailed(redeclare package
          MediumGlycol =
              MediumGlycol)
          annotation (Placement(transformation(extent={{194,80},{218,100}})));
        Components.TABS tABS_detailed
          annotation (Placement(transformation(extent={{86,68},{106,88}})));
        Controllers.DataBus dataBus annotation (Placement(transformation(extent={{-220,-2},
                  {-180,38}}),    iconTransformation(extent={{-210,4},{-190,24}})));
        Controllers.SignalBus signalBus annotation (Placement(transformation(extent={{-218,
                  -42},{-178,-2}}),      iconTransformation(extent={{-210,-30},{-190,-10}})));
        IDEAS.Fluid.FixedResistances.Junction jun4(
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Bidirectional,
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Bidirectional,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(
              extent={{-5,5},{5,-5}},
              rotation=-90,
              origin={-121,-101})));
        IDEAS.Fluid.FixedResistances.Junction jun5(
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Bidirectional,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(
              extent={{-5,5},{5,-5}},
              rotation=-90,
              origin={-121,-129})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t6(
                                 m_flow_nominal=24000/3600,
          allowFlowReversal=false,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(extent={{6,-7},{-6,7}},
              rotation=90,
              origin={-122,-115})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t18(
          redeclare package Medium = IDEAS.Media.Water,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p07_m_flow,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15)
          annotation (Placement(transformation(extent={{6,-88},{-8,-76}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t17(
          redeclare package Medium = IDEAS.Media.Water,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p07_m_flow,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15)
          annotation (Placement(transformation(extent={{-10,-66},{4,-52}})));
        IDEAS.Fluid.FixedResistances.Junction jun6(
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          tau=200,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
          annotation (Placement(transformation(
              extent={{-5,-5},{5,5}},
              rotation=-90,
              origin={77,35})));
        IDEAS.Fluid.FixedResistances.Junction jun7(
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          tau=200,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
          annotation (Placement(transformation(
              extent={{5,5},{-5,-5}},
              rotation=-90,
              origin={47,35})));
        IDEAS.Fluid.Sources.Boundary_pT sink(redeclare package Medium =
              IDEAS.Media.Water,
          nPorts=2,
          p=200000)                        annotation (Placement(transformation(
              extent={{6,-6},{-6,6}},
              rotation=-90,
              origin={8,26})));
        IDEAS.Fluid.FixedResistances.Junction jun8(
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          tau=200,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=-90,
              origin={-120,10})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[35] port_emb
          annotation (Placement(transformation(extent={{84,130},{104,150}})));
        IBPSA.Fluid.HeatExchangers.DryCoilEffectivenessNTU e005(
          redeclare package Medium1 = IDEAS.Media.Water,
          configuration=Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow,
          Q_flow_nominal(displayUnit="W") = 34000,
          r_nominal=0.473/0.619,
          dp1_nominal=49900,
          dp2_nominal=47200,
          allowFlowReversal1=false,
          allowFlowReversal2=false,
          m1_flow_nominal=hydronic.p08_m_flow,
          m2_flow_nominal=hydronic.p09_m_flow,
          redeclare package Medium2 = MediumGlycol,
          T_a1_nominal=301.15,
          T_a2_nominal=306.15) "ahu(+) heat exchanger" annotation (Placement(
              transformation(
              extent={{10,-10},{-10,10}},
              rotation=180,
              origin={170,48})));
        IDEAS.Fluid.Movers.SpeedControlled_y     pump8(
          allowFlowReversal=false,
          addPowerToMedium=false,
          redeclare package Medium = IDEAS.Media.Water,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          y_start=0,
          tau=60,
          riseTime=120,
          redeclare IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos30slash1to12 per,
          inputType=IDEAS.Fluid.Types.InputType.Stages,
          use_inputFilter=false,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
          "pump for primary in e005 (ahu+)"
          annotation (Placement(transformation(extent={{-8,-9},{8,9}},
              rotation=90,
              origin={132,33})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t29(
          redeclare package Medium = IDEAS.Media.Water,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p08_m_flow,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15)
          annotation (Placement(transformation(extent={{142,34},{156,50}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t30(
          redeclare package Medium = IDEAS.Media.Water,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p08_m_flow,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15)                        annotation (Placement(transformation(
              extent={{-7,-7},{7,7}},
              rotation=-90,
              origin={187,19})));
        Modelica.Fluid.Interfaces.FluidPort_b AHUHeaCoi_b(redeclare package
          Medium =
              MediumGlycol)      "return from AHU heat coil"
          annotation (Placement(transformation(extent={{170,130},{190,150}})));
        Modelica.Fluid.Interfaces.FluidPort_a AHUHeaCoi_a(redeclare package
          Medium =
              MediumGlycol)      "supply to AHU heat coil"
          annotation (Placement(transformation(extent={{150,130},{170,150}})));
        Modelica.Fluid.Interfaces.FluidPort_a HeaCoi_a(redeclare package Medium
          =   IDEAS.Media.Water) "supply to vav/ducts heat coil"
          annotation (Placement(transformation(extent={{110,130},{130,150}})));
        Modelica.Fluid.Interfaces.FluidPort_b HeaCoi_b(redeclare package Medium
          =   IDEAS.Media.Water) "return from vav/duct heat coils"
          annotation (Placement(transformation(extent={{130,130},{150,150}})));
        Modelica.Fluid.Interfaces.FluidPort_b AHUCooCoi_b(redeclare package
          Medium =
              IDEAS.Media.Water) "return from AHU cooling coil"
          annotation (Placement(transformation(extent={{10,130},{30,150}})));
        Modelica.Fluid.Interfaces.FluidPort_a AHUCooCoi_a(redeclare package
          Medium =
              IDEAS.Media.Water) "supply to AHU cooling coil"
          annotation (Placement(transformation(extent={{-10,130},{10,150}})));
        IBPSA.Fluid.HeatPumps.ScrollWaterToWater     heaPum2(
          allowFlowReversal1=false,
          allowFlowReversal2=false,
          show_T=true,
          redeclare package Medium1 = IDEAS.Media.Water,
          T1_start=273.15 + 35,
          redeclare package ref = IBPSA.Media.Refrigerants.R410A,
          dp1_nominal=48400,
          dp2_nominal=55500,
          tau1=200,
          tau2=200,
          energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial,
          m1_flow_nominal=hydronic.p03_m_flow/2,
          m2_flow_nominal=hydronic.p01_m_flow/2,
          enable_variable_speed=false,
          scaling_factor=1,
          datHeaPum=Data.Parameters.DYNACIAT_200_LG_LGP_cissimmo_wetter(),
          redeclare package Medium2 = MediumGlycol,
          T2_start=288.15) "Heat pump 12" annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=-90,
              origin={-114,108})));
        IDEAS.Fluid.FixedResistances.Junction jun10(
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          tau=200,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=-90,
              origin={-120,32})));
        IDEAS.Fluid.FixedResistances.Junction junHpConByp(
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          tau=200,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState) annotation (
            Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=0,
              origin={-50,118})));
        IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_byPass_collector(
          allowFlowReversal=false,
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal=hydronic.p03_m_flow,
          dp_nominal(displayUnit="kPa") = 0) "equilibrium valve" annotation (
            Placement(transformation(
              extent={{-6,-7},{6,7}},
              rotation=180,
              origin={62,35})));
        IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_E003(
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p04_m_flow,
          dp_nominal(displayUnit="kPa") = 3800,
          redeclare package Medium = MediumGlycol)
                                                "equilibrium valve" annotation (
            Placement(transformation(
              extent={{-6,-7},{6,7}},
              rotation=180,
              origin={-66,-35})));
        IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_E1(
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p05_m_flow,
          dp_nominal(displayUnit="kPa") = 4000,
          redeclare package Medium = MediumGlycol)
                                                "equilibrium valve" annotation (
            Placement(transformation(
              extent={{-6,-7},{6,7}},
              rotation=180,
              origin={-62,-85})));
        IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_E2(
          allowFlowReversal=false,
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal=hydronic.p06_m_flow,
          dp_nominal(displayUnit="kPa") = 10800) "equilibrium valve" annotation (
            Placement(transformation(
              extent={{-6,-7},{6,7}},
              rotation=270,
              origin={140,69})));
        IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_e005_primary(
          allowFlowReversal=false,
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal=hydronic.p08_m_flow,
          dp_nominal(displayUnit="kPa") = 2700) "equilibrium valve" annotation (
            Placement(transformation(
              extent={{-8,7},{8,-7}},
              rotation=270,
              origin={187,-10})));
        IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_e004_TABS(
          allowFlowReversal=false,
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal=hydronic.p07_m_flow,
          dp_nominal(displayUnit="kPa") = 5100) "equilibrium valve" annotation (
            Placement(transformation(
              extent={{8,9},{-8,-9}},
              rotation=180,
              origin={30,-59})));
        Modelica.Blocks.Interfaces.RealOutput HP_P
          annotation (Placement(transformation(extent={{-200,-118},{-220,-98}})));
        Modelica.Blocks.Sources.RealExpression realExpression(y=heaPum1.P + heaPum2.P)
          annotation (Placement(transformation(extent={{-164,-118},{-184,-98}})));
        Modelica.Blocks.Sources.RealExpression realExpression1(y=heaPum1.P + heaPum2.P
               + pump1.P + pump3.P + pump4.P + pump5.P + pump8.P +
              coolingTower_detailed.P_pumps + coolingTower_detailed.P_CT +
              tABS_detailed.P_pump)
          annotation (Placement(transformation(extent={{-164,-90},{-184,-70}})));
        Modelica.Blocks.Interfaces.RealOutput total_P
          annotation (Placement(transformation(extent={{-200,-90},{-220,-70}})));
        Components.IdealCircuitSwitch idealCircuitSwitch(
          setEqualPressureBC=false,
          allowBCOpen=false,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(extent={{-160,20},{-140,0}})));
        Modelica.Blocks.MathBoolean.Not HPValEvaByp
          annotation (Placement(transformation(extent={{-174,70},{-166,78}})));
        Modelica.Blocks.Logical.Or HPValEva
          annotation (Placement(transformation(extent={{-198,60},{-186,72}})));
        Components.IdealCircuitSwitch idealCircuitSwitch1(
                                 fra=0.5, redeclare package Medium =
            MediumGlycol)                 annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=270,
              origin={-170,100})));
        Modelica.Blocks.Math.IntegerToBoolean HP1_boolean(threshold=1)
          annotation (Placement(transformation(extent={{-230,100},{-218,88}})));
        Modelica.Blocks.Math.IntegerToBoolean HP2_boolean(threshold=1)
          annotation (Placement(transformation(extent={{-230,100},{-218,112}})));
        Components.IdealCircuitSwitch idealCircuitSwitch2(
          redeclare package Medium = IDEAS.Media.Water,
          setEqualPressureBC=false,
          allowBCOpen=false,
          u_val2(start=true))
          annotation (Placement(transformation(extent={{-76,60},{-56,40}})));
        Components.IdealCircuitSwitch idealCircuitSwitch3(redeclare package
          Medium =
              IDEAS.Media.Water, fra=0.5)        annotation (Placement(transformation(
              extent={{10,10},{-10,-10}},
              rotation=270,
              origin={-70,80})));
        IDEAS.Fluid.FixedResistances.Junction junHpConRet(
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal={1,1,1},
          dp_nominal={0,0,0},
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          tau=200,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState) annotation (
            Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=0,
              origin={-90,118})));
        Modelica.Blocks.Logical.Or HPValCon
          annotation (Placement(transformation(extent={{-40,72},{-48,64}})));
        Modelica.Blocks.MathBoolean.Not HPValConByp
          annotation (Placement(transformation(extent={{-52,62},{-56,66}})));
        IBPSA.Fluid.Geothermal.Borefields.TwoUTubes
          borField(
          allowFlowReversal=false,
          borFieDat=Data.Parameters.BorefieldData.INFRAX_bF(),
          redeclare package Medium = MediumGlycol,
          nSeg=5)          "borefield from INFRAX"
          annotation (Placement(transformation(extent={{-134,-176},{-154,-156}})));
        IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_HP(
          allowFlowReversal=false,
          redeclare package Medium = IDEAS.Media.Water,
          m_flow_nominal=hydronic.p03_m_flow,
          dp_nominal(displayUnit="Pa") = 48400) "equilibrium valve" annotation (
            Placement(transformation(
              extent={{-6,-7},{6,7}},
              rotation=180,
              origin={-54,35})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t2(
          redeclare package Medium = IDEAS.Media.Water,
          allowFlowReversal=false,
          m_flow_nominal=24000/3600,
          tau=hydronic.sensorTau,
          transferHeat=false,
          TAmb=291.15)
          annotation (Placement(transformation(extent={{6,7},{-6,-7}},
              rotation=-90,
              origin={-160,41})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entSupTABS(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p07_m_flow) annotation (Placement(transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={90,44})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entRetTABS(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p07_m_flow) annotation (Placement(transformation(
              extent={{10,-10},{-10,10}},
              rotation=90,
              origin={124,-22})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entSupAHUHea(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p08_m_flow) annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=90,
              origin={132,12})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entRetAHUHea(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p08_m_flow) annotation (Placement(transformation(
              extent={{6,-6},{-6,6}},
              rotation=90,
              origin={188,-28})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entSupVAV(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p06_m_flow) annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=90,
              origin={120,106})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entRetVAV(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p06_m_flow) annotation (Placement(transformation(
              extent={{6,-6},{-6,6}},
              rotation=90,
              origin={140,110})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entSupCT(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p10_m_flow) annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=90,
              origin={204,50})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entRetCT(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p10_m_flow) annotation (Placement(transformation(
              extent={{5,-5},{-5,5}},
              rotation=90,
              origin={211,-15})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entSupCTCoo(
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p11_m_flow,
          redeclare package Medium = MediumGlycol)
                                              annotation (Placement(transformation(
              extent={{-7,-7},{7,7}},
              rotation=0,
              origin={55,-101})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entRetCTCoo(
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p11_m_flow,
          redeclare package Medium = MediumGlycol)
                                              annotation (Placement(transformation(
              extent={{6,-6},{-6,6}},
              rotation=0,
              origin={86,-130})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entSupTABSCoo(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p07_m_flow) annotation (Placement(transformation(
              extent={{-7,-7},{7,7}},
              rotation=0,
              origin={69,-59})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entRetTABSCoo(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p07_m_flow) annotation (Placement(transformation(
              extent={{8,-8},{-8,8}},
              rotation=0,
              origin={88,-82})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entSupAHUCoo(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p13_m_flow) annotation (Placement(transformation(
              extent={{-8,-8},{8,8}},
              rotation=0,
              origin={-14,-6})));
        IDEAS.Fluid.Sensors.EnthalpyFlowRate entRetAHUCoo(
          redeclare package Medium = IDEAS.Media.Water,
          tau=0,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p13_m_flow) annotation (Placement(transformation(
              extent={{8,-8},{-8,8}},
              rotation=0,
              origin={-22,-32})));
        Modelica.Blocks.Continuous.Integrator                borFieBal(k=1/3600000)
          annotation (Placement(transformation(extent={{-160,-150},{-180,-130}})));
        Modelica.Blocks.Interfaces.RealOutput accBorFie
          "accumulated borefield energy"
          annotation (Placement(transformation(extent={{-200,-150},{-220,-130}})));
        Modelica.Blocks.Sources.RealExpression groTemResQ(y=borField.groTemRes.QBor_flow)
          annotation (Placement(transformation(extent={{-130,-150},{-150,-130}})));
      equation
        connect(t1.port_b, pump1.port_a) annotation (Line(points={{-178,-169},{-178,
                -116},{-150,-116},{-150,-62}},
                                   color={0,127,255}));
        connect(t14.port_b, pump3.port_a) annotation (Line(points={{-20,35},{-26,35}},
                                    color={0,127,255}));
        connect(buffTank.heatPort, insulationBuffTank.port_b)
          annotation (Line(points={{16,68},{26,68}}, color={191,0,0}));
        connect(basementTemperature.port, insulationBuffTank.port_a)
          annotation (Line(points={{50,68},{42,68}}, color={191,0,0}));

        connect(t14.port_a, buffTank.ports[1]) annotation (Line(points={{-4,35},{4,35},
                {4,58},{8.66667,58}},      color={0,127,255}));
        connect(t19.port_b, supplyCollector.ports[1]) annotation (Line(points={{94,-9},
                {94,0},{113.2,0}},                   color={0,127,255}));
        connect(pump5.port_a, t10.port_b) annotation (Line(points={{-76,-61},{-76,-59},
                {-98,-59}}, color={0,127,255}));
        connect(pump5.port_b, e004.port_a2) annotation (Line(points={{-60,-61},{-60,
                -60},{-44,-60},{-40,-60}},                     color={0,127,255}));
        connect(e003.port_a2, pump4.port_b)
          annotation (Line(points={{-46,-6},{-64,-6},{-64,-8}}, color={0,127,255}));
        connect(t8.port_b, pump4.port_a) annotation (Line(points={{-96,-8},{-84,-8}},
                                   color={0,127,255}));
        connect(jun.port_3, t8.port_a) annotation (Line(points={{-114,-8},{-108,-8}},
                           color={0,127,255}));
        connect(jun.port_2, jun1.port_1) annotation (Line(points={{-120,-14},{-121,-14},
                {-121,-30}},      color={0,127,255}));
        connect(jun1.port_3, t9.port_b) annotation (Line(points={{-116,-35},{-112,-35},
                {-108,-35}}, color={0,127,255}));
        connect(jun2.port_3, t10.port_a) annotation (Line(points={{-116,-61},{-112,
                -61},{-112,-59}}, color={0,127,255}));
        connect(jun2.port_1, jun1.port_2) annotation (Line(points={{-121,-56},{-121,
                -56},{-121,-40}}, color={0,127,255}));
        connect(jun3.port_3, t11.port_b) annotation (Line(points={{-116,-85},{-114,
                -85},{-114,-82},{-110,-82}}, color={0,127,255}));
        connect(jun3.port_1, jun2.port_2) annotation (Line(points={{-121,-80},{-121,
                -73},{-121,-66}}, color={0,127,255}));
        connect(t8.T, dataBus.T8);
        connect(t9.T, dataBus.T9);
        connect(t10.T, dataBus.T10);
        connect(t11.T, dataBus.T11);
        connect(t7.T, dataBus.T7);
        connect(t1.T, dataBus.T1);
        connect(t14.T, dataBus.T14);
        connect(t19.T, dataBus.T19);
        connect(pump1.y, signalBus.P0102_mod);
      //  connect(heaPum1.y, signalBus.HP_mod);
        connect(pump3.dp_in, signalBus.P03_mod);
        connect(dataBus, tABS_detailed.dataBus);
        connect(signalBus, tABS_detailed.signalBus);
        connect(signalBus, coolingTower_detailed.signalBus);
        connect(dataBus, coolingTower_detailed.dataBus);
        connect(jun4.port_1, jun3.port_2) annotation (Line(points={{-121,-96},{-121,
                -96},{-121,-90}}, color={0,127,255}));
        connect(jun5.port_2, t7.port_a) annotation (Line(points={{-121,-134},{-120,
                -134},{-120,-149},{-102,-149}}, color={0,127,255}));
        connect(jun5.port_1, t6.port_b) annotation (Line(points={{-121,-124},{-122,
                -124},{-122,-121}}, color={0,127,255}));
        connect(jun4.port_2, t6.port_a) annotation (Line(points={{-121,-106},{-122,
                -106},{-122,-109}}, color={0,127,255}));
        connect(e004.port_a1, t18.port_b) annotation (Line(points={{-28,-80},{-20,-80},
                {-20,-82},{-8,-82}}, color={0,127,255}));
        connect(e004.port_b1, t17.port_a) annotation (Line(points={{-28,-60},{-20,-60},
                {-20,-59},{-10,-59}}, color={0,127,255}));
        connect(t19.port_a, jun6.port_2) annotation (Line(points={{78,-9},{78,-9},{78,
                30},{77,30}}, color={0,127,255}));
        connect(returnCollector.ports[1], jun7.port_1) annotation (Line(points={{159.2,
                -40},{47,-40},{47,30}},         color={0,127,255}));
        connect(jun7.port_2, buffTank.ports[2]) annotation (Line(points={{47,40},{46,
                40},{46,48},{44,48},{6,48},{6,58}}, color={0,127,255}));
        connect(pump5.y, signalBus.P05_mod);
        connect(t17.T, dataBus.T17);
        connect(t18.T, dataBus.T18);
        connect(sink.ports[1], buffTank.ports[3]) annotation (Line(points={{9.2,32},{9.2,
                58},{3.33333,58}},          color={0,127,255}));
        connect(tABS_detailed.port_emb, port_emb) annotation (Line(points={{93.8182,
                88.1667},{93.8182,95.0833},{94,95.0833},{94,140}},   color={191,0,0}));
        connect(e005.port_a1, t29.port_b)
          annotation (Line(points={{160,42},{156,42}},          color={0,127,255}));
        connect(t29.port_a, pump8.port_b) annotation (Line(points={{142,42},{132,42},{
                132,41}},                             color={0,127,255}));
        connect(e005.port_b1, t30.port_a)
          annotation (Line(points={{180,42},{187,42},{187,26}}, color={0,127,255}));
        connect(e005.port_a2, AHUHeaCoi_b)
          annotation (Line(points={{180,54},{180,96},{180,140}},
                                                        color={0,127,255}));
        connect(e005.port_b2, AHUHeaCoi_a)
          annotation (Line(points={{160,54},{160,140}},          color={0,127,255}));
        connect(jun8.port_1, jun10.port_2) annotation (Line(points={{-120,16},{-120,26}},
                                color={0,127,255}));
        connect(jun8.port_2, jun.port_1) annotation (Line(points={{-120,4},{-120,-2}},
                            color={0,127,255}));
        connect(heaPum1.stage, signalBus.HP1_signal) annotation (Line(points={{-111,60},
                {-111,-22},{-198,-22}},           color={255,127,0},
            visible=false),                                           Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(heaPum2.stage, signalBus.HP2_signal) annotation (Line(points={{-111,96},
                {-112,96},{-112,-24},{-112,-22},{-198,-22}},           color={255,127,
                0},
            visible=false),
                     Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(jun6.port_1, junHpConByp.port_2) annotation (Line(points={{77,40},{76,
                40},{76,118},{-44,118}}, color={0,127,255}));
        connect(jun7.port_3, dp_fixed_byPass_collector.port_b)
          annotation (Line(points={{52,35},{56,35}}, color={0,127,255}));
        connect(jun6.port_3, dp_fixed_byPass_collector.port_a)
          annotation (Line(points={{72,35},{72,35},{68,35}}, color={0,127,255}));
        connect(dp_fixed_E003.port_a, e003.port_b2) annotation (Line(points={{-60,-35},
                {-46,-35},{-46,-26}}, color={0,127,255}));
        connect(dp_fixed_E003.port_b, t9.port_a) annotation (Line(points={{-72,-35},{
                -82,-35},{-94,-35}}, color={0,127,255}));
        connect(t11.port_a, dp_fixed_E1.port_b) annotation (Line(points={{-96,-82},{
                -68,-82},{-68,-85}}, color={0,127,255}));
        connect(dp_fixed_E1.port_a, e004.port_b2) annotation (Line(points={{-56,-85},
                {-52,-85},{-52,-86},{-40,-86},{-40,-80}}, color={0,127,255}));
        connect(dp_fixed_E2.port_b, returnCollector.ports[2]) annotation (Line(points={{140,63},
                {140,63},{140,-32},{157.6,-32},{157.6,-40}},          color={0,127,
                255}));
        connect(t30.port_b, dp_fixed_e005_primary.port_a)
          annotation (Line(points={{187,12},{187,12},{187,-2}}, color={0,127,255}));
        connect(t17.port_b, dp_fixed_e004_TABS.port_a)
          annotation (Line(points={{4,-59},{14,-59},{22,-59}}, color={0,127,255}));
        connect(boundary.ports[1], AHUHeaCoi_b) annotation (Line(points={{-26.8,-170},
                {196,-170},{196,72},{180,72},{180,140}},                   color={0,127,
                255}));
        connect(pump4.stage, signalBus.P04_signal) annotation (Line(points={{-74,4},{-74,
                12},{-112,12},{-112,-22},{-198,-22}},           color={255,127,0},
            visible=false),
            Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(pump8.stage, signalBus.P08_signal) annotation (Line(points={{121.2,33},
                {-112,33},{-112,-22},{-198,-22}},       color={255,127,0},
            visible=false),                                                 Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(realExpression.y, HP_P) annotation (Line(points={{-185,-108},{-196,
                -108},{-210,-108}}, color={0,0,127}));
        connect(realExpression1.y, total_P) annotation (Line(points={{-185,-80},{-196,
                -80},{-210,-80}}, color={0,0,127}));
        connect(jun10.port_1, heaPum1.port_b2) annotation (Line(points={{-120,38},{
                -120,62}},           color={0,127,255}));
        connect(jun10.port_3, heaPum2.port_b2) annotation (Line(points={{-126,32},{-136,
                32},{-136,98},{-120,98}},      color={0,127,255}));
        connect(HPValEvaByp.y, idealCircuitSwitch.u_val2) annotation (Line(
            points={{-165.2,74},{-144,74},{-144,20.6}},
            color={255,0,255},
            visible=false));
        connect(HPValEva.y, HPValEvaByp.u) annotation (Line(
            points={{-185.4,66},{-180,66},{-180,74},{-175.6,74}},
            color={255,0,255},
            visible=false));
        connect(HPValEva.y, idealCircuitSwitch.u_val1) annotation (Line(points={{-185.4,
                66},{-156,66},{-156,20.6}}, color={255,0,255},
            visible=false));
        connect(idealCircuitSwitch.port_c, pump1.port_b) annotation (Line(points={{-150,0},
                {-150,-42}},             color={0,127,255}));
        connect(idealCircuitSwitch.port_b, jun8.port_3) annotation (Line(points={{-140.2,
                10},{-126,10}},                     color={0,127,255}));
        connect(idealCircuitSwitch1.port_b, heaPum2.port_a2) annotation (Line(points={
                {-170,109.8},{-170,118},{-120,118}}, color={0,127,255}));
        connect(idealCircuitSwitch1.port_a, heaPum1.port_a2) annotation (Line(points={{-170,
                89.8},{-170,82},{-120,82}},       color={0,127,255}));
        connect(HPValEva.u2, idealCircuitSwitch1.u_val2) annotation (Line(points={{-199.2,
                61.2},{-199.2,106},{-180.6,106}}, color={255,0,255},
            visible=false));
        connect(HPValEva.u1, idealCircuitSwitch1.u_val1) annotation (Line(points={{-199.2,
                66},{-199.2,94},{-180.6,94}}, color={255,0,255},
            visible=false));
        connect(HP2_boolean.u, signalBus.HP2_signal) annotation (Line(
            points={{-231.2,106},{-240,106},{-240,-22},{-198,-22}},
            color={255,127,0},
            visible=false), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(HP1_boolean.u, signalBus.HP1_signal) annotation (Line(
            points={{-231.2,94},{-238,94},{-238,-22},{-198,-22}},
            color={255,127,0},
            visible=false), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(idealCircuitSwitch2.port_a, idealCircuitSwitch3.port_c) annotation (
            Line(points={{-76.2,50},{-80,50},{-80,80}}, color={0,127,255}));
        connect(idealCircuitSwitch3.port_a, heaPum1.port_a1) annotation (Line(points={{-70,
                69.8},{-70,62},{-108,62}},       color={0,127,255}));
        connect(idealCircuitSwitch3.port_b, heaPum2.port_a1) annotation (Line(points=
                {{-70,89.8},{-70,98},{-108,98}}, color={0,127,255}));
        connect(idealCircuitSwitch2.port_b, junHpConByp.port_3) annotation (Line(
              points={{-56.2,50},{-50,50},{-50,112}}, color={0,127,255}));
        connect(junHpConRet.port_1, heaPum2.port_b1)
          annotation (Line(points={{-96,118},{-108,118}}, color={0,127,255}));
        connect(junHpConRet.port_3, heaPum1.port_b1) annotation (Line(points={{-90,112},
                {-90,82},{-108,82}},      color={0,127,255}));
        connect(junHpConRet.port_2, junHpConByp.port_1)
          annotation (Line(points={{-84,118},{-56,118}}, color={0,127,255}));
        connect(HP2_boolean.y, idealCircuitSwitch1.u_val2) annotation (Line(
            points={{-217.4,106},{-180.6,106}},
            color={255,0,255},
            visible=false));
        connect(HP1_boolean.y, idealCircuitSwitch1.u_val1) annotation (Line(
            points={{-217.4,94},{-180.6,94}},
            color={255,0,255},
            visible=false));
        connect(HP2_boolean.y, idealCircuitSwitch3.u_val2) annotation (Line(
            points={{-217.4,106},{-40,106},{-40,86},{-59.4,86}},
            color={255,0,255},
            visible=false));
        connect(idealCircuitSwitch1.u_val1, idealCircuitSwitch3.u_val1) annotation (
            Line(
            points={{-180.6,94},{-40,94},{-40,74},{-59.4,74}},
            color={255,0,255},
            visible=false));
        connect(HPValCon.y, idealCircuitSwitch2.u_val1) annotation (Line(points={{
                -48.4,68},{-72,68},{-72,60.6}}, color={255,0,255}));
        connect(HPValCon.u2, idealCircuitSwitch3.u_val2) annotation (Line(
            points={{-39.2,71.2},{-39.2,86},{-59.4,86}},
            color={255,0,255},
            visible=false));
        connect(HPValCon.u1, idealCircuitSwitch3.u_val1) annotation (Line(
            points={{-39.2,68},{-40,68},{-40,74},{-59.4,74}},
            color={255,0,255},
            visible=false));
        connect(HPValConByp.u, HPValCon.y)
          annotation (Line(points={{-51.2,64},{-50,64},{-50,68},{-48.4,68}},
                                                           color={255,0,255}));
        connect(HPValConByp.y, idealCircuitSwitch2.u_val2) annotation (Line(points={{-56.4,
                64},{-60,64},{-60,60.6}},       color={255,0,255}));
        connect(t1.port_a, borField.port_b) annotation (Line(points={{-166,-169},{
                -159,-169},{-159,-166},{-154,-166}},
                                                color={0,127,255}));
        connect(t7.port_b, borField.port_a) annotation (Line(points={{-102,-161},{
                -102,-166},{-134,-166}},
                                    color={0,127,255}));
        connect(pump3.port_b, dp_fixed_HP.port_a)
          annotation (Line(points={{-44,35},{-48,35}}, color={0,127,255}));
        connect(dp_fixed_HP.port_b, idealCircuitSwitch2.port_c)
          annotation (Line(points={{-60,35},{-66,35},{-66,40}}, color={0,127,255}));
        connect(idealCircuitSwitch1.port_c, t2.port_b) annotation (Line(points={{-160,
                100},{-160,52},{-160.2,52},{-160,47}}, color={0,127,255}));
        connect(t2.port_a, idealCircuitSwitch.port_a) annotation (Line(points={{-160,
                35},{-160,22.5},{-160.2,22.5},{-160.2,10}}, color={0,127,255}));
        connect(t2.T, dataBus.T2) annotation (Line(points={{-167.7,41},{-200,41},{
                -200,38},{-199.9,38},{-199.9,18.1}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(supplyCollector.ports[2], entSupTABS.port_a)
          annotation (Line(points={{111.6,0},{90,0},{90,34}}, color={0,127,255}));
        connect(entSupTABS.port_b, tABS_detailed.heaSupply) annotation (Line(points={{90,54},
                {90,61},{89.6364,61},{89.6364,68}},        color={0,127,255}));
        connect(returnCollector.ports[3], entRetTABS.port_b) annotation (Line(points={
                {156,-40},{158,-40},{158,-36},{124,-36},{124,-32}}, color={0,127,255}));
        connect(entRetTABS.port_a, tABS_detailed.heaReturn) annotation (Line(points={{124,-12},
                {124,68},{101.455,68}},          color={0,127,255}));
        connect(supplyCollector.ports[3], entSupAHUHea.port_a)
          annotation (Line(points={{110,0},{132,0},{132,6}}, color={0,127,255}));
        connect(entSupAHUHea.port_b, pump8.port_a)
          annotation (Line(points={{132,18},{132,25}}, color={0,127,255}));
        connect(dp_fixed_e005_primary.port_b, entRetAHUHea.port_a) annotation (Line(
              points={{187,-18},{188,-18},{188,-22}}, color={0,127,255}));
        connect(entRetAHUHea.port_b, returnCollector.ports[4]) annotation (Line(
              points={{188,-34},{188,-40},{154.4,-40}}, color={0,127,255}));
        connect(supplyCollector.ports[4], entSupVAV.port_a) annotation (Line(points={{
                108.4,0},{108.4,48},{120,48},{120,100}}, color={0,127,255}));
        connect(entSupVAV.port_b, HeaCoi_a)
          annotation (Line(points={{120,112},{120,140}}, color={0,127,255}));
        connect(dp_fixed_E2.port_a, entRetVAV.port_b)
          annotation (Line(points={{140,75},{140,104}}, color={0,127,255}));
        connect(entRetVAV.port_a, HeaCoi_b)
          annotation (Line(points={{140,116},{140,140}}, color={0,127,255}));
        connect(supplyCollector.ports[5], entSupCT.port_a) annotation (Line(points={{106.8,
                0},{106.8,2},{204,2},{204,44}}, color={0,127,255}));
        connect(entSupCT.port_b, coolingTower_detailed.port_a) annotation (Line(
              points={{204,56},{204,80},{207.9,80}}, color={0,127,255}));
        connect(returnCollector.ports[5], entRetCT.port_b) annotation (Line(points={{152.8,
                -40},{211,-40},{211,-20}}, color={0,127,255}));
        connect(entRetCT.port_a, coolingTower_detailed.port_b)
          annotation (Line(points={{211,-10},{211,80}}, color={0,127,255}));
        connect(jun4.port_3, entSupCTCoo.port_a)
          annotation (Line(points={{-116,-101},{48,-101}}, color={0,127,255}));
        connect(entSupCTCoo.port_b, coolingTower_detailed.port_a1) annotation (Line(
              points={{62,-101},{220,-101},{220,91},{218,91}}, color={0,127,255}));
        connect(jun5.port_3, entRetCTCoo.port_b) annotation (Line(points={{-116,-129},
                {58,-129},{58,-130},{80,-130}}, color={0,127,255}));
        connect(entRetCTCoo.port_a, coolingTower_detailed.port_b1) annotation (Line(
              points={{92,-130},{232,-130},{232,90},{224,90},{224,93},{218,93}},
              color={0,127,255}));
        connect(dp_fixed_e004_TABS.port_b, entSupTABSCoo.port_a)
          annotation (Line(points={{38,-59},{62,-59}}, color={0,127,255}));
        connect(entSupTABSCoo.port_b, tABS_detailed.cooSupply) annotation (Line(
              points={{76,-59},{106,-59},{106,73.8333}}, color={0,127,255}));
        connect(t18.port_a, entRetTABSCoo.port_b)
          annotation (Line(points={{6,-82},{80,-82}}, color={0,127,255}));
        connect(entRetTABSCoo.port_a, tABS_detailed.cooReturn) annotation (Line(
              points={{96,-82},{106,-82},{106,76.3333}}, color={0,127,255}));
        connect(e003.port_b1, entSupAHUCoo.port_a)
          annotation (Line(points={{-34,-6},{-22,-6}}, color={0,127,255}));
        connect(entSupAHUCoo.port_b, AHUCooCoi_a)
          annotation (Line(points={{-6,-6},{0,-6},{0,140}}, color={0,127,255}));
        connect(entRetAHUCoo.port_b, e003.port_a1) annotation (Line(points={{-30,-32},
                {-34,-32},{-34,-26}}, color={0,127,255}));
        connect(entRetAHUCoo.port_a, AHUCooCoi_b)
          annotation (Line(points={{-14,-32},{20,-32},{20,140}}, color={0,127,255}));
        connect(sink.ports[2], AHUCooCoi_b) annotation (Line(points={{6.8,32},{6.8,-32},
                {20,-32},{20,140}}, color={0,127,255}));
        connect(borFieBal.y, accBorFie)
          annotation (Line(points={{-181,-140},{-210,-140}}, color={0,0,127}));
        connect(groTemResQ.y, borFieBal.u)
          annotation (Line(points={{-151,-140},{-158,-140}}, color={0,0,127}));
        connect(boundary.ports[2], borField.port_a) annotation (Line(points={{-29.2,
                -170},{-120,-170},{-120,-166},{-134,-166}}, color={0,127,255}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-200,
                  -180},{220,140}}), graphics={
              Rectangle(
                extent={{-180,100},{220,-100}},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                lineColor={191,0,0}),
              Line(
                points={{72,-20},{52,0}},
                color={0,0,127}),
              Line(
                points={{52,0},{22,-30}},
                color={0,0,127},
                pattern=LinePattern.Dash),
              Line(
                points={{52,0},{14,0}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-6,-20},{-106,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{-6,20},{-106,20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{14,0},{-6,-20}},
                color={191,0,0},
                thickness=0.5),
              Line(
                points={{14,0},{-6,20}},
                color={191,0,0},
                thickness=0.5),
              Polygon(
                points={{-106,0},{-106,40},{-136,20},{-106,0}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Polygon(
                points={{-106,-40},{-106,0},{-136,-20},{-106,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-136,40},{-156,-40}},
                lineColor={191,0,0},
                fillColor={191,0,0},
                fillPattern=FillPattern.Solid),
              Line(
                points={{222,0},{52,0}},
                color={85,170,255},
                smooth=Smooth.None),
              Line(points={{52,70},{52,40}}),
              Line(points={{74.9,32.8},{92.2,57.3}}),
              Line(points={{29.1,32.8},{11.8,57.3}}),
              Line(points={{89.6,13.7},{117.8,23.9}}),
              Ellipse(
                lineColor={64,64,64},
                fillColor={215,215,215},
                extent={{40,-12},{64,12}},
                fillPattern=FillPattern.Solid),
              Polygon(
                origin={52,0},
                rotation=-17.5,
                fillColor={64,64,64},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                points={{-5.0,0.0},{-2.0,60.0},{0.0,65.0},{2.0,60.0},{5.0,0.0}}),
              Ellipse(
                fillColor={64,64,64},
                pattern=LinePattern.None,
                fillPattern=FillPattern.Solid,
                extent={{45,-7},{59,7}}),
              Line(
                points={{82,-30},{72,-20}},
                color={0,0,127},
                pattern=LinePattern.Dash),
              Line(
                points={{22,-100},{22,-30}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash),
              Line(
                points={{82,-100},{82,-30}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash)}), Diagram(coordinateSystem(
                preserveAspectRatio=false, extent={{-200,-180},{220,140}})),
          experiment(
            StopTime=604800,
            Tolerance=1e-006,
            __Dymola_fixedstepsize=30,
            __Dymola_Algorithm="Euler"));
      end HeatingSystem;

      package Components

        model TABS "TABS System for the TACO approach"

          INFRAX.Data.Parameters.Structure structure
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          INFRAX.Data.Parameters.Hydronic hydronic
            annotation (Placement(transformation(extent={{-100,40},{-80,60}})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort t24(redeclare package Medium
            =   IDEAS.Media.Water, m_flow_nominal=hydronic.p07_m_flow,
            allowFlowReversal=false,
            tau=hydronic.sensorTau) "supply temperature of TABS"       annotation (
              Placement(transformation(
                extent={{-5,-6},{5,6}},
                rotation=90,
                origin={-60,-27})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort t25(redeclare package Medium
            =   IDEAS.Media.Water, m_flow_nominal=hydronic.p07_m_flow,
            allowFlowReversal=false,
            tau=hydronic.sensorTau)                                    annotation (
              Placement(transformation(
                extent={{5,-6},{-5,6}},
                rotation=90,
                origin={70,-31})));
          IDEAS.Fluid.HeatExchangers.RadiantSlab.EmbeddedPipe[15] cca0(
            redeclare each INFRAX.Data.Parameters.INFRAXTABS RadSlaCha,
            redeclare each package Medium = IDEAS.Media.Water,
            each allowFlowReversal=false,
            each massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            each nDiscr=3,
            m_flow_nominal=hydronic.m_flow_GndFlr,
            A_floor=structure.CCA_Areas[21:35],
            nParCir=structure.CCA_paralel_circuits[21:35],
            dp_nominal=hydronic.dp_nominal_GndFlr,
            each energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            each mSenFac=1)                          "TABS ground floor"
            annotation (Placement(transformation(extent={{-24,-22},{-4,-2}})));
          Modelica.Fluid.Interfaces.FluidPort_a heaSupply(redeclare package
            Medium =
                IDEAS.Media.Water) "supply of TABS"
            annotation (Placement(transformation(extent={{-70,-150},{-50,-130}})));
          Modelica.Fluid.Interfaces.FluidPort_b heaReturn(redeclare package
            Medium =
                IDEAS.Media.Water) "return of TABS"
            annotation (Placement(transformation(extent={{60,-150},{80,-130}})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort tcca0(
            redeclare package Medium = IDEAS.Media.Water,
            allowFlowReversal=false,
            m_flow_nominal=(9.8/3600)*sum(structure.CCA_Areas[21:35]),
            tau=hydronic.sensorTau)
            "return temperature of CCA in ground floor" annotation (Placement(
                transformation(
                extent={{7,6},{-7,-6}},
                rotation=180,
                origin={45,-12})));
          IDEAS.Fluid.Actuators.Valves.ThreeWayEqualPercentageMixedLinear
                                                                     TWVTABS(
            redeclare package Medium = IDEAS.Media.Water,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            m_flow_nominal=hydronic.p07_m_flow,
            CvData=IDEAS.Fluid.Types.CvTypes.Kv,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            riseTime=150,
            y_start=0,
            use_inputFilter=false,
            Kv=80,
            y(start=1, fixed=false),
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
                                             annotation (Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=90,
                origin={-60,-84})));
          IDEAS.Fluid.Movers.FlowControlled_dp     pump7(
            redeclare package Medium = IDEAS.Media.Water,
            addPowerToMedium=false,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            allowFlowReversal=false,
            redeclare
              IDEAS.Fluid.Movers.Data.Pumps.Wilo.VeroLine40slash130dash2comma2slash2
              per,
            y_start=1,
            tau=60,
            riseTime=120,
            use_inputFilter=false,
            m_flow_nominal=hydronic.p07_m_flow,
            dp_nominal(displayUnit="kPa") = 6*9.81*1000,
            inputType=IDEAS.Fluid.Types.InputType.Stages,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
            annotation (Placement(transformation(extent={{-7,-8},{7,8}},
                rotation=90,
                origin={-60,-43})));
          IDEAS.Fluid.HeatExchangers.RadiantSlab.EmbeddedPipe[9] cca1(
            redeclare INFRAX.Data.Parameters.INFRAXTABS RadSlaCha,
            redeclare each package Medium = IDEAS.Media.Water,
            each allowFlowReversal=false,
            each massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            each nDiscr=3,
            m_flow_nominal=hydronic.m_flow_1stFlr,
            A_floor=structure.CCA_Areas[12:20],
            nParCir=structure.CCA_paralel_circuits[12:20],
            dp_nominal=hydronic.dp_nominal_1stFlr,
            each energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            each mSenFac=1)             "TABS 1st floor"
            annotation (Placement(transformation(extent={{-24,8},{-4,28}})));
          IDEAS.Fluid.HeatExchangers.RadiantSlab.EmbeddedPipe[7] cca2(
            redeclare each INFRAX.Data.Parameters.INFRAXTABS RadSlaCha,
            redeclare each package Medium = IDEAS.Media.Water,
            each allowFlowReversal=false,
            each massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            each nDiscr=3,
            m_flow_nominal=hydronic.m_flow_2ndFlr,
            A_floor=structure.CCA_Areas[5:11],
            nParCir=structure.CCA_paralel_circuits[5:11],
            dp_nominal=hydronic.dp_nominal_2ndFlr,
            each energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            each mSenFac=1)             "TABS 2nd floor"
            annotation (Placement(transformation(extent={{-24,36},{-4,56}})));
          IDEAS.Fluid.HeatExchangers.RadiantSlab.EmbeddedPipe[4] cca3(
            redeclare each INFRAX.Data.Parameters.INFRAXTABS RadSlaCha,
            redeclare each package Medium = IDEAS.Media.Water,
            each allowFlowReversal=false,
            each massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            each nDiscr=3,
            m_flow_nominal=hydronic.m_flow_3rdFlr,
            A_floor=structure.CCA_Areas[1:4],
            nParCir=structure.CCA_paralel_circuits[1:4],
            dp_nominal=hydronic.dp_nominal_3rdFlr,
            each energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            each mSenFac=1)             "TABS 3rd floor"
            annotation (Placement(transformation(extent={{-24,64},{-4,84}})));
          IDEAS.Fluid.FixedResistances.Junction jun0(
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal={1,1,1},
            dp_nominal={0,0,0},
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving)
            annotation (Placement(transformation(
                extent={{6,6},{-6,-6}},
                rotation=-90,
                origin={-60,-12})));
          IDEAS.Fluid.FixedResistances.Junction jun1(
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal={1,1,1},
            dp_nominal={0,0,0},
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving)
            annotation (Placement(transformation(
                extent={{6,6},{-6,-6}},
                rotation=-90,
                origin={-60,18})));
          IDEAS.Fluid.FixedResistances.Junction jun2(
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal={1,1,1},
            dp_nominal={0,0,0},
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving)
            annotation (Placement(transformation(
                extent={{6,6},{-6,-6}},
                rotation=-90,
                origin={-60,46})));
          IDEAS.Fluid.FixedResistances.Junction jun3(
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal={1,1,1},
            dp_nominal={0,0,0},
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving)
            annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=-90,
                origin={70,-12})));
          IDEAS.Fluid.FixedResistances.Junction jun4(
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal={1,1,1},
            dp_nominal={0,0,0},
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving)
            annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=-90,
                origin={70,18})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort tcca1(
            redeclare package Medium = IDEAS.Media.Water,
            allowFlowReversal=false,
            m_flow_nominal=(9.8/3600)*sum(structure.CCA_Areas[21:35]),
            tau=hydronic.sensorTau)
            "return temperature of CCA in ground floor" annotation (Placement(
                transformation(
                extent={{7,6},{-7,-6}},
                rotation=180,
                origin={45,18})));
          IDEAS.Fluid.FixedResistances.Junction jun5(
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal={1,1,1},
            dp_nominal={0,0,0},
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving)
            annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=-90,
                origin={70,46})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort tcca2(
            redeclare package Medium = IDEAS.Media.Water,
            allowFlowReversal=false,
            m_flow_nominal=(9.8/3600)*sum(structure.CCA_Areas[21:35]),
            tau=hydronic.sensorTau)
            "return temperature of CCA in ground floor" annotation (Placement(
                transformation(
                extent={{7,6},{-7,-6}},
                rotation=180,
                origin={47,46})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort tcca3(
            redeclare package Medium = IDEAS.Media.Water,
            allowFlowReversal=false,
            m_flow_nominal=(9.8/3600)*sum(structure.CCA_Areas[21:35]),
            tau=hydronic.sensorTau)
            "return temperature of CCA in ground floor" annotation (Placement(
                transformation(
                extent={{7,6},{-7,-6}},
                rotation=180,
                origin={47,74})));
          IDEAS.Fluid.FixedResistances.Junction jun6(
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal={1,1,1},
            dp_nominal={0,0,0},
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving)
            annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=-90,
                origin={70,-84})));
          Controllers.DataBus dataBus annotation (Placement(transformation(extent={{-120,-2},
                    {-80,38}}),     iconTransformation(extent={{-112,6},{-92,26}})));
          Controllers.SignalBus signalBus annotation (Placement(transformation(extent={{-118,
                    -42},{-78,-2}}),       iconTransformation(extent={{-112,-28},{-92,
                    -8}})));
          IDEAS.Fluid.FixedResistances.Junction jun7(
            redeclare package Medium = IDEAS.Media.Water,
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
            m_flow_nominal={1,hydronic.p07_m_flow,1},
            dp_nominal={0,70000,0})
            annotation (Placement(transformation(
                extent={{6,6},{-6,-6}},
                rotation=-90,
                origin={-60,-60})));
          IDEAS.Fluid.Actuators.Valves.TwoWayLinear val_heat_sup(
            use_inputFilter=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p11_m_flow,
            allowFlowReversal=false,
            dpValve_nominal=1000,
            from_dp=true)         annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=90,
                origin={-60,-120})));
          IDEAS.Fluid.Actuators.Valves.TwoWayLinear val_coo_sup(
            use_inputFilter=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p11_m_flow,
            allowFlowReversal=false,
            dpValve_nominal=1000,
            from_dp=true)         annotation (Placement(transformation(
                extent={{8,-8},{-8,8}},
                rotation=0,
                origin={-22,-60})));
          IDEAS.Fluid.Actuators.Valves.TwoWayLinear val_heat_ret(
            use_inputFilter=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p11_m_flow,
            allowFlowReversal=false,
            dpValve_nominal=1000,
            from_dp=true)         annotation (Placement(transformation(
                extent={{-6,6},{6,-6}},
                rotation=-90,
                origin={70,-120})));
          IDEAS.Fluid.FixedResistances.Junction jun(
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal={1,1,1},
            dp_nominal={0,0,0},
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving)
            annotation (Placement(transformation(
                extent={{-6,6},{6,-6}},
                rotation=-90,
                origin={70,-50})));
          IDEAS.Fluid.Actuators.Valves.TwoWayLinear val_coo_ret(
            use_inputFilter=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p11_m_flow,
            allowFlowReversal=false,
            dpValve_nominal=1000,
            from_dp=true)         annotation (Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=0,
                origin={90,-50})));
          Modelica.Fluid.Interfaces.FluidPort_a cooSupply(redeclare package
            Medium =
                IDEAS.Media.Water) "supply of TABS"
            annotation (Placement(transformation(extent={{110,-80},{130,-60}})));
          Modelica.Fluid.Interfaces.FluidPort_b cooReturn(redeclare package
            Medium =
                IDEAS.Media.Water) "return of TABS"
            annotation (Placement(transformation(extent={{110,-50},{130,-30}})));
          Modelica.Blocks.Math.BooleanToReal booleanToReal[2]
            annotation (Placement(transformation(extent={{-94,-126},{-82,-114}})));
          IDEAS.Fluid.Actuators.Valves.TwoWayQuickOpening
                                                    val_cca0(
            use_inputFilter=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p07_m_flow/4,
            allowFlowReversal=false,
            dpValve_nominal=2000) annotation (Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=0,
                origin={18,-12})));
          IDEAS.Fluid.Actuators.Valves.TwoWayQuickOpening
                                                    val_cca1(
            use_inputFilter=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p07_m_flow/4,
            allowFlowReversal=false,
            dpValve_nominal=2000) annotation (Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=0,
                origin={18,18})));
          IDEAS.Fluid.Actuators.Valves.TwoWayQuickOpening
                                                    val_cca2(
            use_inputFilter=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p07_m_flow/4,
            allowFlowReversal=false,
            dpValve_nominal=2000) annotation (Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=0,
                origin={18,46})));
          IDEAS.Fluid.Actuators.Valves.TwoWayQuickOpening
                                                    val_cca3(
            use_inputFilter=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p07_m_flow/4,
            allowFlowReversal=false,
            dpValve_nominal=2000) annotation (Placement(transformation(
                extent={{-8,-8},{8,8}},
                rotation=0,
                origin={18,74})));
          Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b[35] port_emb
            annotation (Placement(transformation(extent={{-24,92},{-4,112}})));
          IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_byPass_TABS(
            allowFlowReversal=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p07_m_flow,
            dp_nominal(displayUnit="kPa") = 2*83000)
                                                   "equilibrium valve" annotation (
              Placement(transformation(
                extent={{-8,8},{8,-8}},
                rotation=180,
                origin={10,-84})));
          IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_retCollector_TABS(
            allowFlowReversal=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p07_m_flow,
          dp_nominal=64000 + 20000)                "equilibrium valve" annotation (
              Placement(transformation(
                extent={{-6,-8},{6,8}},
                rotation=270,
                origin={70,-104})));
          Modelica.Blocks.Interfaces.RealOutput P_pump
            annotation (Placement(transformation(extent={{-100,-60},{-120,-40}})));
        equation

          connect(pump7.port_b, t24.port_a)
            annotation (Line(points={{-60,-36},{-60,-36},{-60,-32}},
                                                           color={0,127,255}));
          connect(t24.port_b, jun0.port_1) annotation (Line(points={{-60,-22},{-60,
                  -22},{-60,-18}}, color={0,127,255}));
          connect(jun0.port_2, jun1.port_1)
            annotation (Line(points={{-60,-6},{-60,12}}, color={0,127,255}));
          connect(jun1.port_2, jun2.port_1)
            annotation (Line(points={{-60,24},{-60,40}}, color={0,127,255}));
          connect(t25.port_a, jun3.port_2)
            annotation (Line(points={{70,-26},{70,-18}}, color={0,127,255}));
          connect(tcca0.port_b, jun3.port_3) annotation (Line(points={{52,-12},{52,
                  -12},{64,-12}}, color={0,127,255}));
          connect(jun3.port_1, jun4.port_2)
            annotation (Line(points={{70,-6},{70,3},{70,12}}, color={0,127,255}));
          connect(jun4.port_3, tcca1.port_b)
            annotation (Line(points={{64,18},{58,18},{52,18}}, color={0,127,255}));
          connect(tcca2.port_b, jun5.port_3)
            annotation (Line(points={{54,46},{59,46},{64,46}}, color={0,127,255}));
          connect(jun5.port_2, jun4.port_1)
            annotation (Line(points={{70,40},{70,32},{70,24}}, color={0,127,255}));
          connect(tcca3.port_b, jun5.port_1)
            annotation (Line(points={{54,74},{70,74},{70,52}}, color={0,127,255}));
          connect(t24.T, dataBus.T24);
          connect(t25.T, dataBus.T25);
          connect(TWVTABS.y, signalBus.TABS_3way_signal);
          connect(tcca0.T, dataBus.TretCCA0);
          connect(tcca1.T, dataBus.TretCCA1);
          connect(tcca2.T, dataBus.TretCCA2);
          connect(tcca3.T, dataBus.TretCCA3);

          connect(heaSupply, val_heat_sup.port_a)
            annotation (Line(points={{-60,-140},{-60,-126}}, color={0,127,255}));
          connect(heaReturn, val_heat_ret.port_b)
            annotation (Line(points={{70,-140},{70,-126}}, color={0,127,255}));
          connect(val_coo_sup.port_b, jun7.port_3)
            annotation (Line(points={{-30,-60},{-54,-60}},   color={0,127,255}));
          connect(val_coo_ret.port_a, jun.port_3)
            annotation (Line(points={{82,-50},{82,-50},{76,-50}}, color={0,127,255}));
          connect(val_coo_ret.port_b, cooReturn)
            annotation (Line(points={{98,-50},{110,-50},{110,-40},{120,-40}},
                                                          color={0,127,255}));
          connect(val_coo_sup.port_a, cooSupply) annotation (Line(points={{-14,-60},{
                  40,-60},{40,-70},{120,-70}},
                                     color={0,127,255}));
          connect(booleanToReal[1].u, signalBus.heatMode) annotation (Line(points={{-95.2,
                  -120},{-98,-120},{-98,-22}},       color={255,0,255}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(booleanToReal[1].y, val_heat_sup.y);
          connect(val_heat_ret.y, booleanToReal[1].y);
          connect(booleanToReal[2].u, signalBus.coolMode) annotation (Line(points={{-95.2,
                  -120},{-98,-120},{-98,-22},{-98,-22}},       color={255,0,255}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(val_coo_ret.y, booleanToReal[2].y);
          connect(val_coo_sup.y, booleanToReal[2].y);
          connect(val_cca3.port_b, tcca3.port_a)
            annotation (Line(points={{26,74},{34,74},{40,74}}, color={0,127,255}));
          connect(val_cca2.port_b, tcca2.port_a)
            annotation (Line(points={{26,46},{34,46},{40,46}}, color={0,127,255}));
          connect(val_cca1.port_b, tcca1.port_a)
            annotation (Line(points={{26,18},{32,18},{38,18}}, color={0,127,255}));
          connect(val_cca0.port_b, tcca0.port_a)
            annotation (Line(points={{26,-12},{32,-12},{38,-12}}, color={0,127,255}));
            //HeatFlow connections
          connect(cca3[1].heatPortEmb[1], port_emb[1]) annotation (Line(points={{-14,
                  83.3333},{-14,92.2857}},      color={191,0,0}));
          connect(cca3[2].heatPortEmb[1], port_emb[2]);
          connect(cca3[3].heatPortEmb[1], port_emb[3]);
          connect(cca3[4].heatPortEmb[1], port_emb[4]);
          connect(cca2[1].heatPortEmb[1], port_emb[5]);
          connect(cca2[2].heatPortEmb[1], port_emb[6]);
          connect(cca2[3].heatPortEmb[1], port_emb[7]);
          connect(cca2[4].heatPortEmb[1], port_emb[8]);
          connect(cca2[5].heatPortEmb[1], port_emb[9]);
          connect(cca2[6].heatPortEmb[1], port_emb[10]);
          connect(cca2[7].heatPortEmb[1], port_emb[11]);
          connect(cca1[1].heatPortEmb[1], port_emb[12]);
          connect(cca1[2].heatPortEmb[1], port_emb[13]);
          connect(cca1[3].heatPortEmb[1], port_emb[14]);
          connect(cca1[4].heatPortEmb[1], port_emb[15]);
          connect(cca1[5].heatPortEmb[1], port_emb[16]);
          connect(cca1[6].heatPortEmb[1], port_emb[17]);
          connect(cca1[7].heatPortEmb[1], port_emb[18]);
          connect(cca1[8].heatPortEmb[1], port_emb[19]);
          connect(cca1[9].heatPortEmb[1], port_emb[20]);
          connect(cca0[1].heatPortEmb[1], port_emb[21]);
          connect(cca0[2].heatPortEmb[1], port_emb[22]);
          connect(cca0[3].heatPortEmb[1], port_emb[23]);
          connect(cca0[4].heatPortEmb[1], port_emb[24]);
          connect(cca0[5].heatPortEmb[1], port_emb[25]);
          connect(cca0[6].heatPortEmb[1], port_emb[26]);
          connect(cca0[7].heatPortEmb[1], port_emb[27]);
          connect(cca0[8].heatPortEmb[1], port_emb[28]);
          connect(cca0[9].heatPortEmb[1], port_emb[29]);
          connect(cca0[10].heatPortEmb[1], port_emb[30]);
          connect(cca0[11].heatPortEmb[1], port_emb[31]);
          connect(cca0[12].heatPortEmb[1], port_emb[32]);
          connect(cca0[13].heatPortEmb[1], port_emb[33]);
          connect(cca0[14].heatPortEmb[1], port_emb[34]);
          connect(cca0[15].heatPortEmb[1], port_emb[35]);
          connect(cca3[1].heatPortEmb[2], port_emb[1]);
          connect(cca3[2].heatPortEmb[2], port_emb[2]);
          connect(cca3[3].heatPortEmb[2], port_emb[3]);
          connect(cca3[4].heatPortEmb[2], port_emb[4]);
          connect(cca2[1].heatPortEmb[2], port_emb[5]);
          connect(cca2[2].heatPortEmb[2], port_emb[6]);
          connect(cca2[3].heatPortEmb[2], port_emb[7]);
          connect(cca2[4].heatPortEmb[2], port_emb[8]);
          connect(cca2[5].heatPortEmb[2], port_emb[9]);
          connect(cca2[6].heatPortEmb[2], port_emb[10]);
          connect(cca2[7].heatPortEmb[2], port_emb[11]);
          connect(cca1[1].heatPortEmb[2], port_emb[12]);
          connect(cca1[2].heatPortEmb[2], port_emb[13]);
          connect(cca1[3].heatPortEmb[2], port_emb[14]);
          connect(cca1[4].heatPortEmb[2], port_emb[15]);
          connect(cca1[5].heatPortEmb[2], port_emb[16]);
          connect(cca1[6].heatPortEmb[2], port_emb[17]);
          connect(cca1[7].heatPortEmb[2], port_emb[18]);
          connect(cca1[8].heatPortEmb[2], port_emb[19]);
          connect(cca1[9].heatPortEmb[2], port_emb[20]);
          connect(cca0[1].heatPortEmb[2], port_emb[21]);
          connect(cca0[2].heatPortEmb[2], port_emb[22]);
          connect(cca0[3].heatPortEmb[2], port_emb[23]);
          connect(cca0[4].heatPortEmb[2], port_emb[24]);
          connect(cca0[5].heatPortEmb[2], port_emb[25]);
          connect(cca0[6].heatPortEmb[2], port_emb[26]);
          connect(cca0[7].heatPortEmb[2], port_emb[27]);
          connect(cca0[8].heatPortEmb[2], port_emb[28]);
          connect(cca0[9].heatPortEmb[2], port_emb[29]);
          connect(cca0[10].heatPortEmb[2], port_emb[30]);
          connect(cca0[11].heatPortEmb[2], port_emb[31]);
          connect(cca0[12].heatPortEmb[2], port_emb[32]);
          connect(cca0[13].heatPortEmb[2], port_emb[33]);
          connect(cca0[14].heatPortEmb[2], port_emb[34]);
          connect(cca0[15].heatPortEmb[2], port_emb[35]);
          connect(cca3[1].heatPortEmb[3], port_emb[1]);
          connect(cca3[2].heatPortEmb[3], port_emb[2]);
          connect(cca3[3].heatPortEmb[3], port_emb[3]);
          connect(cca3[4].heatPortEmb[3], port_emb[4]);
          connect(cca2[1].heatPortEmb[3], port_emb[5]);
          connect(cca2[2].heatPortEmb[3], port_emb[6]);
          connect(cca2[3].heatPortEmb[3], port_emb[7]);
          connect(cca2[4].heatPortEmb[3], port_emb[8]);
          connect(cca2[5].heatPortEmb[3], port_emb[9]);
          connect(cca2[6].heatPortEmb[3], port_emb[10]);
          connect(cca2[7].heatPortEmb[3], port_emb[11]);
          connect(cca1[1].heatPortEmb[3], port_emb[12]);
          connect(cca1[2].heatPortEmb[3], port_emb[13]);
          connect(cca1[3].heatPortEmb[3], port_emb[14]);
          connect(cca1[4].heatPortEmb[3], port_emb[15]);
          connect(cca1[5].heatPortEmb[3], port_emb[16]);
          connect(cca1[6].heatPortEmb[3], port_emb[17]);
          connect(cca1[7].heatPortEmb[3], port_emb[18]);
          connect(cca1[8].heatPortEmb[3], port_emb[19]);
          connect(cca1[9].heatPortEmb[3], port_emb[20]);
          connect(cca0[1].heatPortEmb[3], port_emb[21]);
          connect(cca0[2].heatPortEmb[3], port_emb[22]);
          connect(cca0[3].heatPortEmb[3], port_emb[23]);
          connect(cca0[4].heatPortEmb[3], port_emb[24]);
          connect(cca0[5].heatPortEmb[3], port_emb[25]);
          connect(cca0[6].heatPortEmb[3], port_emb[26]);
          connect(cca0[7].heatPortEmb[3], port_emb[27]);
          connect(cca0[8].heatPortEmb[3], port_emb[28]);
          connect(cca0[9].heatPortEmb[3], port_emb[29]);
          connect(cca0[10].heatPortEmb[3], port_emb[30]);
          connect(cca0[11].heatPortEmb[3], port_emb[31]);
          connect(cca0[12].heatPortEmb[3], port_emb[32]);
          connect(cca0[13].heatPortEmb[3], port_emb[33]);
          connect(cca0[14].heatPortEmb[3], port_emb[34]);
          connect(cca0[15].heatPortEmb[3], port_emb[35]);
          //Fluid connections
          //CCA0
          connect(jun0.port_3, cca0[1].port_a) annotation (Line(points={{-54,-12},{-39,-12},
                  {-24,-12}}, color={0,127,255}));
          connect(jun0.port_3, cca0[2].port_a);
          connect(jun0.port_3, cca0[3].port_a);
          connect(jun0.port_3, cca0[4].port_a);
          connect(jun0.port_3, cca0[5].port_a);
          connect(jun0.port_3, cca0[6].port_a);
          connect(jun0.port_3, cca0[7].port_a);
          connect(jun0.port_3, cca0[8].port_a);
          connect(jun0.port_3, cca0[9].port_a);
          connect(jun0.port_3, cca0[10].port_a);
          connect(jun0.port_3, cca0[11].port_a);
          connect(jun0.port_3, cca0[12].port_a);
          connect(jun0.port_3, cca0[13].port_a);
          connect(jun0.port_3, cca0[14].port_a);
          connect(jun0.port_3, cca0[15].port_a);
          connect(cca0[1].port_b, val_cca0.port_a)
            annotation (Line(points={{-4,-12},{3,-12},{10,-12}}, color={0,127,255}));
          connect(cca0[2].port_b, val_cca0.port_a);
          connect(cca0[3].port_b, val_cca0.port_a);
          connect(cca0[4].port_b, val_cca0.port_a);
          connect(cca0[5].port_b, val_cca0.port_a);
          connect(cca0[6].port_b, val_cca0.port_a);
          connect(cca0[7].port_b, val_cca0.port_a);
          connect(cca0[8].port_b, val_cca0.port_a);
          connect(cca0[9].port_b, val_cca0.port_a);
          connect(cca0[10].port_b, val_cca0.port_a);
          connect(cca0[11].port_b, val_cca0.port_a);
          connect(cca0[12].port_b, val_cca0.port_a);
          connect(cca0[13].port_b, val_cca0.port_a);
          connect(cca0[14].port_b, val_cca0.port_a);
          connect(cca0[15].port_b, val_cca0.port_a);
          //CCA1

          connect(jun1.port_3, cca1[1].port_a)
            annotation (Line(points={{-54,18},{-39,18},{-24,18}}, color={0,127,255}));
          connect(jun1.port_3, cca1[2].port_a);
          connect(jun1.port_3, cca1[3].port_a);
          connect(jun1.port_3, cca1[4].port_a);
          connect(jun1.port_3, cca1[5].port_a);
          connect(jun1.port_3, cca1[6].port_a);
          connect(jun1.port_3, cca1[7].port_a);
          connect(jun1.port_3, cca1[8].port_a);
          connect(jun1.port_3, cca1[9].port_a);
          connect(cca1[1].port_b, val_cca1.port_a)
            annotation (Line(points={{-4,18},{10,18}},         color={0,127,255}));
          connect(cca1[2].port_b, val_cca1.port_a);
          connect(cca1[3].port_b, val_cca1.port_a);
          connect(cca1[4].port_b, val_cca1.port_a);
          connect(cca1[5].port_b, val_cca1.port_a);
          connect(cca1[6].port_b, val_cca1.port_a);
          connect(cca1[7].port_b, val_cca1.port_a);
          connect(cca1[8].port_b, val_cca1.port_a);
          connect(cca1[9].port_b, val_cca1.port_a);
          connect(jun2.port_3, cca2[1].port_a)
            annotation (Line(points={{-54,46},{-24,46}},          color={0,127,255}));
          connect(jun2.port_3, cca2[2].port_a);
          connect(jun2.port_3, cca2[3].port_a);
          connect(jun2.port_3, cca2[4].port_a);
          connect(jun2.port_3, cca2[5].port_a);
          connect(jun2.port_3, cca2[6].port_a);
          connect(jun2.port_3, cca2[7].port_a);
          connect(cca2[1].port_b, val_cca2.port_a)
            annotation (Line(points={{-4,46},{3,46},{10,46}}, color={0,127,255}));
          connect(cca2[2].port_b, val_cca2.port_a);
          connect(cca2[3].port_b, val_cca2.port_a);
          connect(cca2[4].port_b, val_cca2.port_a);
          connect(cca2[5].port_b, val_cca2.port_a);
          connect(cca2[6].port_b, val_cca2.port_a);
          connect(cca2[7].port_b, val_cca2.port_a);
          connect(jun2.port_2, cca3[1].port_a) annotation (Line(points={{-60,52},{-60,
                  52},{-60,74},{-24,74}},      color={0,127,255}));
          connect(jun2.port_2, cca3[2].port_a);
          connect(jun2.port_2, cca3[3].port_a);
          connect(jun2.port_2, cca3[4].port_a);
          connect(cca3[1].port_b, val_cca3.port_a)
            annotation (Line(points={{-4,74},{4,74},{10,74}}, color={0,127,255}));
          connect(cca3[2].port_b, val_cca3.port_a);
          connect(cca3[3].port_b, val_cca3.port_a);
          connect(cca3[4].port_b, val_cca3.port_a);
          connect(val_cca3.y, signalBus.CCA3_val) annotation (Line(points={{18,83.6},
                  {-98,83.6},{-98,-22}},       color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(val_cca2.y, signalBus.CCA2_val) annotation (Line(points={{18,55.6},
                  {-98,55.6},{-98,-22}},       color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(val_cca1.y, signalBus.CCA1_val) annotation (Line(points={{18,27.6},
                  {-98,27.6},{-98,-22}},       color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(val_cca0.y, signalBus.CCA0_val) annotation (Line(points={{18,-2.4},
                  {-98,-2.4},{-98,-22}},       color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(dp_fixed_retCollector_TABS.port_b, val_heat_ret.port_a) annotation (
             Line(points={{70,-110},{70,-112},{70,-114}}, color={0,127,255}));
          connect(val_heat_sup.port_b, TWVTABS.port_1)
            annotation (Line(points={{-60,-114},{-60,-92}}, color={0,127,255}));
          connect(TWVTABS.port_2, jun7.port_1)
            annotation (Line(points={{-60,-76},{-60,-66}}, color={0,127,255}));
          connect(TWVTABS.port_3, dp_fixed_byPass_TABS.port_b) annotation (Line(
                points={{-52,-84},{-26,-84},{2,-84}}, color={0,127,255}));
          connect(jun7.port_2, pump7.port_a) annotation (Line(points={{-60,-54},{-60,
                  -54},{-60,-50}}, color={0,127,255}));
          connect(dp_fixed_retCollector_TABS.port_a, jun6.port_2)
            annotation (Line(points={{70,-98},{70,-90}}, color={0,127,255}));
          connect(jun6.port_1, jun.port_2)
            annotation (Line(points={{70,-78},{70,-56}}, color={0,127,255}));
          connect(jun.port_1, t25.port_b) annotation (Line(points={{70,-44},{70,-44},
                  {70,-36}}, color={0,127,255}));
          connect(dp_fixed_byPass_TABS.port_a, jun6.port_3) annotation (Line(points={
                  {18,-84},{18,-84},{64,-84}}, color={0,127,255}));
          connect(pump7.P, P_pump) annotation (Line(points={{-67.2,-35.3},{-67.2,-32},
                  {-84,-32},{-84,-50},{-110,-50}}, color={0,0,127}));
          connect(pump7.stage, signalBus.P07_signal) annotation (Line(points={{-69.6,
                  -43},{-84.8,-43},{-84.8,-22},{-98,-22}}, color={255,127,0}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-140},
                    {120,100}}),                                        graphics={
                  Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={28,108,200}),                                       Text(
                  extent={{-70,76},{70,-64}},
                  lineColor={28,108,200},
                  textString="TABS")}), Diagram(coordinateSystem(preserveAspectRatio=false, extent={
                    {-100,-140},{120,100}})));
        end TABS;

        model CoolingTower
          import INFRAX;
        //   replaceable package MediumGlycol =
        //       IDEAS.Media.Antifreeze.Validation.BaseClasses.PropyleneGlycolWater (
        //           property_T=273.15,
        //           X_a=0.30) constrainedby Modelica.Media.Interfaces.PartialMedium;
            replaceable package MediumGlycol = IDEAS.Media.Water;
        Buildings.Fluid.HeatExchangers.CoolingTowers.YorkCalc coolingTower(
            allowFlowReversal=false,
            redeclare final package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p11_m_flow,
            dp_nominal=35000,
            TAirInWB_nominal=273.15 + 22.2,
            TRan_nominal=5,
            PFan_nominal=4700,
            TApp_nominal=7.5,
            fraPFan_nominal=coolingTower.PFan_nominal/hydronic.p11_m_flow,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            tau=3600,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
                                "cooling tower"
            annotation (Placement(transformation(extent={{6,76},{26,96}})));

          IDEAS.Fluid.Sensors.TemperatureTwoPort t26(
            m_flow_nominal=hydronic.p11_m_flow,
            tau=hydronic.sensorTau,
            allowFlowReversal=false,
            TAmb=289.15,
            transferHeat=false,
            redeclare package Medium = MediumGlycol)      annotation (Placement(
                transformation(
                extent={{-5,-6},{5,6}},
                rotation=90,
                origin={-14,67})));
          IDEAS.Fluid.Movers.SpeedControlled_y     p11(
            allowFlowReversal=false,
            addPowerToMedium=false,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial,
            redeclare IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos80slash1to12_CAN_PN6
              per,
            inputType=IDEAS.Fluid.Types.InputType.Stages,
            riseTime=300,
            tau=60,
            use_inputFilter=false,
            redeclare package Medium = MediumGlycol)
                                      "TABS pump" annotation (Placement(
                transformation(
                extent={{-6,-8},{6,8}},
                rotation=90,
                origin={-14,44})));
          IBPSA.Fluid.HeatExchangers.DryCoilEffectivenessNTU e006(
            redeclare package Medium1 = IDEAS.Media.Water,
            configuration=Buildings.Fluid.Types.HeatExchangerConfiguration.CounterFlow,
            m1_flow_nominal=26000/3600,
            dp1_nominal=39300,
            dp2_nominal=47500,
            Q_flow_nominal(displayUnit="W") = 150000,
            r_nominal=0.474/0.621,
            m2_flow_nominal=27000/3600,
            allowFlowReversal1=false,
            allowFlowReversal2=false,
            redeclare package Medium2 = MediumGlycol,
            T_a1_nominal=308.15,
            T_a2_nominal=302.65) "cooling tower heat exchanger" annotation (Placement(
                transformation(
                extent={{7,-8},{-7,8}},
                rotation=180,
                origin={17,-20})));

          IDEAS.Fluid.Movers.SpeedControlled_y     p10(
            redeclare package Medium = IDEAS.Media.Water,
            allowFlowReversal=false,
            addPowerToMedium=false,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            energyDynamics=Modelica.Fluid.Types.Dynamics.DynamicFreeInitial,
            redeclare
              IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos65slash1to12_CAN_PN6slash10
              per,
            inputType=IDEAS.Fluid.Types.InputType.Stages,
            riseTime=300,
            T_start=284.15,
            tau=60,
            use_inputFilter=false)    "TABS pump" annotation (Placement(
                transformation(
                extent={{-7,-9},{7,9}},
                rotation=90,
                origin={-1,-59})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort t31(
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p10_m_flow,
            tau=hydronic.sensorTau,
            allowFlowReversal=false,
            transferHeat=false)     annotation (Placement(transformation(
                extent={{-5,-5},{5,5}},
                rotation=90,
                origin={-1,-31})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort t32(
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p10_m_flow,
            tau=hydronic.sensorTau,
            allowFlowReversal=false,
            transferHeat=false)     annotation (Placement(transformation(
                extent={{5,-4},{-5,4}},
                rotation=90,
                origin={30,-39})));
          INFRAX.Data.Parameters.Hydronic hydronic
            annotation (Placement(transformation(extent={{-80,80},{-60,100}})));
          Modelica.Blocks.Interfaces.RealOutput TLvg annotation (Placement(
                transformation(rotation=0, extent={{100,-70},{120,-50}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_a(redeclare final package
            Medium =
                IDEAS.Media.Water) annotation (Placement(transformation(rotation=0,
                  extent={{-12,-110},{10,-90}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b(redeclare final package
            Medium =
                IDEAS.Media.Water) annotation (Placement(transformation(rotation=0,
                  extent={{18,-110},{42,-90}})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort t27(
            m_flow_nominal=hydronic.p11_m_flow,
            tau=hydronic.sensorTau,
            allowFlowReversal=false,
            TAmb=289.15,
            transferHeat=false,
            redeclare package Medium = MediumGlycol)
                            annotation (Placement(transformation(
                extent={{-7,-6.5},{7,6.5}},
                rotation=-90,
                origin={61.5,65})));
          Controllers.DataBus dataBus annotation (Placement(transformation(extent={{-158,0},
                    {-118,40}}),    iconTransformation(extent={{-150,6},{-130,26}})));
          Controllers.SignalBus signalBus annotation (Placement(transformation(extent={{-158,
                    -40},{-118,0}}),       iconTransformation(extent={{-150,-28},{
                    -130,-8}})));
          Modelica.Fluid.Interfaces.FluidPort_a port_a1(redeclare package
            Medium =
                MediumGlycol)      annotation (Placement(transformation(rotation=0,
                  extent={{88,0},{112,20}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b1(redeclare package
            Medium =
                MediumGlycol)      annotation (Placement(transformation(rotation=0,
                  extent={{88,20},{112,40}})));
          IDEAS.Fluid.Actuators.Valves.TwoWayLinear val_hex_sup(
            use_inputFilter=false,
            m_flow_nominal=hydronic.p11_m_flow,
            dpValve_nominal=0.01,
            l=1e-10,
            redeclare package Medium = MediumGlycol)
                                  annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=90,
                origin={-14,-6})));
          IDEAS.Fluid.Actuators.Valves.TwoWayLinear val_hex_ret(
            use_inputFilter=false,
            m_flow_nominal=hydronic.p11_m_flow,
            dpValve_nominal=0.01,
            l=1e-10,
            redeclare package Medium = MediumGlycol)
                                  annotation (Placement(transformation(
                extent={{-6,6},{6,-6}},
                rotation=-90,
                origin={60,-6})));
          IDEAS.Fluid.FixedResistances.Junction jun(
            m_flow_nominal={1,1,1},
            dp_nominal={0,0,0},
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            redeclare package Medium = MediumGlycol)
            annotation (Placement(transformation(
                extent={{-5,5},{5,-5}},
                rotation=-90,
                origin={61,31})));
          IDEAS.Fluid.FixedResistances.Junction jun1(
            m_flow_nominal={1,1,1},
            dp_nominal={0,0,0},
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
            redeclare package Medium = MediumGlycol)
            annotation (Placement(transformation(
                extent={{5,5},{-5,-5}},
                rotation=-90,
                origin={-13,13})));
          IDEAS.Fluid.Actuators.Valves.TwoWayLinear val_cc_sup(
            use_inputFilter=false,
            m_flow_nominal=hydronic.p11_m_flow,
            dpValve_nominal=0.01,
            allowFlowReversal=false,
            l=1e-10,
            redeclare package Medium = MediumGlycol)
                                   annotation (Placement(transformation(
                extent={{7,-7},{-7,7}},
                rotation=0,
                origin={27,13})));
          IDEAS.Fluid.Actuators.Valves.TwoWayLinear val_cc_ret(
            use_inputFilter=false,
            m_flow_nominal=hydronic.p11_m_flow,
            dpValve_nominal=0.01,
            allowFlowReversal=false,
            l=1e-10,
            redeclare package Medium = MediumGlycol)
                                  annotation (Placement(transformation(
                extent={{-7,-7},{7,7}},
                rotation=0,
                origin={83,31})));
          Modelica.Blocks.Math.BooleanToReal booleanToReal[2]
            annotation (Placement(transformation(extent={{-88,-12},{-72,4}})));
                                                              //1 to hex, 2 to cc
          IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_e006_primary(
            allowFlowReversal=false,
            redeclare package Medium = IDEAS.Media.Water,
            m_flow_nominal=hydronic.p10_m_flow,
            dp_nominal(displayUnit="kPa") = 2900) "equilibrium valve" annotation (
              Placement(transformation(
                extent={{-8,8},{8,-8}},
                rotation=270,
                origin={30,-70})));
          IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_e006_primary1(
            allowFlowReversal=false,
            m_flow_nominal=hydronic.p11_m_flow,
            dp_nominal(displayUnit="kPa") = 2700,
            redeclare package Medium = MediumGlycol)
                                                  "equilibrium valve" annotation (
              Placement(transformation(
                extent={{-8,8},{8,-8}},
                rotation=0,
                origin={42,86})));
          IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_e006_primary2(
            allowFlowReversal=false,
            m_flow_nominal=hydronic.p11_m_flow,
            dp_nominal(displayUnit="kPa") = 33800,
            redeclare package Medium = MediumGlycol)
                                                   "equilibrium valve" annotation (
              Placement(transformation(
                extent={{-8,8},{8,-8}},
                rotation=180,
                origin={82,12})));
          Modelica.Blocks.Interfaces.RealOutput P_pumps annotation (Placement(
                transformation(rotation=0, extent={{100,62},{120,82}})));
          Modelica.Blocks.Math.Add add
            annotation (Placement(transformation(extent={{82,66},{94,78}})));
          Modelica.Blocks.Interfaces.RealOutput P_CT annotation (Placement(
                transformation(rotation=0, extent={{100,80},{120,100}})));
          Modelica.Blocks.Sources.RealExpression realExpression(y=coolingTower.PFan)
            annotation (Placement(transformation(extent={{72,80},{92,100}})));
        equation
          connect(p10.port_b,t31. port_a)
            annotation (Line(points={{-1,-52},{-1,-36}},          color={0,127,255}));
          connect(e006.port_a1,t31. port_b) annotation (Line(points={{10,-24.8},{-1,-24.8},
                  {-1,-26}},       color={0,127,255}));
          connect(e006.port_b1,t32. port_a) annotation (Line(points={{24,-24.8},{30,-24.8},
                  {30,-34}},       color={0,127,255}));
          connect(p11.port_b,t26. port_a)
            annotation (Line(points={{-14,50},{-14,62}},          color={0,127,255}));
          connect(t26.port_b,coolingTower. port_a)
            annotation (Line(points={{-14,72},{-14,86},{6,86}},   color={0,127,255}));
          connect(TLvg, coolingTower.TLvg) annotation (Line(points={{110,-60},{110,
                  -60},{70,-60},{70,80},{27,80}},
                                      color={0,0,127}));
          connect(port_a, p10.port_a)
            annotation (Line(points={{-1,-100},{-1,-66}},       color={0,127,255}));
          connect(t26.T, dataBus.T26);
          connect(t27.T, dataBus.T27);
          connect(t31.T, dataBus.T31);
          connect(t32.T, dataBus.T32);
          connect(coolingTower.TAir, signalBus.Twet);
          connect(p11.stage, signalBus.P11_signal);
          connect(p10.stage, signalBus.P10_signal);
          connect(e006.port_b2, val_hex_sup.port_a) annotation (Line(points={{10,-15.2},
                  {-2,-15.2},{-2,-14},{-14,-14},{-14,-12}}, color={0,127,255}));
          connect(e006.port_a2, val_hex_ret.port_b) annotation (Line(points={{24,-15.2},
                  {42,-15.2},{42,-16},{60,-16},{60,-12}},color={0,127,255}));
          connect(jun.port_2, val_hex_ret.port_a)
            annotation (Line(points={{61,26},{60,26},{60,-8.88178e-16}},
                                                              color={0,127,255}));
          connect(jun.port_1, t27.port_b) annotation (Line(points={{61,36},{62,36},{
                  62,40},{61.5,40},{61.5,58}},
                                      color={0,127,255}));
          connect(val_hex_sup.port_b, jun1.port_1)
            annotation (Line(points={{-14,0},{-14,8},{-13,8}}, color={0,127,255}));
          connect(jun1.port_2, p11.port_a)
            annotation (Line(points={{-13,18},{-14,18},{-14,38}}, color={0,127,255}));
          connect(jun1.port_3, val_cc_sup.port_b)
            annotation (Line(points={{-8,13},{20,13}}, color={0,127,255}));
          connect(port_b1, val_cc_ret.port_b) annotation (Line(points={{100,30},{96,30},
                  {96,31},{90,31}}, color={0,127,255}));
          connect(jun.port_3, val_cc_ret.port_a)
            annotation (Line(points={{66,31},{68,31},{76,31}}, color={0,127,255}));
          connect(booleanToReal[1].u, signalBus.Hex_2way_signal) annotation (Line(
                points={{-89.6,-4},{-138,-4},{-138,-20}},       color={255,0,255}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(booleanToReal[1].y, val_hex_sup.y) annotation (Line(points={{-71.2,-4},
                  {-48,-4},{-21.2,-4},{-21.2,-6}}, color={0,0,127},
              visible=false));
          connect(booleanToReal[1].y, val_hex_ret.y) annotation (Line(points={{-71.2,-4},
                  {-10,-4},{-10,-6},{52.8,-6}},
                                              color={0,0,127},
              visible=false));
          connect(booleanToReal[2].u, signalBus.CC_2way_signal) annotation (Line(points={{-89.6,
                  -4},{-112,-4},{-138,-4},{-138,-20}},              color={255,0,255}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(booleanToReal[2].y, val_cc_sup.y) annotation (Line(points={{-71.2,-4},
                  {-66,-4},{-66,32},{26,32},{26,21.4},{27,21.4}}, color={0,0,127},
              visible=false));
          connect(booleanToReal[2].y, val_cc_ret.y) annotation (Line(points={{-71.2,-4},
                  {-66,-4},{-66,56},{83,56},{83,39.4}}, color={0,0,127},
              visible=false));
          connect(t32.port_b, dp_fixed_e006_primary.port_a) annotation (Line(points={
                  {30,-44},{30,-53},{30,-62}}, color={0,127,255}));
          connect(dp_fixed_e006_primary.port_b, port_b) annotation (Line(points={{30,
                  -78},{30,-78},{30,-100}}, color={0,127,255}));
          connect(coolingTower.port_b, dp_fixed_e006_primary1.port_a)
            annotation (Line(points={{26,86},{34,86}}, color={0,127,255}));
          connect(dp_fixed_e006_primary1.port_b, t27.port_a) annotation (Line(points=
                  {{50,86},{61.5,86},{61.5,72}}, color={0,127,255}));
          connect(port_a1, dp_fixed_e006_primary2.port_a) annotation (Line(points={{
                  100,10},{95,10},{95,12},{90,12}}, color={0,127,255}));
          connect(dp_fixed_e006_primary2.port_b, val_cc_sup.port_a)
            annotation (Line(points={{74,12},{34,12},{34,13}}, color={0,127,255}));
          connect(add.y, P_pumps)
            annotation (Line(points={{94.6,72},{110,72},{110,72}}, color={0,0,127}));
          connect(p11.P, add.u1) annotation (Line(
              points={{-21.2,50.6},{-21.2,75.6},{80.8,75.6}},
              color={0,0,127},
              visible=false));
          connect(p10.P, add.u2) annotation (Line(
              points={{-9.1,-51.3},{-9.1,68.4},{80.8,68.4}},
              color={0,0,127},
              visible=false));
          connect(realExpression.y, P_CT)
            annotation (Line(points={{93,90},{110,90}}, color={0,0,127}));
          connect(coolingTower.y, signalBus.CT_signal) annotation (Line(points={{4,94},
                  {-138,94},{-138,-20}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          annotation (Diagram(coordinateSystem(extent={{-140,-100},{100,100}})), Icon(
                coordinateSystem(extent={{-140,-100},{100,100}})));
        end CoolingTower;

        model IdealCircuitSwitch
          replaceable package Medium = Modelica.Media.Interfaces.PartialMedium;
          parameter Modelica.SIunits.MassFlowRate m_flow_nominal = 1
            "Nominal mass flow rate for checking validity";
          parameter Boolean simplify = true;
          parameter Real fra = 0.5
            "Flow fraction that exits through port b when both valves are opened"
            annotation(Dialog(enable=allowBCOpen));
          parameter Boolean colorRed= true
            "Set to true if lines should be drawn in red instead of black"
            annotation(Dialog(tab="Icon"));
          parameter Boolean setEqualPressureAB = false "True, to equate pressure at A and B, otherwise flow rate is prescribed"
            annotation(Evaluate=true);
          parameter Boolean setEqualPressureBC = true "= true, to equate pressure at B and C, else pressure at A and C are equated"
            annotation(Evaluate=true);
          parameter Boolean allowBCOpen = true "= false, to assert that both valves are not opened simultaneously";
          parameter Modelica.SIunits.Pressure dpValve_nominal=1000
            "Nominal pressure drop of fully open valve, used if CvData=Solarwind.Fluid.Types.CvTypes.OpPoint"
            annotation(Dialog(enable=not simplify));
          Modelica.Fluid.Interfaces.FluidPort_a port_a(redeclare package Medium
            =   Medium)
            annotation (Placement(transformation(extent={{-112,-10},{-92,10}}),
                iconTransformation(extent={{-112,-10},{-92,10}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_b(redeclare package Medium
            =   Medium)
            annotation (Placement(transformation(extent={{88,-10},{108,10}}),
                iconTransformation(extent={{88,-10},{108,10}})));
          Modelica.Fluid.Interfaces.FluidPort_b port_c(redeclare package Medium
            =   Medium)
            annotation (Placement(transformation(extent={{-10,90},{10,110}})));
          Modelica.Blocks.Interfaces.BooleanInput u_val1 "Control signal for valve 1"
            annotation (Placement(transformation(
                extent={{-20,-20},{20,20}},
                rotation=90,
                origin={-60,-106})));
          Modelica.Blocks.Interfaces.BooleanInput u_val2 "Control signal for valve 2"
            annotation (Placement(transformation(
                extent={{20,-20},{-20,20}},
                rotation=270,
                origin={60,-106})));
          IDEAS.Fluid.Actuators.Valves.TwoWayLinear val(
            redeclare package Medium = Medium,
            m_flow_nominal=m_flow_nominal,
            dpValve_nominal=dpValve_nominal,
            use_inputFilter=false) if not simplify
            annotation (Placement(transformation(extent={{-60,10},{-40,-10}})));
          IDEAS.Fluid.Actuators.Valves.TwoWayLinear val1(
            redeclare package Medium = Medium,
            m_flow_nominal=m_flow_nominal,
            dpValve_nominal=dpValve_nominal,
            use_inputFilter=false) if not simplify
            annotation (Placement(transformation(extent={{40,10},{60,-10}})));

          Modelica.Blocks.Math.BooleanToReal booleanToReal if not simplify  annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-50,-50})));
          Modelica.Blocks.Math.BooleanToReal booleanToReal1 if not simplify  annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={50,-50})));
        equation
          assert(u_val1 or u_val2 or abs(port_c.m_flow)< m_flow_nominal/1e4, "IdealCircuitSwitch invalid since mass flow when valves are closed: port_c.m_flow = "+ String(port_c.m_flow));

            if simplify then
              if setEqualPressureAB then
                assert(abs(port_a.m_flow+port_c.m_flow+port_b.m_flow)<m_flow_nominal/1e4, "IdealCircuitSwitch invalid since mass is not conserved: sum = " + String(port_a.m_flow+port_c.m_flow+port_b.m_flow));
                port_a.p= port_b.p;
                port_b.m_flow=  -port_c.m_flow*(if u_val1 and not u_val2 then 0 elseif u_val1 and u_val2 then fra else 1);
              else
                //assert(abs(port_b.p-port_a.p)<0.001, "IdealCircuitSwitch invalid since pressure difference across port_a and port_b");
                port_a.m_flow+port_b.m_flow+port_c.m_flow=0;
                // weird construction since normal else/if causes singularity
                port_a.m_flow= -port_c.m_flow*(if u_val1 and not u_val2 then 1 elseif u_val1 and u_val2 then 1-fra else 0);
              end if;

              if setEqualPressureBC then
                port_b.p=port_c.p;
              else
                port_a.p=port_c.p;
              end if;
              if not allowBCOpen then
                  assert(not u_val1 or not u_val2 or port_c.m_flow >  -m_flow_nominal/1e4, "IdealCircuitSwitch invalid since both valves are opened and mass flow rate is flowing out of port c");
              end if;

            inStream(port_c.h_outflow) = port_a.h_outflow;
            inStream(port_c.h_outflow) = port_b.h_outflow;
            inStream(port_c.Xi_outflow) = port_a.Xi_outflow;
            inStream(port_c.Xi_outflow) = port_b.Xi_outflow;
            inStream(port_c.C_outflow) = port_a.C_outflow;
            inStream(port_c.C_outflow) = port_b.C_outflow;
            if u_val1 then
              port_c.h_outflow=inStream(port_a.h_outflow);
              port_c.Xi_outflow=inStream(port_a.Xi_outflow);
              port_c.C_outflow=inStream(port_a.C_outflow);
            else
              port_c.h_outflow=inStream(port_b.h_outflow);
              port_c.Xi_outflow=inStream(port_b.Xi_outflow);
              port_c.C_outflow=inStream(port_b.C_outflow);
            end if;
          end if;
          connect(val1.port_b, port_b)
            annotation (Line(points={{60,0},{98,0}}, color={0,127,255}));
          connect(val.port_a, port_a)
            annotation (Line(points={{-60,0},{-102,0}}, color={0,127,255}));
          connect(val.port_b, val1.port_a)
            annotation (Line(points={{-40,0},{40,0}}, color={0,127,255}));
          connect(val.port_b, port_c) annotation (Line(points={{-40,0},{-22,0},{0,0},{0,
                  100}}, color={0,127,255}));
          connect(u_val1, booleanToReal.u) annotation (Line(points={{-60,-106},{-50,-106},
                  {-50,-62}}, color={255,0,255}));
          connect(booleanToReal.y, val.y) annotation (Line(points={{-50,-39},{-50,-25.5},
                  {-50,-12}}, color={0,0,127}));
          connect(booleanToReal1.y, val1.y)
            annotation (Line(points={{50,-39},{50,-12}},          color={0,0,127}));
          connect(booleanToReal1.u, u_val2) annotation (Line(points={{50,-62},{50,-106},
                  {60,-106}}, color={255,0,255}));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})), Icon(coordinateSystem(preserveAspectRatio=false,
                  extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,22},{-20,-20}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{-102,8},{-20,-8}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Polygon(
                  points={{-88,24},{-60,2},{-34,24},{-88,24}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Polygon(
                  points={{-88,-20},{-60,2},{-32,-22},{-88,-20}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Polygon(
                  points={{-60,2},{-26,32},{-26,-30},{-60,2}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{-60,2},{-94,32},{-94,-28},{-60,2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  lineThickness=0.5),
                Rectangle(
                  extent={{20,24},{100,-20}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={192,192,192}),
                Rectangle(
                  extent={{20,8},{102,-8}},
                  lineColor={0,0,0},
                  fillPattern=FillPattern.HorizontalCylinder,
                  fillColor={0,127,255}),
                Polygon(
                  points={{32,24},{60,2},{86,24},{32,24}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Polygon(
                  points={{32,-20},{60,2},{88,-22},{32,-20}},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  pattern=LinePattern.None),
                Polygon(
                  points={{60,2},{94,32},{94,-30},{60,2}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{60,2},{26,32},{26,-28},{60,2}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-20,0},{20,0}},
                  color=if colorRed then {255,0,0} else {0,0,0},
                  thickness=0.5),
                Line(
                  points={{-18,0},{84,5.18001e-15}},
                  color=if colorRed then {255,0,0} else {0,0,0},
                  origin={0,18},
                  rotation=90,
                  thickness=0.5),
                Line(points={{-60,-94},{-60,2}},color={255,0,255}),
                Line(points={{60,-94},{60,2}},color={255,0,255})}));
        end IdealCircuitSwitch;
      end Components;
    end HeatingSystem;

    package VentilationSystem

      model VentilationSystem "detailed ventilation system for testing"

        IDEAS.Fluid.Sources.Boundary_pT bouAmb(
          use_T_in=true,
          nPorts=2,
          use_X_in=false,
          redeclare package Medium = MediumAir,
          use_Xi_in=MediumAir.nXi > 0,
          use_C_in=MediumAir.nC > 0)
                    "ambient boundary"
          annotation (Placement(transformation(extent={{-160,-20},{-140,0}})));
        outer IDEAS.BoundaryConditions.SimInfoManager sim
          annotation (Placement(transformation(extent={{-200,80},{-180,100}})));
        INFRAX.Data.Parameters.Hydronic hydronic
          annotation (Placement(transformation(extent={{-140,80},{-120,100}})));

        final parameter Real s_co2[max(MediumAir.nC,1)] = {if Modelica.Utilities.Strings.isEqual(string1=if MediumAir.nC>0 then MediumAir.extraPropertiesNames[i] else "",
                                                   string2="CO2",
                                                   caseSensitive=false)
                                                   then 1 else 0 for i in 1:max(MediumAir.nC,1)};

        replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface[7] dp_ducts_supply "pressure drops in supply ducts"
          annotation (Placement(transformation(extent={{32,-56},{52,-36}})));
        replaceable IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations supplyFan
          "supply fan of the air handling unit"
          annotation (Placement(transformation(extent={{-36,-56},{-16,-36}})));
        replaceable IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations exhaustFan
          "supply fan of the air handling unit"
          annotation (Placement(transformation(extent={{-44,8},{-64,28}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort tAHUSupply(
          m_flow_nominal=10000*1.225/3600,
          allowFlowReversal=false,
          redeclare package Medium = MediumAir,
          tau=60)         annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=0,
              origin={6,-46})));
        INFRAX.Data.Parameters.Air air
          annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
        replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface[15] vav_supply
          "vav supply ducts" annotation (Placement(transformation(
              extent={{-8.5,-8.5},{8.5,8.5}},
              rotation=0,
              origin={42.5,-79.5})));
        replaceable
        IDEAS.Fluid.HeatExchangers.BaseClasses.PartialEffectiveness[21] counterFlowHEX
          constrainedby IDEAS.Fluid.Interfaces.PartialFourPortInterface
          annotation (Placement(transformation(extent={{150,4},{128,-18}})));
        replaceable IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations pump6
                          "HeaCoi pump" annotation (Placement(transformation(
              extent={{-8,-8},{8,8}},
              rotation=90,
              origin={160,-72})));
        IDEAS.Fluid.Actuators.Valves.ThreeWayEqualPercentageLinear[21] TWVHeaCoi(
          each massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          each tau=200,
          each CvData=IDEAS.Fluid.Types.CvTypes.Kv,
          each portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          each portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          each portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          each riseTime=150,
          each y_start=0,
          each use_inputFilter=false,
          Kv=air.Kv,
          m_flow_nominal=air.m_nominal_water,
          R=air.R,
          redeclare package Medium = MediumWater,
          each fraK=1,
          from_dp=true,
          dpFixed_nominal=transpose(cat(
              1,
              {air.dp_water},
              {zeros(21)})),
          each energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
                                            annotation (Placement(transformation(
              extent={{8,-8},{-8,8}},
              rotation=90,
              origin={120,-32})));
        IDEAS.Fluid.FixedResistances.Junction[21] jun(
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          each m_flow_nominal={1,1,1},
          each dp_nominal={0,0,0},
          redeclare package Medium = MediumWater,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving)
          annotation (Placement(transformation(
              extent={{8,-8},{-8,8}},
              rotation=-90,
              origin={160,-32})));
        IDEAS.Fluid.FixedResistances.PressureDrop[21] dp_HeaCoi_supply(
          allowFlowReversal=false,
          m_flow_nominal=air.m_nominal_water,
          redeclare package Medium = MediumWater,
          from_dp=true,
          dp_nominal=(air.dp_fixed_return + air.dp_fixed_supply))
          "pressure loses in pipe to heating coil"
          annotation (Placement(transformation(
              extent={{-8,-8},{8,8}},
              rotation=90,
              origin={160,-52})));
        replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface[10] dp_ducts_extract
         "pressure drops in extract ducts"
          annotation (Placement(transformation(extent={{32,10},{12,30}})));
        replaceable IDEAS.Fluid.Interfaces.PartialTwoPortInterface[14] vav_extract
          "vav supply ducts" annotation (Placement(transformation(
              extent={{8.5,-8.5},{-8.5,8.5}},
              rotation=0,
              origin={22.5,52.5})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort tAHUExtract(
          m_flow_nominal=8850*1.225/3600,
          allowFlowReversal=false,
          redeclare package Medium = MediumAir,
          tau=60)         annotation (Placement(transformation(
              extent={{6,-6},{-6,6}},
              rotation=0,
              origin={-28,20})));
        replaceable Components.AHU_baseline
                                   aHU(
          dpAirCooCoi_nominal=0,
          dpAirHeaCoi_nominal=0,
          dpWatCooCoi_nominal(displayUnit="kPa") = 27100,
          dpWatHeaCoi_nominal(displayUnit="kPa") = 31600,
          redeclare package MediumHeaCoi = MediumGlycol,
          redeclare package MediumCooCoi = MediumWater,
          tau=60,
          tauWater=60,
          tauAir=60,
          tauSensor=60,
          QCooCoi_nominal=-59300,
          TCooCoiWatSup_nominal=285.15,
          TCooCoiWatRet_nominal=288.15,
          TCooCoiAirSup_nominal=299.65,
          TCooCoiAirRet_nominal=287.35,
          THeaCoiWatSup_nominal=305.15,
          THeaCoiWatRet_nominal=301.15,
          THeaCoiAirSup_nominal=265.15,
          THeaCoiAirRet_nominal=274.85)
        constrainedby
        INFRAX.SubSystems.VentilationSystem.Components.Dependencies.PartialAHU(
          mFlowAirSup_nominal=10000*1.225/3600,
          mFlowAirRet_nominal=8850*1.225/3600,
          mFlowWatHeaCoi_nominal=hydronic.p09_m_flow,
          mFlowWatCooCoi_nominal=hydronic.p13_m_flow,
          QHeaCoi_nominal=34000,
          epsRecovery=(0.693 + 0.716)/2,
          QCooCoi_nominal=-59300,
          dpAirRetTW_nominal=0,
          dpWatCooCoi_nominal(displayUnit="kPa") = 27100,
          dpAirCooCoi_nominal=0,
          dpWatHeaCoi_nominal(displayUnit="kPa") = 31600,
          dpAirHeaCoi_nominal=0,
          dpAirSupTW_nominal=0,
          tauWater=600,
          redeclare package MediumAir = MediumAir,
          redeclare package MediumCooCoi = MediumWater,
          redeclare package MediumHeaCoi = MediumGlycol,
          TCooCoiWatSup_nominal=285.15,
          TCooCoiWatRet_nominal=288.15,
          TCooCoiAirSup_nominal=299.65,
          TCooCoiAirRet_nominal=287.35,
          THeaCoiWatSup_nominal=305.15,
          THeaCoiWatRet_nominal=301.15,
          THeaCoiAirSup_nominal=265.15,
          THeaCoiAirRet_nominal=274.85)
          annotation (Placement(transformation(extent={{-84,-24},{-122,14}})));
        replaceable IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations pump9
                          "HeaCoi pump" annotation (Placement(transformation(
              extent={{6.5,-7.5},{-6.5,7.5}},
              rotation=0,
              origin={-160.5,-38.5})));
        replaceable IDEAS.Fluid.Interfaces.LumpedVolumeDeclarations pump13
                                                                          "CooCoi pump" annotation (Placement(transformation(
              extent={{-7,-8},{7,8}},
              rotation=90,
              origin={-80,-61})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t15(
                                 m_flow_nominal=hydronic.p13_m_flow,
          tau=hydronic.sensorTau,
          allowFlowReversal=false,
          redeclare package Medium = MediumWater)                    annotation (
            Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=0,
              origin={-152,-96})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t16(
                                 m_flow_nominal=hydronic.p13_m_flow,
          tau=hydronic.sensorTau,
          allowFlowReversal=false,
          redeclare package Medium = MediumWater)                    annotation (
            Placement(transformation(
              extent={{-6,6},{6,-6}},
              rotation=180,
              origin={-170,-76})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t23(
          tau=hydronic.sensorTau,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p09_m_flow,
          redeclare package Medium = MediumGlycol)
                                              annotation (Placement(transformation(
              extent={{-6,6},{6,-6}},
              rotation=180,
              origin={-126,-38})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort t22(
          tau=hydronic.sensorTau,
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p09_m_flow,
          redeclare package Medium = MediumGlycol)
                                              annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=0,
              origin={-124,-60})));
        IDEAS.Fluid.Actuators.Valves.ThreeWayEqualPercentageLinear TWV_AHU_CooCoi(
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          tau=200,
          CvData=IDEAS.Fluid.Types.CvTypes.Kv,
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          riseTime=150,
          y_start=0,
          use_inputFilter=false,
          Kv=31.5,
          R=100,
          m_flow_nominal=hydronic.p13_m_flow,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          redeclare package Medium = MediumWater,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
                                              "3way valve of cooling coiil of ahu"
                                                     annotation (Placement(
              transformation(
              extent={{6,-6},{-6,6}},
              rotation=90,
              origin={-94,-40})));
        IDEAS.Fluid.FixedResistances.Junction jun1(
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          each m_flow_nominal={1,1,1},
          each dp_nominal={0,0,0},
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          redeclare package Medium = MediumWater)
          annotation (Placement(transformation(
              extent={{6,-6},{-6,6}},
              rotation=-90,
              origin={-80,-40})));
        IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_AHU_CooCoi(
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p13_m_flow,
          dp_nominal(displayUnit="kPa") = 0,
          redeclare package Medium = MediumWater)       "equilibrium valve"
          annotation (Placement(transformation(
              extent={{-8,-6},{8,6}},
              rotation=180,
              origin={-144,-76})));
        IDEAS.Fluid.Actuators.Valves.ThreeWayEqualPercentageLinear TWV_AHU_HeaCoi(
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          tau=200,
          CvData=IDEAS.Fluid.Types.CvTypes.Kv,
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          riseTime=150,
          y_start=0,
          use_inputFilter=false,
          m_flow_nominal=hydronic.p09_m_flow,
          R=100,
          Kv=12.5,
          redeclare package Medium = MediumGlycol,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState)
                   "3way valve of heating coiil of ahu" annotation (Placement(
              transformation(
              extent={{6,-6},{-6,6}},
              rotation=0,
              origin={-142,-38})));
        IDEAS.Fluid.FixedResistances.Junction jun2(
          portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
          energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
          portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          each m_flow_nominal={1,1,1},
          each dp_nominal={0,0,0},
          portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving,
          redeclare package Medium = MediumGlycol)
          annotation (Placement(transformation(
              extent={{6,-6},{-6,6}},
              rotation=180,
              origin={-142,-60})));
        IDEAS.Fluid.FixedResistances.PressureDrop dp_fixed_AHU_HeaCoi(
          allowFlowReversal=false,
          m_flow_nominal=hydronic.p09_m_flow,
          dp_nominal(displayUnit="kPa") = 0,
          redeclare package Medium = MediumGlycol)      "equilibrium valve"
          annotation (Placement(transformation(
              extent={{8,-6},{-8,6}},
              rotation=180,
              origin={-166,-60})));
        Modelica.Fluid.Interfaces.FluidPort_b AHUHeaCoi_b(redeclare package
          Medium =
              MediumGlycol)      "return from AHU heating coil"
          annotation (Placement(transformation(extent={{-210,-50},{-190,-30}})));
        Modelica.Fluid.Interfaces.FluidPort_a AHUHeaCoi_a(redeclare package
          Medium =
              MediumGlycol)      "supply to AHU heating coil"
          annotation (Placement(transformation(extent={{-210,-70},{-190,-50}})));
        Modelica.Fluid.Interfaces.FluidPort_b AHUCooCoi_b(redeclare package
          Medium =
              IDEAS.Media.Water) "return from AHU cooling coil"
          annotation (Placement(transformation(extent={{-210,-86},{-190,-66}})));
        Modelica.Fluid.Interfaces.FluidPort_a AHUCooCoi_a(redeclare package
          Medium =
              IDEAS.Media.Water) "supply to AHU cooling coil"
          annotation (Placement(transformation(extent={{-210,-106},{-190,-86}})));
        Modelica.Fluid.Interfaces.FluidPort_b HeaCoi_b(redeclare package Medium
          =   MediumWater)       "return from the VAV/ducts coils"
          annotation (Placement(transformation(extent={{110,-110},{130,-90}})));
        Modelica.Fluid.Interfaces.FluidPort_a HeaCoi_a(redeclare package Medium
          =   MediumWater)       "supply to VAV/ducts coils"
          annotation (Placement(transformation(extent={{150,-110},{170,-90}})));
        Controllers.SignalBus signalBus annotation (Placement(transformation(extent={{-214,20},
                  {-186,48}}),           iconTransformation(extent={{-210,-30},{-190,-10}})));
        Controllers.DataBus dataBus annotation (Placement(transformation(extent={{-214,44},
                  {-184,72}}),    iconTransformation(extent={{-210,4},{-190,24}})));
        IDEAS.Fluid.Sensors.TemperatureTwoPort[21] tAirSupply(
          m_flow_nominal=10000*1.225/3600,
          allowFlowReversal=false,
          redeclare package Medium = MediumAir,
          tau=60)  annotation (Placement(transformation(
              extent={{-6,-6},{6,6}},
              rotation=0,
              origin={160,0})));
        Modelica.Fluid.Interfaces.FluidPort_b[21] airSupply(redeclare package
          Medium =
              MediumAir)       "air supply"
          annotation (Placement(transformation(extent={{146,90},{166,110}})));
        Modelica.Fluid.Interfaces.FluidPort_a[21] airReturn(redeclare package
          Medium =
              MediumAir)       "air return"
          annotation (Placement(transformation(extent={{106,90},{126,110}})));
        Modelica.Blocks.Sources.RealExpression realExpression2(y=supplyFan.P +
              exhaustFan.P + pump6.P + pump9.P + pump13.P)
          annotation (Placement(transformation(extent={{-98,64},{-118,84}})));
        Modelica.Blocks.Interfaces.RealOutput total_P
          annotation (Placement(transformation(extent={{-200,66},{-220,86}})));
        replaceable package MediumWater = IDEAS.Media.Water constrainedby
        Modelica.Media.Interfaces.PartialMedium;
         replaceable package MediumGlycol =
             IDEAS.Media.Antifreeze.Validation.BaseClasses.PropyleneGlycolWater
          (      property_T=273.15,
                 X_a=0.30) constrainedby
        Modelica.Media.Interfaces.PartialMedium;
      //     replaceable package MediumGlycol = IDEAS.Media.Water;
        replaceable package MediumAir = IDEAS.Media.Air(extraPropertiesNames={"CO2"}) constrainedby
        Modelica.Media.Interfaces.PartialMedium;
        IDEAS.Fluid.Sensors.RelativePressure senRelPRet(redeclare package
          Medium =
              MediumAir)
          annotation (Placement(transformation(extent={{-56,42},{-36,62}})));
        IDEAS.Fluid.Sensors.RelativePressure senRelPreSup(redeclare package
          Medium =
              MediumAir)
          annotation (Placement(transformation(extent={{-24,-22},{-44,-2}})));
        IDEAS.Fluid.FixedResistances.PressureDrop dp_server(
          allowFlowReversal=false,
          redeclare package Medium = MediumAir,
          m_flow_nominal=air.m_nominal_supply_duct[2],
          dp_nominal=0,
          linearized=true)
                        "pressure loses in pipe to heating coil" annotation (
            Placement(transformation(
              extent={{-8,-8},{8,8}},
              rotation=90,
              origin={68,18})));
    protected
        IDEAS.Buildings.Components.Interfaces.WeaBus weaBus1(numSolBus=sim.numIncAndAziInBus,
            outputAngles=sim.outputAngles)
          annotation (Placement(transformation(extent={{-178,84},{-158,104}})));
        Modelica.Blocks.Sources.RealExpression CEnv[max(MediumAir.nC,1)](y=sim.CEnv.y*
              s_co2)
          annotation (Placement(transformation(extent={{-198,-26},{-180,-10}})));
      equation
        connect(supplyFan.port_b, tAHUSupply.port_a)
          annotation (Line(points={{-16,-46},{-16,-46},{0,-46}}, color={0,127,255}));
        for i in 1:7 loop
          connect(tAHUSupply.port_b, dp_ducts_supply[i].port_a)
          annotation (Line(points={{12,-46},{32,-46}}, color={0,127,255}));
        end for;
        for i in 1:15 loop
          connect(tAHUSupply.port_b, vav_supply[i].port_a) annotation (Line(points={{12,
                -46},{12,-79.5},{34,-79.5}}, color={0,127,255}));
        end for;
        //flr3
        connect(vav_supply[1].port_b, counterFlowHEX[1].port_a2) annotation (Line(
              points={{51,-79.5},{88,-79.5},{88,0},{128,0},{128,-0.4}}, color={0,127,
                255}));
        connect(vav_supply[2].port_b, counterFlowHEX[2].port_a2);
        connect(dp_ducts_supply[1].port_b, counterFlowHEX[4].port_a2) annotation (
            Line(points={{52,-46},{88,-46},{88,-0.4},{128,-0.4}}, color={0,127,255}));
                                                                              //MT
        connect(vav_supply[3].port_b, counterFlowHEX[3].port_a2);
        //flr2
        connect(vav_supply[4].port_b, counterFlowHEX[5].port_a2);
        connect(vav_supply[5].port_b, counterFlowHEX[6].port_a2);
        connect(vav_supply[6].port_b, counterFlowHEX[7].port_a2);
        connect(vav_supply[7].port_b, counterFlowHEX[8].port_a2);
        //flr1
        connect(vav_supply[8].port_b, counterFlowHEX[9].port_a2);
        connect(vav_supply[9].port_b, counterFlowHEX[10].port_a2);
        connect(vav_supply[10].port_b, counterFlowHEX[11].port_a2);
        connect(vav_supply[11].port_b, counterFlowHEX[12].port_a2);
        connect(vav_supply[12].port_b, counterFlowHEX[13].port_a2);
        //flr0
        connect(dp_ducts_supply[5].port_b, counterFlowHEX[14].port_a2);
        connect(dp_ducts_supply[3].port_b, counterFlowHEX[15].port_a2);
        connect(vav_supply[13].port_b, counterFlowHEX[16].port_a2);
        connect(vav_supply[14].port_b, counterFlowHEX[17].port_a2);
        connect(vav_supply[15].port_b, counterFlowHEX[18].port_a2);
        connect(dp_ducts_supply[4].port_b, counterFlowHEX[19].port_a2);
        connect(dp_ducts_supply[6].port_b, counterFlowHEX[20].port_a2);
        connect(dp_ducts_supply[7].port_b, counterFlowHEX[21].port_a2);


        connect(pump6.port_b, dp_HeaCoi_supply[2].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[3].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[4].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[5].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[6].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[7].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[8].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[9].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[10].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[11].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[12].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[13].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[14].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[15].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[16].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[17].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[18].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[19].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[20].port_a);
        connect(pump6.port_b, dp_HeaCoi_supply[21].port_a);
        connect(counterFlowHEX.port_b1, TWVHeaCoi.port_1) annotation (Line(points={{
                128,-13.6},{120,-13.6},{120,-24}}, color={0,127,255}));
        connect(jun.port_2, counterFlowHEX.port_a1) annotation (Line(points={{160,-24},
                {160,-13.6},{150,-13.6}}, color={0,127,255}));
        connect(TWVHeaCoi.port_3, jun.port_3) annotation (Line(points={{128,-32},{152,
                -32}},           color={0,127,255}));
        for i in 1:21 loop
          connect(TWVHeaCoi[i].port_2, HeaCoi_b)
          annotation (Line(points={{120,-40},{120,-100}},color={0,127,255}));
        end for;
        connect(dp_HeaCoi_supply.port_b, jun.port_1) annotation (Line(points={{160,-44},
                {160,-40}},           color={0,127,255}));
        connect(pump6.port_b, dp_HeaCoi_supply[1].port_a) annotation (Line(points={{160,-64},
                {160,-60}},                color={0,127,255}));


        connect(tAHUExtract.port_b, exhaustFan.port_a)
          annotation (Line(points={{-34,20},{-40,20},{-40,18},{-44,18}},
                                                                color={0,127,255}));

        //Extraction
        connect(tAHUExtract.port_a, dp_ducts_extract[1].port_b)
          annotation (Line(points={{-22,20},{-14,20},{12,20}},  color={0,127,255}));
        connect(tAHUExtract.port_a, dp_ducts_extract[2].port_b);
        connect(tAHUExtract.port_a, dp_ducts_extract[3].port_b);
        connect(tAHUExtract.port_a, dp_ducts_extract[4].port_b);
        connect(tAHUExtract.port_a, dp_ducts_extract[5].port_b);
        connect(tAHUExtract.port_a, dp_ducts_extract[6].port_b);
        connect(tAHUExtract.port_a, dp_ducts_extract[7].port_b);
        connect(tAHUExtract.port_a, dp_ducts_extract[8].port_b);
        connect(tAHUExtract.port_a, dp_ducts_extract[9].port_b);
        connect(tAHUExtract.port_a, dp_ducts_extract[10].port_b);
        connect(vav_extract[1].port_b, tAHUExtract.port_a) annotation (Line(points={{14,52.5},
                {-10,52.5},{-10,20},{-22,20}},       color={0,127,255}));
        connect(vav_extract[2].port_b, tAHUExtract.port_a);
        connect(vav_extract[3].port_b, tAHUExtract.port_a);
        connect(vav_extract[4].port_b, tAHUExtract.port_a);
        connect(vav_extract[5].port_b, tAHUExtract.port_a);
        connect(vav_extract[6].port_b, tAHUExtract.port_a);
        connect(vav_extract[7].port_b, tAHUExtract.port_a);
        connect(vav_extract[8].port_b, tAHUExtract.port_a);
        connect(vav_extract[9].port_b, tAHUExtract.port_a);
        connect(vav_extract[10].port_b, tAHUExtract.port_a);
        connect(vav_extract[11].port_b, tAHUExtract.port_a);
        connect(vav_extract[12].port_b, tAHUExtract.port_a);
        connect(vav_extract[13].port_b, tAHUExtract.port_a);
        connect(vav_extract[14].port_b, tAHUExtract.port_a);
        connect(tAHUSupply.T, aHU.TSupply) annotation (Line(points={{6,-39.4},{6,58},
                {-114,58},{-114,14},{-113.64,14},{-113.64,12.1}},color={0,0,127},
            visible=false));
        connect(exhaustFan.port_b, aHU.port_a1) annotation (Line(points={{-64,18},{
                -74,18},{-74,6.4},{-84,6.4}},
                                          color={0,127,255}));
        connect(aHU.port_b1, bouAmb.ports[1]) annotation (Line(points={{-122,6.4},{-140,
                6.4},{-140,-8}}, color={0,127,255}));
        connect(bouAmb.ports[2], aHU.port_a2) annotation (Line(points={{-140,-12},{-140,
                -16.4},{-122,-16.4}}, color={0,127,255}));
        connect(aHU.port_b2, supplyFan.port_a) annotation (Line(points={{-84,-16.4},{-74,
                -16.4},{-74,-46},{-36,-46}}, color={0,127,255}));

        connect(t15.port_b, pump13.port_a) annotation (Line(points={{-146,-96},{-120,
                -96},{-80,-96},{-80,-68}}, color={0,127,255}));
        connect(t23.port_a, aHU.portHeaCoi_b1) annotation (Line(points={{-120,-38},{-120,
                -38},{-120,-24},{-118.2,-24}}, color={0,127,255}));
        connect(t22.port_b, aHU.portHeaCoi_a1) annotation (Line(points={{-118,-60},{
                -110,-60},{-110,-24},{-110.6,-24}}, color={0,127,255}));
        connect(TWV_AHU_CooCoi.port_1, aHU.portCooCoi_b1) annotation (Line(points={{-94,
                -34},{-95.4,-34},{-95.4,-24}}, color={0,127,255}));
        connect(TWV_AHU_CooCoi.port_3, jun1.port_3)
          annotation (Line(points={{-88,-40},{-86,-40}}, color={0,127,255}));
        connect(pump13.port_b, jun1.port_1) annotation (Line(points={{-80,-54},{-80,-50},
                {-80,-46}}, color={0,127,255}));
        connect(jun1.port_2, aHU.portCooCoi_a1) annotation (Line(points={{-80,-34},{
                -80,-28},{-87.8,-28},{-87.8,-24}}, color={0,127,255}));
        connect(t16.port_a, dp_fixed_AHU_CooCoi.port_b) annotation (Line(points={{
                -164,-76},{-158,-76},{-152,-76}}, color={0,127,255}));
        connect(dp_fixed_AHU_CooCoi.port_a, TWV_AHU_CooCoi.port_2) annotation (Line(
              points={{-136,-76},{-94,-76},{-94,-46}}, color={0,127,255}));
        connect(t23.port_b, TWV_AHU_HeaCoi.port_1) annotation (Line(points={{-132,-38},
                {-134,-38},{-136,-38}}, color={0,127,255}));
        connect(TWV_AHU_HeaCoi.port_2, pump9.port_a) annotation (Line(points={{-148,-38},
                {-154,-38},{-154,-38.5}}, color={0,127,255}));
        connect(t22.port_a, jun2.port_2) annotation (Line(points={{-130,-60},{-133,
                -60},{-136,-60}}, color={0,127,255}));
        connect(dp_fixed_AHU_HeaCoi.port_b, jun2.port_1) annotation (Line(points={{
                -158,-60},{-153,-60},{-148,-60}}, color={0,127,255}));
        connect(TWV_AHU_HeaCoi.port_3, jun2.port_3) annotation (Line(points={{-142,
                -44},{-142,-49},{-142,-54}}, color={0,127,255}));
        connect(t15.port_a, AHUCooCoi_a) annotation (Line(points={{-158,-96},{-200,
                -96}},       color={0,127,255}));
        connect(t16.port_b, AHUCooCoi_b) annotation (Line(points={{-176,-76},{-200,
                -76}},       color={0,127,255}));
        connect(dp_fixed_AHU_HeaCoi.port_a, AHUHeaCoi_a) annotation (Line(points={{-174,
                -60},{-200,-60}},            color={0,127,255}));
        connect(pump9.port_b, AHUHeaCoi_b) annotation (Line(points={{-167,-38.5},{-183.5,
                -38.5},{-183.5,-40},{-200,-40}}, color={0,127,255}));
        connect(pump6.port_a, HeaCoi_a) annotation (Line(points={{160,-80},{160,-100}},
                             color={0,127,255}));
        connect(tAHUSupply.T, dataBus.TAirSupplyAHU) annotation (Line(points={{6,
                -39.4},{6,-39.4},{6,58},{6,58.07},{-198.925,58.07}}, color={0,0,127},
            visible=false),
            Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(pump9.stage, signalBus.P09_signal) annotation (Line(
            points={{-160.5,-29.5},{-160.5,34},{-200,34}},
            color={255,127,0},
            visible=false), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(pump13.dp_in, signalBus.P13_signal) annotation (Line(
            points={{-89.6,-61},{-200,-61},{-200,34}},
            color={255,127,0},
            visible=false), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(AHUHeaCoi_a, AHUHeaCoi_a) annotation (Line(points={{-200,-60},{-194,
                -60},{-194,-60},{-200,-60}}, color={0,127,255}));
        connect(TWV_AHU_HeaCoi.y, signalBus.HeaCoi_3way_signal) annotation (Line(
              points={{-142,-30.8},{-140,-30.8},{-140,28},{-140,34},{-200,34}},
              color={0,0,127},
            visible=false),     Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(tAHUExtract.T, dataBus.TAirExtractAHU) annotation (Line(points={{-28,
                26.6},{-28,58.07},{-198.925,58.07}}, color={0,0,127},
            visible=false),                                            Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(counterFlowHEX.port_b2, tAirSupply.port_a) annotation (Line(points={{
                150,-0.4},{151,-0.4},{151,0},{154,0}}, color={0,127,255}));
        connect(tAirSupply.T, dataBus.TAirSupplyVAV) annotation (Line(points={{160,6.6},
                {160,58},{-20,58},{-20,58.07},{-198.925,58.07}}, color={0,0,127},
            visible=false),
            Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(pump6.stage, signalBus.P06_signal) annotation (Line(points={{150.4,-72},
                {150.4,34},{-200,34}},          color={255,127,0},
            visible=false),                                         Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));

        connect(TWV_AHU_CooCoi.y, signalBus.CooCoi_3way_signal) annotation (Line(
              points={{-101.2,-40},{-146,-40},{-146,-42},{-200,-42},{-200,34}},
              color={0,0,127},
            visible=false),     Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(TWVHeaCoi.y, signalBus.Heacoils_signal) annotation (Line(points={{110.4,
                -32},{84,-32},{84,34.07},{-199.93,34.07}},       color={0,0,127},
            visible=false),
            Text(
           string="%second",
            index=1,
            extent={{6,3},{6,3}}));

        //flr3
        connect(tAirSupply[1].port_b, airSupply[1]) annotation (Line(points={{166,0},
                {176,0},{176,78},{156,78},{156,90.4762}},color={0,127,255}));
        connect(tAirSupply[2].port_b, airSupply[2]);
        connect(tAirSupply[3].port_b, airSupply[3]);
        connect(tAirSupply[4].port_b, airSupply[4]);
        //flr2
        connect(tAirSupply[5].port_b, airSupply[5]);
        connect(tAirSupply[6].port_b, airSupply[6]);
        connect(tAirSupply[7].port_b, airSupply[7]);
        connect(tAirSupply[8].port_b, airSupply[8]);
        //flr1
        connect(tAirSupply[9].port_b, airSupply[9]);
        connect(tAirSupply[10].port_b, airSupply[10]);
        connect(tAirSupply[11].port_b, airSupply[11]);
        connect(tAirSupply[12].port_b, airSupply[12]);
        connect(tAirSupply[13].port_b, airSupply[13]);
        //flr0                                                                             //server room
        connect(tAirSupply[14].port_b, airSupply[19]); //balie
        connect(tAirSupply[15].port_b, airSupply[15]); //ehbo
        connect(tAirSupply[16].port_b, airSupply[16]); //refter vav
        connect(tAirSupply[17].port_b, airSupply[17]); // meeting1 vav
        connect(tAirSupply[18].port_b, airSupply[18]); // meeting2 vav
        connect(tAirSupply[19].port_b, airSupply[19]); //sas
        connect(tAirSupply[20].port_b, airSupply[20]);
        connect(tAirSupply[21].port_b, airSupply[21]);


        //flr3
        connect(airReturn[1], vav_extract[1].port_a) annotation (Line(points={{116,
                90.4762},{116,90.4762},{116,56},{31,56},{31,52.5}},
                                                           color={0,127,255}));
        connect(airReturn[2], vav_extract[2].port_a);
        connect(airReturn[3], vav_extract[3].port_a);
        //flr2
        connect(airReturn[5], vav_extract[4].port_a);
        connect(airReturn[6], vav_extract[5].port_a);
        connect(airReturn[7], vav_extract[6].port_a);
        connect(airReturn[8], vav_extract[7].port_a);
        //flr1
        connect(airReturn[9], vav_extract[8].port_a);
        connect(airReturn[11], vav_extract[9].port_a);
        connect(airReturn[12], vav_extract[10].port_a);
        connect(airReturn[13], vav_extract[11].port_a);
        //flr0
        connect(airReturn[16], vav_extract[12].port_a);
        connect(airReturn[17], vav_extract[13].port_a);
        connect(airReturn[18], vav_extract[14].port_a);

        connect(airReturn[3], dp_ducts_extract[1].port_a) annotation (Line(points={{116,
                92.381},{116,92.381},{116,56},{40,56},{40,20},{32,20}},
              color={0,127,255}));
        connect(airReturn[2], dp_ducts_extract[2].port_a);
        connect(airReturn[4], dp_ducts_extract[3].port_a);
        connect(airReturn[14], dp_ducts_extract[4].port_a);
        connect(airReturn[15], dp_ducts_extract[5].port_a);
        connect(airReturn[10], dp_ducts_extract[6].port_a); //storage room
        connect(airReturn[19], dp_ducts_extract[7].port_a);
        connect(airReturn[19], dp_ducts_extract[8].port_a);
        connect(airReturn[20], dp_ducts_extract[9].port_a);
        connect(airReturn[21], dp_ducts_extract[10].port_a);

        connect(exhaustFan.dp_in, signalBus.AHUextract) annotation (Line(
            points={{-54,30},{-54,34},{-200,34}},
            color={0,0,127},
            visible=false), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(supplyFan.dp_in, signalBus.AHUsupply) annotation (Line(
            points={{-26,-34},{-26,-34},{-26,34},{-200,34}},
            color={0,0,127},
            visible=false), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}}));
        connect(realExpression2.y, total_P)
          annotation (Line(points={{-119,74},{-210,74},{-210,76}}, color={0,0,127}));
        if MediumAir.nXi>0 then
          connect(bouAmb.Xi_in[1], weaBus1.X_wEnv) annotation (Line(points={{-162,-14},{
                -167.95,-14},{-167.95,94.05}}, color={0,0,127}));
        end if;
        connect(signalBus, aHU.signalBus) annotation (Line(
            points={{-200,34},{-134,34},{-134,-8.8},{-65,-8.8}},
            color={255,204,51},
            thickness=0.5));
        connect(sim.weaBus, weaBus1) annotation (Line(
            points={{-181,93},{-176,93},{-176,94},{-168,94}},
            color={255,204,51},
            thickness=0.5));
        connect(bouAmb.T_in, weaBus1.Te) annotation (Line(points={{-162,-6},{-167.95,-6},
                {-167.95,94.05}}, color={0,0,127}));
        if MediumAir.nC>0 then
        end if;
        connect(senRelPRet.port_a, aHU.port_b1) annotation (Line(points={{-56,52},{
                -122,52},{-122,6.4}}, color={0,127,255}));
        connect(exhaustFan.port_a,senRelPRet. port_b) annotation (Line(points={{-44,
                18},{-42,18},{-42,38},{-36,38},{-36,52}}, color={0,127,255}));
        connect(senRelPreSup.port_b, aHU.port_a2) annotation (Line(points={{-44,-12},
                {-54,-12},{-54,-32},{-122,-32},{-122,-16.4}}, color={0,127,255}));
        connect(senRelPreSup.port_a, supplyFan.port_b) annotation (Line(points={{-24,
                -12},{-16,-12},{-16,-46}}, color={0,127,255}));
        connect(senRelPRet.p_rel, exhaustFan.dpMea)
          annotation (Line(points={{-46,43},{-46,30}}, color={0,0,127}));
        connect(senRelPreSup.p_rel, supplyFan.dpMea)
          annotation (Line(points={{-34,-21},{-34,-34}}, color={0,0,127}));
        connect(CEnv.y, bouAmb.C_in)
          annotation (Line(points={{-179.1,-18},{-162,-18}}, color={0,0,127}));
        connect(dp_server.port_b, airSupply[14]) annotation (Line(points={{68,26},{68,
                42},{156,42},{156,102.857}}, color={0,127,255}));
        connect(dp_server.port_a, dp_ducts_supply[2].port_b)
          annotation (Line(points={{68,10},{68,-46},{52,-46}}, color={0,127,255}));
        annotation (Diagram(coordinateSystem(extent={{-200,-100},{180,100}})), Icon(
              coordinateSystem(extent={{-200,-100},{180,100}})));
      end VentilationSystem;

      model VentilationSystemSim
        extends VentilationSystem(
            redeclare IDEAS.Fluid.Movers.FlowControlled_dp exhaustFan(
              massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
              addPowerToMedium=false,
              tau=10,
              energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
              use_inputFilter=false,
              allowFlowReversal=false,
              m_flow_nominal=8850*1.225/3600,
              redeclare INFRAX.Data.Parameters.INFRAX_AHU_Fans per,
              dp_nominal=150,
              constantHead=150,
              dp_start=150,
              redeclare package Medium = MediumAir,
              prescribeSystemPressure=true),
            redeclare IDEAS.Fluid.Movers.FlowControlled_dp supplyFan(
              massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
              addPowerToMedium=false,
              use_inputFilter=false,
              allowFlowReversal=false,
              tau=60,
              energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
              m_flow_nominal=10000*1.225/3600,
              dp_nominal(displayUnit="Pa") = 180,
              redeclare INFRAX.Data.Parameters.INFRAX_AHU_Fans per,
              dp_start=180,
              redeclare package Medium = MediumAir,
              prescribeSystemPressure=true),
            redeclare IDEAS.Fluid.Movers.FlowControlled_dp pump13(
              tau=30,
              energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
              use_inputFilter=false,
              allowFlowReversal=false,
              addPowerToMedium=false,
              massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
              m_flow_nominal=hydronic.p13_m_flow,
              redeclare
                IDEAS.Fluid.Movers.Data.Pumps.Wilo.VeroLine40slash120dash1comma5slash2
                per,
              redeclare package Medium = MediumWater,
              inputType=IDEAS.Fluid.Types.InputType.Continuous,
              each dp_nominal(displayUnit="kPa") = 40000,
              T_start=284.15),
            redeclare IDEAS.Fluid.Movers.FlowControlled_dp pump6(
              tau=30,
              energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
              use_inputFilter=false,
              allowFlowReversal=false,
              addPowerToMedium=false,
              massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
              inputType=IDEAS.Fluid.Types.InputType.Stages,
              m_flow_nominal=hydronic.p06_m_flow,
              redeclare
                IDEAS.Fluid.Movers.Data.Pumps.Wilo.Stratos40slash1to12CANPN6slash10 per,
              each dp_nominal(displayUnit="Pa") = 7.2*9804.139432,
              dp_start=0,
              redeclare package Medium = MediumWater),
            redeclare IDEAS.Fluid.Movers.FlowControlled_dp pump9(
              tau=30,
              energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
              use_inputFilter=false,
              allowFlowReversal=false,
              addPowerToMedium=false,
              massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
              m_flow_nominal=hydronic.p09_m_flow,
              redeclare
                IDEAS.Fluid.Movers.Data.Pumps.Wilo.VeroLine32slash160dash1comma1slash2
                per,
              each dp_nominal(displayUnit="kPa") = 14*9804.139432,
              inputType=IDEAS.Fluid.Types.InputType.Stages,
              redeclare package Medium = MediumGlycol),
              redeclare IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent dp_ducts_supply(
                m_flow_nominal=air.m_nominal_supply_duct,
                redeclare package Medium = MediumAir,
                each allowFlowReversal=false,
                from_dp=true,
                dpFixed_nominal=100,
            dpValve_nominal=50,
            use_inputFilter=false),
              redeclare IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent dp_ducts_extract(
                m_flow_nominal=air.m_nominal_extract_duct,
                redeclare package Medium = MediumAir,
                each allowFlowReversal=false,
                from_dp=true,
            dpValve_nominal=50,
            use_inputFilter=false),
                redeclare IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent    vav_supply(
                  use_inputFilter=false,
                  allowFlowReversal=false,
                  m_flow_nominal=air.m_nominal_supply_vav,
                  redeclare package Medium = MediumAir,
                  from_dp=true,
                  each dpValve_nominal=60,
                  dpFixed_nominal=100,
                  deltaM=0.02,
                  deltax=0.02),
                redeclare IDEAS.Fluid.Actuators.Valves.TwoWayPressureIndependent    vav_extract(
                  use_inputFilter=false,
                  allowFlowReversal=false,
                  m_flow_nominal=air.m_nominal_extract_vav,
                  each dpValve_nominal=150,
                  redeclare package Medium = MediumAir,
                  from_dp=true),
          redeclare IBPSA.Fluid.HeatExchangers.DryCoilEffectivenessNTU counterFlowHEX(
            m1_flow_nominal=air.m_nominal_water,
            m2_flow_nominal=air.m_nominal_air,
            dp1_nominal=0,
            dp2_nominal=0,
            Q_flow_nominal=air.Q_nominal,
            allowFlowReversal1=false,
            allowFlowReversal2=false,
            redeclare package Medium2 = MediumAir,
            configuration=IBPSA.Fluid.Types.HeatExchangerConfiguration.CounterFlow,
            T_a1_nominal=air.TWatSup_nominal,
            T_a2_nominal=air.TAirSup_nominal,
            redeclare package Medium1 = MediumWater),
          aHU(QCooCoi_nominal=59300));
        Buildings.Controls.OBC.CDL.Continuous.Sources.Constant supplyCAV[7](k=1)
          annotation (Placement(transformation(extent={{12,-16},{22,-6}})));
        Buildings.Controls.OBC.CDL.Continuous.Sources.Constant extractCAV[10](k=1)
          annotation (Placement(transformation(extent={{-20,64},{-8,76}})));
        Modelica.Blocks.Sources.RealExpression extractVAV[14](y={air.m_nominal_extract_vav_min[
              i]/air.m_nominal_extract_vav[i] + (1 - air.m_nominal_extract_vav_min[i]
              /air.m_nominal_extract_vav[i])*signalBus.VAV_signal_extract[i] for i in
                  1:14})
          annotation (Placement(transformation(extent={{2,80},{30,100}})));
        Modelica.Blocks.Sources.RealExpression supplyVAV[15](y={air.m_nominal_supply_vav_min[
              i]/air.m_nominal_supply_vav[i] + (1 - air.m_nominal_supply_vav_min[i]/
              air.m_nominal_supply_vav[i])*signalBus.VAV_signal[i] for i in 1:15})
          annotation (Placement(transformation(extent={{-40,-92},{-12,-72}})));
      equation
        connect(supplyCAV.y, dp_ducts_supply.y)
          annotation (Line(points={{22.5,-11},{42,-11},{42,-34}}, color={0,0,127}));
        connect(extractCAV.y, dp_ducts_extract.y) annotation (Line(points={{-7.4,70},
                {0,70},{0,36},{22,36},{22,32}}, color={0,0,127}));
        connect(supplyVAV.y, vav_supply.y) annotation (Line(points={{-10.6,-82},{2,
                -82},{2,-69.3},{42.5,-69.3}}, color={0,0,127}));
        connect(extractVAV.y, vav_extract.y) annotation (Line(points={{31.4,90},{44,
                90},{44,74},{22.5,74},{22.5,62.7}}, color={0,0,127}));
      end VentilationSystemSim;

      package Components

        model AHU_baseline "Infrax AHU"

          extends
          INFRAX.SubSystems.VentilationSystem.Components.Dependencies.PartialAHU;

          Buildings.Fluid.FixedResistances.Junction                   spl(
            dp_nominal={0,0,0},
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            tau=tau,
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            portFlowDirection_1=Modelica.Fluid.Types.PortFlowDirection.Entering,
            portFlowDirection_2=Modelica.Fluid.Types.PortFlowDirection.Leaving,
            m_flow_nominal={mFlowAirSup_nominal,mFlowAirSup_nominal,mFlowAirSup_nominal},
            redeclare package Medium = MediumAir,
            portFlowDirection_3=Modelica.Fluid.Types.PortFlowDirection.Leaving)
            annotation (Placement(transformation(extent={{26,-54},{14,-66}})));

          IDEAS.Fluid.Actuators.Valves.Simplified.ThreeWayValveMotor  threeWayValveMotor(
            energyDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            massDynamics=Modelica.Fluid.Types.Dynamics.SteadyState,
            m_flow_nominal=mFlowAirSup_nominal,
            redeclare package Medium = MediumAir)
                                                annotation (Placement(transformation(
                extent={{10,10},{-10,-10}},
                rotation=0,
                origin={-20,-60})));
          IBPSA.Fluid.HeatExchangers.ConstantEffectiveness
                                               cooCoi(
            allowFlowReversal1=false,
            allowFlowReversal2=false,
            from_dp2=false,
            dp2_nominal=0,
            redeclare package Medium1 = MediumAir,
            redeclare package Medium2 = MediumCooCoi,
            m1_flow_nominal=mFlowAirSup_nominal,
            m2_flow_nominal=mFlowWatCooCoi_nominal,
            dp1_nominal=0,
            eps=0.85)
            "Cooling coil"
            annotation (Placement(transformation(extent={{-50,-76},{-70,-56}})));
          IBPSA.Fluid.HeatExchangers.DryCoilEffectivenessNTU
                                               heaCoi(
            m2_flow_nominal=mFlowAirSup_nominal,
            redeclare package Medium2 = MediumAir,
            m1_flow_nominal=mFlowWatHeaCoi_nominal,
            allowFlowReversal1=false,
            allowFlowReversal2=false,
            dp2_nominal=620,
            dp1_nominal=0,
            redeclare package Medium1 = MediumHeaCoi,
            configuration=IBPSA.Fluid.Types.HeatExchangerConfiguration.CounterFlow,
            Q_flow_nominal=QHeaCoi_nominal,
            T_a2_nominal=THeaCoiAirSup_nominal,
            T_a1_nominal=THeaCoiWatSup_nominal)
            annotation (Placement(transformation(extent={{50,-56},{70,-76}})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort senTemSup(
            allowFlowReversal=false,
            m_flow_nominal=10,
            tau=0,
            redeclare package Medium = MediumAir) annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=180,
                origin={-84,-60})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort senTemHea(
            allowFlowReversal=false,
            m_flow_nominal=10,
            tau=0,
            redeclare package Medium = MediumAir) annotation (Placement(transformation(
                extent={{-6,-6},{6,6}},
                rotation=180,
                origin={38,-60})));
          IDEAS.Fluid.Sensors.TemperatureTwoPort senTemRecMix(
            allowFlowReversal=false,
            m_flow_nominal=10,
            tau=0,
            redeclare package Medium = MediumAir)
            "Temperature sensor after heat recovery unit, mixed" annotation (Placement(
                transformation(
                extent={{-6,-6},{6,6}},
                rotation=180,
                origin={-40,-60})));
          Modelica.Blocks.Interfaces.RealOutput TOutHea annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={20,-110})));
          Modelica.Blocks.Interfaces.RealOutput TOutCoo annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=270,
                origin={-96,-110})));
          IBPSA.Fluid.HeatExchangers.ConstantEffectiveness
                                        hexUA(
            redeclare package Medium2 = MediumAir,
            allowFlowReversal1=false,
            allowFlowReversal2=false,
            from_dp2=false,
            redeclare package Medium1 = MediumAir,
            m1_flow_nominal=mFlowAirSup_nominal,
            dp2_nominal=0,
            m2_flow_nominal=mFlowAirRet_nominal,
            dp1_nominal=277,
            from_dp1=false,
            eps=0.7)   "Heat recovery wheel"
            annotation (Placement(transformation(extent={{-10,0},{10,20}})));
        equation
          heatPort.T=273.15;

          connect(threeWayValveMotor.port_a1, spl.port_2)
            annotation (Line(points={{-10,-60},{14,-60}}, color={0,127,255}));
          connect(heaCoi.port_a2, port_a2) annotation (Line(points={{70,-60},{86,-60},{
                  86,-60},{100,-60}}, color={0,127,255}));
          connect(heaCoi.port_b1, portHeaCoi_b1)
            annotation (Line(points={{70,-72},{80,-72},{80,-100}}, color={0,127,255}));
          connect(heaCoi.port_a1, portHeaCoi_a1)
            annotation (Line(points={{50,-72},{40,-72},{40,-100}}, color={0,127,255}));
          connect(senTemSup.port_b, port_b2)
            annotation (Line(points={{-90,-60},{-100,-60}}, color={0,127,255}));
          connect(senTemHea.port_b, spl.port_1)
            annotation (Line(points={{32,-60},{26,-60}}, color={0,127,255}));
          connect(senTemHea.port_a, heaCoi.port_b2)
            annotation (Line(points={{44,-60},{50,-60}}, color={0,127,255}));
          connect(senTemRecMix.port_a, threeWayValveMotor.port_b)
            annotation (Line(points={{-34,-60},{-30,-60}}, color={0,127,255}));
          connect(senTemHea.T, TOutHea) annotation (Line(points={{38,-66.6},{38,-80},{
                  20,-80},{20,-110}}, color={0,0,127}));
          connect(senTemSup.T, TOutCoo) annotation (Line(points={{-84,-66.6},{-84,-74},
                  {-96,-74},{-96,-110}}, color={0,0,127}));
          connect(hexUA.port_b1, port_b1)
            annotation (Line(points={{10,16},{10,60},{100,60}}, color={0,127,255}));
          connect(hexUA.port_a1, port_a1)
            annotation (Line(points={{-10,16},{-10,60},{-100,60}}, color={0,127,255}));
          connect(hexUA.port_b2, threeWayValveMotor.port_a2)
            annotation (Line(points={{-10,4},{-20,4},{-20,-50}}, color={0,127,255}));
          connect(spl.port_3, hexUA.port_a2)
            annotation (Line(points={{20,-54},{20,4},{10,4}}, color={0,127,255}));
          connect(threeWayValveMotor.ctrl, signalBus.TW_bypass) annotation (Line(points=
                 {{-20,-70.8},{-20,-80},{-34,-80},{-34,80},{-80,80},{-80,100}}, color={
                  0,0,127}), Text(
              string="%second",
              index=1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(portCooCoi_a1, cooCoi.port_a2) annotation (Line(points={{-80,-100},{
                  -80,-72},{-70,-72}}, color={0,127,255}));
          connect(portCooCoi_b1, cooCoi.port_b2) annotation (Line(points={{-40,-100},{
                  -42,-100},{-42,-72},{-50,-72}}, color={0,127,255}));
          connect(senTemSup.port_a, cooCoi.port_b1)
            annotation (Line(points={{-78,-60},{-70,-60}}, color={0,127,255}));
          connect(cooCoi.port_a1, senTemRecMix.port_b)
            annotation (Line(points={{-50,-60},{-46,-60}}, color={0,127,255}));
          annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -100},{100,100}})),           Icon(coordinateSystem(
                  preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  points={{0,58},{-40,18},{0,-22},{40,18},{0,58}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Line(
                  points={{-100,60},{-26,60},{0,34},{26,60},{98,60}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Line(
                  points={{100,-62},{26,-62},{26,-26},{0,0},{-28,-28},{-28,-62},{-100,
                      -62}},
                  color={0,0,0},
                  smooth=Smooth.None),
                Rectangle(
                  extent={{-76,-36},{-50,-86}},
                  lineColor={0,128,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Rectangle(
                  extent={{52,-34},{78,-84}},
                  lineColor={255,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),
                Text(
                  extent={{58,-50},{70,-72}},
                  lineColor={255,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="+"),
                Text(
                  extent={{-76,-48},{-50,-70}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="-"),
                Line(
                  points={{-38,-60},{-38,-84},{0,-100}},
                  color={0,0,255},
                  smooth=Smooth.None,
                  pattern=LinePattern.Dash),
                Text(
                  extent={{-42,-40},{-32,-60}},
                  lineColor={0,0,0},
                  pattern=LinePattern.Dash,
                  textString="T"),
                Text(
                  extent={{-74,-82},{-48,-104}},
                  lineColor={0,0,255},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="-"),
                Text(
                  extent={{54,-82},{66,-104}},
                  lineColor={255,0,0},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid,
                  textString="+")}),
                      Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)));
        end AHU_baseline;

        package Dependencies "AHU Dependencies from SmartGeotherm/Ter Potterie"

          partial model PartialAHU "air handling unit of INFRAX"

            replaceable package MediumAir = IDEAS.Media.Air;
            replaceable package MediumHeaCoi = IDEAS.Media.Water;
            replaceable package MediumCooCoi = IDEAS.Media.Water;

              extends IDEAS.Fluid.Interfaces.PartialFourPortInterface(redeclare
              final package Medium1 =                                                                 MediumAir,redeclare
              final package Medium2 =                                                                                                       MediumAir,
              final m1_flow_nominal = mFlowAirRet_nominal, final m2_flow_nominal = mFlowAirSup_nominal);
                import Buildings;

            parameter Modelica.SIunits.Time tau = 200 "Time constant of components";
            parameter Modelica.SIunits.Time tauWater = 200;
            parameter Modelica.SIunits.Time tauAir = 200;
            parameter Modelica.SIunits.Time tauSensor = 200;
            parameter Modelica.SIunits.Time tauLoss = 3600*8
              "Time constant of heat losses to environment";

            parameter Modelica.SIunits.MassFlowRate mFlowAirSup_nominal
              "Nominal mass flow rate for supply air"
              annotation(Dialog(tab="General", group="Nominal mass flow rates"));
            parameter Modelica.SIunits.MassFlowRate mFlowAirRet_nominal
              "Nominal mass flow rate for return air"
              annotation(Dialog(tab="General", group="Nominal mass flow rates"));
            parameter Modelica.SIunits.MassFlowRate mFlowWatHeaCoi_nominal
              "Nominal water mass flow rate for heating coil"
              annotation(Dialog(tab="General", group="Nominal mass flow rates"));
            parameter Modelica.SIunits.MassFlowRate mFlowWatCooCoi_nominal
              "Nominal water mass flow rate for cooling coil"
              annotation(Dialog(tab="General", group="Nominal mass flow rates"));

            parameter Modelica.SIunits.Power QHeaCoi_nominal = min(mFlowWatHeaCoi_nominal*4180*(THeaCoiWatSup_nominal-THeaCoiWatRet_nominal),mFlowAirSup_nominal*1005*(THeaCoiAirRet_nominal - THeaCoiAirSup_nominal))
              "Nominal heating power"
              annotation(Dialog(tab="General", group="Nominal power"));
            parameter Modelica.SIunits.Power QCooCoi_nominal = max(mFlowWatCooCoi_nominal*4180*(TCooCoiWatSup_nominal-TCooCoiWatRet_nominal),mFlowAirSup_nominal*1005*(TCooCoiAirRet_nominal - TCooCoiAirSup_nominal))
              "Nominal cooling power"
              annotation(Dialog(tab="General", group="Nominal power"));

            parameter Modelica.SIunits.Temperature TCooCoiWatSup_nominal = 15+273.15
              annotation(Dialog(tab="General", group="Nominal temperatures"));
            parameter Modelica.SIunits.Temperature TCooCoiWatRet_nominal = 20+273.15
            annotation(Dialog(tab="General", group="Nominal temperatures"));
            parameter Modelica.SIunits.Temperature TCooCoiAirSup_nominal = 32+273.15
            annotation(Dialog(tab="General", group="Nominal temperatures"));
            parameter Modelica.SIunits.Temperature TCooCoiAirRet_nominal = 24+273.15
            annotation(Dialog(tab="General", group="Nominal temperatures"));

            parameter Modelica.SIunits.Temperature THeaCoiWatSup_nominal = 70+273.15
            annotation(Dialog(tab="General", group="Nominal temperatures"));
            parameter Modelica.SIunits.Temperature THeaCoiWatRet_nominal = 50+273.15
            annotation(Dialog(tab="General", group="Nominal temperatures"));
            parameter Modelica.SIunits.Temperature THeaCoiAirSup_nominal = -10+273.15
            annotation(Dialog(tab="General", group="Nominal temperatures"));
            parameter Modelica.SIunits.Temperature THeaCoiAirRet_nominal = 23+273.15
            annotation(Dialog(tab="General", group="Nominal temperatures"));

            Modelica.Fluid.Interfaces.FluidPort_a portCooCoi_a1(redeclare
              package Medium =
                  MediumCooCoi)
              "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
              annotation (Placement(transformation(extent={{-90,-110},{-70,-90}})));
            Modelica.Fluid.Interfaces.FluidPort_b portCooCoi_b1(redeclare
              package Medium =
                  MediumCooCoi)
              "Fluid connector b1 (positive design flow direction is from port_a1 to port_b1)"
              annotation (Placement(transformation(extent={{-50,-110},{-30,-90}})));
            Modelica.Fluid.Interfaces.FluidPort_a portHeaCoi_a1(redeclare
              package Medium =
                  MediumHeaCoi)
              "Fluid connector a1 (positive design flow direction is from port_a1 to port_b1)"
              annotation (Placement(transformation(extent={{30,-110},{50,-90}})));
            Modelica.Fluid.Interfaces.FluidPort_b portHeaCoi_b1(redeclare
              package Medium =
                  MediumHeaCoi)
              "Fluid connector b1 (positive design flow direction is from port_a1 to port_b1)"
              annotation (Placement(transformation(extent={{70,-110},{90,-90}})));
            parameter Real epsRecovery=0.7
              "Heat exchanger effectiveness of the recovery unit";
            parameter Modelica.SIunits.TemperatureDifference dTRecovery_nominal=30
              "Nominal/maximum temperature difference between inlet ports of recovery, used for regularization";
            Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a heatPort
              annotation (Placement(transformation(extent={{-50,90},{-30,110}})));
            Modelica.Blocks.Interfaces.RealInput TSupply
              "Mixed outlet temperature setpoint" annotation (Placement(transformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={40,108}), iconTransformation(
                  extent={{-20,-20},{20,20}},
                  rotation=270,
                  origin={56,90})));
            parameter Modelica.SIunits.PressureDifference dpWatCooCoi_nominal
              "Pressure difference" annotation (Dialog(group="Nominal pressure drops"));
            parameter Modelica.SIunits.PressureDifference dpAirCooCoi_nominal
              "Pressure difference" annotation (Dialog(group="Nominal pressure drops"));
            parameter Modelica.SIunits.PressureDifference dpWatHeaCoi_nominal
              "Pressure difference" annotation (Dialog(group="Nominal pressure drops"));
            parameter Modelica.SIunits.PressureDifference dpAirHeaCoi_nominal
              "Pressure difference" annotation (Dialog(group="Nominal pressure drops"));
            parameter Modelica.SIunits.PressureDifference dpAirRetTW_nominal
              "Pressure difference of air supply in thermal wheel"
              annotation (Dialog(group="Nominal pressure drops"));
            parameter Modelica.SIunits.PressureDifference dpAirSupTW_nominal
              "Pressure difference of exhaust air in thermal wheel"
              annotation (Dialog(group="Nominal pressure drops"));
            Controllers.SignalBus signalBus annotation (Placement(transformation(extent={{-94,86},
                      {-66,114}}),           iconTransformation(extent={{-210,-30},{-190,-10}})));
          equation

            annotation (Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                      -100},{100,100}})),           Icon(coordinateSystem(
                    preserveAspectRatio=false, extent={{-100,-100},{100,100}}), graphics={
                  Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={0,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Polygon(
                    points={{0,58},{-40,18},{0,-22},{40,18},{0,58}},
                    lineColor={0,0,0},
                    smooth=Smooth.None,
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Line(
                    points={{-100,60},{-26,60},{0,34},{26,60},{98,60}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Line(
                    points={{100,-62},{26,-62},{26,-26},{0,0},{-28,-28},{-28,-62},{-100,
                        -62}},
                    color={0,0,0},
                    smooth=Smooth.None),
                  Rectangle(
                    extent={{-76,-36},{-50,-86}},
                    lineColor={0,128,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Rectangle(
                    extent={{52,-34},{78,-84}},
                    lineColor={255,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),
                  Text(
                    extent={{58,-50},{70,-72}},
                    lineColor={255,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="+"),
                  Text(
                    extent={{-76,-48},{-50,-70}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="-"),
                  Line(
                    points={{-38,-60},{-38,-84},{0,-100}},
                    color={0,0,255},
                    smooth=Smooth.None,
                    pattern=LinePattern.Dash),
                  Text(
                    extent={{-42,-40},{-32,-60}},
                    lineColor={0,0,0},
                    pattern=LinePattern.Dash,
                    textString="T"),
                  Text(
                    extent={{-74,-82},{-48,-104}},
                    lineColor={0,0,255},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="-"),
                  Text(
                    extent={{54,-82},{66,-104}},
                    lineColor={255,0,0},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid,
                    textString="+")}),
                        Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)));
          end PartialAHU;
        end Dependencies;
      end Components;
    end VentilationSystem;

    package Controllers

      model RBCbaseline "hybridGEOTABS RBC baseline"

        DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{-80,20}}),
              iconTransformation(extent={{-110,-10},{-90,10}})));
        SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{120,
                  20}}), iconTransformation(extent={{90,-10},{110,10}})));
        SubControllers.ModeSelector_baseline modSel(
          heat(start=true),
          rest(start=false),
          cool(start=false)) "Mode selector sequence"
          annotation (Placement(transformation(extent={{60,80},{80,100}})));
        SubControllers.TABS tabsCon
          "Model that includes the control logic of TABS components"
          annotation (Placement(transformation(extent={{60,40},{80,60}})));
        Air.Comfort.Limits temLim(typeLimit=2, nZones=18)
          "Model that computes the building limits and calculates the discomfort"
          annotation (Placement(transformation(extent={{-60,-10},{-40,12}})));
        SubControllers.Valves.Tavg_of_floors avgFlrT
          "Model that computes the average temperature of the different floors"
          annotation (Placement(transformation(extent={{-100,60},{-80,80}})));
        SubControllers.HP_set hpCon
          "Model that includes the control logic of the GSHPs"
          annotation (Placement(transformation(extent={{60,10},{80,30}})));
        SubControllers.AHU_baseline ahuCon
          "Model that includes the control logic of the AHU"
          annotation (Placement(transformation(extent={{60,-34},{80,-6}})));
        SubControllers.Situations.Situations ctCon
          "Model that includes the control logic of the cooling tower"
          annotation (Placement(transformation(extent={{60,-60},{80,-40}})));
        SubControllers.VAV_baseline vavCon
          "Model that includes the control logic of the VAV and heating coils within the ducts"
          annotation (Placement(transformation(extent={{60,-94},{80,-66}})));
        SubControllers.SunShading sunSha
          "Model that includes the control logic of the shading devices"
          annotation (Placement(transformation(extent={{-20,60},{0,80}})));
        inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
              0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
              IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
              IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
          annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
        SubControllers.NightVentilation nightVent
          "Model that includes the control logic of night ventilation"
          annotation (Placement(transformation(extent={{-54,24},{-34,44}})));
      equation

        connect(modSel.heat, signalBus.heatMode) annotation (Line(points={{81,95},{
                100,95},{100,0}}, color={255,0,255}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(modSel.rest, signalBus.restMode) annotation (Line(points={{81,90},{
                100,90},{100,0}}, color={255,0,255}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(modSel.cool, signalBus.coolMode) annotation (Line(points={{81,85},{
                100,85},{100,0}}, color={255,0,255}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(dataBus, tabsCon.dataBus) annotation (Line(
            points={{-100,0},{-100,50},{60,50}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(tabsCon.signalBus, signalBus) annotation (Line(
            points={{80.2,50},{100,50},{100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(temLim.Tavg, signalBus.baseSetpoint) annotation (Line(points={{-39.25,
                2.60769},{28.375,2.60769},{28.375,0},{100,0}}, color={0,0,127}), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(avgFlrT.dataBus, dataBus) annotation (Line(
            points={{-100,70},{-100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(signalBus, hpCon.signalBus) annotation (Line(
            points={{100,0},{100,20},{80.2,20}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(hpCon.dataBus, dataBus) annotation (Line(
            points={{60,20},{-100,20},{-100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(ahuCon.dataBus, dataBus) annotation (Line(
            points={{60,-20},{-100,-20},{-100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(ahuCon.signalBus, signalBus) annotation (Line(
            points={{80.2,-20},{100,-20},{100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(ctCon.signalBus, signalBus) annotation (Line(
            points={{80.2,-50},{100,-50},{100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(ctCon.dataBus, dataBus) annotation (Line(
            points={{60,-50},{-100,-50},{-100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(vavCon.signalBus, signalBus) annotation (Line(
            points={{80.2,-80},{100,-80},{100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{6,3},{6,3}},
            horizontalAlignment=TextAlignment.Left));
        connect(vavCon.dataBus, dataBus) annotation (Line(
            points={{60,-80},{-100,-80},{-100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(sunSha.dataBus, dataBus) annotation (Line(
            points={{-20,70},{-74,70},{-74,0},{-100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T3rdFlr_SZ,temLim. TSensor[1]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,-1.44444},{
                -61.6667,-1.44444}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T3rdFlr_CPR,temLim. TSensor[2]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,-1.25641},{
                -61.6667,-1.25641}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T3rdFlr_MTR,temLim. TSensor[3]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-81.6667,0},{-81.6667,-1.06838},{
                -61.6667,-1.06838}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T3rdFlr_SmaR,temLim. TSensor[4]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,-0.880342},{
                -61.6667,-0.880342}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T2ndFlr_NZ,temLim. TSensor[5]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,-0.692308},{
                -61.6667,-0.692308}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T2ndFlr_SZ,temLim. TSensor[6]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,-0.504274},{
                -61.6667,-0.504274}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T2ndFlr_MT1,temLim. TSensor[7]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,-0.316239},{
                -61.6667,-0.316239}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T2ndFlr_MT2,temLim. TSensor[8]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,-0.128205},{
                -61.6667,-0.128205}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T1stFlr_NZ,temLim. TSensor[9]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,0.0598291},{
                -61.6667,0.0598291}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T1stFlr_SZ1,temLim. TSensor[10]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-81.6667,0},{-81.6667,0.247863},{
                -61.6667,0.247863}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T1stFlr_SZ2,temLim. TSensor[11]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,0.435897},{
                -61.6667,0.435897}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T1stFlr_MT1,temLim. TSensor[12]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-81.6667,0},{-81.6667,0.623932},{
                -61.6667,0.623932}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.T1stFlr_MT2,temLim. TSensor[13]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,0.811966},{
                -61.6667,0.811966}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));

        connect(dataBus.TGndFlr_1stAid,temLim. TSensor[15]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-81.6667,0},{-81.6667,1.18803},{
                -61.6667,1.18803}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.TGndFlr_KTR,temLim. TSensor[16]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-81.6667,0},{-81.6667,1.37607},{
                -61.6667,1.37607}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.TGndFlr_MT1,temLim. TSensor[17]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,1.5641},{
                -61.6667,1.5641}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.TGndFlr_MT2,temLim. TSensor[18]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,1.75214},{
                -61.6667,1.75214}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(dataBus.TGndFlr_hall,temLim. TSensor[14]) annotation (Line(
            points={{-99.9,0.1},{-90,0.1},{-90,0},{-79.6667,0},{-79.6667,1},{-61.6667,
                1}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%first",
            index=-1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));

        connect(nightVent.dataBus, dataBus) annotation (Line(
            points={{-54,34},{-100,34},{-100,0}},
            color={255,204,51},
            thickness=0.5), Text(
            string="%second",
            index=1,
            extent={{-6,3},{-6,3}},
            horizontalAlignment=TextAlignment.Right));
        connect(nightVent.NightVentilation, ahuCon.nightVentilation) annotation (Line(
              points={{-33,33.8},{14,33.8},{14,-24},{38,-24},{38,-30.5},{60,-30.5}},
              color={255,0,255}));
        connect(nightVent.NightVentilation, vavCon.nightVentilation) annotation (Line(
              points={{-33,33.8},{14,33.8},{14,-84},{60,-84},{60,-85.8333}}, color={
                255,0,255}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)));
      end RBCbaseline;

      package SubControllers "Individual controller modules"

        model HP_baseline "On/Off Logic for the HPs according to baseline"

          SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                    120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
          DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                    -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Blocks.Logical.Hysteresis hysteresis(
            pre_y_start=true,
            uLow=0,
            uHigh=3)          "hysteresis logic for HPs"
            annotation (Placement(transformation(extent={{-30,40},{-10,60}})));
          Modelica.Blocks.Logical.Not not1 "heating mode conditions"
            annotation (Placement(transformation(extent={{0,40},{20,60}})));
          Modelica.Blocks.Math.Add add(k2=-1)
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          Modelica.Blocks.Logical.Timer timer
            annotation (Placement(transformation(extent={{-20,-60},{0,-40}})));
          Modelica.Blocks.Logical.GreaterThreshold sleep(threshold=10*60)
            "triggers when 10 minutes passes"
            annotation (Placement(transformation(extent={{10,-60},{30,-40}})));
          Modelica.Blocks.Logical.Hysteresis hysteresis1(
            pre_y_start=true,
            uLow=-1,
            uHigh=1)          "hysteresis logic for HPs"
            annotation (Placement(transformation(extent={{-80,-60},{-60,-40}})));
          Modelica.Blocks.Logical.Not not2
            annotation (Placement(transformation(extent={{-50,-60},{-30,-40}})));
          Modelica.Blocks.Math.BooleanToInteger HP1 "Heat Pump signal 1"
            annotation (Placement(transformation(extent={{60,20},{80,40}})));
          Modelica.Blocks.Math.BooleanToInteger HP2 "Heat Pump signal 2"
            annotation (Placement(transformation(extent={{40,-60},{60,-40}})));
          Modelica.Blocks.Logical.GreaterThreshold sleep1(threshold=273.15 + 18)
            "triggers when 10 minutes passes"
            annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
          Modelica.Blocks.Logical.And actCooMod "active cooling mode conditions"
            annotation (Placement(transformation(extent={{-20,0},{0,20}})));
          Modelica.Blocks.Logical.Or or1
            annotation (Placement(transformation(extent={{32,20},{52,40}})));
        //  Modelica.Blocks.Sources.RealExpression hpMod(y=HP1.y + HP2.y)
        //    "fake modulation level of the GSHP, used for control logic of the borefield pump"
        //    annotation (Placement(transformation(extent={{60,50},{80,70}})));
          IDEAS.Utilities.Math.Max max(nin=3) "maximum of the required setpoints"
            annotation (Placement(transformation(extent={{-14,70},{-34,90}})));
        equation
          connect(hysteresis.y,not1. u)
            annotation (Line(points={{-9,50},{-2,50}},color={255,0,255}));
          connect(hysteresis.u,add. y)
            annotation (Line(points={{-32,50},{-39,50}},          color={0,0,127}));
          connect(dataBus.T14,add. u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,56},{-62,56}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(sleep.u,timer. y)
            annotation (Line(points={{8,-50},{1,-50}},    color={0,0,127}));
          connect(add.y, hysteresis1.u) annotation (Line(points={{-39,50},{-36,50},{
                  -36,32},{-86,32},{-86,-50},{-82,-50}}, color={0,0,127}));
          connect(hysteresis1.y, not2.u)
            annotation (Line(points={{-59,-50},{-52,-50}}, color={255,0,255}));
          connect(not2.y, timer.u)
            annotation (Line(points={{-29,-50},{-22,-50}}, color={255,0,255}));
          connect(sleep.y, HP2.u)
            annotation (Line(points={{31,-50},{38,-50}}, color={255,0,255}));
          connect(HP2.y, signalBus.HP2_signal) annotation (Line(points={{61,-50},{100,
                  -50},{100,0}}, color={255,127,0}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(dataBus.T2, sleep1.u) annotation (Line(
              points={{-99.9,0.1},{-100,0.1},{-100,10},{-62,10}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(sleep1.y, actCooMod.u1)
            annotation (Line(points={{-39,10},{-22,10}}, color={255,0,255}));
          connect(signalBus.coolMode, actCooMod.u2) annotation (Line(
              points={{100,0},{100,-12},{-32,-12},{-32,2},{-22,2}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(actCooMod.y, or1.u2) annotation (Line(points={{1,10},{24,10},{24,22},{
                  30,22}}, color={255,0,255}));
          connect(not1.y, or1.u1) annotation (Line(points={{21,50},{24,50},{24,30},{
                  30,30}}, color={255,0,255}));
          connect(or1.y, HP1.u)
            annotation (Line(points={{53,30},{58,30}}, color={255,0,255}));
          connect(HP1.y, signalBus.HP1_signal) annotation (Line(points={{81,30},{100,
                  30},{100,0}}, color={255,127,0}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
              //  connect(hpMod.y, signalBus.HP_mod)
              // annotation (Line(points={{81,60},{100,60},{
          //        100,0}}, color={0,0,127}), Text(
            //  string="%second",
          //    index=1,
          //    extent={{6,3},{6,3}},
          //    horizontalAlignment=TextAlignment.Left));
          connect(max.u[2], signalBus.T_AHU_HP) annotation (Line(points={{-12,80},{100,80},{100,
                  0}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(max.u[3], signalBus.T_VAV) annotation (Line(points={{-12,81.3333},{
                  100,81.3333},{100,0}},
                       color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(max.u[1], signalBus.T_TABS) annotation (Line(points={{-12,78.6667},
                  {100,78.6667},{100,0}},
                       color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(max.y, add.u2) annotation (Line(points={{-35,80},{-80,80},{-80,44},{-62,
                  44}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                Text(
                  extent={{-62,76},{78,-64}},
                  lineColor={28,108,200},
                  textString="HP")}), Diagram(coordinateSystem(preserveAspectRatio=
                    false)));
        end HP_baseline;

        model HP_set
          DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                    -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
          SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                    120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
          HP_baseline hpCon "Control logic of the GSHP"
            annotation (Placement(transformation(extent={{-10,60},{10,80}})));
          Pumps.P1 p1Con "Control logic of pump 1"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          Pumps.P3 p3Con "Control logic of pump 3"
            annotation (Placement(transformation(extent={{-10,-20},{10,0}})));
        equation
          connect(hpCon.dataBus, dataBus) annotation (Line(
              points={{-10,70},{-100,70},{-100,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(hpCon.signalBus, signalBus) annotation (Line(
              points={{10.2,70},{100,70},{100,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(p1Con.dataBus, dataBus) annotation (Line(
              points={{-10,30},{-100,30},{-100,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(p1Con.signalBus, signalBus) annotation (Line(
              points={{10.2,30},{100,30},{100,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(p3Con.dataBus, dataBus) annotation (Line(
              points={{-10,-10},{-100,-10},{-100,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(p3Con.signalBus, signalBus) annotation (Line(
              points={{10.2,-10},{100,-10},{100,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)));
        end HP_set;

        model AHU_baseline "Controls of AHU loop for baseline"

          SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                    120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
          DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                    -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
          inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},
                {IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
            annotation (Placement(transformation(extent={{-100,180},{-80,200}})));
          Modelica.Blocks.Tables.CombiTable1D curve_AHU(table=[273.15 + 0,273.15 + 20; 273.15
                 + 15,273.15 + 19]) "Infrax AHU heating/cooling curve"
            annotation (Placement(transformation(extent={{-10,166},{10,186}})));
          Modelica.Blocks.Nonlinear.Limiter limiter(uMax=273.15 + 23, uMin=273.15 + 15)
            annotation (Placement(transformation(extent={{20,166},{40,186}})));
          Modelica.Blocks.Sources.RealExpression bouT(y=sim.Te) "ambient temperature"
            annotation (Placement(transformation(extent={{-40,166},{-20,186}})));
          Modelica.Blocks.Logical.LessThreshold thermalWheelByPass(threshold=2)
            "thermal wheel by pass switch"
            annotation (Placement(transformation(extent={{16,128},{36,148}})));
          Modelica.Blocks.Math.Feedback feedback
            "temperature difference between AHU supply and extract"
                                                 annotation (Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-32,138})));
          Modelica.Blocks.Math.Abs abs
            annotation (Placement(transformation(extent={{-14,128},{6,148}})));
          IDEAS.Controls.Continuous.LimPID con3wayCoo(
            initType=Modelica.Blocks.Types.InitPID.InitialState,
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            Td=0,
            k=5,
            Ti(displayUnit="s") = 40,
            reverseAction=true) "Controller for 3-way valve of AHU cooling coil"
            annotation (Placement(transformation(extent={{-10,38},{10,58}})));
          Modelica.Blocks.Tables.CombiTable1D curve_P13(table=[0,0.12; 0.8,0.30; 1,1])
            "pump 13 modulating curve"
            annotation (Placement(transformation(extent={{-38,-2},{-18,18}})));
          Modelica.Blocks.Math.Gain P13_nom(k=14.5*9804.139432)
            "nominal pressure rise of P13"
            annotation (Placement(transformation(extent={{0,-2},{20,18}})));
          IDEAS.Controls.Continuous.LimPID con3wayHea(
            initType=Modelica.Blocks.Types.InitPID.InitialState,
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            Td=0,
            Ti(displayUnit="s") = 40,
            k=2,
            reverseAction=false) "Controller for 3-way valve of AHU heating coil"
            annotation (Placement(transformation(extent={{-8,-80},{12,-60}})));
          Modelica.Blocks.Math.BooleanToInteger P0809_signal
            "pump 08 and 09 signal, nominal conditions if heating is activated"
            annotation (Placement(transformation(extent={{20,-124},{40,-104}})));
          Modelica.Blocks.Logical.GreaterThreshold greaterThreshold
            annotation (Placement(transformation(extent={{-30,-124},{-10,-104}})));
          Modelica.Blocks.Logical.Timer timer
            annotation (Placement(transformation(extent={{-8,-42},{12,-22}})));
          Modelica.Blocks.Logical.GreaterThreshold sleep(threshold=5*60)
            "triggers when 10 minutes passes"
            annotation (Placement(transformation(extent={{20,-42},{40,-22}})));
          Modelica.Blocks.Logical.LessEqualThreshold
                                                lessEqualThreshold
            annotation (Placement(transformation(extent={{-40,-42},{-20,-22}})));
          Modelica.Blocks.Logical.Switch switch1
            annotation (Placement(transformation(extent={{52,10},{74,-12}})));
          Modelica.Blocks.Sources.Constant off(k=0)
            annotation (Placement(transformation(extent={{24,-6},{32,2}})));
          Modelica.Blocks.Math.BooleanToInteger P04_signal "pump 04 signal"
            annotation (Placement(transformation(extent={{68,-68},{88,-48}})));
          Modelica.Blocks.Logical.Not not1
            annotation (Placement(transformation(extent={{46,-38},{58,-26}})));
          Modelica.Blocks.Sources.RealExpression
                                           supplySP(y=if ((clock.hour >= 5 and clock.hour <
                20) and (clock.weekDay) < 6) or nightVentilation == true then 180 else 0)
                         "Supply fan pressure difference set-point"
            annotation (Placement(transformation(extent={{-10,-156},{12,-136}})));
          Modelica.Blocks.Sources.RealExpression
                                           extractSP(y=if ((clock.hour >= 5 and clock.hour <
                20) and (clock.weekDay) < 6) or nightVentilation == true then 125 else 0)
            "Extract fan pressure difference set-point"
            annotation (Placement(transformation(extent={{-10,-186},{10,-164}})));
          Components.Clock           clock
            annotation (Placement(transformation(extent={{-100,144},{-80,164}})));
          Modelica.Blocks.Sources.IntegerExpression P08P09signal(y=if (clock.hour >= 5
                 and clock.hour < 20) and (clock.weekDay) < 6 then P0809_signal.y else 0)
            "Pumps 08 and 09 signal"
            annotation (Placement(transformation(extent={{20,-100},{42,-80}})));
          Modelica.Blocks.Sources.IntegerExpression P04signal(y=if (clock.hour >= 5
                 and clock.hour < 20) and (clock.weekDay) < 6 then P04_signal.y else
                0)
            "pump 04 signal"
            annotation (Placement(transformation(extent={{66,-48},{88,-28}})));
          Modelica.Blocks.Sources.RealExpression
                                           P13signal(y=if (clock.hour >= 5 and clock.hour <
                20) and (clock.weekDay) < 6 then switch1.y else 0)
            "Pump 13 signal"
            annotation (Placement(transformation(extent={{52,8},{74,28}})));
          Modelica.Blocks.Tables.CombiTable1D curve_HP(table=[273.15 + 15,273.15 + 24;
                273.15 + 23,273.15 + 32])
            "HP setpoint depending on AHU required temperature"
            annotation (Placement(transformation(extent={{72,166},{92,186}})));
          Modelica.Blocks.Logical.Switch switch2
            annotation (Placement(transformation(extent={{16,94},{36,74}})));
          Modelica.Blocks.Sources.Constant bypass(k=1)
            "signal for by-passing the thermal wheel"
            annotation (Placement(transformation(extent={{-42,70},{-34,78}})));
          IDEAS.Controls.Continuous.LimPID con3wayTW(
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            Td=0,
            k=2,
            Ti(displayUnit="s") = 40,
            reverseAction=false)
            "Controller for 3-way valve of AHU themal wheel"
            annotation (Placement(transformation(extent={{-26,100},{-6,120}})));
          Modelica.Blocks.Math.Feedback feedback1
            "temperature difference between AHU supply and extract"
                                                 annotation (Placement(transformation(
                extent={{-10,10},{10,-10}},
                rotation=0,
                origin={-56,90})));
          Modelica.Blocks.Math.Abs abs1
            annotation (Placement(transformation(extent={{-34,84},{-22,96}})));
          Modelica.Blocks.Sources.Constant diff_sp(k=0)
            "setpoint both for heating and cooling"
            annotation (Placement(transformation(extent={{-48,104},{-36,116}})));
          Modelica.Blocks.Interfaces.BooleanInput nightVentilation
            "night ventilation active"
            annotation (Placement(transformation(extent={{-120,-170},{-80,-130}})));
          Modelica.Blocks.Logical.Or or1
            annotation (Placement(transformation(extent={{36,98},{16,118}})));
        equation

            connect(con3wayCoo.y, signalBus.CooCoi_3way_signal) annotation (Line(points={{11,48},
                  {100,48},{100,0}},        color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
            connect(con3wayHea.y, signalBus.HeaCoi_3way_signal) annotation (Line(points={{13,-70},
                  {100,-70},{100,0}},         color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));

          connect(curve_AHU.y[1], limiter.u)
            annotation (Line(points={{11,176},{18,176}}, color={0,0,127}));
          connect(bouT.y, curve_AHU.u[1])
            annotation (Line(points={{-19,176},{-12,176}}, color={0,0,127}));
          connect(dataBus.TAirSupplyAHU, feedback.u1) annotation (Line(
              points={{-99.9,0.1},{-100,0.1},{-100,138},{-40,138}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.TAirExtractAHU, feedback.u2) annotation (Line(
              points={{-99.9,0.1},{-99.9,52},{-100,52},{-100,126},{-32,126},{-32,130}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(feedback.y, abs.u)
            annotation (Line(points={{-23,138},{-16,138}}, color={0,0,127}));
          connect(abs.y, thermalWheelByPass.u)
            annotation (Line(points={{7,138},{14,138}},  color={0,0,127}));
          connect(limiter.y, con3wayCoo.u_s) annotation (Line(points={{41,176},{58,
                  176},{58,200},{-72,200},{-72,48},{-12,48}},
                                                         color={0,0,127}));
          connect(dataBus.TAirSupplyAHU, con3wayCoo.u_m) annotation (Line(
              points={{-99.9,0.1},{-100,0.1},{-100,28},{0,28},{0,36}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(con3wayCoo.y, curve_P13.u[1]) annotation (Line(points={{11,48},{20,
                  48},{20,24},{-46,24},{-46,8},{-40,8}},
                                                       color={0,0,127}));
          connect(P13_nom.u, curve_P13.y[1])
            annotation (Line(points={{-2,8},{-17,8}},   color={0,0,127}));
          connect(con3wayHea.u_s, con3wayCoo.u_s) annotation (Line(points={{-10,-70},
                  {-72,-70},{-72,48},{-12,48}},
                                           color={0,0,127}));
          connect(dataBus.TAirSupplyAHU, con3wayHea.u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-54},{-100,-54},{-100,-92},{2,-92},{2,-82}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(con3wayHea.y, greaterThreshold.u) annotation (Line(points={{13,-70},
                  {18,-70},{18,-96},{-40,-96},{-40,-114},{-32,-114}},
                                                                color={0,0,127}));
          connect(greaterThreshold.y, P0809_signal.u)
            annotation (Line(points={{-9,-114},{18,-114}},
                                                         color={255,0,255}));
          connect(sleep.u,timer. y)
            annotation (Line(points={{18,-32},{13,-32}},  color={0,0,127}));
          connect(con3wayCoo.y, lessEqualThreshold.u) annotation (Line(points={{11,48},
                  {20,48},{20,24},{-46,24},{-46,-32},{-42,-32}}, color={0,0,127}));
          connect(lessEqualThreshold.y, timer.u)
            annotation (Line(points={{-19,-32},{-10,-32}}, color={255,0,255}));
          connect(sleep.y, switch1.u2) annotation (Line(points={{41,-32},{44,-32},{44,
                  -1},{49.8,-1}},
                              color={255,0,255}));
          connect(switch1.u3, P13_nom.y) annotation (Line(points={{49.8,7.8},{38,7.8},
                  {38,8},{21,8}},   color={0,0,127}));
          connect(off.y, switch1.u1) annotation (Line(points={{32.4,-2},{40,-2},{40,
                  -9.8},{49.8,-9.8}},
                               color={0,0,127}));
          connect(sleep.y, not1.u)
            annotation (Line(points={{41,-32},{44.8,-32}}, color={255,0,255}));
          connect(not1.y, P04_signal.u) annotation (Line(points={{58.6,-32},{62,-32},
                  {62,-58},{66,-58}},
                                  color={255,0,255}));
          connect(supplySP.y, signalBus.AHUsupply) annotation (Line(points={{13.1,
                  -146},{100,-146},{100,0}},
                                       color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(extractSP.y, signalBus.AHUextract) annotation (Line(points={{11,-175},
                  {100,-175},{100,0}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(P08P09signal.y, signalBus.P08_signal) annotation (Line(points={{43.1,
                  -90},{100,-90},{100,0}},
                                      color={255,127,0}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(P08P09signal.y, signalBus.P09_signal) annotation (Line(points={{43.1,
                  -90},{100,-90},{100,0}},
                                      color={255,127,0}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(P04signal.y, signalBus.P04_signal) annotation (Line(points={{89.1,
                  -38},{94,-38},{94,0},{100,0}},
                                      color={255,127,0}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(P13signal.y, signalBus.P13_signal) annotation (Line(points={{75.1,18},
                  {100,18},{100,0}},     color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(limiter.y, curve_HP.u[1])
            annotation (Line(points={{41,176},{70,176}}, color={0,0,127}));
          connect(limiter.y, signalBus.T_AHU) annotation (Line(points={{41,176},{58,
                  176},{58,156},{100,156},{100,0}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(curve_HP.y[1], signalBus.T_AHU_HP) annotation (Line(points={{93,176},
                  {100,176},{100,0}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(bypass.y, switch2.u1) annotation (Line(points={{-33.6,74},{-10,74},
                  {-10,76},{14,76}}, color={0,0,127}));
          connect(con3wayTW.y, switch2.u3) annotation (Line(points={{-5,110},{4,110},
                  {4,92},{14,92}}, color={0,0,127}));
          connect(switch2.y, signalBus.TW_bypass) annotation (Line(points={{37,84},{
                  100,84},{100,0}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(con3wayTW.u_s, diff_sp.y)
            annotation (Line(points={{-28,110},{-35.4,110}}, color={0,0,127}));
          connect(feedback1.y, abs1.u)
            annotation (Line(points={{-47,90},{-35.2,90}}, color={0,0,127}));
          connect(abs1.y, con3wayTW.u_m) annotation (Line(points={{-21.4,90},{-16,90},
                  {-16,98}}, color={0,0,127}));
          connect(feedback1.u2, con3wayCoo.u_s) annotation (Line(points={{-56,98},{
                  -56,110},{-72,110},{-72,48},{-12,48}}, color={0,0,127}));
          connect(dataBus.TAirSupplyAHU, feedback1.u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,90},{-64,90}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(thermalWheelByPass.y, or1.u1) annotation (Line(points={{37,138},{50,
                  138},{50,108},{38,108}}, color={255,0,255}));
          connect(nightVentilation, or1.u2) annotation (Line(points={{-100,-150},{-66,
                  -150},{-66,-160},{78,-160},{78,100},{38,100}}, color={255,0,255}));
          connect(or1.y, switch2.u2) annotation (Line(points={{15,108},{-2,108},{-2,
                  84},{14,84}}, color={255,0,255}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,
                    -200},{100,200}}),                                  graphics={
                  Rectangle(
                  extent={{-100,180},{100,-180}},
                  lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                Text(
                  extent={{-62,76},{78,-64}},
                  lineColor={28,108,200},
                  textString="AHU")}),Diagram(coordinateSystem(preserveAspectRatio=
                    false, extent={{-100,-200},{100,200}}), graphics={
                Rectangle(extent={{-52,194},{44,152}}, lineColor={28,108,200}),
                Text(
                  extent={{-48,194},{-20,186}},
                  lineColor={28,108,200},
                  textString="AHU setpoint"),
                Rectangle(extent={{-52,152},{44,68}}, lineColor={28,108,200}),
                Text(
                  extent={{-48,154},{-4,148}},
                  lineColor={28,108,200},
                  textString="Thermal wheel bypass"),
                Rectangle(extent={{-52,68},{44,-48}}, lineColor={28,108,200}),
                Text(
                  extent={{-52,68},{-18,62}},
                  lineColor={28,108,200},
                  textString="Cooling coil"),
                Text(
                  extent={{-52,-48},{-18,-54}},
                  lineColor={28,108,200},
                  textString="Heating coil"),
                Rectangle(extent={{-52,-48},{44,-132}}, lineColor={28,108,200}),
                Rectangle(extent={{-52,-132},{44,-192}}, lineColor={28,108,200}),
                Text(
                  extent={{-52,-132},{-18,-138}},
                  lineColor={28,108,200},
                  textString="AHU fans")}));
        end AHU_baseline;

        model CoolingTower "CoolingTower PID"

          SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                    120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
          DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                    -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Blocks.Sources.Constant TSetLea(k=273.15 + 29)
            "Setpoint for leaving temperature"
                         annotation (Placement(transformation(extent={{-60,-60},{-40,
                    -40}})));
          inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          IDEAS.Utilities.Psychrometrics.TWetBul_TDryBulXi wetBul(redeclare
            package Medium =
                       IDEAS.Media.Air)
            annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
          IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(numSolBus=5)
            annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
          Modelica.Blocks.Sources.Constant Patm(k=101325)
            annotation (Placement(transformation(extent={{-80,36},{-68,48}})));
          Modelica.Blocks.Logical.Switch switch1
            annotation (Placement(transformation(extent={{24,-68},{44,-48}})));
          Modelica.Blocks.Sources.Constant off(k=0) "off cooling tower"
            annotation (Placement(transformation(extent={{-20,-100},{0,-80}})));
          Modelica.Blocks.Interfaces.BooleanInput sit1
            annotation (Placement(transformation(extent={{20,-20},{-20,20}},
                rotation=90,
                origin={-28,100})));
          Modelica.Blocks.Interfaces.BooleanInput sit2
            annotation (Placement(transformation(extent={{20,-20},{-20,20}},
                rotation=90,
                origin={10,100})));
          Modelica.Blocks.Interfaces.BooleanInput sit3
            annotation (Placement(transformation(extent={{20,-20},{-20,20}},
                rotation=90,
                origin={50,100})));
          Modelica.Blocks.Sources.BooleanExpression booleanExpression(y=sit1 or sit2
                 or sit3)
            annotation (Placement(transformation(extent={{-64,-10},{-44,10}})));
          IDEAS.Controls.Continuous.LimPID conFan(
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            k=2,
            Ti=40) annotation (Placement(transformation(extent={{-24,-60},{-4,-40}})));
        equation
          connect(sim.weaBus, weaBus) annotation (Line(
              points={{-81,93},{-78,93},{-78,70},{-70,70}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.Te, wetBul.TDryBul) annotation (Line(
              points={{-69.95,70.05},{-56,70.05},{-56,58},{-41,58}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(weaBus.X_wEnv, wetBul.Xi[1]) annotation (Line(
              points={{-69.95,70.05},{-56,70.05},{-56,50},{-41,50}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(wetBul.TWetBul, signalBus.Twet) annotation (Line(points={{-19,50},{
                  100,50},{100,0},{100,0}},       color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(Patm.y, wetBul.p) annotation (Line(points={{-67.4,42},{-67.4,42},{
                  -41,42}}, color={0,0,127}));
          connect(switch1.y, signalBus.CT_signal) annotation (Line(points={{45,-58},{
                  70,-58},{100,-58},{100,0}},       color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(off.y, switch1.u3) annotation (Line(points={{1,-90},{10,-90},{10,
                  -66},{22,-66}}, color={0,0,127}));
          connect(booleanExpression.y, switch1.u2) annotation (Line(points={{-43,0},{
                  -16,0},{8,0},{8,-58},{22,-58}}, color={255,0,255}));
          connect(TSetLea.y, conFan.u_s) annotation (Line(points={{-39,-50},{-32,-50},
                  {-26,-50}}, color={0,0,127}));
          connect(conFan.y, switch1.u1)
            annotation (Line(points={{-3,-50},{22,-50}}, color={0,0,127}));
          connect(conFan.u_m, dataBus.T27) annotation (Line(points={{-14,-62},{-14,
                  -74},{-99.9,-74},{-99.9,0.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                Text(
                  extent={{-62,76},{78,-64}},
                  lineColor={28,108,200},
                  textString="CT")}), Diagram(coordinateSystem(preserveAspectRatio=
                    false)));
        end CoolingTower;

        model TABS "Controls of TABS loop for baseline"

          SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                    120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
          DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                    -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
          Modelica.Blocks.Sources.IntegerConstant p7Con(k=1) "P07 is always on"
            annotation (Placement(transformation(extent={{-10,60},{10,80}})));
          Valves.RBCBaseline.TwoWayValvesTABS twoWayTABSCon
            "Control logic of TABS two way valves"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          outer IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},
                {IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          Valves.RBCBaseline.ThreeWayValveTABS_baseline threeWayTABSCon
            "Control logic of TABS 3 way valves"
            annotation (Placement(transformation(extent={{-10,-20},{10,0}})));
          Pumps.RBCBaseline.P5_baseline p5Con "Pump for passive cooling"
            annotation (Placement(transformation(extent={{-10,-60},{10,-40}})));
        equation
          connect(p7Con.y, signalBus.P07_signal) annotation (Line(points={{11,70},{
                  100,70},{100,0}}, color={255,127,0}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(twoWayTABSCon.signalBus, signalBus) annotation (Line(
              points={{10.2,30},{100,30},{100,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(twoWayTABSCon.dataBus, dataBus) annotation (Line(
              points={{-10,30},{-100,30},{-100,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus, threeWayTABSCon.dataBus) annotation (Line(
              points={{-100,0},{-100,-10},{-10,-10}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(threeWayTABSCon.signalBus, signalBus) annotation (Line(
              points={{10.2,-10},{100,-10},{100,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(dataBus, p5Con.dataBus) annotation (Line(
              points={{-100,0},{-100,-50},{-10,-50}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(p5Con.signalBus, signalBus) annotation (Line(
              points={{10.2,-50},{100,-50},{100,0}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                  Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                Text(
                  extent={{-62,76},{78,-64}},
                  lineColor={28,108,200},
                  textString="TABS")}),
                                      Diagram(coordinateSystem(preserveAspectRatio=
                    false), graphics={Text(
                  extent={{0,-94},{0,-84}},
                  lineColor={28,108,200},
                  fontSize=14,
                  textStyle={TextStyle.Bold},
                  textString=
                      "On-off heating/cooling selector valves are controlled with the mode selector")}));
        end TABS;

        model ModeSelector_baseline
          // -1 cooling, 0 rest, 1 heating
          IDEAS.Controls.ControlHeating.RunningMeanTemperatureEN15251 avgExt "RMOT"
            annotation (Placement(transformation(extent={{-92,-10},{-72,10}})));
          Modelica.Blocks.Logical.GreaterThreshold greaterThreshold(threshold=273.15
                 + 10)
            annotation (Placement(transformation(extent={{-50,-70},{-30,-50}})));
          Modelica.Blocks.Logical.LessThreshold lessThreshold(threshold=273.15 + 8)
            annotation (Placement(transformation(extent={{-50,50},{-30,70}})));
          Modelica.Blocks.Interfaces.BooleanOutput heat
            annotation (Placement(transformation(extent={{100,40},{120,60}})));
          Modelica.Blocks.Interfaces.BooleanOutput rest
            annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          Modelica.Blocks.Interfaces.BooleanOutput cool
            annotation (Placement(transformation(extent={{100,-60},{120,-40}})));
          Components.Step restWait(
            use_activePort=true,
            nOut=1,
            nIn=4,
            initialStep=false)
                   annotation (Placement(transformation(extent={{52,16},{60,24}})));
          Components.Step restDecide(
            initialStep=false,
            use_activePort=false,
            nIn=1,
            nOut=3) annotation (Placement(transformation(extent={{52,-14},{60,-6}})));
          Components.Transition T1(delayedTransition=true, waitTime=86400)
            annotation (Placement(transformation(extent={{52,2},{60,10}})));
          Modelica.Blocks.Logical.GreaterEqualThreshold greaterEqualThreshold(threshold=
               273.15 + 8)
            annotation (Placement(transformation(extent={{-50,10},{-30,30}})));
          Modelica.Blocks.Logical.LessEqualThreshold lessEqualThreshold(threshold=
                273.15 + 10)
            annotation (Placement(transformation(extent={{-50,-28},{-30,-8}})));
          Components.Transition T3(use_conditionPort=true)
            annotation (Placement(transformation(extent={{16,64},{24,56}})));
          Components.Transition T2(use_conditionPort=true)
            annotation (Placement(transformation(extent={{36,12},{44,4}})));
          Components.Transition T4(use_conditionPort=true)
            annotation (Placement(transformation(extent={{52,-38},{60,-30}})));
          Components.Step coolWait(
            use_activePort=true,
            nOut=1,
            initialStep=false,
            nIn=3) annotation (Placement(transformation(extent={{52,-56},{60,-48}})));
          Components.Step coolDecide(
            initialStep=false,
            use_activePort=false,
            nIn=1,
            nOut=2) annotation (Placement(transformation(extent={{52,-88},{60,-80}})));
          Components.Transition T5(delayedTransition=true, waitTime=86400)
            annotation (Placement(transformation(extent={{52,-70},{60,-62}})));
          Components.Step heatWait(
            use_activePort=true,
            nOut=1,
            initialStep=false,
            nIn=3) annotation (Placement(transformation(extent={{52,76},{60,84}})));
          Modelica.Blocks.Logical.And and1
            annotation (Placement(transformation(extent={{-14,-2},{6,18}})));
          Components.Step heatDecide(
            initialStep=false,
            use_activePort=false,
            nIn=1,
            nOut=2) annotation (Placement(transformation(extent={{52,46},{60,54}})));
          Components.Transition T6(delayedTransition=true, waitTime=86400)
            annotation (Placement(transformation(extent={{52,64},{60,72}})));
          Components.Transition T7(use_conditionPort=true)
            annotation (Placement(transformation(extent={{52,34},{60,42}})));
          Components.Transition T8(use_conditionPort=true)
            annotation (Placement(transformation(extent={{16,-66},{24,-74}})));
          Components.Transition T9(use_conditionPort=true)
            annotation (Placement(transformation(extent={{36,-56},{44,-64}})));
          Components.Transition T10(use_conditionPort=true)
            annotation (Placement(transformation(extent={{36,72},{44,64}})));

          Components.Step ini(
            initialStep=true,
            nOut=1,
            use_activePort=true)
            annotation (Placement(transformation(extent={{70,34},{78,42}})));
          Components.Transition T11(
                                   delayedTransition=true, waitTime=64800)
            annotation (Placement(transformation(extent={{88,20},{96,28}})));

          Components.Step iniDecide(
            nOut=3,
            use_activePort=false,
            nIn=1,
            initialStep=false)
            annotation (Placement(transformation(extent={{88,4},{96,12}})));
          Components.Transition T12(
                                   use_conditionPort=true)
            annotation (Placement(transformation(extent={{78,-8},{86,-16}})));
          Components.Transition T13(
                                   use_conditionPort=true)
            annotation (Placement(transformation(extent={{92,-26},{100,-18}})));
          Components.Transition T14(
                                   use_conditionPort=true)
            annotation (Placement(transformation(extent={{84,66},{92,58}})));
          Modelica.Blocks.Logical.Or  and2
            annotation (Placement(transformation(extent={{86,32},{98,44}})));
        equation

          connect(avgExt.TRm, greaterThreshold.u) annotation (Line(points={{-71.4,0},{-66,
                  0},{-62,0},{-62,-60},{-52,-60}}, color={0,0,127}));

          connect(avgExt.TRm, lessThreshold.u) annotation (Line(points={{-71.4,0},{-62,0},
                  {-62,60},{-52,60}},     color={0,0,127}));

          connect(restWait.outPort[1], T1.inPort)
            annotation (Line(points={{56,15.4},{56,12.7},{56,10}}, color={0,0,0}));
          connect(T1.outPort, restDecide.inPort[1])
            annotation (Line(points={{56,1},{56,-2},{56,-6}},
                                                      color={0,0,0}));
          connect(restDecide.outPort[1], T4.inPort) annotation (Line(points={{54.6667,
                  -14.6},{54.6667,-22},{56,-22},{56,-30}},
                                                    color={0,0,0}));
          connect(coolWait.activePort, cool) annotation (Line(points={{60.72,-52},{60.72,
                  -56},{92,-56},{92,-50},{110,-50}}, color={255,0,255}));
          connect(T4.outPort, coolWait.inPort[1])
            annotation (Line(points={{56,-39},{56,-48},{54.6667,-48}},
                                                                  color={0,0,0}));
          connect(coolWait.outPort[1], T5.inPort)
            annotation (Line(points={{56,-56.6},{56,-59.3},{56,-62}}, color={0,0,0}));
          connect(T5.outPort, coolDecide.inPort[1])
            annotation (Line(points={{56,-71},{56,-75.5},{56,-80}}, color={0,0,0}));
          connect(greaterEqualThreshold.u, lessThreshold.u) annotation (Line(points={{-52,
                  20},{-62,20},{-62,60},{-52,60}}, color={0,0,127}));
          connect(lessEqualThreshold.u, greaterThreshold.u) annotation (Line(points={{-52,
                  -18},{-62,-18},{-62,-60},{-52,-60}}, color={0,0,127}));
          connect(greaterThreshold.y, T4.conditionPort) annotation (Line(points={{-29,-60},
                  {10,-60},{10,-34},{51,-34}}, color={255,0,255}));
          connect(restDecide.outPort[2], T3.inPort) annotation (Line(points={{56,-14.6},
                  {54,-14.6},{54,-20},{20,-20},{20,18},{20,38},{20,56}}, color={0,0,0}));
          connect(lessThreshold.y, T3.conditionPort)
            annotation (Line(points={{-29,60},{15,60}}, color={255,0,255}));
          connect(heatWait.activePort, heat) annotation (Line(points={{60.72,80},{80,80},
                  {80,50},{110,50}}, color={255,0,255}));
          connect(T3.outPort, heatWait.inPort[1]) annotation (Line(points={{20,65},{
                  20,66},{20,96},{54.6667,96},{54.6667,84}},color={0,0,0}));
          connect(restDecide.outPort[3], T2.inPort) annotation (Line(points={{57.3333,
                  -14.6},{50,-14.6},{50,-16},{40,-16},{40,4}},
                                                        color={0,0,0}));
          connect(T2.outPort, restWait.inPort[1]) annotation (Line(points={{40,13},{
                  40,30},{54.5,30},{54.5,24}},color={0,0,0}));
          connect(and1.y, T2.conditionPort)
            annotation (Line(points={{7,8},{22,8},{35,8}}, color={255,0,255}));
          connect(heatWait.outPort[1], T6.inPort)
            annotation (Line(points={{56,75.4},{56,73.7},{56,72}}, color={0,0,0}));
          connect(T6.outPort, heatDecide.inPort[1])
            annotation (Line(points={{56,63},{56,58.5},{56,54}}, color={0,0,0}));
          connect(heatDecide.outPort[1], T7.inPort)
            annotation (Line(points={{55,45.4},{56,43.7},{56,42}}, color={0,0,0}));
          connect(T7.outPort, restWait.inPort[2])
            annotation (Line(points={{56,33},{56,24},{55.5,24}},       color={0,0,0}));
          connect(greaterEqualThreshold.y, T7.conditionPort) annotation (Line(points={{-29,
                  20},{-16,20},{-16,38},{51,38}}, color={255,0,255}));
          connect(lessEqualThreshold.y, and1.u2)
            annotation (Line(points={{-29,-18},{-16,-18},{-16,0}}, color={255,0,255}));
          connect(greaterEqualThreshold.y, and1.u1) annotation (Line(points={{-29,20},{-24,
                  20},{-16,20},{-16,8}}, color={255,0,255}));
          connect(coolDecide.outPort[1], T8.inPort) annotation (Line(points={{55,-88.6},
                  {55,-92},{20,-92},{20,-74}}, color={0,0,0}));
          connect(lessEqualThreshold.y, T8.conditionPort) annotation (Line(points={{-29,
                  -18},{-24,-18},{-16,-18},{-16,-70},{15,-70}}, color={255,0,255}));
          connect(T8.outPort, restWait.inPort[3]) annotation (Line(points={{20,-65},{
                  28,-65},{28,-64},{30,-64},{30,32},{58,32},{58,24},{56.5,24}}, color={0,
                  0,0}));
          connect(coolDecide.outPort[2], T9.inPort)
            annotation (Line(points={{57,-88.6},{40,-88.6},{40,-64}}, color={0,0,0}));
          connect(T9.outPort, coolWait.inPort[2]) annotation (Line(points={{40,-55},{
                  40,-55},{40,-44},{56,-44},{56,-48}},
                                                    color={0,0,0}));
          connect(greaterThreshold.y, T9.conditionPort)
            annotation (Line(points={{-29,-60},{35,-60}}, color={255,0,255}));
          connect(T10.outPort, heatWait.inPort[2]) annotation (Line(points={{40,73},{
                  40,73},{40,90},{56,90},{56,84}},
                                                color={0,0,0}));
          connect(heatDecide.outPort[2], T10.inPort) annotation (Line(points={{57,45.4},
                  {50,45.4},{50,46},{40,46},{40,64}}, color={0,0,0}));
          connect(lessThreshold.y, T10.conditionPort) annotation (Line(points={{-29,60},
                  {2,60},{2,68},{35,68}}, color={255,0,255}));
          connect(ini.outPort[1], T11.inPort)
            annotation (Line(points={{74,33.4},{74,30},{92,30},{92,28}},
                                                         color={0,0,0}));
          connect(T11.outPort, iniDecide.inPort[1])
            annotation (Line(points={{92,19},{92,15.5},{92,12}}, color={0,0,0}));
          connect(iniDecide.outPort[1], T12.inPort) annotation (Line(points={{90.6667,
                  3.4},{88,3.4},{88,-16},{82,-16}}, color={0,0,0}));
          connect(T12.outPort, restWait.inPort[4]) annotation (Line(points={{82,-7},{
                  80,-7},{80,-4},{80,24},{57.5,24}}, color={0,0,0}));
          connect(and1.y, T12.conditionPort) annotation (Line(points={{7,8},{24,8},{
                  24,-2},{78,-2},{44,-2},{44,-12},{77,-12}}, color={255,0,255}));
          connect(iniDecide.outPort[2], T13.inPort) annotation (Line(points={{92,3.4},
                  {92,-7.3},{96,-7.3},{96,-18}}, color={0,0,0}));
          connect(T13.outPort, coolWait.inPort[3]) annotation (Line(points={{96,-27},
                  {76,-27},{76,-48},{57.3333,-48}}, color={0,0,0}));
          connect(greaterThreshold.y, T13.conditionPort) annotation (Line(points={{
                  -29,-60},{10,-60},{10,-22},{91,-22}}, color={255,0,255}));
          connect(iniDecide.outPort[3], T14.inPort) annotation (Line(points={{93.3333,
                  3.4},{93.3333,2},{82,2},{82,58},{88,58}}, color={0,0,0}));
          connect(T14.outPort, heatWait.inPort[3]) annotation (Line(points={{88,67},{
                  88,68},{88,68},{88,68},{88,94},{57.3333,94},{57.3333,84}}, color={0,
                  0,0}));
          connect(T14.conditionPort, lessThreshold.y) annotation (Line(points={{83,62},
                  {6,62},{6,60},{-29,60}}, color={255,0,255}));
          connect(and2.y, rest) annotation (Line(points={{98.6,38},{100,38},{100,0},{
                  110,0}}, color={255,0,255}));
          connect(ini.activePort, and2.u1) annotation (Line(points={{78.72,38},{84.8,
                  38},{84.8,38}}, color={255,0,255}));
          connect(restWait.activePort, and2.u2) annotation (Line(points={{60.72,20},{
                  78,20},{78,33.2},{84.8,33.2}}, color={255,0,255}));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)));
        end ModeSelector_baseline;

        package Pumps "Controllers of Hydraulic Pumps"

          model P1 "hydraulic pumps logic"

            Modelica.Blocks.Tables.CombiTable1D P1_HP_off(table=[-5,0.30; 0,0.1; 5,
                  0.70]) "P1 action if HP is off"
              annotation (Placement(transformation(extent={{-20,40},{0,60}})));
            DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{-80,20}}),
                  iconTransformation(extent={{-110,-10},{-90,10}})));
            SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{120,
                      20}}), iconTransformation(extent={{92,-10},{112,10}})));
            Modelica.Blocks.Math.Add add(k2=-1)
              annotation (Placement(transformation(extent={{-50,40},{-30,60}})));
            Modelica.Blocks.Logical.Switch switch1
              annotation (Placement(transformation(extent={{52,10},{72,-10}})));
            Modelica.Blocks.Logical.Switch switch2
              annotation (Placement(transformation(extent={{0,-20},{20,-40}})));
            Modelica.Blocks.Sources.Constant twoHPs(k=0.8) "two HPs working"
              annotation (Placement(transformation(extent={{-60,-60},{-40,-40}})));
            Modelica.Blocks.Sources.Constant oneHP(k=0.55) "only one HP working"
              annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
            Modelica.Blocks.Math.RealToBoolean HPAreOn(threshold=1.5) "Both HP are on"
              annotation (Placement(transformation(extent={{40,-70},{20,-50}})));
            Modelica.Blocks.Math.RealToBoolean HPIsOn(threshold=0.5)
              "At least one HP is on"
              annotation (Placement(transformation(extent={{12,-10},{32,10}})));
            Modelica.Blocks.Nonlinear.Limiter limiter(uMax=1, uMin=0)
              annotation (Placement(transformation(extent={{10,40},{30,60}})));
            Modelica.Blocks.MathBoolean.Or  Off(nu=3) "multiple off conditions"
              annotation (Placement(transformation(extent={{44,54},{56,66}})));
            Modelica.Blocks.Logical.Not not1
              annotation (Placement(transformation(extent={{68,54},{80,66}})));
            Modelica.Blocks.Logical.Switch isOffCheck "P01 is off"
              annotation (Placement(transformation(extent={{72,22},{90,40}})));
            Modelica.Blocks.Sources.Constant off(k=0) "HPs are off"
              annotation (Placement(transformation(extent={{52,34},{60,42}})));
            Modelica.Blocks.Math.IntegerToReal realToInteger[2]
              annotation (Placement(transformation(extent={{94,-70},{74,-50}})));
            Modelica.Blocks.Math.Add add1
              annotation (Placement(transformation(extent={{64,-68},{48,-52}})));
            Modelica.Blocks.Math.IntegerToBoolean P04signal "Check if P04 is on"
              annotation (Placement(transformation(extent={{78,76},{68,86}})));
            Modelica.Blocks.Math.RealToBoolean    P05signal(threshold=0.01)
                                                            "Check if P06 is on"
              annotation (Placement(transformation(extent={{78,88},{68,98}})));
          equation
            connect(dataBus.T1, add.u1) annotation (Line(
                points={{-99.9,0.1},{-99.9,56},{-52,56}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T7, add.u2) annotation (Line(
                points={{-99.9,0.1},{-99.9,44},{-52,44}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(add.y, P1_HP_off.u[1])
              annotation (Line(points={{-29,50},{-22,50}}, color={0,0,127}));
            connect(oneHP.y, switch2.u3) annotation (Line(points={{-39,-10},{-12,-10},{-12,
                    -22},{-2,-22}}, color={0,0,127}));
            connect(twoHPs.y, switch2.u1) annotation (Line(points={{-39,-50},{-12,-50},{-12,
                    -38},{-2,-38}}, color={0,0,127}));
            connect(switch2.y, switch1.u1) annotation (Line(points={{21,-30},{30,-30},
                    {40,-30},{40,-8},{50,-8}},
                                           color={0,0,127}));
            connect(HPAreOn.y, switch2.u2) annotation (Line(points={{19,-60},{-20,-60},{-20,
                    -30},{-2,-30}}, color={255,0,255}));
            connect(HPIsOn.y, switch1.u2)
              annotation (Line(points={{33,0},{50,0}}, color={255,0,255}));
            connect(P1_HP_off.y[1], limiter.u)
              annotation (Line(points={{1,50},{8,50}}, color={0,0,127}));
            connect(limiter.y, switch1.u3)
              annotation (Line(points={{31,50},{40,50},{40,8},{50,8}}, color={0,0,127}));
            connect(Off.y, not1.u)
              annotation (Line(points={{56.9,60},{66.8,60}}, color={255,0,255}));

            connect(not1.y, isOffCheck.u2) annotation (Line(points={{80.6,60},{86,60},{86,
                    46},{50,46},{50,31},{70.2,31}}, color={255,0,255}));
            connect(off.y, isOffCheck.u1) annotation (Line(points={{60.4,38},{65.25,38},{65.25,
                    38.2},{70.2,38.2}}, color={0,0,127}));
            connect(switch1.y, isOffCheck.u3) annotation (Line(points={{73,0},{80,0},{80,16},
                    {60,16},{60,23.8},{70.2,23.8}}, color={0,0,127}));
            connect(isOffCheck.y, signalBus.P0102_mod) annotation (Line(points={{90.9,31},
                    {100,31},{100,0}}, color={0,0,127}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}},
                horizontalAlignment=TextAlignment.Left));
            connect(realToInteger[1].u, signalBus.HP1_signal) annotation (Line(points={{96,
                    -60},{100,-60},{100,0}}, color={255,127,0}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}},
                horizontalAlignment=TextAlignment.Left));
            connect(realToInteger[2].u, signalBus.HP2_signal) annotation (Line(points={{96,
                    -60},{100,-60},{100,0}}, color={255,127,0}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}},
                horizontalAlignment=TextAlignment.Left));
            connect(HPAreOn.u, add1.y)
              annotation (Line(points={{42,-60},{47.2,-60}}, color={0,0,127}));
            connect(realToInteger[1].y, add1.u1) annotation (Line(points={{73,-60},{70,-60},
                    {70,-55.2},{65.6,-55.2}}, color={0,0,127}));
            connect(realToInteger[2].y, add1.u2) annotation (Line(points={{73,-60},{70,-60},
                    {70,-64.8},{65.6,-64.8}}, color={0,0,127}));
            connect(add1.y,HPIsOn. u) annotation (Line(points={{47.2,-60},{46,-60},{46,-16},
                    {0,-16},{0,0},{10,0}}, color={0,0,127}));
            connect(HPIsOn.y, Off.u[1]) annotation (Line(points={{33,0},{38,0},{38,
                    62.8},{44,62.8}}, color={255,0,255}));
            connect(P04signal.u, signalBus.P04_signal) annotation (Line(points={{79,
                    81},{100,81},{100,0}}, color={255,127,0}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}},
                horizontalAlignment=TextAlignment.Left));
            connect(P04signal.y, Off.u[2]) annotation (Line(points={{67.5,81},{44,81},
                    {44,60}}, color={255,0,255}));
            connect(P05signal.y, Off.u[3]) annotation (Line(points={{67.5,93},{44,93},
                    {44,57.2}}, color={255,0,255}));
            connect(P05signal.u, signalBus.P05_mod) annotation (Line(points={{79,93},
                    {100,93},{100,0}}, color={0,0,127}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}},
                horizontalAlignment=TextAlignment.Left));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                    Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={28,108,200}),                                       Text(
                    extent={{-62,76},{78,-64}},
                    lineColor={28,108,200},
                    textString="P1")}),    Diagram(coordinateSystem(preserveAspectRatio=false)));
          end P1;

          model P3 "hydraulic pumps logic"

            Modelica.Blocks.Tables.CombiTable1D P3_HP_off(table=[-5,3*9806.38; 5,10*9806.38])
              "P3 action if HPs are off"
              annotation (Placement(transformation(extent={{-22,-10},{-2,10}})));
            DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{-80,20}}),
                  iconTransformation(extent={{-110,-10},{-90,10}})));
            SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{120,
                      20}}), iconTransformation(extent={{92,-10},{112,10}})));
            Modelica.Blocks.Math.Feedback delta "delta T19-T14"
              annotation (Placement(transformation(extent={{-50,-10},{-30,10}})));
            Modelica.Blocks.Logical.Switch HPSwitch
              annotation (Placement(transformation(extent={{40,20},{60,40}})));
            Modelica.Blocks.Sources.Constant setPoiIfHPisOn(k=12*9806.38)
              "only one HP working"
              annotation (Placement(transformation(extent={{-20,36},{0,56}})));
            Modelica.Blocks.Math.IntegerToBoolean hpIsOn
              annotation (Placement(transformation(extent={{-50,20},{-30,40}})));
            Modelica.Blocks.Nonlinear.Limiter limiter(uMin=0, uMax=12*9806.38)
              annotation (Placement(transformation(extent={{12,-10},{32,10}})));
          equation


            connect(delta.y, P3_HP_off.u[1])
              annotation (Line(points={{-31,0},{-24,0}}, color={0,0,127}));
            connect(dataBus.T19, delta.u1) annotation (Line(
                points={{-99.9,0.1},{-72,0.1},{-72,0},{-48,0}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}},
                horizontalAlignment=TextAlignment.Right));
            connect(dataBus.T14, delta.u2) annotation (Line(
                points={{-99.9,0.1},{-99.9,-20},{-40,-20},{-40,-8}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-3,-6},{-3,-6}},
                horizontalAlignment=TextAlignment.Right));
            connect(HPSwitch.y, signalBus.P03_mod) annotation (Line(points={{61,30},{
                    80,30},{80,0},{100,0}}, color={0,0,127}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}},
                horizontalAlignment=TextAlignment.Left));
            connect(setPoiIfHPisOn.y, HPSwitch.u1) annotation (Line(points={{1,46},{
                    14,46},{14,38},{38,38}}, color={0,0,127}));
            connect(hpIsOn.y, HPSwitch.u2)
              annotation (Line(points={{-29,30},{38,30}}, color={255,0,255}));
            connect(signalBus.HP1_signal, hpIsOn.u) annotation (Line(
                points={{100,0},{100,80},{-60,80},{-60,30},{-52,30}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}},
                horizontalAlignment=TextAlignment.Right));
            connect(limiter.u, P3_HP_off.y[1])
              annotation (Line(points={{10,0},{-1,0}}, color={0,0,127}));
            connect(limiter.y, HPSwitch.u3) annotation (Line(points={{33,0},{34,0},{
                    34,22},{38,22}}, color={0,0,127}));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                    Rectangle(
                    extent={{-100,100},{100,-100}},
                    lineColor={28,108,200},
                    fillColor={255,255,255},
                    fillPattern=FillPattern.Solid),                                Text(
                    extent={{-62,76},{78,-64}},
                    lineColor={28,108,200},
                    textString="P3")}),    Diagram(coordinateSystem(preserveAspectRatio=false)));
          end P3;

          package RBCBaseline

            model P5_baseline "hydraulic pumps logic p05"

              DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{-80,20}}),
                    iconTransformation(extent={{-110,-10},{-90,10}})));
              SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{120,
                        20}}), iconTransformation(extent={{92,-10},{112,10}})));
              outer IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                    0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                    IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                    IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
                annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
              IDEAS.Controls.ControlHeating.RunningMeanTemperatureEN15251 rmot
                annotation (Placement(transformation(extent={{-100,40},{-80,60}})));
              Modelica.Blocks.Tables.CombiTable1D cooCurve_TABS(table=[273.15 + 18,
                    273.15 + 22.5; 273.15 + 23,273.15 + 21; 273.15 + 30,273.15 + 19.5])
                "Infrax TABS cooling curve"
                annotation (Placement(transformation(extent={{-70,40},{-50,60}})));
              Modelica.Blocks.Nonlinear.Limiter limiter(uMax=273.15 + 23, uMin=273.15 + 19)
                annotation (Placement(transformation(extent={{-42,40},{-22,60}})));
              IDEAS.Controls.Continuous.LimPID conP05(
                initType=Modelica.Blocks.Types.InitPID.InitialState,
                controllerType=Modelica.Blocks.Types.SimpleController.PI,
                Td=0,
                reverseAction=true,
                k=10,
                Ti(displayUnit="s") = 45) "Controller for TABS pump"
                annotation (Placement(transformation(extent={{60,40},{80,60}})));
              Modelica.Blocks.Logical.GreaterThreshold greaterThreshold
                annotation (Placement(transformation(extent={{-40,-40},{-20,-20}})));
              Modelica.Blocks.Math.BooleanToReal compensationFactor(realTrue=1.5, realFalse=
                   0.5) "compensation factor computation"
                annotation (Placement(transformation(extent={{-8,-40},{12,-20}})));
              Modelica.Blocks.Math.Product product
                annotation (Placement(transformation(extent={{24,-40},{44,-20}})));
              Modelica.Blocks.Math.Feedback feedback annotation (Placement(transformation(
                    extent={{-10,-10},{10,10}},
                    rotation=-90,
                    origin={-60,-20})));
              Modelica.Blocks.Math.Add add
                annotation (Placement(transformation(extent={{-4,34},{16,54}})));
              Modelica.Blocks.Math.Max dewProt "dew protection"
                annotation (Placement(transformation(extent={{26,40},{46,60}})));
              Modelica.Blocks.Sources.RealExpression DewPoiThre(y=sim.TDewPoi + 3)
                "dew point temperature threshold"
                annotation (Placement(transformation(extent={{-4,60},{16,80}})));
              Modelica.Blocks.Math.Product product1
                annotation (Placement(transformation(extent={{60,70},{80,90}})));
              Modelica.Blocks.Math.BooleanToReal cooModReal(realTrue=1, realFalse=0)
                "compensation factor computation"
                annotation (Placement(transformation(extent={{28,78},{44,94}})));
            equation

              connect(rmot.TRm, cooCurve_TABS.u[1])
                annotation (Line(points={{-79.4,50},{-72,50}}, color={0,0,127}));
              connect(dataBus.T17, conP05.u_m) annotation (Line(
                  points={{-99.9,0.1},{-99.9,20},{70,20},{70,38}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-3,-6},{-3,-6}},
                  horizontalAlignment=TextAlignment.Right));
              connect(compensationFactor.u, greaterThreshold.y)
                annotation (Line(points={{-10,-30},{-19,-30}}, color={255,0,255}));
              connect(compensationFactor.y, product.u1) annotation (Line(points={{13,-30},{16,
                      -30},{16,-24},{22,-24}}, color={0,0,127}));
              connect(signalBus.baseSetpoint, feedback.u1) annotation (Line(
                  points={{100,0},{-60,0},{-60,-12}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-3,6},{-3,6}},
                  horizontalAlignment=TextAlignment.Right));
              connect(dataBus.Tavg_building, feedback.u2) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-20},{-68,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}},
                  horizontalAlignment=TextAlignment.Right));
              connect(feedback.y, greaterThreshold.u)
                annotation (Line(points={{-60,-29},{-60,-30},{-42,-30}}, color={0,0,127}));
              connect(feedback.y, product.u2) annotation (Line(points={{-60,-29},{-60,-50},{
                      16,-50},{16,-36},{22,-36}}, color={0,0,127}));
              connect(add.u1, limiter.y)
                annotation (Line(points={{-6,50},{-21,50}}, color={0,0,127}));
              connect(cooCurve_TABS.y[1], limiter.u)
                annotation (Line(points={{-49,50},{-44,50}}, color={0,0,127}));
              connect(product.y, add.u2) annotation (Line(points={{45,-30},{56,-30},{56,-6},
                      {-14,-6},{-14,38},{-6,38}}, color={0,0,127}));
              connect(add.y, dewProt.u2)
                annotation (Line(points={{17,44},{24,44}}, color={0,0,127}));
              connect(dewProt.y, conP05.u_s)
                annotation (Line(points={{47,50},{58,50}}, color={0,0,127}));
              connect(DewPoiThre.y, dewProt.u1) annotation (Line(points={{17,70},{20,70},{20,
                      56},{24,56}}, color={0,0,127}));
              connect(conP05.y, product1.u2) annotation (Line(points={{81,50},{86,50},
                      {86,66},{44,66},{44,74},{58,74}}, color={0,0,127}));
              connect(product1.y, signalBus.P05_mod) annotation (Line(points={{81,80},
                      {100,80},{100,0}}, color={0,0,127}), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}},
                  horizontalAlignment=TextAlignment.Left));
              connect(cooModReal.y, product1.u1)
                annotation (Line(points={{44.8,86},{58,86}}, color={0,0,127}));
              connect(signalBus.coolMode, cooModReal.u) annotation (Line(
                  points={{100,0},{100,100},{8,100},{8,86},{26.4,86}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}},
                  horizontalAlignment=TextAlignment.Right));
              annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                      Rectangle(
                      extent={{-100,100},{100,-100}},
                      lineColor={28,108,200}),                                       Text(
                      extent={{-62,76},{78,-64}},
                      lineColor={28,108,200},
                      textString="P5")}),    Diagram(coordinateSystem(preserveAspectRatio=false)));
            end P5_baseline;
          end RBCBaseline;
        end Pumps;

        package Valves

          model Tavg_of_floors
            Tavg3Flr avg3rdT "Average temperature of third floor"
              annotation (Placement(transformation(extent={{-10,50},{10,70}})));
            Tavg2ndFlr avg2ndT "Average temperature of second floor"
              annotation (Placement(transformation(extent={{-10,10},{10,30}})));
            Tavg1stFlr avg1stT "Average temperature of first floor"
              annotation (Placement(transformation(extent={{-10,-30},{10,-10}})));
            TavgGndFlr avgGndT "Average temperature of ground floor"
              annotation (Placement(transformation(extent={{-10,-70},{10,-50}})));
            DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                      -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
            IDEAS.Utilities.Math.Average ave(nin=4) "Building average temperature"
              annotation (Placement(transformation(extent={{40,-10},{60,10}})));
          equation
            connect(dataBus,avg3rdT. dataBus) annotation (Line(
                points={{-100,0},{-56,0},{-56,60},{-10,60}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus, avg2ndT.dataBus) annotation (Line(
                points={{-100,0},{-56,0},{-56,20},{-10,20}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus,avg1stT. dataBus) annotation (Line(
                points={{-100,0},{-56,0},{-56,-20},{-10,-20}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus,avgGndT. dataBus) annotation (Line(
                points={{-100,0},{-56,0},{-56,-60},{-10,-60}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(avg3rdT.y, ave.u[4]) annotation (Line(points={{11,60},{26,60},{26,
                    1.5},{38,1.5}}, color={0,0,127}));
            connect(avg2ndT.y, ave.u[3]) annotation (Line(points={{11,20},{24,20},{24,
                    0.5},{38,0.5}}, color={0,0,127}));
            connect(avg1stT.y, ave.u[2]) annotation (Line(points={{11,-20},{24,-20},{
                    24,-0.5},{38,-0.5}}, color={0,0,127}));
            connect(avgGndT.y, ave.u[1]) annotation (Line(points={{11,-60},{24,-60},{
                    24,-1.5},{38,-1.5}}, color={0,0,127}));
            connect(ave.y, dataBus.Tavg_building) annotation (Line(points={{61,0},{64,
                    0},{64,86},{-99.9,86},{-99.9,0.1}}, color={0,0,127}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}}));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)));
          end Tavg_of_floors;

          model Tavg3Flr "3rd floor average temp"

            DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                      -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
            inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                  0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                  IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                  IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            IDEAS.Utilities.Math.Average T3rdFlr(nin=4)
              "average temperature of 3rd floor zones"
              annotation (Placement(transformation(extent={{-86,-54},{-66,-34}})));
            Modelica.Blocks.Interfaces.RealOutput y
              annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          equation
            connect(dataBus.T3rdFlr_SZ, T3rdFlr.u[1]) annotation (Line(
                points={{-99.9,0.1},{-120,0.1},{-120,6},{-100,6},{-100,16.1},{-100,
                    -45.5},{-88,-45.5}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T3rdFlr_MTR, T3rdFlr.u[2]) annotation (Line(
                points={{-99.9,0.1},{-119.9,0.1},{-119.9,6},{-100,6},{-100,16.1},{
                    -100,-44.5},{-88,-44.5}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T3rdFlr_CPR, T3rdFlr.u[3]) annotation (Line(
                points={{-99.9,0.1},{-120,0.1},{-120,6},{-100,6},{-100,16.1},{-100,
                    -43.5},{-88,-43.5}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T3rdFlr_SmaR, T3rdFlr.u[4]) annotation (Line(
                points={{-99.9,0.1},{-119.9,0.1},{-119.9,6},{-100,6},{-100,16.1},{
                    -100,-42.5},{-88,-42.5}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(T3rdFlr.y, dataBus.Tavg_3rdFlr) annotation (Line(points={{-65,-44},
                    {-56,-44},{-56,0.1},{-99.9,0.1}}, color={0,0,127}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}}));

            connect(T3rdFlr.y, y) annotation (Line(points={{-65,-44},{18,-44},{18,0},
                    {110,0}}, color={0,0,127}));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)));
          end Tavg3Flr;

          model Tavg2ndFlr "average temperature of second floor"

            DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                      -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
            inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                  0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                  IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                  IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            IDEAS.Utilities.Math.Average T3rdFlr(nin=4)
              "average temperature of 3rd floor zones"
              annotation (Placement(transformation(extent={{-84,-48},{-64,-28}})));
            Modelica.Blocks.Interfaces.RealOutput y
              annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          equation
            connect(dataBus.T2ndFlr_NZ, T3rdFlr.u[1]) annotation (Line(
                points={{-99.9,0.1},{-99.9,-39.5},{-86,-39.5}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T2ndFlr_SZ, T3rdFlr.u[2]) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-10},{-86,-10},{-86,-38.5}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T2ndFlr_MT1, T3rdFlr.u[3]) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-12},{-86,-12},{-86,-37.5}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T2ndFlr_MT2, T3rdFlr.u[4]) annotation (Line(
                points={{-99.9,0.1},{-99.9,-36.5},{-86,-36.5}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(T3rdFlr.y, dataBus.Tavg_2ndFlr) annotation (Line(points={{-63,-38},
                    {-56,-38},{-56,4},{-99.9,4},{-99.9,0.1}}, color={0,0,127}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}}));

            connect(T3rdFlr.y, y) annotation (Line(points={{-63,-38},{20,-38},{20,0},
                    {110,0}}, color={0,0,127}));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)));
          end Tavg2ndFlr;

          model Tavg1stFlr "average tmperature of 1st floor"

            DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                      -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
            inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                  0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                  IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                  IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            IDEAS.Utilities.Math.Average T3rdFlr(nin=5)
              "average temperature of 3rd floor zones"
              annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
            Modelica.Blocks.Interfaces.RealOutput y
              annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          equation
            connect(dataBus.T1stFlr_NZ, T3rdFlr.u[1]) annotation (Line(
                points={{-99.9,0.1},{-99.9,-11.6},{-82,-11.6}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T1stFlr_SZ1, T3rdFlr.u[2]) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-12},{-82,-12},{-82,-10.8}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T1stFlr_SZ2, T3rdFlr.u[3]) annotation (Line(
                points={{-99.9,0.1},{-99.9,-10},{-82,-10}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T1stFlr_MT1, T3rdFlr.u[4]) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-12},{-82,-12},{-82,-9.2}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T1stFlr_MT2, T3rdFlr.u[5]) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-8.4},{-82,-8.4}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(T3rdFlr.y, dataBus.Tavg_1stFlr) annotation (Line(points={{-59,-10},
                    {-56,-10},{-56,0},{-56,0.1},{-99.9,0.1}}, color={0,0,127}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}}));
            connect(T3rdFlr.y, y) annotation (Line(points={{-59,-10},{22,-10},{22,0},
                    {110,0}}, color={0,0,127}));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)));
          end Tavg1stFlr;

          model TavgGndFlr "average temperature of second floor"

            DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                      -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
            inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                  0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                  IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                  IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            IDEAS.Utilities.Math.Average T3rdFlr(nin=6)
              "average temperature of 3rd floor zones"
              annotation (Placement(transformation(extent={{-80,-20},{-60,0}})));
            Modelica.Blocks.Interfaces.RealOutput y
              annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          equation
            connect(dataBus.TGndFlr_SVR, T3rdFlr.u[1]) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-12},{-82,-12},{-82,-11.6667}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));

            connect(dataBus.TGndFlr_1stAid, T3rdFlr.u[2]) annotation (Line(
                points={{-99.9,0.1},{-98,0.1},{-98,-12},{-82,-12},{-82,-11}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.TGndFlr_KTR, T3rdFlr.u[3]) annotation (Line(
                points={{-99.9,0.1},{-99.9,-10.3333},{-82,-10.3333}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.TGndFlr_MT1, T3rdFlr.u[4]) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-9.66667},{-82,-9.66667}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.TGndFlr_MT2, T3rdFlr.u[5]) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-9},{-82,-9}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.TGndFlr_hall, T3rdFlr.u[6]) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-12},{-82,-12},{-82,-8.33333}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));

            connect(T3rdFlr.y, dataBus.Tavg_GndFlr) annotation (Line(points={{-59,-10},
                    {-56,-10},{-56,6},{-99.9,6},{-99.9,0.1}}, color={0,0,127}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}}));

            connect(T3rdFlr.y, y) annotation (Line(points={{-59,-10},{22,-10},{22,0},
                    {110,0}}, color={0,0,127}));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)));
          end TavgGndFlr;

          package BaseClasses

            model TwoWayValveCCAbaseline
              "controller of the two way valve in the ground floor of TABS"
              import INFRAX;

              DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},
                        {-80,20}}),iconTransformation(extent={{-110,-10},{-90,10}})));
              SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                        120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
              inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                    0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                    IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                    IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
                annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
              IDEAS.Utilities.Math.Average FloorAvg
                "Average temperature of the floor zones"
                annotation (Placement(transformation(extent={{-90,-30},{-70,-10}})));
              Modelica.Blocks.Tables.CombiTable1D floorSetPoint(table=[1,3; 2,2; 3,1])
                "TABS temperature difference setpoint (per floor)"
                annotation (Placement(transformation(extent={{-4,-18},{16,2}})));
              IDEAS.Controls.Continuous.LimPID valvePID(
                controllerType=Modelica.Blocks.Types.SimpleController.PI,
                k=1,
                Ti(displayUnit="min") = 1800,
                y_start=1,
                reverseAction=true,
                yMin=0.05)
                annotation (Placement(transformation(extent={{24,-18},{44,2}})));
              Modelica.Blocks.Math.Add deltaTABS(k2=-1)
                "TABS temperature difference (per floor)"
                annotation (Placement(transformation(extent={{-40,-80},{-20,-60}})));
              Modelica.Blocks.Logical.Switch neutralCheck
                annotation (Placement(transformation(extent={{60,-10},{80,10}})));
              Modelica.Blocks.Sources.Constant neutralOpen(k=0.2)
                "Valve opening in neutral mode or absence of demand"
                annotation (Placement(transformation(extent={{20,12},{40,32}})));
              Modelica.Blocks.Math.Add deltaSetPoint(k2=-1)
                "Base setpoint and floor average temperature difference"
                annotation (Placement(transformation(extent={{-60,-18},{-40,2}})));
              Modelica.Blocks.Math.Abs abs "Absolute value of deltaTABS"
                annotation (Placement(transformation(extent={{0,-80},{20,-60}})));
              Modelica.Blocks.Math.Abs abs1
                                           "Absolute value of deltaTABS"
                annotation (Placement(transformation(extent={{-32,-18},{-12,2}})));
            equation
              connect(floorSetPoint.y[1], valvePID.u_s)
                annotation (Line(points={{17,-8},{22,-8}},
                                                         color={0,0,127}));
              connect(dataBus.T24, deltaTABS.u1) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-64},{-42,-64}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));

              connect(FloorAvg.y, deltaSetPoint.u2) annotation (Line(points={{-69,-20},
                      {-68,-20},{-68,-14},{-62,-14}}, color={0,0,127}));
              connect(deltaTABS.y, abs.u)
                annotation (Line(points={{-19,-70},{-2,-70}}, color={0,0,127}));
              connect(abs.y, valvePID.u_m) annotation (Line(points={{21,-70},{34,-70},
                      {34,-20}}, color={0,0,127}));
              connect(valvePID.y, neutralCheck.u3) annotation (Line(points={{45,-8},{
                      58,-8}},                                   color={0,0,127}));
              connect(neutralOpen.y, neutralCheck.u1) annotation (Line(points={{41,22},
                      {42,22},{42,8},{58,8}}, color={0,0,127}));
              connect(signalBus.restMode, neutralCheck.u2) annotation (Line(
                  points={{100,0},{100,-20},{50,-20},{50,0},{58,0}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}},
                  horizontalAlignment=TextAlignment.Right));
              connect(signalBus.baseSetpoint, deltaSetPoint.u1) annotation (Line(
                  points={{100,0},{100,40},{-70,40},{-70,-2},{-62,-2}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}},
                  horizontalAlignment=TextAlignment.Right));
              connect(deltaSetPoint.y, abs1.u)
                annotation (Line(points={{-39,-8},{-34,-8}}, color={0,0,127}));
              connect(abs1.y, floorSetPoint.u[1])
                annotation (Line(points={{-11,-8},{-6,-8}}, color={0,0,127}));
              annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                    coordinateSystem(preserveAspectRatio=false)));
            end TwoWayValveCCAbaseline;
          end BaseClasses;

          package RBCBaseline

            model TwoWayValveCCA0
              extends BaseClasses.TwoWayValveCCAbaseline(FloorAvg(nin=6));
            equation
              connect(neutralCheck.y, signalBus.CCA0_val) annotation (Line(points={{81,0},{
                      86,0},{86,0},{100,0}},
                                          color={0,0,127}), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}},
                  horizontalAlignment=TextAlignment.Left));
              connect(dataBus.TretCCA0, deltaTABS.u2) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-76},{-42,-76},{-42,-76}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-3,6},{-3,6}},
                  horizontalAlignment=TextAlignment.Right));

              connect(dataBus.TGndFlr_SVR, FloorAvg.u[1]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-22},{-92,-22},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));

              connect(dataBus.TGndFlr_1stAid, FloorAvg.u[2]) annotation (Line(
                  points={{-99.9,0.1},{-98,0.1},{-98,-26},{-92,-26},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.TGndFlr_KTR, FloorAvg.u[3]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-20},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.TGndFlr_MT1, FloorAvg.u[4]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-20},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.TGndFlr_MT2, FloorAvg.u[5]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-20},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.TGndFlr_hall, FloorAvg.u[6]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-30},{-92,-30},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));


            end TwoWayValveCCA0;

            model TwoWayValveCCA1
              extends BaseClasses.TwoWayValveCCAbaseline(FloorAvg(nin=5));
            equation

              connect(dataBus.TretCCA1, deltaTABS.u2) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-76},{-42,-76}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}},
                  horizontalAlignment=TextAlignment.Right));
              connect(neutralCheck.y, signalBus.CCA1_val) annotation (Line(points={{71,0},{100,
                      0}}, color={0,0,127}), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}},
                  horizontalAlignment=TextAlignment.Left));
              connect(dataBus.T1stFlr_NZ, FloorAvg.u[1]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-20},{-82,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.T1stFlr_SZ1, FloorAvg.u[2]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-22},{-82,-22},{-82,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.T1stFlr_SZ2, FloorAvg.u[3]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-20},{-82,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.T1stFlr_MT1, FloorAvg.u[4]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-22},{-82,-22},{-82,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.T1stFlr_MT2, FloorAvg.u[5]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-20},{-82,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
            end TwoWayValveCCA1;

            model TwoWayValveCCA2
              extends BaseClasses.TwoWayValveCCAbaseline(FloorAvg(nin=4));
            equation

              connect(neutralCheck.y, signalBus.CCA2_val) annotation (Line(points={{81,0},{
                      100,0}},
                           color={0,0,127}), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}},
                  horizontalAlignment=TextAlignment.Left));
              connect(dataBus.TretCCA2, deltaTABS.u2) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-76},{-42,-76}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-3,-6},{-3,-6}},
                  horizontalAlignment=TextAlignment.Right));
              connect(dataBus.T2ndFlr_NZ, FloorAvg.u[1]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-20},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.T2ndFlr_SZ, FloorAvg.u[2]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-20},{-92,-20},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.T2ndFlr_MT1, FloorAvg.u[3]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-22},{-92,-22},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.T2ndFlr_MT2, FloorAvg.u[4]) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-20},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
            end TwoWayValveCCA2;

            model TwoWayValveCCA3
              extends BaseClasses.TwoWayValveCCAbaseline(FloorAvg(nin=4));
            equation

              connect(neutralCheck.y, signalBus.CCA3_val) annotation (Line(points={{81,0},{
                      100,0}},
                           color={0,0,127}), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}},
                  horizontalAlignment=TextAlignment.Left));
              connect(dataBus.TretCCA3, deltaTABS.u2) annotation (Line(
                  points={{-99.9,0.1},{-99.9,-76},{-42,-76}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}},
                  horizontalAlignment=TextAlignment.Right));
              connect(dataBus.T3rdFlr_SZ, FloorAvg.u[1]) annotation (Line(
                  points={{-99.9,0.1},{-100,0.1},{-100,-20},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.T3rdFlr_MTR, FloorAvg.u[2]) annotation (Line(
                  points={{-99.9,0.1},{-100,0.1},{-100,-20},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.T3rdFlr_CPR, FloorAvg.u[3]) annotation (Line(
                  points={{-99.9,0.1},{-100,0.1},{-100,-20},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus.T3rdFlr_SmaR, FloorAvg.u[4]) annotation (Line(
                  points={{-99.9,0.1},{-100,0.1},{-100,-20},{-92,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
            end TwoWayValveCCA3;

            model TwoWayValvesTABS
              TwoWayValveCCA3 twoWayCCA3Con "Control logic of 2way valve in floor 3"
                annotation (Placement(transformation(extent={{-10,50},{10,70}})));
              TwoWayValveCCA2 twoWayCCA2Con "Control logic of 2way valve in floor 3"
                annotation (Placement(transformation(extent={{-10,10},{10,30}})));
              TwoWayValveCCA1 twoWayCCA1Con "Control logic of 2way valve in floor 1"
                annotation (Placement(transformation(extent={{-10,-30},{10,-10}})));
              TwoWayValveCCA0 twoWayCCA0Con "Control logic of 2way valve in floor 0"
                annotation (Placement(transformation(extent={{-10,-70},{10,-50}})));
              DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                        -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
              SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                        120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
            equation
              connect(dataBus, twoWayCCA3Con.dataBus) annotation (Line(
                  points={{-100,0},{-56,0},{-56,60},{-10,60}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus, twoWayCCA2Con.dataBus) annotation (Line(
                  points={{-100,0},{-56,0},{-56,20},{-10,20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus, twoWayCCA1Con.dataBus) annotation (Line(
                  points={{-100,0},{-56,0},{-56,-20},{-10,-20}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(dataBus, twoWayCCA0Con.dataBus) annotation (Line(
                  points={{-100,0},{-56,0},{-56,-60},{-10,-60}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(twoWayCCA3Con.signalBus, signalBus) annotation (Line(
                  points={{10.2,60},{52,60},{52,0},{100,0}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}}));
              connect(twoWayCCA2Con.signalBus, signalBus) annotation (Line(
                  points={{10.2,20},{52,20},{52,0},{100,0}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}}));
              connect(twoWayCCA1Con.signalBus, signalBus) annotation (Line(
                  points={{10.2,-20},{52,-20},{52,0},{100,0}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}}));
              connect(twoWayCCA0Con.signalBus, signalBus) annotation (Line(
                  points={{10.2,-60},{52,-60},{52,0},{100,0}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}}));
              annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                      Rectangle(extent={{-100,100},{100,-100}}, lineColor={28,108,200}),
                                                                                     Text(
                      extent={{-70,80},{70,-60}},
                      lineColor={28,108,200},
                      textString="2-way valves")}),                          Diagram(
                    coordinateSystem(preserveAspectRatio=false)));
            end TwoWayValvesTABS;

            model ThreeWayValveTABS_baseline
              "controller of the mixing 3-way valve of TABS"
              DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                        -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
              SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                        120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
              inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                    0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                    IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                    IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
                annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
              IDEAS.Controls.Continuous.LimPID     con3WayHea(
                controllerType=Modelica.Blocks.Types.SimpleController.PI,
                Td=0,
                k=5,
                Ti(displayUnit="min") = 60,
                y_start=1)                  "Controller for 3-way valve"
                annotation (Placement(transformation(extent={{0,40},{20,60}})));
              Modelica.Blocks.Tables.CombiTable1D heaCurve_TABS(table=[273.15 - 10,
                    273.15 + 27; 273.15,273.15 + 24.5; 273.15 + 15,273.15 + 22.5])
                "Infrax TABS heating curve"
                annotation (Placement(transformation(extent={{-70,40},{-50,60}})));
              Modelica.Blocks.Sources.Constant cooMode(k=1)
                "In cooling mode, valve is opened"
                annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
              Modelica.Blocks.Logical.Switch heaCheck "Checking if heating mode"
                annotation (Placement(transformation(extent={{-10,-12},{10,8}})));
              Modelica.Blocks.Logical.Switch neutralCheck
                annotation (Placement(transformation(extent={{52,16},{72,-4}})));
              Modelica.Blocks.Sources.Constant restMode(k=0)
                "In neutral mode valve is closed"
                annotation (Placement(transformation(extent={{0,-60},{20,-40}})));
              IDEAS.Controls.ControlHeating.RunningMeanTemperatureEN15251 rmot
                annotation (Placement(transformation(extent={{-100,40},{-80,60}})));
              Modelica.Blocks.Nonlinear.Limiter limiter(uMax=273.15 + 30, uMin=273.15
                     + 23)
                annotation (Placement(transformation(extent={{-36,40},{-16,60}})));
            equation

              connect(signalBus.heatMode, heaCheck.u2) annotation (Line(
                  points={{100,0},{100,20},{-24,20},{-24,-2},{-12,-2}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));

              connect(neutralCheck.y, signalBus.TABS_3way_signal) annotation (Line(
                    points={{73,6},{100,6},{100,0}}, color={0,0,127}), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}}));
              connect(signalBus.restMode, neutralCheck.u2) annotation (Line(
                  points={{100,0},{100,20},{20,20},{20,6},{50,6}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-6,3},{-6,3}}));
              connect(heaCheck.y, neutralCheck.u3) annotation (Line(points={{11,-2},{
                      30,-2},{30,14},{50,14}}, color={0,0,127}));
              connect(restMode.y, neutralCheck.u1) annotation (Line(points={{21,-50},
                      {40,-50},{40,-2},{50,-2}}, color={0,0,127}));
              connect(cooMode.y, heaCheck.u3)
                annotation (Line(points={{-39,-10},{-12,-10}}, color={0,0,127}));
              connect(rmot.TRm, heaCurve_TABS.u[1])
                annotation (Line(points={{-79.4,50},{-72,50}}, color={0,0,127}));
              connect(dataBus.T24, con3WayHea.u_m) annotation (Line(
                  points={{-99.9,0.1},{-99.9,26},{10,26},{10,38}},
                  color={255,204,51},
                  thickness=0.5), Text(
                  string="%first",
                  index=-1,
                  extent={{-3,-6},{-3,-6}},
                  horizontalAlignment=TextAlignment.Right));
              connect(con3WayHea.y, heaCheck.u1) annotation (Line(points={{21,50},{50,
                      50},{50,24},{-18,24},{-18,6},{-12,6}}, color={0,0,127}));
              connect(limiter.u, heaCurve_TABS.y[1])
                annotation (Line(points={{-38,50},{-49,50}}, color={0,0,127}));
              connect(limiter.y, con3WayHea.u_s)
                annotation (Line(points={{-15,50},{-2,50}}, color={0,0,127}));
              connect(limiter.y, signalBus.T_TABS) annotation (Line(points={{-15,50},
                      {-8,50},{-8,82},{100,82},{100,0}}, color={0,0,127}), Text(
                  string="%second",
                  index=1,
                  extent={{6,3},{6,3}},
                  horizontalAlignment=TextAlignment.Left));
              annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                    coordinateSystem(preserveAspectRatio=false)));
            end ThreeWayValveTABS_baseline;
          end RBCBaseline;
        end Valves;

        package Situations

          model Situations
            DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                      -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
            SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                      120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
            SituationSelector sitSel
              "Control logic that decides how the cooling tower is working depending on the situation"
              annotation (Placement(transformation(extent={{-62,-10},{-42,10}})));
            SituationActions comCon
              "signals to the different components of the cooling tower system"
              annotation (Placement(transformation(extent={{0,-10},{20,10}})));
            CoolingTower cooTowCon
              annotation (Placement(transformation(extent={{0,-50},{20,-30}})));
          equation
            connect(sitSel.sit1, comCon.sit1) annotation (Line(points={{-41,2},{-41,4},
                    {-20,4},{0,4}}, color={255,0,255}));
            connect(sitSel.sit2, comCon.sit2) annotation (Line(points={{-41,-2},{-20,
                    -2},{-20,0},{0,0}}, color={255,0,255}));
            connect(sitSel.sit3, comCon.sit3) annotation (Line(points={{-41,-6},{-41,
                    -4},{0,-4}}, color={255,0,255}));
            connect(dataBus, sitSel.dataBus) annotation (Line(
                points={{-100,0},{-80,0},{-62,0}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(sitSel.signalBus, signalBus) annotation (Line(
                points={{-41.8,0},{-24,0},{-24,36},{100,36},{100,0}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}}));
            connect(sitSel.sit3, cooTowCon.sit3) annotation (Line(points={{-41,-6},{-18,
                    -6},{-18,-12},{15,-12},{15,-30}}, color={255,0,255}));
            connect(sitSel.sit2, cooTowCon.sit2) annotation (Line(points={{-41,-2},{-22,
                    -2},{-22,-16},{11,-16},{11,-30}}, color={255,0,255}));
            connect(cooTowCon.sit1, comCon.sit1) annotation (Line(points={{7.2,-30},{
                    8,-30},{8,-20},{-26,-20},{-26,4},{0,4}}, color={255,0,255}));
            connect(dataBus, cooTowCon.dataBus) annotation (Line(
                points={{-100,0},{-100,0},{-100,-40},{0,-40}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(cooTowCon.signalBus, signalBus) annotation (Line(
                points={{20.2,-40},{60,-40},{100,-40},{100,0}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}}));
            connect(comCon.p10, signalBus.P10_signal) annotation (Line(points={{21,6},
                    {56,6},{98,6},{98,4},{98,0},{100,0},{100,0}}, color={255,127,0}),
                Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}}));
            connect(comCon.p11, signalBus.P11_signal) annotation (Line(points={{21,2},
                    {100,2},{100,0}}, color={255,127,0}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}}));
            connect(comCon.twv_cc, signalBus.CC_2way_signal) annotation (Line(points=
                    {{21,-2},{94,-2},{94,0},{100,0}}, color={255,0,255}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}},
                horizontalAlignment=TextAlignment.Left));
            connect(comCon.twv_hex, signalBus.Hex_2way_signal) annotation (Line(
                  points={{21,-6},{100,-6},{100,0}}, color={255,0,255}), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}},
                horizontalAlignment=TextAlignment.Left));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                    Rectangle(extent={{-100,100},{100,-100}}, lineColor={28,108,200}),
                                                                                   Text(
                    extent={{-96,86},{96,-76}},
                    lineColor={28,108,200},
                    textString="Cooling
Tower")}),                                                                 Diagram(
                  coordinateSystem(preserveAspectRatio=false)));
          end Situations;

          model SituationSelector
            DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                      -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
            Modelica.Blocks.Logical.GreaterThreshold activeCoolingSetPoint(threshold=
                  273.15 + 5)  "set point to activate active cooling"
              annotation (Placement(transformation(extent={{14,-96},{34,-76}})));
            Modelica.Blocks.Interfaces.BooleanOutput sit1
              annotation (Placement(transformation(extent={{100,10},{120,30}})));
            Modelica.Blocks.Interfaces.BooleanOutput sit2
              annotation (Placement(transformation(extent={{100,-30},{120,-10}})));
            Modelica.Blocks.Interfaces.BooleanOutput sit3
              annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
            Modelica.Blocks.Logical.Hysteresis hysteresis(
              uLow=273.15 + 38,
              uHigh=273.15 + 40,
              pre_y_start=false)
              annotation (Placement(transformation(extent={{-60,10},{-40,30}})));
            Modelica.Blocks.Logical.And and1
              annotation (Placement(transformation(extent={{-20,10},{0,30}})));
            SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                      120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
            Modelica.Blocks.Logical.LessThreshold lessThreshold(threshold=273.15 + 38)
              annotation (Placement(transformation(extent={{-60,-20},{-40,0}})));
            Modelica.Blocks.Logical.Hysteresis       activeCoolingSetPoint1(uLow=
                  273.15 + 12, uHigh=273.15 + 15)
                               "set point to activate active cooling"
              annotation (Placement(transformation(extent={{-60,-50},{-40,-30}})));
            Modelica.Blocks.Logical.And and2
              annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
            Modelica.Blocks.Logical.And and3
              annotation (Placement(transformation(extent={{20,-30},{40,-10}})));
            Modelica.Blocks.Logical.Not not1
              annotation (Placement(transformation(extent={{-20,-70},{0,-50}})));
            Modelica.Blocks.Logical.And and4
              annotation (Placement(transformation(extent={{14,-62},{34,-42}})));
            Modelica.Blocks.Logical.And and5
              annotation (Placement(transformation(extent={{44,-88},{64,-68}})));
            inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                  0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                  IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                  IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
              annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
            IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(numSolBus=5)
              annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
            Modelica.Blocks.Math.Add add(k2=-1)
              annotation (Placement(transformation(extent={{-60,-96},{-40,-76}})));
            Modelica.Blocks.Logical.And and6
              annotation (Placement(transformation(extent={{20,10},{40,30}})));
            Modelica.Blocks.Logical.And and7
              annotation (Placement(transformation(extent={{60,-30},{80,-10}})));
            Modelica.Blocks.Logical.And and8
              annotation (Placement(transformation(extent={{74,-70},{94,-50}})));
            Modelica.Blocks.Math.IntegerToBoolean integerToBoolean
              annotation (Placement(transformation(extent={{4,-6},{-8,6}})));
          equation
            connect(dataBus.T14, hysteresis.u) annotation (Line(
                points={{-99.9,0.1},{-99.9,20},{-62,20}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(hysteresis.y, and1.u1)
              annotation (Line(points={{-39,20},{-39,20},{-22,20}},
                                                           color={255,0,255}));
            connect(dataBus.T14, lessThreshold.u) annotation (Line(
                points={{-99.9,0.1},{-99.9,-10},{-62,-10}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(lessThreshold.y, and2.u1) annotation (Line(points={{-39,-10},{-32,
                    -10},{-32,-30},{-22,-30}}, color={255,0,255}));
            connect(activeCoolingSetPoint1.y, and2.u2) annotation (Line(points={{-39,
                    -40},{-30,-40},{-30,-38},{-22,-38}}, color={255,0,255}));
            connect(and2.y, and3.u2) annotation (Line(points={{1,-30},{8,-30},{8,-28},{
                    18,-28}}, color={255,0,255}));
            connect(sim.weaBus, weaBus) annotation (Line(
                points={{-81,93},{-78,93},{-78,70},{-70,70}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%second",
                index=1,
                extent={{6,3},{6,3}}));
            connect(weaBus.Te, add.u2) annotation (Line(
                points={{-69.95,70.05},{-73.95,70.05},{-73.95,-92},{-62,-92}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(add.y, activeCoolingSetPoint.u) annotation (Line(points={{-39,-86},
                    {-14,-86},{12,-86}}, color={0,0,127}));
            connect(activeCoolingSetPoint.y, and5.u2) annotation (Line(points={{35,
                    -86},{35,-86},{42,-86}}, color={255,0,255}));
            connect(not1.y, and4.u2)
              annotation (Line(points={{1,-60},{12,-60}}, color={255,0,255}));
            connect(and4.u1, and2.y) annotation (Line(points={{12,-52},{8,-52},{8,-30},
                    {1,-30}}, color={255,0,255}));
            connect(and4.y, and5.u1) annotation (Line(points={{35,-52},{38,-52},{38,
                    -62},{38,-78},{42,-78}}, color={255,0,255}));
            connect(and1.y, and6.u1)
              annotation (Line(points={{1,20},{10,20},{18,20}}, color={255,0,255}));
            connect(signalBus.coolMode, and6.u2) annotation (Line(
                points={{100,0},{56,0},{10,0},{10,12},{18,12}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(and6.y, sit1)
              annotation (Line(points={{41,20},{110,20}}, color={255,0,255}));
            connect(and7.y, sit2) annotation (Line(points={{81,-20},{110,-20},{110,
                    -20}}, color={255,0,255}));
            connect(and5.y, and8.u2) annotation (Line(points={{65,-78},{68,-78},{68,
                    -68},{72,-68}}, color={255,0,255}));
            connect(and8.y, sit3) annotation (Line(points={{95,-60},{110,-60},{110,
                    -60}}, color={255,0,255}));
            connect(signalBus.coolMode, and8.u1) annotation (Line(
                points={{100,0},{76,0},{52,0},{52,-60},{72,-60}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(and3.y, and7.u1) annotation (Line(points={{41,-20},{50,-20},{58,
                    -20}}, color={255,0,255}));
            connect(signalBus.coolMode, and7.u2) annotation (Line(
                points={{100,0},{76,0},{52,0},{52,-28},{58,-28}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T7, activeCoolingSetPoint1.u) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-42},{-99.9,-40},{-62,-40}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(dataBus.T7, add.u1) annotation (Line(
                points={{-99.9,0.1},{-99.9,0.1},{-99.9,-82},{-99.9,-80},{-62,-80}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{-6,3},{-6,3}}));
            connect(signalBus.HP1_signal, integerToBoolean.u) annotation (Line(
                points={{100,0},{5.2,0}},
                color={255,204,51},
                thickness=0.5), Text(
                string="%first",
                index=-1,
                extent={{6,3},{6,3}},
                horizontalAlignment=TextAlignment.Left));
            connect(integerToBoolean.y, and1.u2) annotation (Line(points={{-8.6,0},{
                    -26,0},{-26,12},{-22,12}}, color={255,0,255}));
            connect(integerToBoolean.y, not1.u) annotation (Line(points={{-8.6,0},{
                    -26,0},{-26,-60},{-22,-60}}, color={255,0,255}));
            connect(and3.u1, not1.u) annotation (Line(points={{18,-20},{8,-20},{8,-12},
                    {-26,-12},{-26,-60},{-22,-60}}, color={255,0,255}));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)));
          end SituationSelector;

          model SituationActions
            import INFRAX;

            Modelica.Blocks.Interfaces.IntegerOutput p10
              annotation (Placement(transformation(extent={{100,50},{120,70}})));
            Modelica.Blocks.Interfaces.IntegerOutput p11
              annotation (Placement(transformation(extent={{100,10},{120,30}})));
            Modelica.Blocks.Interfaces.BooleanOutput twv_hex
              annotation (Placement(transformation(extent={{100,-70},{120,-50}})));
                                                             //valves v7 and v8
            Modelica.Blocks.Interfaces.BooleanOutput twv_cc
              annotation (Placement(transformation(extent={{100,-30},{120,-10}})));
                                                            //valves v9 and v10
            Modelica.Blocks.Interfaces.BooleanInput sit1
              annotation (Placement(transformation(extent={{-120,20},{-80,60}})));
            Modelica.Blocks.Interfaces.BooleanInput sit2
              annotation (Placement(transformation(extent={{-120,-20},{-80,20}})));
            Modelica.Blocks.Interfaces.BooleanInput sit3
              annotation (Placement(transformation(extent={{-120,-60},{-80,-20}})));

            INFRAX.Data.Parameters.Hydronic hydronic
              annotation (Placement(transformation(extent={{-10,80},{10,100}})));
          //  Modelica.Blocks.Interfaces.RealOutput p10_real
          //    annotation (Placement(transformation(extent={{100,30},{120,50}})));
          //  Modelica.Blocks.Interfaces.RealOutput p11_real
          //    annotation (Placement(transformation(extent={{100,-10},{120,10}})));
          //  Modelica.Blocks.Interfaces.RealOutput twv_cc_real
          //    annotation (Placement(transformation(extent={{100,-50},{120,-30}})));
          //  Modelica.Blocks.Interfaces.RealOutput twv_hex_real
          //    annotation (Placement(transformation(extent={{100,-90},{120,-70}})));
          equation

            if sit1 == true then
              p10 = 1;
          //    p10_real = 1;
              p11 = 1;
          //    p11_real = 1;
              twv_cc = false;
          //    twv_cc_real = 0;
              twv_hex = true;
          //    twv_hex_real = 1;
            elseif sit2 == true then
              p10 = 0;
          //    p10_real = 0;
              p11 = 1;
          //    p11_real = 1;
              twv_cc = true;
          //    twv_cc_real = 1;
              twv_hex = false;
          //    twv_hex_real = 0;
            elseif sit3 == true then
              p10 = 0;
          //    p10_real = 0;
              p11 = 1;
           //   p11_real = 1;
              twv_cc = true;
          //    twv_cc_real = 1;
              twv_hex = false;
          //    twv_hex_real = 0;
            else //sit0
              p10 = 0;
          //    p10_real = 0;
              p11 = 0;
          //    p11_real = 0;
              twv_cc = false;
          //    twv_cc_real = 0;
              twv_hex = false;
          //    twv_hex_real = 0;
            end if;

            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                  coordinateSystem(preserveAspectRatio=false)));
          end SituationActions;
        end Situations;

        model NightVentilation "night ventilation RBC"

          DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                    -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));

          Modelica.Blocks.Sources.BooleanExpression on_off(y=if (clock.hour >= 0 and
                clock.hour < 5) or clock.hour > 22 then true else false)
            "Time zone for which the night ventilation can be activated"
            annotation (Placement(transformation(extent={{-60,66},{-40,86}})));
          Modelica.Blocks.Logical.GreaterEqualThreshold greaterEqualThreshold(
              threshold=273.15 + 10)
            annotation (Placement(transformation(extent={{-60,40},{-40,60}})));
          inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          Modelica.Blocks.Math.Add add(k2=-1)
            annotation (Placement(transformation(extent={{-60,0},{-40,20}})));
          Modelica.Blocks.Logical.Hysteresis hysteresis(uLow=1, uHigh=3)
            annotation (Placement(transformation(extent={{-30,0},{-10,20}})));
          Modelica.Blocks.MathBoolean.And nv1(nu=4)
            "First activation of night ventilation"
            annotation (Placement(transformation(extent={{0,50},{20,70}})));
          Modelica.Blocks.Logical.Hysteresis hysteresis1(uLow=273.15 + 24, uHigh=
                273.15 + 25.5)
            annotation (Placement(transformation(extent={{-30,-34},{-10,-14}})));
          Modelica.Blocks.MathBoolean.And nv2(nu=4)
            "Second activation of night ventilation"
            annotation (Placement(transformation(extent={{0,30},{20,50}})));
          Components.Step stab(
            nOut=2,
            nIn=1,
            initialStep=false,
            use_activePort=false) "stabilization period"
            annotation (Placement(transformation(extent={{56,-24},{64,-16}})));
          Components.Transition T1(                        waitTime=86400,
            use_conditionPort=true,
            delayedTransition=false,
            use_firePort=false)
            annotation (Placement(transformation(extent={{56,36},{64,44}})));
          Components.Step no_nv(
            nOut=1,
            nIn=1,
            initialStep=true,
            use_activePort=false) "night ventilation off"
            annotation (Placement(transformation(extent={{56,56},{64,64}})));
          Components.Step nv_1(
            use_activePort=true,
            nOut=1,
            nIn=1,
            initialStep=false) "night ventilation 1"
            annotation (Placement(transformation(extent={{56,16},{64,24}})));
          Components.Step nv_2(
            use_activePort=true,
            nOut=1,
            nIn=1,
            initialStep=false) "night ventilation 2"
            annotation (Placement(transformation(extent={{56,-64},{64,-56}})));
          Components.Transition T2(                        waitTime=86400,
            use_conditionPort=true,
            delayedTransition=false,
            use_firePort=false)
            annotation (Placement(transformation(extent={{56,-4},{64,4}})));
          Components.Transition T3(
            use_firePort=false,
            delayedTransition=true,
            waitTime=15*60,
            use_conditionPort=true)
            annotation (Placement(transformation(extent={{56,-44},{64,-36}})));
          Modelica.Blocks.Logical.Hysteresis hysteresis2(uLow=273.15 + 23.5, uHigh=
                273.15 + 24.5)
            annotation (Placement(transformation(extent={{-30,-60},{-10,-40}})));
          Components.Transition T4(
            use_firePort=false,
            delayedTransition=true,
            waitTime=15*60,
            use_conditionPort=true)
            annotation (Placement(transformation(extent={{76,-34},{84,-26}})));
          Modelica.Blocks.Logical.Not not1
            annotation (Placement(transformation(extent={{40,-36},{52,-24}})));
          Components.Step wait(
            use_activePort=true,
            nOut=1,
            nIn=2,
            initialStep=false) "wait till next day"
            annotation (Placement(transformation(extent={{76,-90},{84,-82}})));
          Components.Transition T5(
            use_firePort=false,
            use_conditionPort=false,
            delayedTransition=true,
            waitTime=6*3600)
            annotation (Placement(transformation(extent={{136,-80},{144,-88}})));
          Modelica.Blocks.Logical.Not not2
            annotation (Placement(transformation(extent={{38,-6},{50,6}})));
          Components.Transition T6(
            use_firePort=false,
            waitTime=15*60,
            use_conditionPort=true,
            delayedTransition=false)
            annotation (Placement(transformation(extent={{56,-80},{64,-72}})));
          Modelica.Blocks.Logical.Not not3
            annotation (Placement(transformation(extent={{38,-82},{50,-70}})));
          Modelica.Blocks.Logical.Or or1
            annotation (Placement(transformation(extent={{74,14},{86,26}})));
          Modelica.Blocks.Interfaces.BooleanOutput NightVentilation
            annotation (Placement(transformation(extent={{100,-12},{120,8}})));
          Components.Clock           clock
            annotation (Placement(transformation(extent={{80,80},{100,100}})));
          Modelica.Blocks.Sources.RealExpression Te(y=sim.Te) "External temperature"
            annotation (Placement(transformation(extent={{-94,40},{-74,60}})));
        equation

          connect(dataBus.Tavg_building, add.u1) annotation (Line(
              points={{-99.9,0.1},{-82,0.1},{-82,16},{-62,16}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(add.y, hysteresis.u) annotation (Line(points={{-39,10},{-39,10},{
                  -32,10}},  color={0,0,127}));
          connect(dataBus.Tavg_building, hysteresis1.u) annotation (Line(
              points={{-99.9,0.1},{-82,0.1},{-82,-24},{-34,-24},{-32,-24}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(no_nv.outPort[1], T1.inPort)
            annotation (Line(points={{60,55.4},{60,49.7},{60,44}}, color={0,0,0}));
          connect(nv1.y, T1.conditionPort) annotation (Line(points={{21.5,60},{40.75,
                  60},{40.75,40},{55,40}}, color={255,0,255}));
          connect(T1.outPort, nv_1.inPort[1])
            annotation (Line(points={{60,35},{60,29.5},{60,24}}, color={0,0,0}));
          connect(nv_1.outPort[1], T2.inPort)
            annotation (Line(points={{60,15.4},{60,4}}, color={0,0,0}));
          connect(T2.outPort, stab.inPort[1])
            annotation (Line(points={{60,-5},{60,-5},{60,-16}}, color={0,0,0}));
          connect(stab.outPort[1], T3.inPort)
            annotation (Line(points={{59,-24.6},{60,-30},{60,-36}}, color={0,0,0}));
          connect(dataBus.Tavg_building, hysteresis2.u) annotation (Line(
              points={{-99.9,0.1},{-92,0.1},{-82,0.1},{-82,-50},{-32,-50}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(nv2.y, T3.conditionPort) annotation (Line(points={{21.5,40},{30,40},
                  {30,-40},{55,-40}}, color={255,0,255}));
          connect(T3.outPort, nv_2.inPort[1])
            annotation (Line(points={{60,-45},{60,-50.5},{60,-56}}, color={0,0,0}));
          connect(nv2.y, not1.u) annotation (Line(points={{21.5,40},{30,40},{30,-30},
                  {38.8,-30}}, color={255,0,255}));
          connect(not1.y, T4.conditionPort)
            annotation (Line(points={{52.6,-30},{75,-30}}, color={255,0,255}));
          connect(T4.outPort, wait.inPort[1])
            annotation (Line(points={{80,-35},{80,-82},{79,-82}}, color={0,0,0}));
          connect(wait.outPort[1], T5.inPort) annotation (Line(points={{80,-90.6},{80,
                  -100},{140,-100},{140,-88}}, color={0,0,0}));
          connect(T5.outPort, no_nv.inPort[1]) annotation (Line(points={{140,-79},{
                  140,-79},{140,72},{60,72},{60,64}}, color={0,0,0}));
          connect(not2.y, T2.conditionPort)
            annotation (Line(points={{50.6,0},{55,0}}, color={255,0,255}));
          connect(nv1.y, not2.u) annotation (Line(points={{21.5,60},{34,60},{34,0},{
                  36,0},{36.8,0}},                      color={255,0,255}));
          connect(not3.y, T6.conditionPort) annotation (Line(points={{50.6,-76},{55,
                  -76},{55,-76}}, color={255,0,255}));
          connect(nv2.y, not3.u) annotation (Line(points={{21.5,40},{28,40},{28,-76},
                  {36.8,-76}}, color={255,0,255}));
          connect(T6.inPort, nv_2.outPort[1]) annotation (Line(points={{60,-72},{60,
                  -64.6},{60,-64.6}}, color={0,0,0}));
          connect(T6.outPort, wait.inPort[2]) annotation (Line(points={{60,-81},{60,
                  -81},{60,-82},{81,-82}}, color={0,0,0}));
          connect(stab.outPort[2], T4.inPort) annotation (Line(points={{61,-24.6},{70,
                  -24.6},{70,-26},{80,-26}}, color={0,0,0}));
          connect(nv_1.activePort, or1.u1)
            annotation (Line(points={{64.72,20},{72.8,20}}, color={255,0,255}));
          connect(nv_2.activePort, or1.u2) annotation (Line(points={{64.72,-60},{70,
                  -60},{70,15.2},{72.8,15.2}}, color={255,0,255}));
          connect(on_off.y, nv1.u[1]) annotation (Line(points={{-39,76},{-20,76},{-20,
                  65.25},{0,65.25}}, color={255,0,255}));
          connect(on_off.y, nv2.u[1]) annotation (Line(points={{-39,76},{-20,76},{-20,
                  45.25},{0,45.25}}, color={255,0,255}));
          connect(greaterEqualThreshold.y, nv1.u[2]) annotation (Line(points={{-39,50},
                  {-36,50},{-36,61.75},{0,61.75}}, color={255,0,255}));
          connect(greaterEqualThreshold.y, nv2.u[2]) annotation (Line(points={{-39,50},
                  {-20,50},{-20,41.75},{0,41.75}}, color={255,0,255}));
          connect(hysteresis.y, nv1.u[3]) annotation (Line(points={{-9,10},{-10,10},{
                  -10,58.25},{0,58.25}}, color={255,0,255}));
          connect(hysteresis.y, nv2.u[3])
            annotation (Line(points={{-9,10},{0,10},{0,38.25}}, color={255,0,255}));
          connect(hysteresis1.y, nv1.u[4]) annotation (Line(points={{-9,-24},{-6,-24},
                  {-6,54.75},{0,54.75}}, color={255,0,255}));
          connect(hysteresis2.y, nv2.u[4]) annotation (Line(points={{-9,-50},{-10,-50},
                  {-10,-50},{-10,-50},{0,-50},{0,34.75}}, color={255,0,255}));
          connect(or1.y, NightVentilation) annotation (Line(points={{86.6,20},{86.6,
                  -2},{110,-2}}, color={255,0,255}));
          connect(Te.y, greaterEqualThreshold.u)
            annotation (Line(points={{-73,50},{-62,50}}, color={0,0,127}));
          connect(Te.y, add.u2) annotation (Line(points={{-73,50},{-68,50},{-68,4},{
                  -62,4}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)));
        end NightVentilation;

        model SunShading "sunshading control"

          DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                    -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));

          Modelica.Blocks.Sources.BooleanExpression east_on(y=if clock.hour > 7 and
                clock.hour < 13 then true else false)
            "Time frame for which the east windows can activate the shading device"
            annotation (Placement(transformation(extent={{-40,80},{-20,100}})));
          Modelica.Blocks.Logical.GreaterEqualThreshold greaterEqualThreshold(threshold=
               10)
            annotation (Placement(transformation(extent={{8,-40},{28,-20}})));
          inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},{
                IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
            annotation (Placement(transformation(extent={{-100,80},{-80,100}})));
          IDEAS.Buildings.Components.Interfaces.WeaBus weaBus(numSolBus=5)
            annotation (Placement(transformation(extent={{-80,60},{-60,80}})));
          Modelica.Blocks.Math.Add altAng(k2=-1) "Altitude angle of sun"
            annotation (Placement(transformation(extent={{-40,-60},{-20,-40}})));
          Modelica.Blocks.Logical.Hysteresis hysteresis(uLow=273.15 + 21, uHigh=
                273.15 + 23)
            "External temperature for which the shading device can be on"
            annotation (Placement(transformation(extent={{-40,-20},{-20,0}})));
          Modelica.Blocks.MathBoolean.And east2nd(nu=4)
            annotation (Placement(transformation(extent={{40,80},{60,100}})));
          Modelica.Blocks.Sources.BooleanExpression south_on(y=if clock.hour > 11
                 and clock.hour < 19 then true else false)
            "Time frame for which the south windows can activate the shading device"
            annotation (Placement(transformation(extent={{-40,60},{-20,80}})));
          Modelica.Blocks.Sources.BooleanExpression west_on(y=if clock.hour > 14 and
                clock.hour < 20 then true else false)
            "Time frame for which the west windows can activate the shading device"
            annotation (Placement(transformation(extent={{-40,40},{-20,60}})));
          Modelica.Blocks.Sources.Constant ninety_degrees(k=Modelica.Constants.pi/2)
            annotation (Placement(transformation(extent={{-100,-40},{-80,-20}})));
          Modelica.Blocks.Math.Gain radiansToDegrees(k=180/Modelica.Constants.pi)
            annotation (Placement(transformation(extent={{-14,-54},{-6,-46}})));
          Modelica.Blocks.Logical.GreaterEqualThreshold greaterEqualThreshold1(threshold=
               20)
            annotation (Placement(transformation(extent={{8,-80},{28,-60}})));
          Modelica.Blocks.MathBoolean.And south(nu=4)
            annotation (Placement(transformation(extent={{40,60},{60,80}})));
          Modelica.Blocks.MathBoolean.And west(nu=4)
            annotation (Placement(transformation(extent={{40,40},{60,60}})));
          Modelica.Blocks.Logical.LessEqualThreshold    greaterEqualThreshold2(threshold=
               30)
            annotation (Placement(transformation(extent={{40,-40},{60,-20}})));
          Modelica.Blocks.Logical.LessEqualThreshold    greaterEqualThreshold3(threshold=
               22)
            annotation (Placement(transformation(extent={{40,-80},{60,-60}})));
          Modelica.Blocks.Math.BooleanToReal booleanToReal
            annotation (Placement(transformation(extent={{-130,-20},{-120,-10}})));
          Modelica.Blocks.Math.BooleanToReal booleanToReal1
            annotation (Placement(transformation(extent={{-130,10},{-120,20}})));
          Modelica.Blocks.Math.BooleanToReal booleanToReal2
            annotation (Placement(transformation(extent={{-130,-6},{-120,4}})));
          Modelica.Blocks.MathBoolean.And east3rd(nu=4)
            annotation (Placement(transformation(extent={{40,100},{60,120}})));
          Modelica.Blocks.Math.BooleanToReal booleanToReal3
            annotation (Placement(transformation(extent={{-130,26},{-120,36}})));
          Components.Clock           clock
            annotation (Placement(transformation(extent={{80,80},{100,100}})));
        equation

          connect(weaBus.Te, hysteresis.u) annotation (Line(
              points={{-69.95,70.05},{-69.95,70.05},{-69.95,-10},{-42,-10}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}}));
          connect(ninety_degrees.y, altAng.u1) annotation (Line(points={{-79,-30},{-60,
                  -30},{-60,-44},{-42,-44}}, color={0,0,127}));
          connect(altAng.y, radiansToDegrees.u)
            annotation (Line(points={{-19,-50},{-14.8,-50}}, color={0,0,127}));
          connect(west_on.y, west.u[1]) annotation (Line(points={{-19,50},{40,50},{40,
                  55.25}}, color={255,0,255}));
          connect(south_on.y, south.u[1]) annotation (Line(points={{-19,70},{40,70},{
                  40,75.25}}, color={255,0,255}));
          connect(east_on.y, east2nd.u[1]) annotation (Line(points={{-19,90},{40,90},
                  {40,95.25}}, color={255,0,255}));
          connect(hysteresis.y, west.u[2]) annotation (Line(points={{-19,-10},{-10,
                  -10},{0,-10},{0,51.75},{40,51.75}}, color={255,0,255}));
          connect(hysteresis.y, south.u[2]) annotation (Line(points={{-19,-10},{0,-10},
                  {0,71.75},{40,71.75}}, color={255,0,255}));
          connect(hysteresis.y, east2nd.u[2]) annotation (Line(points={{-19,-10},{0,-10},
                  {0,91.75},{40,91.75}}, color={255,0,255}));
          connect(radiansToDegrees.y, greaterEqualThreshold.u) annotation (Line(
                points={{-5.6,-50},{0,-50},{0,-30},{6,-30}}, color={0,0,127}));
          connect(radiansToDegrees.y, greaterEqualThreshold2.u) annotation (Line(
                points={{-5.6,-50},{34,-50},{34,-30},{38,-30}}, color={0,0,127}));
          connect(radiansToDegrees.y, greaterEqualThreshold1.u) annotation (Line(
                points={{-5.6,-50},{0,-50},{0,-70},{6,-70}}, color={0,0,127}));
          connect(radiansToDegrees.y, greaterEqualThreshold3.u) annotation (Line(
                points={{-5.6,-50},{-5.6,-50},{34,-50},{34,-70},{38,-70}}, color={0,0,
                  127}));
          connect(greaterEqualThreshold.y, east2nd.u[3]) annotation (Line(points={{29,
                  -30},{28,-30},{28,86},{28,88.25},{40,88.25}}, color={255,0,255}));
          connect(greaterEqualThreshold2.y, east2nd.u[4]) annotation (Line(points={{
                  61,-30},{60,-30},{60,18},{60,20},{30,20},{30,84.75},{40,84.75}},
                color={255,0,255}));
          connect(greaterEqualThreshold1.y, west.u[3]) annotation (Line(points={{29,
                  -70},{32,-70},{32,48.25},{40,48.25}}, color={255,0,255}));
          connect(greaterEqualThreshold3.y, west.u[4]) annotation (Line(points={{61,
                  -70},{61,32},{40,32},{40,44.75}}, color={255,0,255}));
          connect(greaterEqualThreshold1.y, south.u[3]) annotation (Line(points={{29,
                  -70},{30,-70},{30,68.25},{40,68.25}}, color={255,0,255}));
          connect(greaterEqualThreshold3.y, south.u[4]) annotation (Line(points={{61,
                  -70},{60,-70},{60,36},{40,36},{40,64.75}}, color={255,0,255}));
          connect(east2nd.y, booleanToReal1.u) annotation (Line(points={{61.5,90},{62,
                  90},{62,104},{-122,104},{-138,104},{-138,15},{-131,15}}, color={255,
                  0,255}));
          connect(south.y, booleanToReal2.u) annotation (Line(points={{61.5,70},{61.5,
                  102},{-136,102},{-136,-1},{-131,-1}}, color={255,0,255}));
          connect(booleanToReal2.y, dataBus.southShading) annotation (Line(points={{
                  -119.5,-1},{-110.75,-1},{-110.75,0.1},{-99.9,0.1}}, color={0,0,127}),
              Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(west.y, booleanToReal.u) annotation (Line(points={{61.5,50},{62,50},
                  {62,104},{62,106},{-140,106},{-140,-15},{-131,-15}}, color={255,0,
                  255}));
          connect(booleanToReal.y, dataBus.westShading) annotation (Line(points={{
                  -119.5,-15},{-99.9,-15},{-99.9,0.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(booleanToReal1.y, dataBus.eastShading2nd) annotation (Line(points={
                  {-119.5,15},{-99.9,15},{-99.9,0.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(greaterEqualThreshold1.y, east3rd.u[1]) annotation (Line(points={{
                  29,-70},{28,-70},{28,115.25},{40,115.25}}, color={255,0,255}));
          connect(greaterEqualThreshold3.y, east3rd.u[2]) annotation (Line(points={{
                  61,-70},{64,-70},{64,28},{64,26},{34,26},{34,111.75},{40,111.75}},
                color={255,0,255}));
          connect(east_on.y, east3rd.u[3]) annotation (Line(points={{-19,90},{-8,90},
                  {-8,108.25},{40,108.25}}, color={255,0,255}));
          connect(hysteresis.y, east3rd.u[4]) annotation (Line(points={{-19,-10},{-6,
                  -10},{-6,104.75},{40,104.75}}, color={255,0,255}));
          connect(east3rd.y, booleanToReal3.u) annotation (Line(points={{61.5,110},{
                  61.5,126},{-131,126},{-131,31}}, color={255,0,255}));
          connect(booleanToReal3.y, dataBus.eastShading3rd) annotation (Line(points={
                  {-119.5,31},{-99.9,31},{-99.9,0.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}}));
          connect(weaBus.angZen, altAng.u2) annotation (Line(
              points={{-69.95,70.05},{-70,70.05},{-70,-56},{-42,-56}},
              color={255,204,51},
              thickness=0.5));
          connect(sim.weaBus, weaBus) annotation (Line(
              points={{-81,93},{-78,93},{-78,70},{-70,70}},
              color={255,204,51},
              thickness=0.5));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)));
        end SunShading;

        model VAV_baseline "Controls of AHU loop for baseline"

          SignalBus signalBus annotation (Placement(transformation(extent={{80,-20},{
                    120,20}}), iconTransformation(extent={{92,-10},{112,10}})));
          DataBus dataBus annotation (Placement(transformation(extent={{-120,-20},{
                    -80,20}}), iconTransformation(extent={{-110,-10},{-90,10}})));
          inner IDEAS.BoundaryConditions.SimInfoManager sim(incAndAziInBus={{IDEAS.Types.Tilt.Ceiling,
                0},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.S},{IDEAS.Types.Tilt.Wall,
                IDEAS.Types.Azimuth.W},{IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.N},
                {IDEAS.Types.Tilt.Wall,IDEAS.Types.Azimuth.E}})
            annotation (Placement(transformation(extent={{-100,100},{-80,120}})));
          Components.Clock           clock
            annotation (Placement(transformation(extent={{-60,100},{-40,120}})));
          IDEAS.Controls.Continuous.LimPID conVAV[21](
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            each Ti=100,
            reverseAction=true,
            each k=0.5) "Controller for VAV based on temperature"
            annotation (Placement(transformation(extent={{-44,20},{-24,40}})));
          Modelica.Blocks.Sources.Constant tracking[21](k=0)
            "set point tracking signal"
            annotation (Placement(transformation(extent={{-80,20},{-60,40}})));
          Modelica.Blocks.Math.Feedback diff[21]
            annotation (Placement(transformation(extent={{-90,-36},{-70,-16}})));
          Modelica.Blocks.Math.Abs abs[21]
            "absolute value (air flow either for heating or cooling)"
            annotation (Placement(transformation(extent={{-60,-36},{-40,-16}})));
          Modelica.Blocks.Routing.Replicator replicator(nout=21) annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=90,
                origin={-80,-70})));
          Modelica.Blocks.Logical.Switch heaDemand[21]
            annotation (Placement(transformation(extent={{74,48},{94,28}})));
          Modelica.Blocks.Logical.Hysteresis hysteresisHea[21](            uHigh=-0.25, uLow=-1.25)
            annotation (Placement(transformation(extent={{-60,60},{-40,80}})));
          Modelica.Blocks.Logical.Not not1[21]
            annotation (Placement(transformation(extent={{-20,64},{-8,76}})));
          Modelica.Blocks.Tables.CombiTable1D supplySetpoint[21](each table=[-1,
                273.15 + 24; 0,273.15 + 22; 0.5,273.15 + 18])
                              "setpoint for the supply air temperature"
            annotation (Placement(transformation(extent={{-10,20},{10,40}})));
          Modelica.Blocks.Nonlinear.Limiter limiter[21](                  uMin=273.15 +
                18, uMax=273.15 + 24)
                    "air supply temperature setpoint"
            annotation (Placement(transformation(extent={{16,20},{36,40}})));
          IDEAS.Controls.Continuous.LimPID conHeaCoi[21](
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            each k=2,
            each Ti=100,
            each reset=IDEAS.Types.Reset.Disabled)
            "Controller for heating coils in air ducts"
            annotation (Placement(transformation(extent={{44,20},{64,40}})));
          IDEAS.Utilities.Math.Max max[15](nin=3)
            "Maximum of the setpoints is the setpoint for the damper" annotation (
              Placement(transformation(
                extent={{-10,-10},{10,10}},
                rotation=-90,
                origin={-10,-44})));
          Modelica.Blocks.Sources.RealExpression flush[15](y=if (clock.hour >= 5 and
                clock.hour <= 6) or nightVentilation then 1 else 0)
                         "at 5am, dampers are opening at maximum"
            annotation (Placement(transformation(extent={{40,-36},{20,-16}})));

          Modelica.Blocks.MathBoolean.Or or1(nu=21)
            annotation (Placement(transformation(extent={{20,88},{32,100}})));
          Modelica.Blocks.Math.BooleanToInteger P06_signal
            "If any valve is open, then pump mass flow"
            annotation (Placement(transformation(extent={{64,92},{80,108}})));
          IDEAS.Utilities.Math.Max max1(nin=21)
            annotation (Placement(transformation(extent={{20,50},{36,66}})));
          Modelica.Blocks.Tables.CombiTable1D curve_HP(table=[273.15 + 18,273.15 + 26;
                273.15 + 24,273.15 + 32])
            "HP setpoint depending on VAV coils required temperature"
            annotation (Placement(transformation(extent={{42,50},{58,66}})));
          IDEAS.Controls.Continuous.LimPID conCO2[15](
            controllerType=Modelica.Blocks.Types.SimpleController.PI,
            each reset=IDEAS.Types.Reset.Disabled,
            reverseAction=true,
            each k=0.5,
            each Ti(displayUnit="min") = 120) "Controller for VAV based on CO2"
            annotation (Placement(transformation(extent={{10,-100},{30,-80}})));
          Modelica.Blocks.Routing.Replicator replicator1(nout=15)
                                                                 annotation (Placement(
                transformation(
                extent={{-10,-10},{10,10}},
                rotation=0,
                origin={-10,-90})));
          Modelica.Blocks.Sources.Constant CO2setpoint(k=850)
            "set point tracking signal"
            annotation (Placement(transformation(extent={{-50,-100},{-30,-80}})));
          Modelica.Blocks.Logical.Switch airDemand[15] annotation (Placement(
                transformation(
                extent={{-10,10},{10,-10}},
                rotation=-90,
                origin={-10,-6})));
          Modelica.Blocks.Routing.Replicator replicator2(nout=15)
                                                                 annotation (Placement(
                transformation(
                extent={{-6,-6},{6,6}},
                rotation=0,
                origin={-44,4})));
          Modelica.Blocks.Logical.Hysteresis hysteresisVAV[15](
            pre_y_start=true,
            uHigh=1,
            uLow=0.3)
            annotation (Placement(transformation(extent={{-80,80},{-62,98}})));
          Modelica.Blocks.Interfaces.BooleanInput nightVentilation
            "night ventilation active"
            annotation (Placement(transformation(extent={{-120,-70},{-80,-30}})));
          Modelica.Blocks.Sources.BooleanExpression AHUon(y=if ((clock.hour >= 5 and
                clock.hour < 20) and (clock.weekDay) < 6) == true then true else
                false) "Supply fan pressure difference set-point"
            annotation (Placement(transformation(extent={{10,100},{32,120}})));
          Modelica.Blocks.Logical.And and1
            annotation (Placement(transformation(extent={{42,94},{54,106}})));
        equation

          connect(tracking.y, conVAV.u_s)
            annotation (Line(points={{-59,30},{-46,30}}, color={0,0,127}));
          connect(diff.y, abs.u)
            annotation (Line(points={{-71,-26},{-62,-26}}, color={0,0,127}));
          connect(signalBus.baseSetpoint, replicator.u) annotation (Line(
              points={{100,0},{100,-120},{-80,-120},{-80,-82}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(replicator.y, diff.u2)
            annotation (Line(points={{-80,-59},{-80,-34}}, color={0,0,127}));
          connect(abs.y, conVAV.u_m)
            annotation (Line(points={{-39,-26},{-34,-26},{-34,18}}, color={0,0,127}));
          connect(dataBus.T3rdFlr_SZ, diff[1].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T3rdFlr_CPR, diff[2].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T3rdFlr_MTR, diff[4].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T3rdFlr_SmaR, diff[3].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T2ndFlr_NZ, diff[5].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T2ndFlr_SZ, diff[6].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T2ndFlr_MT1, diff[7].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-12},{-100,-12},{-100,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,6},{-3,6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T2ndFlr_MT2, diff[8].u1) annotation (Line(
              points={{-99.9,0.1},{-100,0.1},{-100,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T1stFlr_NZ, diff[9].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T1stFlr_SZ1, diff[10].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T1stFlr_SZ2, diff[11].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T1stFlr_MT1, diff[12].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.T1stFlr_MT2, diff[13].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.TGndFlr_hall, diff[14].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.TGndFlr_1stAid, diff[15].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.TGndFlr_KTR, diff[16].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.TGndFlr_MT2, diff[17].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.TGndFlr_MT1, diff[18].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.TGndFlr_hall, diff[19].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.TGndFlr_WStairs, diff[20].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.TGndFlr_EStairs, diff[21].u1) annotation (Line(
              points={{-99.9,0.1},{-99.9,-26},{-88,-26}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-6,3},{-6,3}},
              horizontalAlignment=TextAlignment.Right));
          connect(diff.y, hysteresisHea.u) annotation (Line(points={{-71,-26},{-66,-26},
                  {-66,14},{-88,14},{-88,70},{-62,70}}, color={0,0,127}));
          connect(hysteresisHea.y, not1.u)
            annotation (Line(points={{-39,70},{-21.2,70}}, color={255,0,255}));
          connect(not1.y, heaDemand.u2) annotation (Line(points={{-7.4,70},{66,70},{66,38},
                  {72,38}},                   color={255,0,255}));
          connect(supplySetpoint.y[1], limiter.u)
            annotation (Line(points={{11,30},{14,30}},color={0,0,127}));
          connect(conHeaCoi.u_s, limiter.y)
            annotation (Line(points={{42,30},{37,30}}, color={0,0,127}));
          connect(dataBus.TAirSupplyVAV, conHeaCoi.u_m) annotation (Line(
              points={{-99.9,0.1},{54,0.1},{54,18}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(flush.y, max.u[1])
            annotation (Line(points={{19,-26},{-10,-26},{-10,-32},{-11.3333,-32}},
                                                                    color={0,0,127}));
          connect(max.y, signalBus.VAV_signal) annotation (Line(points={{-10,-55},{-10,-60},
                  {100.1,-60},{100.1,0.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));



          connect(conVAV[1].y, airDemand[1].u1) annotation (Line(points={{-23,30},{-18,30},
                  {-18,-2},{-18,-2},{-18,6}},color={0,0,127}));
          connect(conVAV[2].y, airDemand[2].u1);
          connect(conVAV[3].y, airDemand[3].u1);
          connect(conVAV[5].y, airDemand[4].u1);
          connect(conVAV[6].y, airDemand[5].u1);
          connect(conVAV[7].y, airDemand[6].u1);
          connect(conVAV[8].y, airDemand[7].u1);
          connect(conVAV[9].y, airDemand[8].u1);
          connect(conVAV[10].y, airDemand[9].u1);
          connect(conVAV[11].y, airDemand[10].u1);
          connect(conVAV[12].y, airDemand[11].u1);
          connect(conVAV[13].y, airDemand[12].u1);
          connect(conVAV[16].y, airDemand[13].u1);
          connect(conVAV[17].y, airDemand[14].u1);
          connect(conVAV[18].y, airDemand[15].u1);



          connect(heaDemand.y, signalBus.Heacoils_signal) annotation (Line(points={{95,38},
                  {100.1,38},{100.1,0.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(max[1].y, signalBus.VAV_signal_extract[1]) annotation (Line(points={{-10,-55},
                  {-10,-60},{100.1,-60},{100.1,0.1}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(max[2].y, signalBus.VAV_signal_extract[2]);
          connect(max[3].y, signalBus.VAV_signal_extract[3]);
          connect(max[4].y, signalBus.VAV_signal_extract[4]);
          connect(max[5].y, signalBus.VAV_signal_extract[5]);
          connect(max[6].y, signalBus.VAV_signal_extract[6]);
          connect(max[7].y, signalBus.VAV_signal_extract[7]);
          connect(max[8].y, signalBus.VAV_signal_extract[8]);
          connect(max[9].y, signalBus.VAV_signal_extract[9]);
          connect(max[11].y, signalBus.VAV_signal_extract[10]);
          connect(max[12].y, signalBus.VAV_signal_extract[11]);
          connect(max[13].y, signalBus.VAV_signal_extract[12]);
          connect(max[14].y, signalBus.VAV_signal_extract[13]);
          connect(max[15].y, signalBus.VAV_signal_extract[14]);

          connect(max[10].y, signalBus.VAV_signal_extract[15]); //dummy connection

          connect(not1.y, or1.u[1:21]) annotation (Line(points={{-7.4,70},{8,70},{8,
                  90},{20,90}}, color={255,0,255}));
          connect(P06_signal.y, signalBus.P06_signal) annotation (Line(points={{80.8,
                  100},{100,100},{100,0}},
                                         color={255,127,0}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(conHeaCoi.y, heaDemand.u1)
            annotation (Line(points={{65,30},{72,30}}, color={0,0,127}));
          connect(heaDemand.u3, tracking.y) annotation (Line(points={{72,46},{-54,46},
                  {-54,30},{-59,30}}, color={0,0,127}));
          connect(max1.y, curve_HP.u[1])
            annotation (Line(points={{36.8,58},{40.4,58}}, color={0,0,127}));
          connect(curve_HP.y[1], signalBus.T_VAV) annotation (Line(points={{58.8,58},
                  {100,58},{100,0}}, color={0,0,127}), Text(
              string="%second",
              index=1,
              extent={{6,3},{6,3}},
              horizontalAlignment=TextAlignment.Left));
          connect(replicator1.y, conCO2.u_s)
            annotation (Line(points={{1,-90},{8,-90}}, color={0,0,127}));
          connect(CO2setpoint.y, replicator1.u)
            annotation (Line(points={{-29,-90},{-22,-90}}, color={0,0,127}));
          connect(conCO2.y, max.u[3]) annotation (Line(points={{31,-90},{60,-90},{60,-32},
                  {-8.66667,-32}}, color={0,0,127}));
          connect(dataBus.CO2_3rdFlr_SZ, conCO2[1].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_3rdFlr_CPR, conCO2[2].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_3rdFlr_SmaR, conCO2[3].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_2ndFlr_NZ, conCO2[4].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_2ndFlr_SZ, conCO2[5].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_2ndFlr_MT1, conCO2[6].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_2ndFlr_MT2, conCO2[7].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_1stFlr_NZ, conCO2[8].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_1stFlr_SZ1, conCO2[9].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_1stFlr_SZ2, conCO2[10].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_1stFlr_MT1, conCO2[11].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_1stFlr_MT2, conCO2[12].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_GndFlr_KTR, conCO2[13].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_GndFlr_MT1, conCO2[14].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(dataBus.CO2_GndFlr_MT2, conCO2[15].u_m) annotation (Line(
              points={{-99.9,0.1},{-99.9,-112},{20,-112},{20,-102}},
              color={255,204,51},
              thickness=0.5), Text(
              string="%first",
              index=-1,
              extent={{-3,-6},{-3,-6}},
              horizontalAlignment=TextAlignment.Right));
          connect(airDemand.y, max.u[2])
            annotation (Line(points={{-10,-17},{-10,-32}}, color={0,0,127}));
          connect(replicator2.y, airDemand.u3) annotation (Line(points={{-37.4,4},{-32,4},
                  {-32,12},{-2,12},{-2,6}}, color={0,0,127}));
          connect(tracking[1].y, replicator2.u) annotation (Line(points={{-59,30},{-54,30},
                  {-54,4},{-51.2,4}}, color={0,0,127}));
          connect(abs[1].y, hysteresisVAV[1].u) annotation (Line(points={{-39,-26},{
                  -34,-26},{-34,-8},{-94,-8},{-94,89},{-81.8,89}},
                                         color={0,0,127}));
          connect(abs[2].y, hysteresisVAV[2].u);
          connect(abs[3].y, hysteresisVAV[3].u);
          connect(abs[5].y, hysteresisVAV[4].u);
          connect(abs[6].y, hysteresisVAV[5].u);
          connect(abs[7].y, hysteresisVAV[6].u);
          connect(abs[8].y, hysteresisVAV[7].u);
          connect(abs[9].y, hysteresisVAV[8].u);
          connect(abs[10].y, hysteresisVAV[9].u);
          connect(abs[11].y, hysteresisVAV[10].u);
          connect(abs[12].y, hysteresisVAV[11].u);
          connect(abs[13].y, hysteresisVAV[12].u);
          connect(abs[16].y, hysteresisVAV[13].u);
          connect(abs[17].y, hysteresisVAV[14].u);
          connect(abs[18].y, hysteresisVAV[15].u);

          connect(hysteresisVAV.y, airDemand.u2) annotation (Line(points={{-61.1,89},
                  {-10,89},{-10,6}}, color={255,0,255}));
          connect(limiter.y, max1.u) annotation (Line(points={{37,30},{38,30},{38,48},
                  {12,48},{12,58},{18.4,58}}, color={0,0,127}));
          connect(and1.y, P06_signal.u)
            annotation (Line(points={{54.6,100},{62.4,100}}, color={255,0,255}));
          connect(or1.y, and1.u2) annotation (Line(points={{32.9,94},{38,94},{38,95.2},
                  {40.8,95.2}}, color={255,0,255}));
          connect(AHUon.y, and1.u1) annotation (Line(points={{33.1,110},{38,110},{38,
                  100},{40.8,100}}, color={255,0,255}));
          connect(hysteresisHea.u, supplySetpoint.u[1]) annotation (Line(points={{-62,
                  70},{-72,70},{-72,52},{-16,52},{-16,30},{-12,30}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-120},
                    {100,120}}),                                        graphics={
                  Rectangle(
                  extent={{-100,120},{100,-120}},
                  lineColor={28,108,200},
                  fillColor={255,255,255},
                  fillPattern=FillPattern.Solid),                                Text(
                  extent={{-62,76},{78,-64}},
                  lineColor={28,108,200},
                  textString="VAV")}),Diagram(coordinateSystem(preserveAspectRatio=
                    false, extent={{-100,-120},{100,120}})));
        end VAV_baseline;
      end SubControllers;

      package Components

        model Step "Step (optionally with initial step and/or activePort)"
          parameter Integer nIn(min=0) = 0 "Number of input connections"
            annotation (Dialog(__Dymola_connectorSizing=true), HideResult=true);
          parameter Integer nOut(min=0) = 0 "Number of output connections"
            annotation (Dialog(__Dymola_connectorSizing=true), HideResult=true);
          parameter Boolean initialStep=false
            "=true, if initial step (graph starts at this step)" annotation (
            Evaluate=true,
            HideResult=true,
            choices(__Dymola_checkBox=true));
          parameter Boolean use_activePort=false "=true, if activePort enabled"
            annotation (
            Evaluate=true,
            HideResult=true,
            choices(__Dymola_checkBox=true));

          Modelica_StateGraph2.Internal.Interfaces.Step_in inPort[nIn]
            "Port for zero, one, or more input transitions"
            annotation (Placement(transformation(extent={{-50,85},{50,115}})));
          Modelica_StateGraph2.Internal.Interfaces.Step_out outPort[nOut]
            "Port for zero, one, or more output transitions"
            annotation (Placement(transformation(extent={{-50,-130},{50,-100}})));
          Modelica.Blocks.Interfaces.BooleanOutput activePort=active if use_activePort
            "= true if step is active, otherwise the step is not active"
            annotation (Placement(transformation(extent={{100,-18},{136,18}})));
          output Boolean active
            "= true if step is active, otherwise the step is not active";

      protected
          Boolean newActive(start=initialStep, fixed=true)
            "Value of active in the next iteration";
          Boolean oldActive(start=initialStep, fixed=true)
            "Value of active when CompositeStep was aborted";

          Modelica_StateGraph2.Internal.Interfaces.Node node
            "Handles rootID as well as suspend and resume transitions from a Modelica_StateGraph2";

          Boolean inport_fire;
          Boolean outport_fire;

        equation
          // set active state
          inport_fire = Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(inPort.fire);
          outport_fire = Modelica_StateGraph2.Blocks.BooleanFunctions.anyTrue(outPort.fire);
          newActive = if node.resume then oldActive else inport_fire or (active and
            not outport_fire) and not node.suspend;
          active = pre(newActive);

          // Remember state for suspend action
          when node.suspend then
            oldActive = active;
          end when;

          // Report state to output transitions
          for i in 1:nOut loop
            outPort[i].available = if i == 1 then active and not node.suspend else
              outPort[i - 1].available and not outPort[i - 1].fire and not node.suspend;
          end for;

          inPort.checkUnaryConnection = fill(true, nIn);
          outPort.checkOneDelayedTransitionPerLoop = fill(
            Modelica_StateGraph2.Internal.Utilities.propagateLoopCheck(inPort.checkOneDelayedTransitionPerLoop),
            nOut);

          // Handle initial step and propagate node information from inPort to node

          for i in 1:nIn loop
            Connections.branch(inPort[i].node, node);
            inPort[i].node = node;
          end for;

          if initialStep then
            Connections.uniqueRoot(node, "
The StateGraph has a wrong connection structure. Reasons:
(1) The StateGraph is initialized at two different locations (initial steps or entry ports).
(2) A transition is made wrongly out of a Parallel component.
(3) A transition is made between two branches of a Parallel component.
All these cases are not allowed.
");

            node.suspend = false;
            node.resume = false;
          else
            // Check that connections to the connector are correct
            assert(nIn > 0, "Step is not reachable since it has no input transition");

            // In order that check works (nIn=0), provide the missing equations
            if nIn == 0 then
              node.suspend = false;
              node.resume = false;
            end if;
          end if;

          // Propagate node information from node to outPort
          for i in 1:nOut loop
            Connections.branch(node, outPort[i].node);
            outPort[i].node = node;
          end for;

          // Check that all graph connectors are connected
          for i in 1:size(inPort, 1) loop
            if cardinality(inPort[i]) == 0 then
              inPort[i].fire = true;
              inPort[i].checkOneDelayedTransitionPerLoop = true;
              assert(false, "
An element of the inPort connector of this step is not connected. Most likely, the Modelica tool
has a bug and does not correctly handle the connectorSizing annotation in a particular case.
You can fix this by removing all input connections to this step and by manually removing
the line 'nIn=...' in the text layer where this step is declared.
");         end if;
          end for;

          for i in 1:size(outPort, 1) loop
            if cardinality(outPort[i]) == 0 then
              outPort[i].fire = true;
              assert(false, "
An element of the outPort connector of this step is not connected. Most likely, the Modelica tool
has a bug and does not correctly handle the connectorSizing annotation in a particular case.
You can fix this by removing all output connections to this step and by manually removing
the line 'nOut=...' in the text layer where this step is declared.
");         end if;
          end for;
          annotation (
            defaultComponentName="step1",
            Documentation(info="<html>
<p>
A Step is the graphical representation of a state and is said to be either
active or not active. A StateGraph2 model is comprised of one or more
steps that may or may not change their states during execution.
The input port of a Step (inPort) can only be connected to the output port
of a Transition, and the output port of a Step (outPort) can only be connected
to the input of a Transition. An arbitrary number of input and/or output
Transitions can be connected to these ports.
</p>

<p>
The state of a step is available via the output variable <b>active</b> that can
be used in action blocks (e.g. \"step.active\"). Alternatively, via parameter
\"use_activePort\" the Boolean output port \"activePort\" can be enabled.
When the step is active, activePort = <b>true</b>, otherwise it is <b>false</b>. This port can
be connected to Boolean action blocks, e.g., from
<a href=\"modelica://Modelica_StateGraph2.Blocks.MathBoolean\">Modelica_StateGraph2.Blocks.MathBoolean</a>.
</p>

<p>
Every StateGraph2 graph
must have exactly one initial step. An initial step is defined by setting parameter initialStep
at one Step or one Parallel component to true. The initial step is visualized by a
small arrow pointing to this step.
</p>

<p>
In the following table different configurations of a Step are shown:
</p>

<blockquote>
<table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" width=\"600\">
<tr><th>Parameter setting</th>
    <th>Icon</th>
    <th>Description</th>
    </tr>

<tr><td> Default step</td>
    <td><img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/Step-default.png\"></td>
    <td> If the step is active, the public Step variable &quot;active&quot; is <b>true</b>
         otherwise, it is <b>false</b>. An active Step is visualized by a green
         fill color in diagram animation.</td>
    </tr>

<tr><td> use_activePort = <b>true</b></td>
    <td><img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/Step-use_activePort.png\"></td>
    <td>If the step is active, the connector &quot;activePort&quot; is <b>true</b>
        otherwise, it is <b>false</b> (the activePort is the small, violet, triangle
        at the rigth side of the Step icon). Actions may be triggered, e.g., by connecting block
        <a href=\"modelica://Modelica_StateGraph2.Blocks.MathBoolean.MultiSwitch\">MultiSwitch</a>
        to the activePort.</td></tr>

<tr><td> initialStep = <b>true</b></td>
    <td><img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/Step-initial.png\"></td>
    <td> Exactly <u>one</u> Step or Parallel component in a StateGraph2 graph
         must have &quot;initialStep = <b>true</b>&quot;. At the first model evaluation
         during initialization, &quot;active&quot; is set to <b>true</b> for
         the initial Step or the initial Parallel component, i.e.,
         the respective component is activated.</td>
    </tr>
</table>
</blockquote>

<p>
The inPort and the outPort connectors of a Step are &quot;vectors of connectors&quot;.
How connections to these ports are automatically handled in a convenient way is sketched
<a href=\"modelica://Modelica_StateGraph2.UsersGuide.Tutorial.VectorsOfConnectors\">here</a>
in the tutorial.
</p>

</html>"),  Icon(coordinateSystem(
                extent={{-100,-100},{100,100}},
                preserveAspectRatio=true,
                initialScale=0.04,
                grid={1,1}), graphics={
                Text(
                  extent={{15,118},{470,193}},
                  textString="%name",
                  lineColor={0,0,255}),
                Rectangle(
                  extent={{-100,100},{100,-100}},
                  lineColor={0,0,0},
                  fillColor=DynamicSelect({255,255,255}, if active > 0.5 then {0,255,0}
                       else {255,255,255}),
                  fillPattern=FillPattern.Solid,
                  radius=60),
                Line(
                  visible=initialStep,
                  points={{-235,181},{-137,181},{-90,90}},
                  color={0,0,0},
                  smooth=Smooth.Bezier),
                Ellipse(
                  visible=initialStep,
                  extent={{-255,199},{-219,163}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid),
                Polygon(
                  visible=initialStep,
                  points={{-95,140},{-90,90},{-126,124},{-95,140}},
                  lineColor={0,0,0},
                  smooth=Smooth.None,
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid)}),
            Diagram(coordinateSystem(
                extent={{-100,-100},{100,100}},
                preserveAspectRatio=true,
                initialScale=0.04,
                grid={1,1}), graphics));
        end Step;

        model Transition
          "Transition between steps (optionally with delayed transition and/or condition input port)"
          parameter Boolean use_conditionPort=false "= true, if conditionPort enabled"
            annotation (
            Evaluate=true,
            HideResult=true,
            choices(__Dymola_checkBox=true));

          input Boolean condition=true
            "Fire condition (time varying Boolean expression)"
            annotation (Dialog(enable=not use_conditionPort));

          parameter Boolean delayedTransition=false
            "= true, if transition fires after waitTime" annotation (
            Evaluate=true,
            HideResult=true,
            choices(__Dymola_checkBox=true));
          parameter Modelica.SIunits.Time waitTime=0
            "Wait time before transition fires (> 0 required)"
            annotation (Dialog(enable=delayedTransition));

          parameter Boolean use_firePort=false "= true, if firePort enabled"
            annotation (
            Evaluate=true,
            HideResult=true,
            choices(__Dymola_checkBox=true));

          parameter Boolean loopCheck=true
            "= true, if one delayed transition per loop required" annotation (
            Evaluate=true,
            HideResult=true,
            Dialog(tab="Advanced"),
            choices(__Dymola_checkBox=true));

          Modelica_StateGraph2.Internal.Interfaces.Transition_in inPort
            "Input port of transition (exactly one connection to this port is required)"
            annotation (Placement(transformation(extent={{-17,83},{17,117}})));

          Modelica_StateGraph2.Internal.Interfaces.Transition_out outPort
            "Output port of transition (exactly one connection from this port is required)"
            annotation (Placement(transformation(extent={{-25,-150},{25,-100}})));

          Modelica.Blocks.Interfaces.BooleanInput conditionPort if use_conditionPort
            "Fire condition as Boolean input."
            annotation (Placement(transformation(extent={{-150,-25},{-100,25}})));

          Modelica.Blocks.Interfaces.BooleanOutput firePort=fire if use_firePort
            "= true, if transition fires"
            annotation (Placement(transformation(extent={{90,-15},{120,15}})));

          output Boolean fire "= true, if transition fires";
          output Boolean enableFire "= true, if firing condition is true";

      protected
          constant Modelica.SIunits.Time minimumWaitTime=100*Modelica.Constants.eps;
          Modelica.SIunits.Time t_start
            "Time instant at which the transition would fire, if waitTime would be zero";
          Modelica.Blocks.Interfaces.BooleanInput localCondition;
        initial equation
          pre(enableFire) = false;
          if delayedTransition then
            pre(t_start) = 0;
          end if;
        equation
          // Handle conditional conditionPort
          connect(conditionPort, localCondition);
          if not use_conditionPort then
            localCondition = condition;
          end if;

          // Determine firing condition
          enableFire = localCondition and inPort.available;

          if delayedTransition then
            when enableFire then
              t_start = time;
            end when;
            fire = enableFire and time >= t_start + waitTime;
            outPort.checkOneDelayedTransitionPerLoop = true;
          else
            t_start = 0;
            fire = enableFire;
            if loopCheck then
              outPort.checkOneDelayedTransitionPerLoop = inPort.checkOneDelayedTransitionPerLoop;
            else
              outPort.checkOneDelayedTransitionPerLoop = true;
            end if;
          end if;

          inPort.fire = fire;
          outPort.fire = fire;

          // Handling of node
          Connections.branch(inPort.node, outPort.node);
          outPort.node = inPort.node;

          // Asserts
          assert(not delayedTransition or delayedTransition and waitTime >
            minimumWaitTime, "Either set delayTransition = false, or set waitTime (= "
             + String(waitTime) + ") > " + String(minimumWaitTime));
          annotation (
            defaultComponentName="T1",
            Icon(coordinateSystem(
                extent={{-100,-100},{100,100}},
                initialScale=0.04,
                preserveAspectRatio=true,
                grid={1,1}), graphics={
                Text(
                  visible=delayedTransition,
                  extent={{-200,10},{200,-10}},
                  lineColor={255,0,0},
                  textString="%waitTime",
                  origin={210,-70},
                  rotation=0),
                Line(
                  visible=delayedTransition,
                  points={{0,-12.5},{0,-30}},
                  color={255,0,0}),
                Line(
                  visible=delayedTransition,
                  points={{0,-86},{0,-100}},
                  color={255,0,0}),
                Line(
                  visible=delayedTransition,
                  points={{0,-47},{0,-63}},
                  color={255,0,0}),
                Line(
                  visible=not delayedTransition,
                  points={{0,0},{0,-100}},
                  color={0,0,0}),
                Text(
                  extent={{-150,-15},{150,15}},
                  textString="%name",
                  lineColor={0,0,255},
                  origin={160,75},
                  rotation=0),
                Rectangle(
                  extent={{-100,-15},{100,15}},
                  lineColor={0,0,0},
                  fillColor={0,0,0},
                  fillPattern=FillPattern.Solid,
                  radius=10),
                Line(points={{0,90},{0,12}}, color={0,0,0}),
                Text(
                  visible=not use_conditionPort,
                  extent={{-300,-15},{300,15}},
                  lineColor=DynamicSelect({128,128,128}, if condition > 0.5 then {0,255,
                      0} else {128,128,128}),
                  textString="%condition",
                  origin={-155,-3},
                  rotation=90),
                Text(
                  visible=not loopCheck,
                  extent={{10,-60},{400,-80}},
                  lineColor={255,0,0},
                  fillColor={170,255,213},
                  fillPattern=FillPattern.Solid,
                  textString="no check"),
                Line(
                  visible=not loopCheck,
                  points={{0,-15},{0,-100}},
                  color={255,0,0},
                  smooth=Smooth.None)}),
            Documentation(info="<html>
<p>
<img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/SimpleStateGraph.png\" align=\"right\">
To define a possible change of states, a Transition is connected to the output of the preceding Step and to the input of the succeeding Step, see figure to the right, where Transition t1 defines the transition from Step s1 to Step s2. Note: A Transition has exactly one preceding and one succeeding Step. A Transition is said to be enabled if the preceding step is active. An enabled transition is said to be fireable when the Boolean condition defined in the parameter menu of the transition is evaluated to <b>true</b>. This condition is also called <u>Transition condition</u> and is displayed in the icon of the Transition (e.g., &quot;time &gt; 1&quot; is the condition of Transition t1). When parameter <u>use_conditionPort</u> is set, the Transition condition is alternatively defined by a Boolean signal that is connected to the enabled <u>conditionPort</u>.
</p>

<p>
A fireable transition will fire immediately. In the figure to the right, t1 fires when s1 is active and time is greater than one, i.e., s1 becomes inactive and s2 becomes active.
The firing of a transition can optionally also be delayed for a certain period of time defined by parameter &quot;waitTime&quot;. See, e.g., t2 in the figure to right, that is delayed for one second before it may fire, given that the condition remains true and the preceding Step remains active during the entire delay time.
</p>

<p>
In the following table different configurations of a Transition are shown:
</p>

<blockquote>
<table cellspacing=\"0\" cellpadding=\"4\" border=\"1\" width=\"600\">
<tr><th>Parameter setting</th>
    <th>Icon</th>
    <th>Description</th></tr>

<tr><td>Default transition</td>
    <td><img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/Transition-default.png\"></td>
    <td>The transition fires when the preceding step is active
        and the expression &quot;condition&quot; in the parameter menu is <b>true</b>.</td>
    </tr>

<tr><td>use_conditionPort = <b>true</b></td>
    <td><img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/Transition-use_conditionPort.png\"></td>
    <td>The transition fires when the preceding step is active
        and connector &quot;conditionPort&quot; is <b>true</b>.</td>
    </tr>

<tr><td>delayedTransition = <b>true</b></td>
    <td><img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/Transition-delayedTransition.png\"></td>
    <td>The transition fires after the delay time &quot;waitTime&quot; (here: 1.23 s),
        if the preceding step was active, and &quot;condition = <b>true</b>&quot;
        during the entire delay time.</td>
    </tr>

<tr><td>use_firePort = <b>true</b></td>
    <td><img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/Transition-use_firePort.png\"></td>
    <td>Connector &quot;firePort&quot; is <b>true</b> when the transition fires.
        Actions may be triggered, e.g., by connecting block
        <a href=\"modelica://Modelica_StateGraph2.Blocks.MathBoolean.MultiSwitch\">MultiSwitch</a>
        to the firePort.</td>
    </tr>

<tr><td>loopCheck = <b>false</b><br>
        (in &quot;Advanced&quot; tab)</td>
    <td><img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/Transition-noLoopCheck.png\"></td>
    <td>It is <u>not</u> checked whether the loop in which this Transition
        is used, has at least one delayed transition.
        Use this option only, if you are completley sure that
        infinite event looping is not possible in this loop.
        Consider to use
        <a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
        instead!</td>
    </tr>

</table>
</blockquote>

<p>
<img src=\"modelica://Modelica_StateGraph2/Resources/Images/StateGraph/Elements/SimpleInfiniteLoop.png\" align=\"right\">
At an event instant, an iteration occurs, due to the Modelica semantics (= whenever a new event occurs, the model is re-evaluated). This means that Transitions keep firing along a connected graph, as long as the firing conditions are true. In principal, it is therefore possible that infinite event looping occurs.
A simple example of this kind is shown in the figure to the right. Here, all Transition conditions are true and therefore all Transitions would fire forever at the initial time. This is, however, no valid StateGraph2 model and will result in a translation error, since it is required that a StateGraph2 model has at least one delayed Transition per loop.
This means that one of T1, T2, or T3, must have parameter delayedTransition=<b>true</b>. Since event iteration stops at a delayed Transition, infinite event looping cannot occur. This also means that at one time instant every Transition can fire at most once and therefore the number of model evaluations at an event instant is bounded by the number of Transition components.
</p>

<p>
If you have to artifically introduce a delay time in order to fulfill the requirement above, it is recommended to use the special
<a href=\"modelica://Modelica_StateGraph2.LoopBreakingTransition\">LoopBreakingTransition</a>
that is designed for this case.
</p>

<p>
Note, it is still possible that infinite event looping occurs due to <u>model errors</u> in other parts of the model. For example, if a user introduces an equation of the form &quot;J = <b>pre</b>(J) + 1&quot; outside of a when-clause, event iteration does not stop.
</p>

<p>
There are rare situations, where infinite event looping cannot occur even if there is no delayed transition in a loop. When you do not want to introduce an artifical time delay in a loop in this case, you can switch off the loop check by setting parameter &quot;loopCheck = <b>false</b>&quot; in the &quot;Advanced&quot; tab of the parameter menu of one Transition in this loop.
</p>

</html>"),  Diagram(coordinateSystem(
                preserveAspectRatio=true,
                extent={{-100,-100},{100,100}},
                grid={1,1}), graphics));
        end Transition;

        model Clock
          "Computation of hour and day assuming time = epoch time stamp and no daylight savings"
          parameter Modelica.SIunits.Time timZon = 3600 "Time zone, GMT+1 = 3600 s";

          Modelica.Blocks.Sources.RealExpression hourExp(y=mod((time + timZon)/3600, 24))
            "Hour computation"
            annotation (Placement(transformation(extent={{-20,10},{0,30}})));
          Modelica.Blocks.Interfaces.RealOutput hour "Hour of the day"
            annotation (Placement(transformation(extent={{100,10},{120,30}})));
          Modelica.Blocks.Sources.RealExpression weekDayExp(y=1 + mod((time + timZon)/
                86400 + 3, 7)) "Day computation, monday=1, sunday=7"
            annotation (Placement(transformation(extent={{-20,-30},{0,-10}})));
          Modelica.Blocks.Interfaces.RealOutput weekDay
            "Day of the week, monday=1, sunday=7"
            annotation (Placement(transformation(extent={{100,-30},{120,-10}})));
        equation
          connect(hourExp.y, hour) annotation (Line(points={{1,20},{52,20},{52,20},{110,
                  20}}, color={0,0,127}));
          connect(weekDayExp.y, weekDay)
            annotation (Line(points={{1,-20},{110,-20}}, color={0,0,127}));
          annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                                        Rectangle(
                extent={{-100,-100},{100,100}},
                lineColor={0,0,127},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid), Text(
                extent={{-150,150},{150,110}},
                textString="%name",
                lineColor={0,0,255}),
                Ellipse(extent={{-80,80},{80,-80}}, lineColor={160,160,164},
                  fillColor={215,215,215},
                  fillPattern=FillPattern.Solid),
                Line(points={{0,80},{0,60}}, color={160,160,164}),
                Line(points={{80,0},{60,0}}, color={160,160,164}),
                Line(points={{0,-80},{0,-60}}, color={160,160,164}),
                Line(points={{-80,0},{-60,0}}, color={160,160,164}),
                Line(points={{37,70},{26,50}}, color={160,160,164}),
                Line(points={{70,38},{49,26}}, color={160,160,164}),
                Line(points={{71,-37},{52,-27}}, color={160,160,164}),
                Line(points={{39,-70},{29,-51}}, color={160,160,164}),
                Line(points={{-39,-70},{-29,-52}}, color={160,160,164}),
                Line(points={{-71,-37},{-50,-26}}, color={160,160,164}),
                Line(points={{-71,37},{-54,28}}, color={160,160,164}),
                Line(points={{-38,70},{-28,51}}, color={160,160,164}),
                Line(
                  points={{0,0},{-50,50}},
                  thickness=0.5),
                Line(
                  points={{0,0},{40,0}},
                  thickness=0.5)}),                                      Diagram(
                coordinateSystem(preserveAspectRatio=false)));
        end Clock;
      end Components;

      expandable connector SignalBus "Data bus that stores signal data"
        extends Modelica.Icons.SignalBus;

      //   Boolean HP_onoff "heat pumps on or off";
      //   Integer HP1_signal "heat pump 1 signal";
      //   Integer HP2_signal "heat pump 2 signal";
      //   Real P0102_mod "percentage of rpm of pump 01/02";
      //   Real P03_mod "signal for pump 03";
      //   Integer P04_signal "signal for pump 04";
      //   Real P05_mod "modulation for pump 05";
      //   Integer P06_signal "signal for pump 06";
      //   Integer P07_signal "signal for pump 07";
      //   Integer P08_signal "signal for pump 08";
      //   Integer P09_signal "signal for pump 09";
      //   Integer P13_signal "signal for pupmp 13";
      //   Boolean heatMode "heating mode signal";
      //   Boolean coolMode "cooling mode signal";
      //   Boolean restMode "rest mode signal";
      //   Real CT_signal "cooling tower signal";
      //   Modelica.SIunits.Temperature Twet "wet bulb temperature";
      //   Real TABS_3way_signal "TABS mixing 3 way valve signal";
      //   Real HP_3way_signal "Bypass when HP is turned off";
      //   Real PC_3way_signal "two way valves for choosing between heating, cooling or rest";
      //   Real HeaCoi_3way_signal(start=0) "3 way valve mixing heating coil for VAV";
      //   Real CooCoi_3way_signal(start=0) "3 way valve mixing cooling coil for VAV";
      //   Real[4] CCA3_valve_signal "signal for two-way valve of 3rd floor CCA";
      //   Real CCA3_val "DETAILED signal for 2way valve 3rd floor CCA";
      //   Real[7] CCA2_valve_signal "signal for two-way valve of 2nd floor CCA";
      //   Real CCA2_val "DETAILED signal for 2way valve 2nd floor CCA";
      //   Real[9] CCA1_valve_signal "signal for two-way valve of 1st floor CCA";
      //   Real CCA1_val "DETAILED signal for 2way valve 1st floor CCA";
      //   Real[15] CCA0_valve_signal "signal for two-way valve of ground floor CCA";
      //   Real CCA0_val "DETAILED signal for 2way valve ground floor CCA";
      //   Boolean TABSheatingDemand "TABS heating demand";
      //   Boolean TABScoolingDemand "TABS cooling demand";
      //   Boolean AHUheatingDemand "AHU heating demand";
      //   Boolean AHUcoolingDemand "AHU cooling demand";
      //   Boolean VAVheatingDemand "VAV global heating demand";
      //   Boolean VAVcoolingDemand "VAV global cooling demand";
      //   Boolean VAVheatingDemandInd[21] "VAV individual heating demand";
      //   Boolean VAVcoolingDemandInd[21] "VAV individual cooling demand";
      //   Boolean heatingDemand "any heating demand on";
      //   Boolean coolingDemand "any cooling demand on";
      //   Boolean CC_2way_signal "two way valves for flow towards cooling circuit";
      //   Boolean Hex_2way_signal "two way valves for flow towards heat exchanger";
      //   Real CC_3way_signal;
      //   Real Hex_3way_signal;
      //   Integer P10_signal "signal for pump 10";
      //   Real P10_real;
      //   Real P11_real;
      //   Integer P11_signal "signal for pump 11";
      //   Real AHUsupply "signal for AHU supply fan";
      //   Real AHUextract "signal for AHU extraction fan";
         Real[15] VAV_signal;
         Real[15] VAV_signal_extract "signal for ventilation extract";
         Real[21] Heacoils_signal(each start=0) "signal for ventilation heating coils";
      //   Modelica.SIunits.Temperature[21] TSupplySetPoints "Supply temperature setpoints";
      //   Modelica.SIunits.Temperature T_TABS "TABS supply water temperature setpoint";
      //   Modelica.SIunits.Temperature T_AHU "air handling unit setpoint";
      //   Real TW_3way_signal "thermal wheel minimum state (no working)";
      //   Real NightVentilation "night ventilation on/off";


        annotation (
          defaultComponentName="weaBus",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-20,2},{22,-2}},
                lineColor={255,204,51},
                lineThickness=0.5)}),
          Documentation(info="<html>
<p>
This component is an expandable connector that is used to implement a bus that contains the weather data.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end SignalBus;

      expandable connector DataBus "Data bus that stores sensor data"
        extends Modelica.Icons.SignalBus;

        Modelica.SIunits.Temperature T1;
        Modelica.SIunits.Temperature T2;
        Modelica.SIunits.Temperature T3;
        Modelica.SIunits.Temperature T4;
        Modelica.SIunits.Temperature T5;
        Modelica.SIunits.Temperature T6;
        Modelica.SIunits.Temperature T7;
        Modelica.SIunits.Temperature T8;
        Modelica.SIunits.Temperature T9;
        Modelica.SIunits.Temperature T10;
        Modelica.SIunits.Temperature T11;
        Modelica.SIunits.Temperature T12;
        Modelica.SIunits.Temperature T13;
        Modelica.SIunits.Temperature T14;
        Modelica.SIunits.Temperature T15;
        Modelica.SIunits.Temperature T16;
        Modelica.SIunits.Temperature T17;
        Modelica.SIunits.Temperature T18;
        Modelica.SIunits.Temperature T19;
        Modelica.SIunits.Temperature T20;
        Modelica.SIunits.Temperature T21;
        Modelica.SIunits.Temperature T22;
        Modelica.SIunits.Temperature T23;
        Modelica.SIunits.Temperature T24;
        Modelica.SIunits.Temperature T25;
        Modelica.SIunits.Temperature T26;
        Modelica.SIunits.Temperature T27;
        Modelica.SIunits.Temperature T28;
        Modelica.SIunits.Temperature T29;
        Modelica.SIunits.Temperature T30;
        Modelica.SIunits.Temperature T31;
        Modelica.SIunits.Temperature T32;
        Modelica.SIunits.Temperature T33;
        Modelica.SIunits.Temperature T34;
        Modelica.SIunits.Temperature TretCCA0;
        Modelica.SIunits.Temperature TretCCA1;
        Modelica.SIunits.Temperature TretCCA2;
        Modelica.SIunits.Temperature TretCCA3;
        Modelica.SIunits.Temperature TAirSupplyAHU;
        Modelica.SIunits.Temperature TAirExtractAHU;
        Modelica.SIunits.Temperature[21] TAirSupplyVAV;
        //Floor sensors
          //3rdFloor
        Modelica.SIunits.Temperature T3rdFlr_SZ;
        Modelica.SIunits.Temperature T3rdFlr_MTR;
        Modelica.SIunits.Temperature T3rdFlr_CPR;
        Modelica.SIunits.Temperature T3rdFlr_SmaR;
          //2ndFloor
        Modelica.SIunits.Temperature T2ndFlr_NZ;
        Modelica.SIunits.Temperature T2ndFlr_SZ;
        Modelica.SIunits.Temperature T2ndFlr_MT1;
        Modelica.SIunits.Temperature T2ndFlr_MT2;
          //1stFloor
        Modelica.SIunits.Temperature T1stFlr_NZ;
        Modelica.SIunits.Temperature T1stFlr_SZ1;
        Modelica.SIunits.Temperature T1stFlr_SZ2;
        Modelica.SIunits.Temperature T1stFlr_MT1;
        Modelica.SIunits.Temperature T1stFlr_MT2;
          //GndFloor
        Modelica.SIunits.Temperature TGndFlr_SVR;
        Modelica.SIunits.Temperature TGndFlr_1stAid;
        Modelica.SIunits.Temperature TGndFlr_KTR;
        Modelica.SIunits.Temperature TGndFlr_MT1;
        Modelica.SIunits.Temperature TGndFlr_MT2;
        Modelica.SIunits.Temperature TGndFlr_hall;
          //Stairs
        Modelica.SIunits.Temperature TGndFlr_WStairs;
        Modelica.SIunits.Temperature TGndFlr_EStairs;
          //3rdFloor
        Real CO2_3rdFlr_SZ;
        Real CO2_3rdFlr_MTR;
        Real CO2_3rdFlr_CPR;
        Real CO2_3rdFlr_SmaR;
          //2ndFloor
        Real CO2_2ndFlr_NZ;
        Real CO2_2ndFlr_SZ;
        Real CO2_2ndFlr_MT1;
        Real CO2_2ndFlr_MT2;
          //1stFloor
        Real CO2_1stFlr_NZ;
        Real CO2_1stFlr_SZ1;
        Real CO2_1stFlr_SZ2;
        Real CO2_1stFlr_MT1;
        Real CO2_1stFlr_MT2;
          //GndFloor
        Real CO2_GndFlr_SVR;
        Real CO2_GndFlr_1stAid;
        Real CO2_GndFlr_KTR;
        Real CO2_GndFlr_MT1;
        Real CO2_GndFlr_MT2;
        Real CO2_GndFlr_hall;
          //Stairs
        Real CO2_GndFlr_WStairs;
        Real CO2_GndFlr_EStairs;

         //Average
        Modelica.SIunits.Temperature Tavg_3rdFlr "average temperature of the 3rd floor";
        Modelica.SIunits.Temperature Tavg_2ndFlr "average temperature of the 2nd floor";
        Modelica.SIunits.Temperature Tavg_1stFlr "average temperature of the 1st floor";
        Modelica.SIunits.Temperature Tavg_GndFlr "average temperature of the ground floor";
        Modelica.SIunits.Temperature Tavg_building  "average temperature of the building";
        //Pump mass flows
        //Modelica.SIunits.MassFlowRate p04_m_flow "current mass flow on pump 04";
        //Modelica.SIunits.MassFlowRate p05_m_flow "current mass flow on pump 05";
        //Modelica.SIunits.MassFlowRate p13_m_flow "current mass flow on pump 13";

        //Mass flow rate to outside in storage room, 1st floor
        //Modelica.SIunits.MassFlowRate m_dist;
        //Mass flow rate to outside in south zone, 3rd floor
        //Modelica.SIunits.MassFlowRate m_dist1;
        //Shading control for building
        Real eastShading2nd "movable east windows shading signal, 2nd floor";
        Real eastShading3rd "movable east windows shading signal, 3rd floor";
        Real southShading "movable south windows shading signal";
        Real westShading "movable west windows shading signal";



        annotation (
          defaultComponentName="weaBus",
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-100,-100},{100,
                  100}}), graphics={Rectangle(
                extent={{-20,2},{22,-2}},
                lineColor={255,204,51},
                lineThickness=0.5)}),
          Documentation(info="<html>
<p>
This component is an expandable connector that is used to implement a bus that contains the weather data.
</p>
</html>",       revisions="<html>
<ul>
<li>
June 25, 2010, by Wangda Zuo:<br/>
First implementation.
</li>
</ul>
</html>"));
      end DataBus;
    end Controllers;

    package Occupancy

      model OccupantwithCalendar

        extends BaseClasses.Occupant(nZones=1);

        parameter Integer id=1 "id-number on extern data references";
        parameter Real RatioConv = 0.67 "Part of Heat Load realted to occupancy describe to convective heat gain";
        parameter Integer profileType[nZones]= fill(0, nZones);

       //parameter String filenameTables = "C:/Users/Administrator/Documents/GitHub/HybridGeotabs/TablesOccupancyInfrax.txt" "File where matrix is stored";
       parameter String filenameTables = Modelica.Utilities.Files.loadResource("modelica://INFRAX/SubSystems/Occupancy/Data/Tables/TablesOccupancyInfrax.txt");
       parameter Integer startYear = 2018;
       parameter Integer startDay = 1;

      //INTERNAL VARIABLES
      // Heat Gain People
        Data.HeatGenerationPeople heatGenerationPeople annotation (Placement(transformation(extent={{-166,60},
                  {-146,80}})));

      //Occupancy Profiles

      //Q_flow
        Real QHeatOccTotal[nZones];

         Occupancy.Data.Schemes.OccupancySchemeOffice occupancyScheme(
          profileType=profileType,
          nZones=nZones,
          filenameTables=filenameTables,
          startYear=startYear,
          startDay=startDay)
          annotation (Placement(transformation(extent={{-140,20},{-72,80}})));
        Modelica.Blocks.Interfaces.RealOutput[nZones] nOcc annotation (Placement(
              transformation(
              extent={{-10,-10},{10,10}},
              rotation=90,
              origin={-56,110})));
      equation

      for i in 1:nZones loop
        QHeatOccTotal[i]=occupancyScheme.nOcc[i]*heatGenerationPeople.OfficeActivitiesTyping;
        heatPortCon[i].Q_flow = RatioConv*QHeatOccTotal[i];
        heatPortRad[i].Q_flow = (1-RatioConv)*QHeatOccTotal[i];
       end for;

        connect(occupancyScheme.nOcc, nOcc) annotation (Line(points={{-69.28,71},{-56,
                71},{-56,110}}, color={0,0,127}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-200,
                  -100},{200,100}}),
                               graphics={
              Rectangle(
                extent={{-200,100},{200,-100}},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid,
                lineColor={191,0,0}),
              Line(
                points={{200,100},{200,-100}},
                color={85,170,255},
                smooth=Smooth.None),
              Polygon(
                points={{-10,-38},{-10,42},{50,2},{-10,-38}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineThickness=0.5),
              Rectangle(
                extent={{70,42},{50,-38}},
                lineColor={0,0,0},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid,
                lineThickness=0.5),
              Text(
                extent={{-28,32},{34,-28}},
                lineColor={0,0,0},
                fillColor={95,95,95},
                fillPattern=FillPattern.Solid,
                textStyle={TextStyle.Italic},
                fontName="Bookman Old Style",
                textString="?"),
              Line(
                points={{-200,20},{-20,20}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{-200,-20},{-20,-20}},
                color={127,0,0},
                smooth=Smooth.None),
              Line(
                points={{0,100},{0,52}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash),
              Line(
                points={{60,100},{60,52}},
                color={0,0,127},
                smooth=Smooth.None,
                pattern=LinePattern.Dash),
              Line(
                points={{210,0},{80,0}},
                color={85,170,255},
                smooth=Smooth.None)}), Diagram(coordinateSystem(preserveAspectRatio=false,
                extent={{-200,-100},{200,100}})));
      end OccupantwithCalendar;

      model Appliances
        "this is a model to estimate the appliances in Infrax (computers, screens, copiers...)"

        // {9,0,8,0,0,7,7,6,6,0,5,5,5,4,4,0,0,0,0,1,2,3,0,0,0,0,0}

        parameter Modelica.SIunits.HeatFlowRate OpePC = 75
        "Heat flow produced by a operating computer";
        parameter Modelica.SIunits.HeatFlowRate StaPC = 30
        "Heat flow produced by a stand-by computer";
        parameter Modelica.SIunits.HeatFlowRate OpeMon = 80
        "Heat flow produced by a operating monitor";
        parameter Modelica.SIunits.HeatFlowRate StaMon = 0
        "Heat flow produced by a stand-by monitor";
        parameter Modelica.SIunits.HeatFlowRate IdlOffCop = 300
        "Heat flow produced by a office copier (idle)";
        parameter Modelica.SIunits.HeatFlowRate IdlDesCop = 20
        "Heat flow produced by a desktop copier (idle)";
        parameter Modelica.SIunits.HeatFlowRate IdlOffPrt = 125
        "Heat flow produced by a office printer (idle)";
        parameter Modelica.SIunits.HeatFlowRate IdlDesPrt = 35
        "Heat flow produced by a desktop printer (idle)";
        parameter Modelica.SIunits.HeatFlowRate prjScr = 150
        "Heat flow produced by a projector screen";

        parameter Modelica.SIunits.HeatFlowRate micWav = 750
        "Heat flow produced by a microwave";
        parameter Modelica.SIunits.HeatFlowRate SouCoo = 120
        "Heat flow produced by a soup cooker";
        parameter Modelica.SIunits.HeatFlowRate CofMch = 450
        "Heat flow produced by a coffee machine";
        parameter Modelica.SIunits.HeatFlowRate WatCoo = 350
        "Heat flow produced by a water cooler";
        parameter Modelica.SIunits.HeatFlowRate dishWash = 350
        "Heat flow produced by a dishwasher";
        parameter Modelica.SIunits.HeatFlowRate srvUnit = 800
        "Heat flow produced by the servers";
        parameter Modelica.SIunits.HeatFlowRate fridge = 400
        "Heat flow produced by a fridge";


        parameter Real fraRad = 0.3
        "radiant heat transfer fraction for computer+monitor and copier";


      //3rd Floor

      //Bathroom and small room -- no internal gains



        Real AppGains[27];

        Modelica.Blocks.Interfaces.RealInput[27] nOcc
        "Occupant number input for different zones"
          annotation (Placement(
              transformation(
              extent={{20,-20},{-20,20}},
              rotation=90,
              origin={30,100})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[27] conv
        "Heat port for convective heat transfer"
          annotation (Placement(transformation(extent={{90,10},{110,30}})));
        Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a[27] rad
        "Heat port for radiative heat transfer"
          annotation (Placement(transformation(extent={{90,-30},{110,-10}})));
        Modelica.Blocks.Sources.RealExpression appliances[27](y=AppGains)
          annotation (Placement(transformation(extent={{-60,-10},{-40,10}})));
        Modelica.Blocks.Math.Gain gainCon[27](k=1 - fraRad)
          annotation (Placement(transformation(extent={{-4,10},{16,30}})));
        Modelica.Blocks.Math.Gain gainRad[27](k=fraRad)
          annotation (Placement(transformation(extent={{-2,-30},{18,-10}})));
        Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow heaCon[27]
          annotation (Placement(transformation(extent={{40,10},{60,30}})));
        Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow heaRad[27]
          annotation (Placement(transformation(extent={{42,-30},{62,-10}})));
      equation
        AppGains[1] = nOcc[1]*(OpePC + OpeMon) + (17-nOcc[1])*(StaPC + StaMon)+WatCoo;
        AppGains[2] = IdlOffCop*2 + IdlOffPrt*2;
        AppGains[3] = nOcc[3]*(OpePC)+ prjScr+OpeMon;
        AppGains[4] = IdlDesPrt +IdlDesCop + 2*(StaPC + StaMon)+prjScr+OpeMon;
        AppGains[5] = 0;
        AppGains[6] = nOcc[6]/3*(OpePC + OpeMon) + 1/3*(17-nOcc[6])*(StaPC + StaMon)+CofMch+dishWash;
        AppGains[7] = nOcc[7]*2/3*(OpePC+OpeMon) + 2/3*(17-nOcc[7])*(StaPC + StaMon)+WatCoo;
        AppGains[8] = nOcc[8]*(OpePC)+prjScr+OpeMon;
        AppGains[9] = nOcc[9]*(OpePC)+prjScr+OpeMon;
        AppGains[10] = 0;
        AppGains[11] = nOcc[11]/3*(OpePC + OpeMon) + 1/3*(17-nOcc[11])*(StaPC + StaMon) + 2*IdlDesPrt+IdlDesCop;
        AppGains[12] = nOcc[12]/3*(OpePC + OpeMon) + 1/3*(17-nOcc[12])*(StaPC + StaMon) + 2*IdlDesPrt+IdlDesCop+WatCoo+CofMch;
        AppGains[13] = nOcc[13]/3*(OpePC + OpeMon) + 1/3*(17-nOcc[13])*(StaPC + StaMon) + 2*IdlDesPrt+IdlDesCop+WatCoo+CofMch;
        AppGains[14] = nOcc[14]*(OpePC)+prjScr+OpeMon;
        AppGains[15] = nOcc[15]*(OpePC)+prjScr+OpeMon;
        AppGains[16] = CofMch + WatCoo + IdlDesPrt + IdlDesCop+dishWash;
        AppGains[17] = 0;
        AppGains[18] = srvUnit;
        AppGains[19] = 0;
        if nOcc[20] > 0 then AppGains[20] = 3*micWav + 2*SouCoo + 2*CofMch+ 3*WatCoo+2*dishWash+2*fridge; else AppGains[20] = 2*CofMch+3*WatCoo+2*fridge; end if;
        AppGains[21] = nOcc[21]*(OpePC)+prjScr+OpeMon+2*WatCoo+CofMch;
        AppGains[22] = nOcc[22]*(OpePC)+prjScr+OpeMon+2*WatCoo+CofMch;
        AppGains[23] = IdlDesPrt + IdlDesCop + OpePC + OpeMon + 3*WatCoo;
        AppGains[24] = 0;
        AppGains[25] = 0;
        AppGains[26] = 0;
        AppGains[27] = 0;

        connect(heaCon.port, conv)
          annotation (Line(points={{60,20},{100,20}}, color={191,0,0}));
        connect(heaRad.port, rad)
          annotation (Line(points={{62,-20},{100,-20}}, color={191,0,0}));
        connect(heaRad.Q_flow, gainRad.y)
          annotation (Line(points={{42,-20},{19,-20}}, color={0,0,127}));
        connect(heaCon.Q_flow, gainCon.y)
          annotation (Line(points={{40,20},{17,20}}, color={0,0,127}));
        connect(appliances.y, gainCon.u) annotation (Line(points={{-39,0},{-22,0},{-22,
                20},{-6,20}}, color={0,0,127}));
        connect(appliances.y, gainRad.u) annotation (Line(points={{-39,0},{-22,0},{-22,
                -20},{-4,-20}}, color={0,0,127}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
              Rectangle(
                extent={{-100,100},{100,-100}},
                lineColor={28,108,200},
                fillColor={255,255,255},
                fillPattern=FillPattern.Solid),
              Rectangle(
                extent={{-56,66},{62,-26}},
                lineColor={28,108,200},
                fillColor={255,255,255},
                fillPattern=FillPattern.None),
              Rectangle(
                extent={{-46,58},{52,-18}},
                lineColor={28,108,200},
                fillColor={255,255,255},
                fillPattern=FillPattern.None),
              Rectangle(
                extent={{-74,-26},{86,-76}},
                lineColor={28,108,200},
                fillColor={255,255,255},
                fillPattern=FillPattern.None),
              Rectangle(
                extent={{-70,-30},{82,-72}},
                lineColor={28,108,200},
                fillColor={255,255,255},
                fillPattern=FillPattern.None),
              Text(
                extent={{-28,42},{36,2}},
                lineColor={28,108,200},
                fillColor={255,255,255},
                fillPattern=FillPattern.None,
                textString="PC")}),                                    Diagram(
              coordinateSystem(preserveAspectRatio=false)));
      end Appliances;

      package Data

        record HeatGenerationPeople "Based on ASHRAE Fundamentals 2013"
        extends Modelica.Icons.Record;

        parameter Modelica.SIunits.Area surfaceAreaBody= 1.8;

        //HeatGeneration [W/person]
        parameter Modelica.SIunits.Power  Sleeping= 41*surfaceAreaBody;
        parameter Modelica.SIunits.Power  Reclining= 45*surfaceAreaBody;
        parameter Modelica.SIunits.Power  SeatedQuiet= 60*surfaceAreaBody;
        parameter Modelica.SIunits.Power  StandingRelaxed= 70*surfaceAreaBody;

        parameter Modelica.SIunits.Power  Walking1=115*surfaceAreaBody "3.2 km/h (0.9 m/s)";
        parameter Modelica.SIunits.Power  Walking2=150*surfaceAreaBody "4.3 km/h (1.2 m/s)";
        parameter Modelica.SIunits.Power  Walking3=220*surfaceAreaBody "6.4 km/h (1.8 m/s)";

        parameter Modelica.SIunits.Power  OfficeActivitiesReading= 55*surfaceAreaBody;
        parameter Modelica.SIunits.Power  OfficeActivitiesWriting= 60*surfaceAreaBody;
        parameter Modelica.SIunits.Power  OfficeActivitiesTyping= 65*surfaceAreaBody;
        parameter Modelica.SIunits.Power  OfficeActivitiesFiling_seated=70*surfaceAreaBody;
        parameter Modelica.SIunits.Power  OfficeActivitiesFiling_standing=80*surfaceAreaBody;
        parameter Modelica.SIunits.Power  OfficeActivitiesWalking= 100*surfaceAreaBody;
        parameter Modelica.SIunits.Power  OfficeActivitiesLifting= 120*surfaceAreaBody;

        //Drving
        parameter Modelica.SIunits.Power Car = 60*surfaceAreaBody "60 -115";

        //Miscellaneous Occupational Activities
        parameter Modelica.SIunits.Power Cooking = 100*surfaceAreaBody "95 -115";
        parameter Modelica.SIunits.Power Housecleaning = 120*surfaceAreaBody "115-200";
        parameter Modelica.SIunits.Power Seated = 130*surfaceAreaBody "heavy limb movement";
        parameter Modelica.SIunits.Power MachineWork = 105*surfaceAreaBody;
        parameter Modelica.SIunits.Power MachineWorkSawing = 105*surfaceAreaBody "table saw";
        parameter Modelica.SIunits.Power MachineWorkLight = 120*surfaceAreaBody "electrical industry: 115-140";
        parameter Modelica.SIunits.Power MachineWorkHeavy = 235*surfaceAreaBody;

        //Miscellaneous Leisure Activities
        parameter Modelica.SIunits.Power Dancing = 150*surfaceAreaBody "140-255";
        parameter Modelica.SIunits.Power exercise=175*surfaceAreaBody "175-235";
        parameter Modelica.SIunits.Power Tennis=210*surfaceAreaBody "210-270";
        parameter Modelica.SIunits.Power Basketball = 290*surfaceAreaBody "290-440";
        parameter Modelica.SIunits.Power Wrestling= 410*surfaceAreaBody "410-505";

         annotation (
            Icon(coordinateSystem(preserveAspectRatio=false)),
            Diagram(coordinateSystem(preserveAspectRatio=false)),
            Documentation(info="<html>
<table cellspacing=\"2\" cellpadding=\"0\" border=\"0\"><tr>
<td><pre>Activity</td>
<td>Activity Level [W/m&sup2;] </td>
<td>met[-] </td>
</tr>
<tr>
<td>Resting</td>
<td></td>
<td></td>
</tr>
<tr>
<td> 
Sleeping</td>
<td>40</td>
<td>0.7</td>
</tr>
<tr>
<td>Reclining</td>
<td>45</td>
<td>0.8</td>
</tr>
<tr>
<td>Seated, quiet</td>
<td>60</td>
<td>1</td>
</tr>
<tr>
<td>Standing, relaxed</td>
<td>70</td>
<td>1.2</td>
</tr>
<tr>
<td>Walking (on level surface)</td>
<td></td>
<td></td>
</tr>
<tr>
<td> 
3.2 km/h (0.9 m/s)</td>
<td>115</td>
<td>2</td>
</tr>
<tr>
<td>4.3 km/h (1.2 m/s)</td>
<td>150</td>
<td>2.6</td>
</tr>
<tr>
<td>6.4 km/h (1.8 m/s)</td>
<td>220</td>
<td>3.8</td>
</tr>
<tr>
<td>Office Activities</td>
<td></td>
<td></td>
</tr>
<tr>
<td> 
Reading, seated</td>
<td>55</td>
<td>1</td>
</tr>
<tr>
<td>Writing</td>
<td>60</td>
<td>1</td>
</tr>
<tr>
<td>Typing</td>
<td>65</td>
<td>1.1</td>
</tr>
<tr>
<td>Filing, seated</td>
<td>70</td>
<td>1.2</td>
</tr>
<tr>
<td>Filing, standing</td>
<td>80</td>
<td>1.4</td>
</tr>
<tr>
<td>Walking about</td>
<td>100</td>
<td>1.7</td>
</tr>
<tr>
<td>Lifting/packing</td>
<td>120</td>
<td>2.1</td>
</tr>
<tr>
<td>Miscellaneous Occupational Activities</td>
<td></td>
<td></td>
</tr>
<tr>
<td> 
Cooking</td>
<td>95 to 115</td>
<td>1.6 to 2.0</td>
</tr>
<tr>
<td>Housecleaning</td>
<td>115 to 200</td>
<td>2.0 to 3.4</td>
</tr>
<tr>
<td>Seated, heavy limb movement</td>
<td>130</td>
<td>2.2</td>
</tr>
<tr>
<td>Machine work</td>
<td>105</td>
<td>1.8</td>
</tr>
<tr>
<td>sawing (table saw)</td>
<td>115 to 140</td>
<td>2.0 to 2.4</td>
</tr>
<tr>
<td>light (electrical industry)</td>
<td>235</td>
<td>4</td>
</tr>
<tr>
<td>Handling 50 kg bags</td>
<td>235</td>
<td>4</td>
</tr>
<tr>
<td>Pick and shovel work</td>
<td>235 to 280</td>
<td>4.0 to 4.8</td>
</tr>
<tr>
<td>Miscellaneous Leisure Activities</td>
<td></td>
<td></td>
</tr>
<tr>
<td> 
Dancing, social</td>
<td>140 to 255</td>
<td>2.4 to 4.4</td>
</tr>
<tr>
<td>Calisthenics/exercise</td>
<td>175 to 235</td>
<td>3.0 to 4.0</td>
</tr>
<tr>
<td>Tennis, singles</td>
<td>210 to 270</td>
<td>3.6 to 4.0</td>
</tr>
<tr>
<td>Basketball, competitive</td>
<td>290 to 440</td>
<td>5.0 to 7.6</td>
</tr>
<tr>
<td>Wrestling, competitive</td>
<td>410 to 505</td>
<td>7.0 to 8.7</pre></td>
</tr>
</table>
</html>"));
        end HeatGenerationPeople;

        package Schemes

          model OccupancySchemeOffice

          //Based on InfraxBuildingDilbeek

          //INPUTS AND PARAMETERS
            parameter Integer nZones "Total Number of Floor Levels";
            parameter Integer profileType[nZones]  "Profile type of the zone 
    0= no occupants,
    1 = Kitchen, 
    2 = Flr 0 MT1
    3 = Flr 0 MT2
    4 = Fl 1 Small Meeting Rooms
    5 = Fl 1 Landscape office (SouthZone and Northzone)
    6 = Fl 2 Small Meeting Rooms
    7 = Fl 2 Landscape Office
    8 = Fl 2 Meeting Room Atomium
    9 = Fl 2 Landscape Office
";

           //parameter String filenameTables = "C:/Users/Administrator/Documents/GitHub/HybridGeotabs/TablesOccupancyInfrax.txt" "File where matrix is stored";
            parameter String filenameTables = "C:/Users/u0112721/Documents/Dymola/hybridGEOTABS/INFRAX/SubSystems/Occupancy/Data/Tables/TablesOccupancyInfrax.txt";
           parameter Integer startYear = 2018;
           parameter Integer startDay = 1;

          //OUTPUTS
           Modelica.Blocks.Interfaces.RealOutput nOcc[nZones] "Total Number of Occupants for each zone"
              annotation (Placement(transformation(extent={{98,60},{118,80}})));

          //INTERNAL VARIABLES
            Modelica.Blocks.Logical.LessThreshold Weekday(each threshold=5.5)
              annotation (Placement(transformation(extent={{-56,82},{-48,90}})));
            Modelica.Blocks.Logical.And buildingOpen
              annotation (Placement(transformation(extent={{-6,64},{14,84}})));
            Modelica.Blocks.Sources.CombiTimeTable
                                              Holidays(
              table=[0,0; 1,0; 1.00001,1; 121,1; 121.00001,0; 122,0; 122.00001,1; 202,1; 202.00001,
                  0; 203,0; 203.00001,1; 227,1; 227.00001,0; 228,0; 228.00001,1; 305,1; 305.00001,
                  0; 306,0; 306.00001,1; 315,1; 315.00001,0; 316,0; 316.00001,1; 359,1; 359.00001,
                  0; 360,0; 360.00001,1; 366,1],
              smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments,
              extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
              startTime=startTime,
              timeScale=86400)
              annotation (Placement(transformation(extent={{-60,48},{-40,68}})));
            Modelica.Blocks.Math.RealToBoolean realToBoolean
              annotation (Placement(transformation(extent={{-30,54},{-20,64}})));
            Modelica.Blocks.Sources.CombiTimeTable Kitchen(
              tableOnFile=true,
              tableName="Kitchen",
              fileName=filenameTables,
              timeScale = 3600,
              extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
              startTime=startHour,
              smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments)
              annotation (Placement(transformation(extent={{-60,8},{-48,20}})));
            Modelica.Blocks.Sources.CombiTimeTable LargeMeetingRoom_MT1(
              tableOnFile=true,
              fileName=filenameTables,
              timeScale=3600,
              extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
              tableName="0_MT1",
              startTime=startHour,
              smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments)
              annotation (Placement(transformation(extent={{-40,8},{-28,20}})));
            Modelica.Blocks.Sources.CombiTimeTable LargeMeetingRoom_MT2(
              tableOnFile=true,
              fileName=filenameTables,
              timeScale=3600,
              extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
              tableName="0_MT2",
              startTime=startHour,
              smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments)
              annotation (Placement(transformation(extent={{-20,8},{-8,20}})));
            Modelica.Blocks.Sources.CombiTimeTable Flr1_SmallMeetingRooms(
              tableOnFile=true,
              fileName=filenameTables,
              timeScale=3600,
              extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
              tableName="1_SmallMR",
              startTime=startHour,
              smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments)
              annotation (Placement(transformation(extent={{-60,-24},{-48,-12}})));
            Modelica.Blocks.Sources.CombiTimeTable Flr1_LandscapeOffice(
              tableOnFile=true,
              fileName=filenameTables,
              timeScale=3600,
              extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
              tableName="1_LandscapeOffice",
              startTime=startHour,
              smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments)
              annotation (Placement(transformation(extent={{-40,-24},{-28,-12}})));
            Modelica.Blocks.Sources.CombiTimeTable Flr2_SmallMeetingRooms1(
              tableOnFile=true,
              fileName=filenameTables,
              timeScale=3600,
              extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
              tableName="2_SmallMR",
              startTime=startHour,
              smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments)
              annotation (Placement(transformation(extent={{-60,-52},{-48,-40}})));
            Modelica.Blocks.Sources.CombiTimeTable Flr2_LandscapeOffice1(
              tableOnFile=true,
              fileName=filenameTables,
              timeScale=3600,
              extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
              tableName="2_LandscapeOffice",
              startTime=startHour,
              smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments)
              annotation (Placement(transformation(extent={{-40,-52},{-28,-40}})));
            Modelica.Blocks.Sources.CombiTimeTable Flr3_MeetingRoomAtomium(
              tableOnFile=true,
              fileName=filenameTables,
              timeScale=3600,
              extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
              tableName="3_MR_Atomium",
              startTime=startHour,
              smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments)
              annotation (Placement(transformation(extent={{-60,-84},{-48,-72}})));
            Modelica.Blocks.Sources.CombiTimeTable Flr3_LandscapeOffice(
              tableOnFile=true,
              fileName=filenameTables,
              timeScale=3600,
              extrapolation=Modelica.Blocks.Types.Extrapolation.Periodic,
              tableName="3_LandscapeOffice",
              startTime(displayUnit="s") = startHour,
              smoothness=Modelica.Blocks.Types.Smoothness.ConstantSegments)
              annotation (Placement(transformation(extent={{-40,-84},{-28,-72}})));

            IDEAS.Utilities.Time.CalendarTime calTim(zerTim=IDEAS.Utilities.Time.Types.ZeroTime.UnixTimeStamp)
              annotation (Placement(transformation(extent={{-96,72},{-76,92}})));
            Modelica.Blocks.Math.IntegerToReal integerToReal
              annotation (Placement(transformation(extent={{-68,82},{-60,90}})));

            parameter Modelica.SIunits.Time startHour(fixed=false);
            parameter Modelica.SIunits.Time startTime(fixed=false);

          initial equation
            startHour = 3600*24*(calTim.weekDay-1);
            startTime = time;
          equation

          for i in 1:nZones loop
              if profileType[i]==0 then
                nOcc[i] = 0;
              elseif profileType[i]==1 then
                nOcc[i] =if buildingOpen.y then Kitchen.y[1] else 0;
              elseif profileType[i]==2 then
                nOcc[i] =if buildingOpen.y then LargeMeetingRoom_MT1.y[1] else 0;
              elseif profileType[i]==3 then
                nOcc[i] =if buildingOpen.y then LargeMeetingRoom_MT2.y[1] else 0;
              elseif profileType[i]==4 then
                nOcc[i] =if buildingOpen.y then Flr1_SmallMeetingRooms.y[1] else 0;
              elseif profileType[i]==5 then
                nOcc[i] =if buildingOpen.y then Flr1_LandscapeOffice.y[1] else 0;
              elseif profileType[i]==6 then
                nOcc[i] =if buildingOpen.y then Flr2_SmallMeetingRooms1.y[1] else 0;
              elseif profileType[i]==7 then
                nOcc[i] =if buildingOpen.y then Flr2_LandscapeOffice1.y[1] else 0;
              elseif profileType[i]==8 then
                nOcc[i] =if buildingOpen.y then Flr3_MeetingRoomAtomium.y[1] else 0;
              elseif profileType[i]==9 then
                nOcc[i] =if buildingOpen.y then Flr3_LandscapeOffice.y[1] else 0;
              else
                nOcc[i] = 0;
              end if;
          end for;

            connect(Weekday.y, buildingOpen.u1) annotation (Line(points={{-47.6,86},{-28,86},
                    {-28,74},{-8,74}}, color={255,0,255}));
            connect(realToBoolean.y, buildingOpen.u2)
              annotation (Line(points={{-19.5,59},{-8,59},{-8,66}}, color={255,0,255}));
            connect(integerToReal.y, Weekday.u)
              annotation (Line(points={{-59.6,86},{-56.8,86}}, color={0,0,127}));
            connect(calTim.weekDay, integerToReal.u) annotation (Line(points={{-75,77},{-68.8,
                    77},{-68.8,86}}, color={255,127,0}));
            connect(Holidays.y[1], realToBoolean.u) annotation (Line(points={{-39,58},{-34,
                    58},{-34,59},{-31,59}}, color={0,0,127}));
            annotation (Icon(coordinateSystem(preserveAspectRatio=false), graphics={
                    Rectangle(extent={{-92,92},{90,-94}}, lineColor={28,108,200}), Text(
                    extent={{-70,80},{80,46}},
                    lineColor={28,108,200},
                    textString="Name")}),                                  Diagram(
                  coordinateSystem(preserveAspectRatio=false), graphics={
                  Text(
                    extent={{-64,94},{-30,94}},
                    lineColor={28,108,200},
                    textString="Weekday/Weekend"),
                  Rectangle(extent={{-98,98},{94,36}},    lineColor={28,108,200}),
                  Text(
                    extent={{-62,76},{-36,76}},
                    lineColor={28,108,200},
                    textString="Fixed Hollidays"),
                  Rectangle(extent={{-66,32},{94,-96}},   lineColor={28,108,200}),
                  Text(
                    extent={{-72,-4},{-26,-4}},
                    lineColor={28,108,200},
                    textString="FIRST FLOOR LEVEL"),
                  Text(
                    extent={{-74,26},{-28,26}},
                    lineColor={28,108,200},
                    textString="GROUND FLOOR"),
                  Text(
                    extent={{56,94},{92,94}},
                    lineColor={28,108,200},
                    textString="AMOUNT OF OCCUPANTS"),
                  Text(
                    extent={{-44,82},{-18,82}},
                    lineColor={28,108,200},
                    textString="1 Week December"),
                  Text(
                    extent={{58,26},{94,26}},
                    lineColor={28,108,200},
                    textString="OCCUPANCY PROFILES
(check excel)"),  Text(
                    extent={{-70,-34},{-24,-34}},
                    lineColor={28,108,200},
                    textString="SECOND FLOOR LEVEL"),
                  Text(
                    extent={{-72,-66},{-26,-66}},
                    lineColor={28,108,200},
                    textString="THIRD FLOOR LEVEL")}),
              Documentation(info="<html>
<p><code>Based on CO2 measurements in the Infrax Building Dilbeek</code></p>
</html>"));
          end OccupancySchemeOffice;
          annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
                coordinateSystem(preserveAspectRatio=false)));
        end Schemes;
      end Data;

      package BaseClasses

        partial model Occupant
          extends IDEAS.Templates.Interfaces.BaseClasses.Occupant(nLoads=1);
          parameter Modelica.SIunits.Temperature TSet_val[nZones] = fill(273.15 + 17, nZones)
            "Set point temperature";

          //Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow prescribedHeatFlowRad[nZones](each Q_flow=0)
          //Modelica.Thermal.HeatTransfer.Sources.FixedHeatFlow prescribedHeatFlowCon[nZones](each Q_flow=0)

        equation
          TSet = TSet_val;
          mDHW60C = 0;

          //connect(prescribedHeatFlowCon.port, heatPortCon) annotation (Line(points={{-180,20},{-200,20}}, color={191,0,0}));
         // connect(prescribedHeatFlowRad.port, heatPortRad) annotation (Line(points={{-178,-20},{-200,-20}}, color={191,0,0}));
                                                                                            annotation (Placement(transformation(extent={{-158,-30},{-178,-10}})),
                                                                                                        Placement(transformation(extent={{-160,10},{-180,30}})),
                      Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(coordinateSystem(preserveAspectRatio=false)));
        end Occupant;
        annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(coordinateSystem(preserveAspectRatio=false)));
      end BaseClasses;
    end Occupancy;
  end SubSystems;

  package Air

    package Comfort

      model Limits
        parameter Integer nZones=13;
        parameter Integer typeLimit=1 "1 = Temp limits EN16798, 2 = Office - Frequency analysis, 3 = Libeznice, 4 = Ter Poterie";
        Modelica.Blocks.Interfaces.RealOutput THardUp(each unit="K", each displayUnit="degC") "Upper hard limit" annotation (Placement(transformation(extent={{140,70},{170,100}})));
        Modelica.Blocks.Interfaces.RealOutput TSoftUp(each unit="K", each displayUnit="degC")
          "Upper soft limit"                                                                                     annotation (Placement(transformation(extent={{140,4},{170,34}}), iconTransformation(extent={{140,4},{170,34}})));
        Modelica.Blocks.Interfaces.RealOutput TSoftDown(each unit="K", each displayUnit="degC") "Lower soft limit" annotation (Placement(transformation(extent={{140,-56},{170,-26}}), iconTransformation(extent={{140,-56},{170,-26}})));
        Modelica.Blocks.Interfaces.RealOutput THardDown(each unit="K", each displayUnit="degC") "Lower hard limit" annotation (Placement(transformation(extent={{140,
                  -116},{170,-86}}),                                                                                                                                                    iconTransformation(extent={{140,
                  -116},{170,-86}})));
        CtrlLimits ctrlLimits(minOT=minOT, maxOT=maxOT)               annotation (Placement(transformation(extent={{-20,-40},{0,-20}})));
        outer IDEAS.BoundaryConditions.SimInfoManager
                                                    sim annotation (Placement(transformation(extent={{-60,60},{-40,80}})));
        Modelica.Blocks.Interfaces.RealInput TSensor[nZones](each unit="K",each displayUnit = "degC") "Operative temperature from zones"    annotation (Placement(transformation(extent={{-140,-60},{-100,-20}}), iconTransformation(extent={{-140,-60},{-100,-20}})));
        Real intOverh[nZones] "DeltadegC*hour out of the hard limit (forbidden zone, overheat)";
        Real intOverhSoft[nZones] "DeltadegC*hour between the soft limit and the hard limit (only accepted overheat)";
        Real intUnderSoft[nZones] "DeltadegC*hour out of the soft limit and the hard limit (only accepted underheat)";
        Real intUnder[nZones] "DeltadegC*hour out of the hard limit (forbidden zone, underheat)";
        Modelica.Blocks.Interfaces.RealOutput totalOverHeat "DeltadegC*hour out of the hard limit (forbidden zone, overheat)" annotation (Placement(transformation(extent={{-100,40},{-120,60}})));
        Modelica.Blocks.Interfaces.RealOutput totalOverhSoft "DeltadegC*hour between the soft limit and the hard limit (only accepted overheat)" annotation (Placement(transformation(extent={{-100,0},{-120,20}})));
        Modelica.Blocks.Interfaces.RealOutput totalUndeHeatSoft "DeltadegC*hour out of the soft limit and the hard limit (only accepted underheat)" annotation (Placement(transformation(extent={{-100,-90},{-120,-70}}), iconTransformation(extent={{-100,-90},{-120,-70}})));
        Modelica.Blocks.Interfaces.RealOutput totalUnderHeat "DeltadegC*hour out of the hard limit (forbidden zone, underheat)" annotation (Placement(transformation(extent={{-100,-120},{-120,-100}}), iconTransformation(extent={{-100,-120},{-120,-100}})));
        parameter Real minOT=10 + 273.15 "Minimum outside temperature";
        parameter Real maxOT=15 + 273.15 "Maximum outside temperature";
        Modelica.Blocks.Interfaces.RealOutput Tavg(each unit="K", each displayUnit=
              "degC") "Average setpoint" annotation (Placement(transformation(extent=
                  {{140,-26},{170,4}}), iconTransformation(extent={{140,-20},{158,-2}})));
        Modelica.Blocks.Sources.RealExpression realExpression(y=(TSoftUp + TSoftDown)
              /2) annotation (Placement(transformation(extent={{78,-22},{102,0}})));
        INFRAX.SubSystems.Controllers.Components.Clock
                                   clock
          annotation (Placement(transformation(extent={{0,60},{20,80}})));
      equation
        for i in 1:nZones loop
          if TSensor[i]>THardUp then
            der(intOverh[i])=(TSensor[i]-THardUp)/3600;
            der(intOverhSoft[i])=0;
            der(intUnderSoft[i])=0;
            der(intUnder[i])=0;
          elseif TSensor[i]>TSoftUp then
            der(intOverh[i])=0;
            der(intOverhSoft[i])=(TSensor[i]-TSoftUp)/3600;
            der(intUnderSoft[i])=0;
            der(intUnder[i])=0;
          elseif TSensor[i]<THardDown then
            der(intOverh[i])=0;
            der(intOverhSoft[i])=0;
            der(intUnderSoft[i])=0;
            der(intUnder[i])=(THardDown-TSensor[i])/3600;
          elseif TSensor[i]<TSoftDown then
            der(intOverh[i])=0;
            der(intOverhSoft[i])=0;
            der(intUnderSoft[i])=(TSoftDown-TSensor[i])/3600;
            der(intUnder[i])=0;
          else
            der(intOverh[i])=0;
            der(intOverhSoft[i])=0;
            der(intUnderSoft[i])=0;
            der(intUnder[i])=0;
          end if;
        end for;

        totalOverHeat = sum(intOverh[:]);
        totalOverhSoft = sum(intOverhSoft[:]);
        totalUndeHeatSoft = sum(intUnderSoft[:]);
        totalUnderHeat=sum(intUnder[:]);

        // Set the values for the different kinds of control
        THardUp = if (clock.hour >= 5 and clock.hour < 19) and (clock.weekDay) < 6 then ctrlLimits.limValue[typeLimit, 1] else ctrlLimits.limValue[typeLimit, 1] + 5;
        TSoftUp = if (clock.hour >= 5 and clock.hour < 19) and (clock.weekDay) < 6 then ctrlLimits.limValue[typeLimit, 2] else ctrlLimits.limValue[typeLimit, 2] + 5;
        TSoftDown = if (clock.hour >= 5 and clock.hour < 19) and (clock.weekDay) < 6 then ctrlLimits.limValue[typeLimit, 3] else ctrlLimits.limValue[typeLimit, 3] - 5;
        THardDown = if (clock.hour >= 5 and clock.hour < 19) and (clock.weekDay) < 6 then ctrlLimits.limValue[typeLimit, 4] else ctrlLimits.limValue[typeLimit, 4] - 5;
        //limits = if ctrlLimits.RMOT < (273.15 + (10 + 15)/2) then ctrlLimits.limValue[typeLimit, 3] else ctrlLimits.limValue[typeLimit, 2];
        connect(Tavg, realExpression.y) annotation (Line(points={{155,-11},{130,-11},
                {130,-11},{103.2,-11}}, color={0,0,127}));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-160},{140,100}}),
                                                                      graphics={
              Rectangle(
                extent={{-100,104},{140,-160}},
                pattern=LinePattern.None,
                lineThickness=0.5,
                fillColor={255,249,235},
                fillPattern=FillPattern.Solid,
                lineColor={0,0,0}),
              Polygon(
                points={{140,-158},{140,-58},{32,-58},{-22,-100},{-100,-100},{-100,-158},{140,-158}},
                fillColor={170,213,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Polygon(
                points={{-100,100},{-100,0},{-22,0},{32,42},{140,42},{140,100},{-100,100}},
                fillColor={255,170,170},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Polygon(
                points={{-100,100},{-100,22},{-22,22},{32,64},{140,64},{140,100},{-100,100}},
                fillColor={238,46,47},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Polygon(
                points={{140,-160},{140,-80},{32,-80},{-22,-122},{-100,-122},{-100,-160},{140,-160}},
                fillColor={28,108,200},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Line(
                points={{-100,0},{-22,0},{32,42},{140,42}},
                color={238,46,47},
                thickness=0.5,
                pattern=LinePattern.Dot),
              Line(
                points={{-100,-100},{-22,-100},{32,-58},{140,-58}},
                color={28,108,200},
                thickness=0.5,
                pattern=LinePattern.Dot),
              Line(
                points={{-102,-40},{-94,-40},{-88,-36},{-72,24},{-50,12},{-38,-34},{-28,76},{-4,66},{4,-54},{8,-102},{30,-70},{42,8},{46,-114},{86,-138},{140,-6}},
                color={255,0,255},
                thickness=0.5,
                smooth=Smooth.Bezier),
              Ellipse(
                extent={{-22,56},{-10,44}},
                lineThickness=0.5,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Line(
                points={{-20,50},{-100,50}},
                color={0,0,0}),
              Line(
                points={{-68,10},{-100,10}},
                color={0,0,0}),
              Ellipse(
                extent={{-70,16},{-58,4}},
                lineThickness=0.5,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Ellipse(
                extent={{8,-74},{20,-86}},
                lineThickness=0.5,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Line(
                points={{10,-80},{-100,-80}},
                color={0,0,0}),
              Ellipse(
                extent={{64,-104},{76,-116}},
                lineThickness=0.5,
                fillColor={0,0,0},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None,
                lineColor={0,0,0}),
              Line(
                points={{66,-110},{-100,-110}},
                color={0,0,0}),
              Polygon(
                points={{-120,-26},{-94,-40},{-120,-54},{-120,-26}},
                lineThickness=0.5,
                fillColor={255,0,255},
                fillPattern=FillPattern.Solid,
                pattern=LinePattern.None),
              Line(
                points={{102,70},{112,86},{146,86}},
                color={0,0,0},
                thickness=0.5),
              Ellipse(
                extent={{94,70},{106,58}},
                lineThickness=0.5,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Line(
                points={{102,-86},{112,-102},{146,-102}},
                color={0,0,0},
                thickness=0.5),
              Ellipse(
                extent={{94,-86},{106,-74}},
                lineThickness=0.5,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{94,-52},{106,-64}},
                lineThickness=0.5,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Ellipse(
                extent={{94,36},{106,48}},
                lineThickness=0.5,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid),
              Line(
                points={{102,-52},{112,-36},{146,-36}},
                color={0,0,0},
                thickness=0.5),
              Line(
                points={{102,36},{112,20},{146,20}},
                color={0,0,0},
                thickness=0.5)}),                                      Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-160},{140,100}})));
      end Limits;

      model CtrlLimits "1 = Temp limits EN16798, 2 = Office - Frequency analysis, 3 = Libeznice, 4 = Ter Poterie"
        IDEAS.Controls.ControlHeating.RunningMeanTemperatureEN15251 rmot annotation (Placement(transformation(extent={{-100,0},{-60,20}})));
        outer IDEAS.BoundaryConditions.SimInfoManager                 sim annotation (Placement(transformation(extent={{-88,70},{-68,90}})));
        Modelica.Blocks.Interfaces.RealOutput limValue[4,4](each unit="K",each displayUnit = "degC") "Each type of limit has 4: TMaxSoft, TMaxHard, TminHard, TminSoft"
                                                                                                     annotation (Placement(transformation(extent={{100,-90},{120,-70}})));
        parameter Real minOT(each unit="K",each displayUnit = "degC")=10+273.15 "Minimum outside temperature";
        parameter Real maxOT(each unit="K",each displayUnit = "degC")=15+273.15 "Maximum outside temperature";
        parameter Real limits[4,8](each unit="K",each displayUnit = "degC")=
             [24, 23, 21, 20, 25.5, 25, 23.5, 23;
              23.5, 23, 21, 20.5, 26, 25.5, 23.5, 23;
              24.5, 24, 22, 21.5, 27, 26.5, 24.5, 24;
              24.5, 24, 22, 21.5, 26, 25.5, 23.5, 23].+273.15 "Limits winter and summer: WMs, WMh, Wmh, Wms, SMs, SMh, Smh, Sms";
        Modelica.Blocks.Interfaces.RealOutput RMOT(each unit="K", each displayUnit="degC") "Running mean outdoor temperature"
                                                                                           annotation (Placement(transformation(extent={{100,50},{120,70}})));
      equation
        for i in 1:4 loop // i = type of limit (1 = Temp limits EN16798, 2 = Office - Frequency analysis, 3 = Libeznice, 4 = Ter Poterie)
          for j in 1:4 loop // j = curves. Each type of limit has 4: TMaxSoft, TMaxHard, TminHard, TminSoft.
             if rmot.TRm <= minOT then
              limValue[i,j]=limits[i,j];
             elseif rmot.TRm >= maxOT then
              limValue[i,j]=limits[i,j+4];
             else
              limValue[i,j]=limits[i,j]+(limits[i,j+4]-limits[i,j])*(rmot.TRm-minOT)/(maxOT-minOT);
             end if;
          end for;
        end for;
        RMOT=rmot.TRm;
        annotation (Icon(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,80}}), graphics={Rectangle(
                extent={{-100,80},{100,-100}},
                pattern=LinePattern.None,
                lineColor={0,0,0},
                fillColor={215,215,215},
                fillPattern=FillPattern.Solid), Text(
                extent={{-100,80},{100,-100}},
                lineColor={28,108,200},
                textString="Ctrl",
                fontName="monospace",
                textStyle={TextStyle.Bold})}),                                                        Diagram(coordinateSystem(preserveAspectRatio=false, extent={{-100,-100},{100,100}})),
          experiment(StopTime=94694400));
      end CtrlLimits;
    end Comfort;
  end Air;

  package Data

    package Parameters

      record Structure
        extends Modelica.Icons.Record;

        final constant Real pi=Modelica.Constants.pi;
        //Total building height
        parameter Modelica.SIunits.Height h = 15;

        //Windows
        parameter Modelica.SIunits.Height WindowHeight = 2.69;
        parameter Modelica.SIunits.Area WindowA = WindowHeight*(0.025+0.08+0.29+0.08+0.055+0.765+0.065);
        parameter Modelica.SIunits.Area WindowB = WindowHeight*(0.025+0.08+0.735+0.08+0.06+0.315+0.07);
        parameter Modelica.SIunits.Area WindowC = WindowHeight*(0.065+1.23+0.065);
        parameter Modelica.SIunits.Area WindowD = WindowHeight*(0.065+0.73+0.065);
        parameter Modelica.SIunits.Area GlazingA = 0.29*(WindowHeight-0.12-0.12)+0.765*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingB = 0.735*(WindowHeight-0.08-0.105)+0.31*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingC = 1.23*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingD = 0.73*(WindowHeight-0.05-0.075);

        //Stairs areas
        parameter Modelica.SIunits.Area A_westStair = 4.8*4.85 "area of the western stairs";
        parameter Modelica.SIunits.Area A_eastStair = 5*2.55 "area of the eastern stairs";
        parameter Modelica.SIunits.Area AWindows_westStair = 3*WindowD + 2.1*2.04;
        parameter Modelica.SIunits.Area AWindows_eastStair = 1.8*(4.35+2.91);
        parameter Modelica.SIunits.Volume Vol_westStair = A_westStair*h;
        parameter Modelica.SIunits.Volume Vol_eastStair = A_eastStair*h;

        //Basement parameters (garage)
        parameter Modelica.SIunits.Height HeightFlr = 2.60;
        parameter Modelica.SIunits.Area A_Grg = 28.8*32.6+13.08*(32.6+5.7)/2;
        parameter Modelica.SIunits.Area A_Grg_OutRoof = 28.8*16.3+5.4*16.3/2 "area of the garage roof facing the exterior";
        parameter Modelica.SIunits.Area AWall_Grg_Soil = (13.08+5.7+28.8+32.6+28.8)*HeightFlr "wall of the basement in contact with the soil";
        parameter Modelica.SIunits.Area AWall_Grg_Out = 40.47*HeightFlr
                                                                       "wall of the basement facing the west outdoor";

        //koepels
        parameter Modelica.SIunits.Area A_stairs_koepel = 1.3*0.8;

        //Areas between floors (TABS loops)
        //   Floor 3 loops
        parameter Modelica.SIunits.Area A_3rdFlr_SZ = (11*32.3+(4.75+0.4)*1.1);
        parameter Modelica.SIunits.Area A_3rdFlr_CPR = 5.15*(4.2+0.4);
        parameter Modelica.SIunits.Area A_3rdFlr_MTR = 7.8*5.0;
        parameter Modelica.SIunits.Area A_3rdFlr_SmaR = 2.63*5.0;
        //   Floor 2 and 3
        parameter Modelica.SIunits.Area A_2NZ_3SZ = 1.25*(5.15+0.3+7.8+0.3+5.15);
        parameter Modelica.SIunits.Area A_2NZ_3CPR = 5.15*4.8;
        parameter Modelica.SIunits.Area A_2NZ_3MTR = 5*7.8;
        parameter Modelica.SIunits.Area A_2NZ_3SmaR = 2.63*5;
        parameter Modelica.SIunits.Area A_2NZ_3StoR = 5*2.56;
        parameter Modelica.SIunits.Area A_2SZ_3SZ = (4.6*1.9+(16.2-4.6)*10.75+18.85*6.75+1.35*3.294+2.65*4.347);
        parameter Modelica.SIunits.Area A_2MT1_3SZ = 3.84*3.2;
        parameter Modelica.SIunits.Area A_2MT2_3SZ = 3.84*3.2;
        parameter Modelica.SIunits.Area A_2CPR_3SZ = 3.2*(3.49+4.84);
        parameter Modelica.SIunits.Area A_2BRZ_3BRZ = 3.55*4.3;
        //    Floor 1 and 2
        parameter Modelica.SIunits.Area A_1NZ_2NZ = 18.7*(4.75+1.5) "same as area of NZ 1 and 2";
        parameter Modelica.SIunits.Area A_1SZ1_2SZ = 1.2*2.7*3 "width 1.2 length three times 2.7";
        parameter Modelica.SIunits.Area A_1SZ2_2SZ = 24.11*6.8+1.35*3.2+2.65*(3.2+1.1)+1.2*2.7 "same as total area of 1stFlr SZ2";
        parameter Modelica.SIunits.Area A_1MT1_2MT1 = 3.84*3.2  "same as area of MT1 in 1 and 2 floors";
        parameter Modelica.SIunits.Area A_1MT2_2MT2 = 3.84*3.2  "same as area of MT2 in 1 and 2 floors";
        parameter Modelica.SIunits.Area A_1BRZ_2BRZ = 3.55*4.3  "same as area of the bathrooms";
        parameter Modelica.SIunits.Area A_1HALL_2SZ = ((1.68+0.3+0.7+1.1+1.2+2.4+0.4+1.12+1.18+2.65)*(4.25+0.12+0.12+5.3+0.8)+1.1*(4.75-0.4)+(4.26+0.12+0.12)*1.36)
                                                                                                                                                                   "same as hall area (str1stFlr) withouth the triangle part";
        //    Floor 0 and 2
        parameter Modelica.SIunits.Area A_hall_2SZ = 6.75*4.50 "glass hollow";

        //    Floor 1 external
        parameter Modelica.SIunits.Area A_Roof1stFlr_hall = Square(7.27+3.18+0.21)*sin(71*pi/180)*cos(71*pi/180)/2;
        parameter Modelica.SIunits.Area A_Roof1stFlr_SZ1 = ((5.4+0.3+1.2)*2.7*4+Square(0.55+4.8+0.95+0.84)*sin(71*pi/180)*cos(71*pi/180)/2)-1.2*2.7*3;

        //    Floor 0 and 1
        parameter Modelica.SIunits.Area A_hall_1SZ2 = 2.05*(4*2.7-3.84)+2.7*6.8;
        parameter Modelica.SIunits.Area A_hall_1hall = ((0.3+0.7+1.1+1.2+2.4+0.4+1.12+1.18+2.65)*(5.3+0.8)+1.1*(4.75-0.4)+Square(5.3+4.75+0.4)/(2*tan(71*pi/180))) "same as 1st Flr hall";
        parameter Modelica.SIunits.Area A_hall_1MT1 = 3.84*2.05;
        parameter Modelica.SIunits.Area A_hall_1SZ1 = ((5.4+0.3+1.2)*2.7*4+1.2*2.7+(4.26+0.12+0.12)*1.36+(4.26+0.12*2)*((5.18+(5.3+4.75+0.4)/tan(71*pi/180))/2))-5.24*3*2.7+2.7*5.24/2;
        parameter Modelica.SIunits.Area A_KT_1SZ2 = 2*2.7*2.7+2.7*(4*1.47+3*1.23+1.58)+9.05*2.7*3-3.84*3.2-5.23*(2.7-(2.55-(3.2-2.05)));
        parameter Modelica.SIunits.Area A_KT_1MT2 = 3.84*3.2 "same as total area of 1st Flr MT2";
        parameter Modelica.SIunits.Area A_KT_1NZ = 5.23*(2.7-(2.55-(3.2-2.05)));
        parameter Modelica.SIunits.Area A_SV_1SZ2 = 5.25*(2.55-(3.2-2.05));
        parameter Modelica.SIunits.Area A_SV_1NZ = 9.28*4.3 + 5.25*(7-4.3)-5.25*(2.55-(3.2-2.05));
        parameter Modelica.SIunits.Area A_Sto_1SZ2 = 3.9*(2.55-(3.2-2.05));
        parameter Modelica.SIunits.Area A_Sto_1NZ = 7.0*3.9+5.23*4.15-3.9*(2.55-(3.2-2.05));
        parameter Modelica.SIunits.Area A_MT1_1SZ1 = 5.24*3*2.7+2.7*5.24/2 "same as total area of Gnd Flr MT1";
        parameter Modelica.SIunits.Area A_MT2_1SZ2 = 4*2.7*6.75 "same as total area of GndFlr MT2";
        parameter Modelica.SIunits.Area A_FirstAid_1NZ1 = 3.84*(2.55-(3.2-2.05));
        parameter Modelica.SIunits.Area A_FirstAid_1MT1 = 3.84*(3.2-2.05);
        parameter Modelica.SIunits.Area A_BRZ_1BRZ = (2.30+2.35+0.15)*4.3;

        parameter Modelica.SIunits.Area A_2Flr_3Flr[8] = {A_2NZ_3SZ,  A_2SZ_3SZ, A_2MT1_3SZ, A_2MT2_3SZ, A_2BRZ_3BRZ, A_2NZ_3CPR, A_2NZ_3MTR, A_2NZ_3SmaR+A_2NZ_3StoR};
        parameter Modelica.SIunits.Area A_1Flr_2Flr[7] = {A_1NZ_2NZ, A_1SZ1_2SZ, A_1SZ2_2SZ, A_1MT1_2MT1, A_1MT2_2MT2, A_1BRZ_2BRZ, A_1HALL_2SZ};
        parameter Modelica.SIunits.Area A_GndFlr_1stFlr[16] = {A_hall_1SZ2, A_hall_1hall, A_hall_1MT1, A_hall_1SZ1, A_KT_1SZ2, A_KT_1MT2, A_KT_1NZ, A_SV_1SZ2, A_SV_1NZ, A_Sto_1SZ2, A_Sto_1NZ, A_MT1_1SZ1, A_MT2_1SZ2, A_FirstAid_1NZ1, A_FirstAid_1MT1, A_BRZ_1BRZ};

        //CCA Areas
        parameter Modelica.SIunits.Area CCA_Areas[35] = {A_3rdFlr_SZ, A_3rdFlr_CPR, A_3rdFlr_MTR, A_3rdFlr_SmaR,
                                                         A_2NZ_3SZ,  A_2SZ_3SZ, A_2MT1_3SZ, A_2MT2_3SZ, A_2NZ_3CPR, A_2NZ_3MTR, A_2NZ_3SmaR+A_2NZ_3StoR,
                                                         A_1NZ_2NZ, A_1SZ1_2SZ, A_1SZ2_2SZ, A_1MT1_2MT1, A_1MT2_2MT2, A_1HALL_2SZ, A_hall_2SZ, A_Roof1stFlr_hall, A_Roof1stFlr_SZ1,
                                                         A_hall_1SZ2, A_hall_1hall, A_hall_1MT1, A_hall_1SZ1, A_KT_1SZ2, A_KT_1MT2, A_KT_1NZ, A_SV_1SZ2, A_SV_1NZ, A_Sto_1SZ2, A_Sto_1NZ, A_MT1_1SZ1, A_MT2_1SZ2, A_FirstAid_1NZ1, A_FirstAid_1MT1};
        parameter Real CCA_paralel_circuits[35] = {46, 3, 5, 3,
                                                   7, 43, 4, 4, 3, 5, 3,
                                                  16, 4, 31, 4, 4, 10, 8, 12, 4,
                                                   8, 9, 4, 6, 14, 4, 2, 2, 3, 2, 5, 6, 10, 2, 2};
        parameter Modelica.SIunits.Area total_CCA_Areas[4] = {sum(CCA_Areas[1:4]), sum(CCA_Areas[5:11]), sum(CCA_Areas[12:20]),sum(CCA_Areas[21:35])};
        parameter Real splitEmb_perFloor[35] = {A_3rdFlr_SZ/total_CCA_Areas[1], A_3rdFlr_CPR/total_CCA_Areas[1], A_3rdFlr_MTR/total_CCA_Areas[1], A_3rdFlr_SmaR/total_CCA_Areas[1],
                                       A_2NZ_3SZ/total_CCA_Areas[2],  A_2SZ_3SZ/total_CCA_Areas[2], A_2MT1_3SZ/total_CCA_Areas[2], A_2MT2_3SZ/total_CCA_Areas[2],
                                       A_2NZ_3CPR/total_CCA_Areas[2], A_2NZ_3MTR/total_CCA_Areas[2], (A_2NZ_3SmaR+A_2NZ_3StoR)/total_CCA_Areas[2],
                                       A_1NZ_2NZ/total_CCA_Areas[3], A_1SZ1_2SZ/total_CCA_Areas[3], A_1SZ2_2SZ/total_CCA_Areas[3], A_1MT1_2MT1/total_CCA_Areas[3],
                                       A_1MT2_2MT2/total_CCA_Areas[3], A_1HALL_2SZ/total_CCA_Areas[3], A_hall_2SZ/total_CCA_Areas[3], A_Roof1stFlr_hall/total_CCA_Areas[3], A_Roof1stFlr_SZ1/total_CCA_Areas[3],
                                       A_hall_1SZ2/total_CCA_Areas[4], A_hall_1hall/total_CCA_Areas[4], A_hall_1MT1/total_CCA_Areas[4], A_hall_1SZ1/total_CCA_Areas[4], A_KT_1SZ2/total_CCA_Areas[4],
                                       A_KT_1MT2/total_CCA_Areas[4], A_KT_1NZ/total_CCA_Areas[4], A_SV_1SZ2/total_CCA_Areas[4], A_SV_1NZ/total_CCA_Areas[4], A_Sto_1SZ2/total_CCA_Areas[4],
                                       A_Sto_1NZ/total_CCA_Areas[4], A_MT1_1SZ1/total_CCA_Areas[4], A_MT2_1SZ2/total_CCA_Areas[4], A_FirstAid_1NZ1/total_CCA_Areas[4], A_FirstAid_1MT1/total_CCA_Areas[4]};
        parameter Modelica.SIunits.Area totalCCA = sum(CCA_Areas);
        parameter Real splitEmb[35] = {A_3rdFlr_SZ/totalCCA,  A_3rdFlr_CPR/totalCCA,  A_3rdFlr_MTR/totalCCA,  A_3rdFlr_SmaR/totalCCA,
                                       A_2NZ_3SZ/totalCCA,   A_2SZ_3SZ/totalCCA,  A_2MT1_3SZ/totalCCA,  A_2MT2_3SZ/totalCCA,
                                       A_2NZ_3CPR/totalCCA,  A_2NZ_3MTR/totalCCA,  (A_2NZ_3SmaR+A_2NZ_3StoR)/totalCCA,
                                       A_1NZ_2NZ/totalCCA,  A_1SZ1_2SZ/totalCCA,  A_1SZ2_2SZ/totalCCA,  A_1MT1_2MT1/totalCCA,
                                       A_1MT2_2MT2/totalCCA,  A_1HALL_2SZ/totalCCA,  A_hall_2SZ/totalCCA,  A_Roof1stFlr_hall/totalCCA,  A_Roof1stFlr_SZ1/totalCCA,
                                       A_hall_1SZ2/totalCCA,  A_hall_1hall/totalCCA,  A_hall_1MT1/totalCCA,  A_hall_1SZ1/totalCCA,  A_KT_1SZ2/totalCCA,
                                       A_KT_1MT2/totalCCA,  A_KT_1NZ/totalCCA,  A_SV_1SZ2/totalCCA,  A_SV_1NZ/totalCCA,  A_Sto_1SZ2/totalCCA,
                                       A_Sto_1NZ/totalCCA,  A_MT1_1SZ1/totalCCA,  A_MT2_1SZ2/totalCCA,  A_FirstAid_1NZ1/totalCCA,  A_FirstAid_1MT1/totalCCA};
        //Function Square declaration
        function Square
          input Real x;
          output Real y;
        algorithm
          y := x*x;
        end Square;

         annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)));
      end Structure;

      record StrGndFlr
        extends Modelica.Icons.Record;

        final constant Real pi=Modelica.Constants.pi;
        parameter Modelica.SIunits.Angle orientation = INFRAX.Data.Orientations.inc;
        parameter Modelica.SIunits.Height WindowHeight = 3.25;
        parameter Modelica.SIunits.Height WindowGndHeight = 2.04;
        parameter Modelica.SIunits.Height HeightGndFlr = 3.5;
        //Angle 71degree with HORIZONTAL

        //OuterWalls and Windows
        parameter Modelica.SIunits.Area WindowA = WindowHeight*(0.025+0.08+0.29+0.08+0.055+0.765+0.065);
        parameter Modelica.SIunits.Area WindowB = WindowHeight*(0.025+0.08+0.735+0.08+0.06+0.315+0.07);
        parameter Modelica.SIunits.Area WindowC = WindowHeight*(0.065+1.23+0.065);
        parameter Modelica.SIunits.Area WindowD = WindowHeight*(0.065+0.73+0.065);
        parameter Modelica.SIunits.Area WindowF = WindowGndHeight*(0.08+0.1+0.52);
        parameter Modelica.SIunits.Area WindowG = WindowGndHeight*(0.06+0.88+0.08+0.08+0.74+0.1+0.08+2.15+0.08+0.12+0.74+0.1);
        parameter Modelica.SIunits.Area WindowH = WindowHeight*(5.7-0.8-0.41);
        parameter Modelica.SIunits.Area WindowI = WindowHeight*(0.05+0.97+0.05+1.6+0.05);
        parameter Modelica.SIunits.Area GlazingA = 0.29*(WindowHeight-0.12-0.12)+0.765*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingB = 0.735*(WindowHeight-0.08-0.105)+0.31*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingC = 1.23*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingD = 0.73*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingE = 2.15*(WindowGndHeight-0.05-0.07)+0.56*(WindowGndHeight-0.085-0.11);
        parameter Modelica.SIunits.Area GlazingF = 0.52*(WindowGndHeight-0.075-0.08);
        parameter Modelica.SIunits.Area GlazingG = 2*0.74*(WindowGndHeight-0.085-0.11)+0.88*(WindowGndHeight-0.05-0.07)+2.15*(WindowGndHeight-0.05-0.07);
        parameter Modelica.SIunits.Area GlazingH = (WindowHeight-0.05)*(5.7-0.8-0.41-0.11);
        parameter Modelica.SIunits.Area GlazingI = (WindowHeight-0.1)*(0.97+1.6);

        //    Kitchen Lunchroom
        parameter Modelica.SIunits.Volume Vol_GndFlr_KT = HeightGndFlr*A_GndFlr_KT "kitchenlunchroom volume";
        parameter Modelica.SIunits.Area A_GndFlr_KT = 2*2.7*2.7+2.7*(4*1.47+3*1.23+1.58)+9.05*2.7*3 "kitchenlunchroom area";
        parameter Modelica.SIunits.Area AWall_GndFlr_KT[2] = HeightGndFlr*{(3*1.23+1.58), (0.67+2.7)} "kitchen lunchroom wall area, excluding windows";
        parameter Modelica.SIunits.Area AWindows_GndFlr_KT[2] = {3*WindowA+WindowC, 3*WindowI};
        parameter Real FrameRatio_GndFlr_KT[2] = {1-(3*GlazingA+GlazingC)/(3*WindowA+WindowC), 1-GlazingI/WindowI};
        //    Hall Reception
        parameter Modelica.SIunits.Volume Vol_GndFlr_HR = (A_GndFlr_HR - 6.75*4.50)*HeightGndFlr + 6.75*4.50*(HeightGndFlr+2.95+0.37+0.45+0.05) "hall and reception volume";
        parameter Modelica.SIunits.Area A_GndFlr_HR = 4*2.7*2.05+2*2.7*2.6+2.7*(0.45+1.22+1.18)+2.7*(0.55+0.33+1.02)+(4*2.7+2.11)*9.25+(0.34+0.15)*3.95+3.95*4.18*cos(71/180*pi)+(3.78+1.02)*(0.5+2.7/2)+(3.78+1.02)*2.7/4 "hall and reception area";
        parameter Modelica.SIunits.Area AWalls_GndFlr_HR= 9.25/sin(71*pi/180)*HeightGndFlr - AWindows_GndFlr_HR[2];
        parameter Modelica.SIunits.Area AWindows_GndFlr_HR[2] = {2.7*3, 3.18*WindowGndHeight+WindowD/WindowHeight}*WindowGndHeight "hall and reception window area";
        //parameter Real FrameRatio_GndFlr_HR "hall and reception frame ratio";
        //    Servers room
        parameter Modelica.SIunits.Volume Vol_GndFlr_SV = A_GndFlr_SV*HeightGndFlr "volume of server rooms";
        parameter Modelica.SIunits.Area A_GndFlr_SV = 9.28*4.3 + 5.25*(7-4.3) "server rooms area";
        parameter Modelica.SIunits.Area AWall_GndFlr_SV = 9.28*HeightGndFlr "server room wall area (no windows)";
        //    MeetingRoom1
        parameter Modelica.SIunits.Volume Vol_GndFlr_MT1 = A_GndFlr_MT1*HeightGndFlr;
        parameter Modelica.SIunits.Area A_GndFlr_MT1 = 5.24*3*2.7+2.7*5.24/2;
        parameter Modelica.SIunits.Area AWall_GndFlr_MT1[3] = {0.8, 5*2.7, 1.13}*HeightGndFlr;
        parameter Modelica.SIunits.Area AWindows_GndFlr_MT1[2] = {(5.24-0.8)*WindowHeight,4.8*WindowGndHeight};
        //    Storage room
        parameter Modelica.SIunits.Volume Vol_GndFlr_Sto = HeightGndFlr*A_GndFlr_Sto "volume of storage rooms";
        parameter Modelica.SIunits.Area A_GndFlr_Sto = 7.0*3.9+5.23*4.15 "area of storage rooms";
        parameter Modelica.SIunits.Area AWall_GndFlr_Sto = (3.9+5.23+0.15)*HeightGndFlr "storage rooms wall area (no windows)";

        //InnerWalls
        parameter Modelica.SIunits.Area AinternalWall_HRSV = HeightGndFlr*5.25;
        parameter Modelica.SIunits.Area AinternalWall_KTSto = 3*2.7*HeightGndFlr;
        parameter Modelica.SIunits.Area AinternalWall_SVSto = 7*HeightGndFlr;
        parameter Modelica.SIunits.Area AinternalWall_HRMT1 = 3*2.7*HeightGndFlr;
        parameter Modelica.SIunits.Area AinternalWall_kitchen_hallway = 2.5*HeightGndFlr;

        //RectangularZones
        //    MeetingRoom2
        parameter Modelica.SIunits.Length l_GndFlr_MT2 = 4*2.7;
        parameter Modelica.SIunits.Length w_GndFlr_MT2 = 6.75;
        parameter Modelica.SIunits.Volume Vol_GndFlr_MT2 = l_GndFlr_MT2*w_GndFlr_MT2*HeightGndFlr;
        parameter Modelica.SIunits.Area AWindows_GndFlr_MT2 = 4*2.7-2*1*HeightGndFlr;
        //    FirstAid Room
        parameter Modelica.SIunits.Length l_GndFlr_1stAid = 3.90;
        parameter Modelica.SIunits.Length w_GndFlr_1stAid = 2.55;
        parameter Modelica.SIunits.Volume Vol_GndFlr_1stAid = l_GndFlr_1stAid*w_GndFlr_1stAid*HeightGndFlr;
        //    BathroomZone
        parameter Modelica.SIunits.Length l_GndFlr_BRZ = 2.30+2.35+0.15;
        parameter Modelica.SIunits.Length w_GndFlr_BRZ = 4.3;
        parameter Modelica.SIunits.Volume Vol_GndFlr_BRZ = w_GndFlr_BRZ*l_GndFlr_BRZ*HeightGndFlr;

        parameter Modelica.SIunits.Volume FlrGnd_TotalVol = Vol_GndFlr_1stAid+Vol_GndFlr_BRZ+Vol_GndFlr_HR+Vol_GndFlr_KT+Vol_GndFlr_MT1+Vol_GndFlr_MT2+Vol_GndFlr_Sto+Vol_GndFlr_SV;

        //    Areas
        parameter Modelica.SIunits.Area Areas_GndFlr[8] = {A_GndFlr_HR, A_GndFlr_MT1, l_GndFlr_MT2*w_GndFlr_MT2, A_GndFlr_KT, A_GndFlr_SV, l_GndFlr_1stAid*w_GndFlr_1stAid, l_GndFlr_BRZ*w_GndFlr_BRZ,A_GndFlr_Sto};

        annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)));
      end StrGndFlr;

      record Str1stFlr
        extends Modelica.Icons.Record;

        final constant Real pi=Modelica.Constants.pi;
        parameter Modelica.SIunits.Angle orientation = INFRAX.Data.Orientations.inc;
        parameter Modelica.SIunits.Height WindowHeight = 2.69;
        parameter Modelica.SIunits.Height WindowHeight1stFlr = 2.42;
        parameter Modelica.SIunits.Height Height1stFlr = 2.95;
        //Angle 71degree with HORIZONTAL

        //OuterWalls and Windows
        parameter Modelica.SIunits.Area WindowA = WindowHeight*(0.025+0.08+0.29+0.08+0.055+0.765+0.065);
        parameter Modelica.SIunits.Area WindowB = WindowHeight*(0.025+0.08+0.735+0.08+0.06+0.315+0.07);
        parameter Modelica.SIunits.Area WindowC = WindowHeight*(0.065+1.23+0.065);
        parameter Modelica.SIunits.Area WindowD = WindowHeight*(0.065+0.73+0.065);
        parameter Modelica.SIunits.Area WindowE = WindowHeight1stFlr*(0.07+2.15+0.12+0.08+0.56+0.105);
        parameter Modelica.SIunits.Area WindowF = WindowHeight1stFlr*(0.08+0.1+0.52);
        parameter Modelica.SIunits.Area WindowG = WindowHeight1stFlr*(0.06+0.88+0.08+0.08+0.74+0.1+0.08+2.15+0.08+0.12+0.74+0.1);
        parameter Modelica.SIunits.Area WindowH = WindowHeight*(5.7-0.8-0.41);
        parameter Modelica.SIunits.Area GlazingA = 0.29*(WindowHeight-0.12-0.12)+0.765*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingB = 0.735*(WindowHeight-0.08-0.105)+0.31*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingC = 1.23*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingD = 0.73*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingE = 2.15*(WindowHeight1stFlr-0.05-0.07)+0.56*(WindowHeight1stFlr-0.085-0.11);
        parameter Modelica.SIunits.Area GlazingF = 0.52*(WindowHeight1stFlr-0.075-0.08);
        parameter Modelica.SIunits.Area GlazingG = 2*0.74*(WindowHeight1stFlr-0.085-0.11)+0.88*(WindowHeight1stFlr-0.05-0.07)+2.15*(WindowHeight1stFlr-0.05-0.07);
        parameter Modelica.SIunits.Area GlazingH = (WindowHeight-0.05)*(5.7-0.8-0.41-0.11);

        parameter Modelica.SIunits.Area Roof1stFlr[2] = {Square(7.27+3.18+0.21)*sin(71*pi/180)*cos(71*pi/180)/2, ((5.4+0.3+1.2)*2.7*4+Square(0.55+4.8+0.95+0.84)*sin(71*pi/180)*cos(71*pi/180)/2)-1.2*2.7*3};
        //    NorthZone
        parameter Modelica.SIunits.Length w_1stFlr_NZ = 4.75+1.5 "north zone width, till meeting rooms";
        parameter Modelica.SIunits.Length l_1stFlr_NZ = 10.66+0.08*3+2.63*2+2.56 "north zone length, north facade";
        parameter Modelica.SIunits.Volume Vol_1stFlr_NZ = Height1stFlr*w_1stFlr_NZ*l_1stFlr_NZ "north zone volume";
        parameter Modelica.SIunits.Area AWall_1stFlr_NZ = Height1stFlr*l_1stFlr_NZ - AWindows_1stFlr_NZ "north zone wall area, excluding windows";
        parameter Modelica.SIunits.Area AWindows_1stFlr_NZ = 7*WindowA;
        parameter Real FrameRatio_1stFlr_NZ = 1-GlazingA/WindowA;

        //    SouthZone1
        parameter Modelica.SIunits.Volume Vol_1stFlr_SZ1= Height1stFlr*((5.4+0.3+1.2)*2.7*4+1.2*2.7+(4.26+0.12+0.12)*1.36+(4.26+0.12*2)*((5.18+(5.3+4.75+0.4)/tan(71*pi/180))/2)) "south zone 1 volume";
        parameter Modelica.SIunits.Area AWall_1stFlr_SZ1[3] = Height1stFlr*{5.7, 2.7*6, 0.55+4.8+0.95+0.84+2/3*7.27} "south zone 1 wall area, excluding windows";
        parameter Modelica.SIunits.Area AWindows_1stFlr_SZ1[3] = {WindowH, WindowC, WindowF + WindowG}; //windowC south, same height on east, east no frame
        parameter Real FrameRatio_1stFlr_SZ1[3] = {1-GlazingH/WindowH, 1-GlazingC/WindowC, 1-(GlazingF+GlazingG)/(WindowF+WindowG)};
        //frame window east: window west:

        //    SouthZone2
        parameter Modelica.SIunits.Volume Vol_1stFlr_SZ2= Height1stFlr*(24.11*6.8+1.35*3.2+2.65*(3.2+1.1)) "south zone 2 volume";
        parameter Modelica.SIunits.Area AWall_1stFlr_SZ2[2] = Height1stFlr*{6.85+3.2+1.1,27} "south zone 2 wall area, excluding windows";
        parameter Modelica.SIunits.Area AWindows_1stFlr_SZ2[2] = {2*WindowC+2*WindowB, 4*WindowC+4*WindowA+WindowB}; //4WindowsB, 5windowA+4windowB
        parameter Modelica.SIunits.Area AGlazing_1stFlr_SZ2[2] = {2*GlazingC+2*GlazingB, 4*(GlazingC+GlazingA)+GlazingB};
        parameter Real FrameRatio_1stFlr_SZ2[2] = {1-AGlazing_1stFlr_SZ2[1]/AWindows_1stFlr_SZ2[1], 1-AGlazing_1stFlr_SZ2[2]/AWindows_1stFlr_SZ2[2]};

        //    hall
        parameter Modelica.SIunits.Volume Vol_1stFlr_hall= Height1stFlr*((0.3+0.7+1.1+1.2+2.4+0.4+1.12+1.18+2.65)*(5.3+0.8)+1.1*(4.75-0.4)+Square(5.3+4.75+0.4)/(2*tan(71*pi/180))) "hall volume";
        parameter Modelica.SIunits.Area AWall_1stFlr_hall[2] = Height1stFlr*{1.1+0.65, 7.27+3.18+0.21+(1.68+0.15)/cos(71*pi/180)} "hall wall area, excluding windows";
        parameter Modelica.SIunits.Area AWindows_1stFlr_hall[2] = {WindowD, WindowE};
        parameter Real FrameRatio_1stFlr_hall[2] = {1-GlazingD/WindowD, 1-GlazingE/WindowE};

        //InnerWalls
        parameter Modelica.SIunits.Area AinternalWallsNZ[2] = Height1stFlr*{0.08+2.51+0.3+2.51+0.08+2.56, 3*(4.75+0.4)};
        parameter Modelica.SIunits.Area AinternalWallsSZ2[2] = Height1stFlr*{3.49+4.84, 3.2*2};
        parameter Modelica.SIunits.Area AinternalWall_NZSZ2 = Height1stFlr*(3.49+4.84);
        parameter Modelica.SIunits.Area AinternalWall_hallSZ1 = Height1stFlr*5.18;

        //RectangularZones
        //    CopyRooms
        parameter Modelica.SIunits.Length l_1stFlr_CPR = 3.49+4.84;
        parameter Modelica.SIunits.Length w_1stFlr_CPR = 3.2;
        parameter Modelica.SIunits.Volume Vol_1stFlr_CPR = w_1stFlr_CPR*l_1stFlr_CPR*Height1stFlr;
        //    MeetingRoom1
        parameter Modelica.SIunits.Length l_1stFlr_MTR1 = 3.84;
        parameter Modelica.SIunits.Length w_1stFlr_MTR1 = 3.2;
        parameter Modelica.SIunits.Volume Vol_1stFlr_MTR1 = w_1stFlr_MTR1*l_1stFlr_MTR1*Height1stFlr;
        //    MeetingRoom2
        parameter Modelica.SIunits.Length l_1stFlr_MTR2 = 3.84;
        parameter Modelica.SIunits.Length w_1stFlr_MTR2 = 3.2;
        parameter Modelica.SIunits.Volume Vol_1stFlr_MTR2 = w_1stFlr_MTR2*l_1stFlr_MTR2*Height1stFlr;
        //    BathroomZone
        parameter Modelica.SIunits.Length l_1stFlr_BRZ = 3.55;
        parameter Modelica.SIunits.Length w_1stFlr_BRZ = 4.2+0.1;
        parameter Modelica.SIunits.Volume Vol_1stFlr_BRZ = l_1stFlr_BRZ*w_1stFlr_BRZ*Height1stFlr;

        //GlassHollow
        parameter Modelica.SIunits.Length l_1stFlr_GH = 6.75;
        parameter Modelica.SIunits.Length w_1stFlr_GH = 4.5;
        parameter Modelica.SIunits.Volume Vol_1stFlr_GH = l_1stFlr_GH*w_1stFlr_GH*Height1stFlr;

        parameter Modelica.SIunits.Volume Flr1st_TotalVol = Vol_1stFlr_BRZ+Vol_1stFlr_CPR+Vol_1stFlr_GH+Vol_1stFlr_hall+Vol_1stFlr_MTR1+Vol_1stFlr_MTR2+Vol_1stFlr_NZ+Vol_1stFlr_SZ1+Vol_1stFlr_SZ2;

        //Function Square declaration
        function Square
          input Real x;
          output Real y;
        algorithm
          y := x*x;
        end Square;
        annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)));
      end Str1stFlr;

      record Air "parameters for air system"
        extends Modelica.Icons.Record;
        //VAV and ducts - supply
        //Values are taken from commisioning tests when possible, otherwise nominal values are used
        parameter Modelica.SIunits.MassFlowRate m_nominal_supply_duct[7] = {167, 100, 50, 450, 150, 90, 70}*1.225/3600;
        //1 MTR_3rdFlr, 2 Server Room, 3 EHBO, 4 hall, 5 reception, 6 westStairs, 7 eastStairs
        parameter Modelica.SIunits.MassFlowRate m_nominal_supply_vav[15] = {1664.33333333333, 298, 300, 330, 1321, 377, 365, 531, 392, 913, 386, 347, 3307.5, 970, 1613}*1.225/3600;
        parameter Modelica.SIunits.MassFlowRate m_nominal_supply_vav_min[15] = {650, 0, 0, 330, 550, 0, 0, 0, 0, 650, 0, 0, 200, 0, 0}*1.225/3600; //minimum value for some of the VAVs, NZ with fixed value (PID)
        parameter Real heaDamper[15] = {0, 0.5, 0.3, 1, 0.2, 0.2, 0.2, 1, 1, 0.25, 0.05, 0.05, 0.5, 0.4, 0.25}; //damper position under heating demand
        parameter Modelica.SIunits.TemperatureDifference openHea[21] = {-1, -2, -2, -2, -1.2, -2, -2, -1, -0.5, 0, -2, -2, -0.3, -0.5, -0.5, -1, -1, -1, -1, -1, -1}; //value which activates heating coil demand in ducts with VAV
        parameter Modelica.SIunits.TemperatureDifference closeHea[21] = {-0.5, -1.2, -1.2, -1.2, 1.3, -1.2, -1.2, 0, 0.5, 1.5, -1.2, 0, -0.2, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5}; //value which deactivates heating coil demand in ducts with VAV
        parameter Modelica.SIunits.Temperature openCoo[15] = {1, 1.5, 1.5, 100, 1.5, 1.5, 1.5, 100, 1.5, 1.5, 1.3, 1.3, 1.5, 2, 1}; //parameter which activates vav cooling flow demand in ducts with VAV
        parameter Modelica.SIunits.Temperature closeCoo[15] = {0.5, 1.3, 1.3, 100, 1.3, 1.3, 1.3, 100, 1.3, 1.3, 1.3, 1.3, 1.3, -0.5, -1}; //parameter which deactivates vav cooling flow demand in ducts with VAV
        //1 SZ_3rdFlr, 2 CPR_3rdFlr, 3 SmaR_3rdFlr, 4 NZ_2ndFlr, 5 SZ_2ndFlr, 6 MT1_2ndFlr, 7 MT2_2ndFlr,
        //8 NZ_1stFlr, 9 SZ1_1stFlr, 10 SZ2_1stFlr, 11 MT1_1stFlr, 12 MT2_1stFlr, 13 KT_GndFlr, 14 MT1_GndFlr, 15 MT2_GndFlr

        //VAV and ducts - extract
        //Values are taken from commisioning tests when possible, otherwise nominal values are used
        parameter Modelica.SIunits.MassFlowRate m_nominal_extract_duct[10] = {150, 200, 200, 100, 50, 250, 150, 100, 90, 70}*1.225/3600;
        //1 MTR_3rdFlr, 2 CPR_3rdFlr, 3 SmaR_3rdFlr, 4 server room, 5 EHBO, 6 storage room, 7 hall, 8 reception,  9 westStairs, 10 eastStairs
        parameter Modelica.SIunits.MassFlowRate m_nominal_extract_vav[14] = {862, 370, 250, 338, 1065, 284, 260, 492, 966.5, 309, 265, 2850, 982, 1600}*1.225/3600;
        parameter Modelica.SIunits.MassFlowRate m_nominal_extract_vav_min[14] = {0, 0, 0, 0, 300, 0, 0, 0, 300, 0, 0, 0, 0, 0}*1.225/3600; //minimum value for some of the VAVs
        //1 SZ_3rdFlr, 2 CPR_3rdFlr, 3 SmaR_3rdFlr, 4 NZ_2ndFlr, 5 SZ_2ndFlr, 6 MT1_2ndFlr, 7 MT2_2ndFlr,
        //8 NZ_1stFlr, 9 SZ2_1stFlr, 10 MT1_1stFlr, 11 MT2_1stFlr, 12 KT_GndFlr, 13 MT1_GndFlr, 14 MT2_GndFlr

        //Air heating coils
        //Code: 1 SZ_3rdFlr, 2 CPR_3rdFlr, 3 MTR_3rdFlr, 4 SmaR_3rdFlr, 5 NZ_2ndFlr, 6 SZ_2ndFlr, 7 MT1_2ndFlr, 8 MT2_2ndFlr,
        // 9 NZ_1stFlr, 10 SZ1_1stFlr, 11 SZ2_1stFlr, 12 MT1_1stFlr, 13 MT2_1stFlr, 14 reception, 15 EHBO, 16 KT, 17 MT1, 18 MT2,
        // 19 hall, 20 westStairs, 21 eastStairs
        parameter Modelica.SIunits.Pressure dp_water[21] = {18000, 2000, 3000, 2000, 5000, 13000, 2000, 2000, 8000, 5000, 5000, 2000, 2000, 3000, 3000, 8000, 6000, 17000, 5000, 1000, 1000}; //heating coils pressure drop on water side
        parameter Modelica.SIunits.MassFlowRate m_nominal_water[21] = {0.32, 0.06, 0.03, 0.06, 0.07, 0.28, 0.06, 0.06, 0.11, 0.08, 0.16, 0.06, 0.06, 0.03, 0.01, 0.61, 0.18, 0.32, 0.09, 0.02, 0.02}; //nominal mass flow on water side
        //parameter Modelica.SIunits.MassFlowRate m_nominal_water2[21] = {0.325, 0.061111, 0.030556, 0.061111, 0.072222, 0.283333, 0.061111, 0.061111, 0.111111, 0.080556, 0.161111, 0.061111, 0.061111, 0.030556, 0.011111, 0.65, 0.183333, 0.325, 0.091667, 0.013889, 0.013389}; //nominal mass flow on water side
        parameter Modelica.SIunits.MassFlowRate m_nominal_air[21] = {1664.33333333333, 298, 167, 300, 330, 1321, 377, 365, 531, 392, 913, 386, 347, 150, 50, 3307.5, 970, 1613, 450, 70, 70}*1.225/3600; //nominal mass flow rate on air side;
        parameter Modelica.SIunits.Power Q_nominal[21] = {5440, 1020, 510, 1020, 1190, 4760, 1020, 1020, 1870, 1360, 2720, 1020, 1020, 510, 170, 10880, 3060, 5440, 1530, 238, 238}; //power of the heating coils
        parameter Real R[21] = {100, 50, 50, 50, 50, 100, 50, 50, 50, 50, 100, 50, 50, 50, 50, 100, 100, 100, 50, 50, 50}; //rangeability
        parameter Modelica.SIunits.Pressure dp_3wayvalves[21] = {31000, 3970, 13000, 3970, 5410, 24000, 3970, 3970, 12380, 7070, 7680, 3970, 3970, 13000, 1480, 13360, 9720, 31000, 8940, 1480, 1480};
        parameter Real Kv[21] = (m_nominal_water.*(3600/1000))./(sqrt(dp_3wayvalves./100000)); //Kv value for 3 way valves
        parameter Real real_m_nominal_water[21] = {0.32, 0.06, 0.03, 0.06, 0.07, 0.28, 0.06, 0.06, 0.11, 0.08, 0.16, 0.06, 0.06, 0.03, 0.03, 0.61, 0.18, 0.32, 0.09, 0.02, 0.02};
        parameter Modelica.SIunits.Pressure dp_fixed_supply[21] = {3300, 6600, 6800, 6400, 6100, 3000, 5700, 5900, 5400, 3500, 3700, 5000, 5200, 2600, 3200, 8800, 3300, 4200, 3600, 8600, 2900};
        parameter Modelica.SIunits.Pressure dp_fixed_return[21] = {3900, 43700, 31400, 43900, 39700, 16200, 44500, 44300, 30500, 40700, 39900, 45300, 45100, 35600, 50500, 26000, 37200, 3000, 38700, 45100, 50800};
        parameter Modelica.SIunits.Temperature TWatSup_nominal = 273.15 + 32;
        parameter Modelica.SIunits.Temperature TWatRet_nominal = 273.15 + 28;
        parameter Modelica.SIunits.Temperature TAirSup_nominal = 273.15 + 15;
        parameter Modelica.SIunits.Temperature TAirRet_nominal = 273.15 + 25;

        parameter Real k[21] = {2, 2, 2, 2, 2, 2, 2, 5, 10, 5, 2, 2, 2, 5, 5, 2, 2, 2, 2, 2, 2};
        parameter Modelica.SIunits.Time[21] Ti = {100, 100, 100, 100, 100, 100, 100, 100, 120, 60, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100};

            annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)));
      end Air;

      record Str2ndFlr
        extends Modelica.Icons.Record;

        //OuterWalls and Windows
        parameter Modelica.SIunits.Height WindowHeight = 2.69;
        parameter Modelica.SIunits.Height Height2ndFlr = 2.95;
        parameter Modelica.SIunits.Area WindowA = WindowHeight*(0.025+0.08+0.29+0.08+0.055+0.765+0.065);
        parameter Modelica.SIunits.Area WindowB = WindowHeight*(0.025+0.08+0.735+0.08+0.06+0.315+0.07);
        parameter Modelica.SIunits.Area WindowC = WindowHeight*(0.065+1.23+0.065);
        parameter Modelica.SIunits.Area WindowD = WindowHeight*(0.065+0.73+0.065);
        parameter Modelica.SIunits.Area GlazingA = 0.29*(WindowHeight-0.12-0.12)+0.765*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingB = 0.735*(WindowHeight-0.08-0.105)+0.31*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingC = 1.23*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingD = 0.73*(WindowHeight-0.05-0.075);
        //    NorthZone
        parameter Modelica.SIunits.Length w_2ndFlr_NZ = 4.75+1.5 "north zone width, till meeting rooms";
        parameter Modelica.SIunits.Length l_2ndFlr_NZ = 5.15+0.3+7.8+0.3+5.15 "north zone length, north facade";
        parameter Modelica.SIunits.Volume Vol_2ndFlr_NZ = Height2ndFlr*w_2ndFlr_NZ*l_2ndFlr_NZ "north zone volume";
        parameter Modelica.SIunits.Area AWall_2ndFlr_NZ = Height2ndFlr*l_2ndFlr_NZ - AWindows_2ndFlr_NZ "north zone wall area, excluding windows";
        parameter Modelica.SIunits.Area AWindows_2ndFlr_NZ = 7*WindowA;
        parameter Real FrameRatio_2ndFlr_NZ = 1-GlazingA/WindowA;
        //    SouthZone
        parameter Real azi_2ndFlr_SZ[4] = {INFRAX.Data.Orientations.N,INFRAX.Data.Orientations.E,
            INFRAX.Data.Orientations.S,INFRAX.Data.Orientations.W};
        parameter Real inc_2ndFlr_SZ[4] = {IDEAS.Types.Tilt.Wall,IDEAS.Types.Tilt.Wall,IDEAS.Types.Tilt.Wall,IDEAS.Types.Tilt.Wall};
        parameter Modelica.SIunits.Volume Vol_2ndFlr_SZ = Height2ndFlr*(11*2.65+1.35*3.2+6.8*(5.15+0.3+7.8+0.3+5.15+0.16+0.16)+11*(0.7+1.1+1.2+2.4+0.4+1.12+1.18+2.65)+1.1*(4.75+0.4));
        parameter Modelica.SIunits.Volume Vol_2ndFlr_SZ2 = Vol_2ndFlr_SZ + 3.2*(4.84+3.49)*Height2ndFlr;
        parameter Modelica.SIunits.Area AWall_2ndFlr_SZ[4] = Height2ndFlr*{1.9, 11, 32.3, 11+4.75+0.4} - AWindows_2ndFlr_SZ;
        parameter Modelica.SIunits.Area AWindows_2ndFlr_SZ[4] = {WindowD, 3*WindowC+WindowB, 5*(WindowC+WindowA)+WindowC, 2*(WindowC+WindowB)};
        parameter Modelica.SIunits.Area AGlazing_2ndFlr_SZ[4] = {GlazingD, 3*GlazingC+GlazingB, 5*(GlazingC+GlazingA)+GlazingC, 2*(GlazingC+GlazingB)};
        parameter Real FrameRatio_2ndFlr_SZ[4] = {1 - AGlazing_2ndFlr_SZ[1]/AWindows_2ndFlr_SZ[1], 1 - AGlazing_2ndFlr_SZ[2]/AWindows_2ndFlr_SZ[2],  1 - AGlazing_2ndFlr_SZ[3]/AWindows_2ndFlr_SZ[3], 1 - AGlazing_2ndFlr_SZ[4]/AWindows_2ndFlr_SZ[4]};

        //InnerWalls
        parameter Modelica.SIunits.Area AglassWall = 3.2*2*Height2ndFlr;
        parameter Modelica.SIunits.Area AinternalWalls[2] = Height2ndFlr*{4.84+3.49, 3.2*2};
        parameter Modelica.SIunits.Area Awall_NZSZ = Height2ndFlr*(4.84+3.49);

        //RectangularZones
        //    BathroomZone
        parameter Modelica.SIunits.Length l_2ndFlr_BRZ = 3.55;
        parameter Modelica.SIunits.Length w_2ndFlr_BRZ = 2.25+0.2+1.65+0.2;
        parameter Modelica.SIunits.Volume Vol_2ndFlr_BRZ = l_2ndFlr_BRZ*w_2ndFlr_BRZ*Height2ndFlr;
        //    MeetingRoom1
        parameter Modelica.SIunits.Length l_2ndFlr_MTR1 = 3.84;
        parameter Modelica.SIunits.Length w_2ndFlr_MTR1 = 3.2;
        parameter Modelica.SIunits.Volume Vol_2ndFlr_MTR1 = w_2ndFlr_MTR1*l_2ndFlr_MTR1*Height2ndFlr;
        parameter Modelica.SIunits.Area AWindows_2ndFlr_MTR1 = 2*1*Height2ndFlr;
        parameter Modelica.SIunits.Area AGlazing_2ndFlr_MTR1 = 2*0.9*(Height2ndFlr-0.1);
        parameter Real FrameRatio_2ndFlr_MTR1 = 1 - AGlazing_2ndFlr_MTR1/AWindows_2ndFlr_MTR1;
        //    MeetingRoom2
        parameter Modelica.SIunits.Length l_2ndFlr_MTR2 = 3.84;
        parameter Modelica.SIunits.Length w_2ndFlr_MTR2 = 3.2;
        parameter Modelica.SIunits.Volume Vol_2ndFlr_MTR2 = w_2ndFlr_MTR2*l_2ndFlr_MTR2*Height2ndFlr;
        parameter Modelica.SIunits.Area AWindows_2ndFlr_MTR2 = 2*1*Height2ndFlr;
        parameter Modelica.SIunits.Area AGlazing_2ndFlr_MTR2 = 2*0.9*(Height2ndFlr-0.1);
        parameter Real FrameRatio_2ndFlr_MTR2 = 1 - AGlazing_2ndFlr_MTR1/AWindows_2ndFlr_MTR1;
        //    CopyRooms
        parameter Modelica.SIunits.Length l_2ndFlr_CPR = 4.84+3.49;
        parameter Modelica.SIunits.Length w_2ndFlr_CPR = 3.2;
        parameter Modelica.SIunits.Volume Vol_2ndFlr_CPR = l_2ndFlr_CPR*w_2ndFlr_CPR*Height2ndFlr;

        parameter Modelica.SIunits.Volume Flr2nd_TotalVol = Vol_2ndFlr_BRZ+Vol_2ndFlr_CPR+Vol_2ndFlr_MTR1+Vol_2ndFlr_MTR2+Vol_2ndFlr_NZ+Vol_2ndFlr_SZ2;

        //Floor area
        parameter Modelica.SIunits.Area Atotal2ndFlr = l_2ndFlr_CPR*w_2ndFlr_CPR + l_2ndFlr_BRZ*w_2ndFlr_BRZ + l_2ndFlr_MTR1*w_2ndFlr_MTR1 + l_2ndFlr_MTR2*w_2ndFlr_MTR2 + Vol_2ndFlr_SZ/Height2ndFlr + Vol_2ndFlr_NZ/Height2ndFlr;
        parameter Modelica.SIunits.Area A_2ndFlr[6] = {Vol_2ndFlr_NZ/Height2ndFlr, Vol_2ndFlr_SZ/Height2ndFlr, l_2ndFlr_MTR1*w_2ndFlr_MTR1, l_2ndFlr_MTR2*w_2ndFlr_MTR2, l_2ndFlr_CPR*w_2ndFlr_CPR, l_2ndFlr_BRZ*w_2ndFlr_BRZ};
        annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)));
      end Str2ndFlr;

      record Str3rdFlr
        extends Modelica.Icons.Record;

        //OuterWalls and Windows
        parameter Modelica.SIunits.Height WindowHeight = 2.69;
        parameter Modelica.SIunits.Height Height3rdFlr = 2.95;
        parameter Modelica.SIunits.Angle inc_roof = 9.32*Modelica.Constants.pi/180;
        parameter Modelica.SIunits.Area WindowA = WindowHeight*(0.025+0.08+0.29+0.08+0.055+0.765+0.065);
        parameter Modelica.SIunits.Area WindowB = WindowHeight*(0.025+0.08+0.735+0.08+0.06+0.315+0.07);
        parameter Modelica.SIunits.Area WindowC = WindowHeight*(0.065+1.23+0.065);
        parameter Modelica.SIunits.Area WindowD = WindowHeight*(0.065+0.73+0.065);
        parameter Modelica.SIunits.Area GlazingA = 0.29*(WindowHeight-0.12-0.12)+0.765*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingB = 0.735*(WindowHeight-0.08-0.105)+0.31*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingC = 1.23*(WindowHeight-0.05-0.075);
        parameter Modelica.SIunits.Area GlazingD = 0.73*(WindowHeight-0.05-0.075);

        //    SouthZone
        parameter Modelica.SIunits.Volume Vol_3rdFlr_SZ = Height3rdFlr*(11*32.3+(4.75+0.4)*1.1)+32.3*(11*1.77/2);
        parameter Modelica.SIunits.Area A_3rdFlr_SZ = (11*32.3+(4.75+0.4)*1.1);
        parameter Modelica.SIunits.Area AWall_3rdFlr_SZ[4] = {Height3rdFlr*1.9, Height3rdFlr*11+11*1.77/2, Height3rdFlr*32.3, Height3rdFlr*11+11*1.77/2+Height3rdFlr*(4.75+0.4)}-AWindows_3rdFlr_SZ;
        parameter Modelica.SIunits.Area AWindows_3rdFlr_SZ[4] = {WindowD, 3*WindowC+WindowB, 11*WindowB, 4*WindowB};
        parameter Modelica.SIunits.Area AGlazing_3rdFlr_SZ[4] = {GlazingD, 3*GlazingD+GlazingB, 11*GlazingB, 4*GlazingB};
        parameter Real FrameRatio_3rdFlr_SZ[4] = {1- AGlazing_3rdFlr_SZ[1]/AWindows_3rdFlr_SZ[1], 1- AGlazing_3rdFlr_SZ[2]/AWindows_3rdFlr_SZ[2], 1- AGlazing_3rdFlr_SZ[3]/AWindows_3rdFlr_SZ[3], 1- AGlazing_3rdFlr_SZ[4]/AWindows_3rdFlr_SZ[4]};
        parameter Modelica.SIunits.Angle azi_3rdFlr_SZ[4] = {INFRAX.Data.Orientations.N,
            INFRAX.Data.Orientations.E,INFRAX.Data.Orientations.S,INFRAX.Data.Orientations.W};
        parameter Modelica.SIunits.Angle inc_3rdFlr_SZ[4] = {IDEAS.Types.Tilt.Wall,IDEAS.Types.Tilt.Wall,IDEAS.Types.Tilt.Wall,IDEAS.Types.Tilt.Wall};
            //High level windows
        parameter Modelica.SIunits.Area AWindoiws_3rdFlr_HW = 32.2*0.8;
        parameter Real FrameRatio_3rdFlr_HW = 0.08;

        //RectangularZones
        //    SouthZone
        //parameter Modelica.SIunits.Length l_3rdFlr_SZ = 32.3;
        //parameter Modelica.SIunits.Length w_3rdFlr_SZ = 11;
        //    BathroomZone
        parameter Modelica.SIunits.Length l_3rdFlr_BRZ = 3.55;
        parameter Modelica.SIunits.Length w_3rdFlr_BRZ = 4.2+0.4;
        parameter Modelica.SIunits.Volume Vol_3rdFlr_BRZ = l_3rdFlr_BRZ*w_3rdFlr_BRZ*Height3rdFlr;
        //    CopyRoom
        parameter Modelica.SIunits.Length l_3rdFlr_CPR = 5.15;
        parameter Modelica.SIunits.Length w_3rdFlr_CPR = 4.2+0.4;
        parameter Modelica.SIunits.Volume Vol_3rdFlr_CPR = l_3rdFlr_CPR*w_3rdFlr_CPR*Height3rdFlr;
        parameter Modelica.SIunits.Area AWindows_3rdFlr_CPR = 2*WindowA;
        parameter Real FrameRatio_3rdFlr_CPR = 1 - GlazingA/WindowA;
        //    MeetingRoom
        parameter Modelica.SIunits.Length l_3rdFlr_MTR = 7.8;
        parameter Modelica.SIunits.Length w_3rdFlr_MTR = 5.0;
        parameter Modelica.SIunits.Volume Vol_3rdFlr_MTR = l_3rdFlr_MTR*w_3rdFlr_MTR*Height3rdFlr;
        parameter Modelica.SIunits.Area AWindows_3rdFlr_MTR = 3*WindowA;
        parameter Real FrameRatio_3rdFlr_MTR = 1 - GlazingA/WindowA;
        //    SmallRoom
        parameter Modelica.SIunits.Length l_3rdFlr_SmaR = 2.63;
        parameter Modelica.SIunits.Length w_3rdFlr_SmaR = 5.0;
        parameter Modelica.SIunits.Volume Vol_3rdFlr_SmaR = l_3rdFlr_SmaR*w_3rdFlr_SmaR*Height3rdFlr;
        parameter Modelica.SIunits.Area AWindows_3rdFlr_SmaR = WindowA;
        parameter Real FrameRatio_3rdFlr_SmaR = 1 - GlazingA/WindowA;
        //    StorageRoom
        parameter Modelica.SIunits.Length l_3rdFlr_StoR = 2.56;
        parameter Modelica.SIunits.Length w_3rdFlr_StoR = 5.0;
        parameter Modelica.SIunits.Volume Vol_3rdFlr_StoR = w_3rdFlr_StoR*l_3rdFlr_StoR*Height3rdFlr;
        parameter Modelica.SIunits.Area AWindows_3rdFlr_StoR = WindowA;
        parameter Real FrameRatio_3rdFlr_StoR = 1 - GlazingA/WindowA;

        parameter Modelica.SIunits.Volume Flr3rd_TotalVol = Vol_3rdFlr_BRZ+Vol_3rdFlr_CPR+Vol_3rdFlr_MTR+Vol_3rdFlr_SmaR+Vol_3rdFlr_StoR+Vol_3rdFlr_SZ;

        //Floor area
          //Floor area
        parameter Modelica.SIunits.Area Atotal3rdFlr = Vol_3rdFlr_SZ/Height3rdFlr + l_3rdFlr_BRZ*w_3rdFlr_BRZ + l_3rdFlr_CPR*w_3rdFlr_CPR + l_3rdFlr_MTR*w_3rdFlr_MTR + l_3rdFlr_SmaR*w_3rdFlr_SmaR + l_3rdFlr_StoR*w_3rdFlr_StoR;
        parameter Modelica.SIunits.Area A_3rdFlr[5] = {Vol_3rdFlr_SZ/Height3rdFlr, l_3rdFlr_BRZ*w_3rdFlr_BRZ, l_3rdFlr_CPR*w_3rdFlr_CPR, l_3rdFlr_MTR*w_3rdFlr_MTR, l_3rdFlr_SmaR*w_3rdFlr_SmaR + l_3rdFlr_StoR*w_3rdFlr_StoR};

        parameter Modelica.SIunits.Area CCA3rdFlr = Atotal3rdFlr - l_3rdFlr_BRZ*w_3rdFlr_BRZ;
        annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)));
      end Str3rdFlr;

      record Hydronic "Hydronic System Data"
        extends Modelica.Icons.Record;
        //Media

        //Time constants
        parameter Modelica.SIunits.Time sensorTau = 60;

        //Flow rates
        parameter Modelica.SIunits.MassFlowRate sink_m_flow = p06_m_flow + p07_m_flow + p08_m_flow + p10_m_flow;
        parameter Modelica.SIunits.MassFlowRate source_m_flow = 38000/3600;
        //TABS flow rates and pressure drops
        // 3rdFlr

        parameter Modelica.SIunits.MassFlowRate m_flow_3rdFlr[4] = {5140, 740/3, 740/3, 740/3}/3600;
        parameter Modelica.SIunits.PressureDifference dp_nominal_3rdFlr[4] = 20000*ones(4);
        // 2ndFlr

        // collector 1 and 4: south zone (2nd index)
        // collector 3: meetingrooms 980l/h (3rd and 4th index) and part of north zone
        parameter Modelica.SIunits.MassFlowRate m_flow_2ndFlr[7] = {980/4, 1520+890, 980*3/8, 980*3/8, 730/3, 730/3, 730/3}/3600;
        parameter Modelica.SIunits.PressureDifference dp_nominal_2ndFlr[7]= 40000*ones(7);
        // 1stFlr

        parameter Modelica.SIunits.MassFlowRate m_flow_1stFlr[9] = {785, 1085/3, 1560, 945/2, 945/2, 830*3/5, 830/5, 830/5, 1085*2/3}/3600;
        parameter Modelica.SIunits.PressureDifference dp_nominal_1stFlr[9]= 40000*ones(9);
        // GndFlr
        // collector 3: server room and storage room: 50/50 of 740 l/h
        // 5+6+7 = kitchen
        parameter Modelica.SIunits.MassFlowRate m_flow_GndFlr[15] = {1570*2/9, 515, 1030, 1030, 1570/3, 1030/6, 1030/6, 1030/6, 740/2, 1030/6, 740/2, 705, 1570*4/9, 1030/6, 1030/6}/3600;
        parameter Modelica.SIunits.PressureDifference dp_nominal_GndFlr[15] = 40000*ones(15);

        //Ratio massflow
        parameter Real ratio_mflow_TABS[35] = (cat(1, m_flow_3rdFlr, m_flow_2ndFlr, m_flow_1stFlr, m_flow_GndFlr))/p07_m_flow;

        //Hydraulic pumps nominal mass flow rates
        parameter Modelica.SIunits.MassFlowRate p01_m_flow = 38000/3600 "mass flow rate of hydraulic pump p01";
        parameter Modelica.SIunits.MassFlowRate p02_m_flow = 38000/3600 "mass flow rate of hydraulic pump p02";
        parameter Modelica.SIunits.MassFlowRate p03_m_flow = 24000/3600 "mass flow rate of hydraulic pump p03";
        parameter Modelica.SIunits.MassFlowRate p04_m_flow = 28300/3600 "mass flow rate of hydraulic pump p04";
        parameter Modelica.SIunits.MassFlowRate p05_m_flow = 21000/3600 "mass flow rate of hydraulic pump p05";
        parameter Modelica.SIunits.MassFlowRate p06_m_flow = 9800/3600 "mass flow rate of hydraulic pump p06";
        parameter Modelica.SIunits.MassFlowRate[21] p06_m_flow_dist = {0.32, 0.03, 0.06, 0.06, 0.07, 0.28, 0.06, 0.06, 0.11, 0.08, 0.16, 0.06, 0.06, 0.01, 0.02, 0.61, 0.18, 0.32, (0.03+0.09), 0.02, 0.02};
        parameter Modelica.SIunits.MassFlowRate p07_m_flow = 19400/3600 "mass flow rate of hydraulic pump p07";
        parameter Modelica.SIunits.MassFlowRate p08_m_flow = 7300/3600 "mass flow rate of hydraulic pump p08";
        parameter Modelica.SIunits.MassFlowRate p09_m_flow = 7950/3600 "mass flow rate of hydraulic pump p09";
        parameter Modelica.SIunits.MassFlowRate p10_m_flow = 24000/3600 "mass flow rate of hydraulic pump p10";
        parameter Modelica.SIunits.MassFlowRate p11_m_flow = 30000/3600 "mass flow rate of hydraulic pump p11";
        parameter Modelica.SIunits.MassFlowRate p12_m_flow = 5730/3600 "mass flow rate of hydraulic pump p12";
        parameter Modelica.SIunits.MassFlowRate p13_m_flow = 17000/3600 "mass flow rate of hydraulic pump p13";
        parameter Modelica.SIunits.MassFlowRate p14_m_flow = 5730/3600 "mass flow rate of hydraulic pump p14";

        //Buffer tank data
        parameter Modelica.SIunits.Volume VolTank = 2500/1000 "buffer tank volume";
        parameter Modelica.SIunits.Height HeightTank = 2275/1000 "buffer tank height";
        parameter Modelica.SIunits.CoefficientOfHeatTransfer UTank = 0.026/0.04 "U coefficient, U=k/d";

        //106kW Cooling H-ex
        parameter Modelica.SIunits.CoefficientOfHeatTransfer U_Cool_Hex = 5302 "OHTC service";
        parameter Modelica.SIunits.Area A_Cool_Hex = 27.8 "heat transfer area";
        parameter Modelica.SIunits.PressureDifference dp_water_Cool_Hex = 48.7*1000 "pressure drop on water side";
        parameter Modelica.SIunits.PressureDifference dp_glycol_Cool_Hex = 49.3*1000 "pressure drop on glycol side";

        //90kW Passive Cooling H-ex
        parameter Modelica.SIunits.CoefficientOfHeatTransfer U_PassiveCool_Hex = 5724 "OHTC service";
        parameter Modelica.SIunits.Area A_PassiveCool_Hex = 31.4 "heat transfer area";
        parameter Modelica.SIunits.PressureDifference dp_water_PassiveCool_Hex = 40.1*1000 "pressure drop on water side";
        parameter Modelica.SIunits.PressureDifference dp_glycol_PassiveCool_Hex = 53.2*1000 "pressure drop on glycol side";

        INFRAXTABS iNFRAXTABS
          annotation (Placement(transformation(extent={{-60,60},{-40,80}})));
        Structure structure
          annotation (Placement(transformation(extent={{-60,20},{-40,40}})));
        annotation (Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)));
      end Hydronic;

      record INFRAXTABS "INFRAX: CCA data"
        extends
        IDEAS.Fluid.HeatExchangers.RadiantSlab.BaseClasses.RadiantSlabChar(
            tabs = true,
            T = 0.15,
            d_a = 0.02,
            s_r = 0.0023,
            lambda_r = 0.35,
            S_1 = 0.31,
            S_2 = 0.06,
            lambda_b = 1.4,
            c_b = 840,
            rho_b = 2100);
         parameter Real m_flow_nominal_spe(unit="kg/(s.m2)") = 9.8 / 3600
          "Nominal mass flow rate per square meter floor heating, taken from hollandsch huys"; // * 3 is added to avoid having to split the TABS.

      end INFRAXTABS;

      record DYNACIAT_200_LG_LGP_cissimmo_wetter =
        IBPSA.Fluid.HeatPumps.Data.ScrollWaterToWater.Generic (
          volRat = 2.30724270104,
          V_flow_nominal = 0.0114761424136,
          leaCoe = 0.0035247058965,
          etaEle = 0.917967648379,
          PLos = 198.349670073,
          dTSup = 0.00527806112236,
          UACon = 76516.2456947,
          UAEva = 138624.163733)
        annotation (
          defaultComponentPrefixes = "parameter",
          defaultComponentName="datHeaPum",
          preferredView="info",
        Documentation(info="<html>
<p>
Generated by Iago Cupeiro on 2017-12-06.
</p>
</html>"));

      package BorefieldData "borefield INFRAX data"

        record INFRAX_bF
          "INFRAX borefield (38x94m doble U)"
          extends IBPSA.Fluid.Geothermal.Borefields.Data.Borefield.Template(
            conDat = INFRAX.Data.Parameters.BorefieldData.GeneralINFRAX(),
            soiDat = INFRAX.Data.Parameters.BorefieldData.SoilINFRAX(),
            filDat = INFRAX.Data.Parameters.BorefieldData.FillingINFRAX());

        end INFRAX_bF;

        record GeneralINFRAX
          "INFRAX parameters of the geometrical configuration of the borefield"
            extends
          IBPSA.Fluid.Geothermal.Borefields.Data.Configuration.Template(
            borCon = IBPSA.Fluid.Geothermal.Borefields.Types.BoreholeConfiguration.DoubleUTubeParallel,
            nBor=37,
            cooBor={{3, 0},{9, 0},{15, 0},{21, 0},{27, 0},{33, 0},{39, 0},{45, 0},{51, 0},
                   {0, sqrt(27)},{6, sqrt(27)},{12, sqrt(27)},{18, sqrt(27)},{24, sqrt(27)},{36, sqrt(27)},{42, sqrt(27)},{48, sqrt(27)},{54, sqrt(27)},
                   {3, 2*sqrt(27)},{9, 2*sqrt(27)},{15, 2*sqrt(27)},{21, 2*sqrt(27)},{27, 2*sqrt(27)},{33, 2*sqrt(27)},{39, 2*sqrt(27)},{45, 2*sqrt(27)},{51, 2*sqrt(27)},
                   {48, 3*sqrt(27)},{51, 4*sqrt(27)},{48, 5*sqrt(27)},{51, 6*sqrt(27)},{48, 7*sqrt(27)},{51, 8*sqrt(27)},{48, 9*sqrt(27)},{51, 10*sqrt(27)},{48, 11*sqrt(27)},{51, 12*sqrt(27)}},
            mBor_flow_nominal=10.55/37,
            hBor=94.0,
            rBor=0.15/2,
            rTub=0.032/2,
            kTub=0.42,
            eTub=0.003,
            dBor=1.0,
            xC=0.085/2,
            dp_nominal=28500,
            use_Rb=false,
            Rb=0.094);

                        //assumed parameter
                         //k for HDPE
                             //Assumming Double U is placed in center of BH
                         //Thermal conductivity of HPDE
                                 // data sheet
                         // building plans
                                       //building plans                                                                                                    //undeep boreholes
                                                                                                            //deep boreholes
                         // data sheet
                       // external sources
                         // data sheet
                          // assuming pipe is symmetrically spaced
        end GeneralINFRAX;

        record SoilINFRAX "Soil properties for INFRAX borefield"
            extends IBPSA.Fluid.Geothermal.Borefields.Data.Soil.Template(
            kSoi=1.3,
            dSoi=1358.4,
            cSoi=980);
            // k and c extracted from EED data
            // calculation of d based on soil profile from smartgeotherm project tool
            // density data extracted from structx.com/Soil_Properties_002.html [kg/m3]
            // 4.5m of loam (4.5) d=1430
            // 15m of clay sand (19.5) = 1470
            // 1.2m of loam (20.7) d=1430
            // 73.3m of clay (94) d= 1330 (note: goes down to 98m)
            // d = 1358.4
        end SoilINFRAX;

        record FillingINFRAX "Filling data for INFRAX bore field"
            extends IBPSA.Fluid.Geothermal.Borefields.Data.Filling.Template(
            kFil=2.35,
            dFil=1225,
            cFil=1550);

            //On 200L grout is the borehole filling composition
            //- 25 kg blast furnace cement
            //- 15 kg bentonite cement stable
            //- 80 kg of quartz sand (30 micr.)
            //- 125 l of water (125kg)
            //density is 245kg/200l = 1225kg/m3
            //k is extracted from EED data
        end FillingINFRAX;
      end BorefieldData;

      record INFRAX_AHU_Fans "record for fans in INFRAX AHU"
        extends IDEAS.Fluid.Movers.Data.Generic(
          speed_rpm_nominal=2000,
          use_powerCharacteristic = false,
          motorEfficiency(V_flow={2},eta={0.95*0.87*0.94}),
          hydraulicEfficiency(V_flow={1.9, 2.1, 2.3, 2.7, 2.85, 3.15, 3.5},
                eta={0.80, 0.81, 0.80, 0.75, 0.70, 0.60, 0.40}),
          pressure(V_flow={1.5, 2.5, 3.1, 3.5},
                dp={1000, 800, 500, 200}));

        annotation (
      defaultComponentPrefixes="parameter",
      defaultComponentName="per",
                    Icon(coordinateSystem(preserveAspectRatio=false)), Diagram(
              coordinateSystem(preserveAspectRatio=false)));
      end INFRAX_AHU_Fans;
    end Parameters;

    package Constructions

      record OuterWalls "INFRAX outer walls with override for U"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          nLay(min=1)=size(mats,1),
          incLastLay = IDEAS.Types.Tilt.Wall,
          mats={Data.Materials.Fiberboard(            d=0.022),
          Data.Insulation.Glasswool(            d=0.18),
          Data.Materials.Sandstone(            d=0.2),
          Data.Materials.Gypsum(            d=0.015)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end OuterWalls;

      record Roof "INFRAX flat Roof"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          nLay(min=1)=size(mats,1),
          incLastLay = IDEAS.Types.Tilt.Ceiling,
          locGain(each min=1) = {4},
          mats={Data.Materials.Grind(            d=0.06),
          Data.Insulation.Pir26(            d=0.08),
          Data.Insulation.Pir23(            d=0.08),
          Data.Materials.Concrete(            d=0.21),
          Data.Materials.Concrete(          d=0.06),
          Data.Materials.Gypsum(            d=0.00)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end Roof;

      record StepRoof "INFRAX sloped Roof"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          incLastLay = IDEAS.Types.Tilt.Ceiling,
          locGain = {3},
          mats={Data.Insulation.Pir26(            d=0.08),
          Data.Insulation.Pir23(            d=0.08),
          Data.Materials.Concrete(            d=0.27),
          Data.Materials.Concrete(            d=0.06),
          Data.Materials.Gypsum(            d=0.00)});

      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end StepRoof;

      record Floor "INFRAX groundfloor Floor"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          nLay(min=1)=size(mats,1),
          incLastLay = IDEAS.Types.Tilt.Floor,
          mats={Data.Insulation.Woodwool(            d=0.02),
          Data.Insulation.Pir23(            d=0.08),
          Data.Materials.HoledConcrete(            d=0.32),
          Data.Materials.Screed(            d=0.05),
          Data.Materials.Air(            d=0.55),
          Data.Materials.Silicate(            d=0.038),
          Data.Materials.Tile(            d=0.012)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end Floor;

      record Slab "INFRAX Slab"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          incLastLay = IDEAS.Types.Tilt.Floor,
          mats={Data.Materials.Concrete(            d=0.05),
          Data.Materials.Concrete(            d=0.3),
          Data.Materials.Screed(            d=0.1)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end Slab;

      record InnerFloor "INFRAX Inner Floors"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          nLay(min=1)=size(mats,1),
          incLastLay = IDEAS.Types.Tilt.Floor,
          locGain(each min=1) = {2},
          mats={Data.Materials.Gypsum(d=0.00),
          Data.Materials.Concrete(d=0.06),
          Data.Materials.Concrete(d=0.31),
          Data.Materials.Air(d=0.45),
          Data.Materials.ParticleBoard(d=0.03)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end InnerFloor;

      record GarageWall "INFRAX garage concrete walls"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          incLastLay = IDEAS.Types.Tilt.Wall,
          mats={Data.Materials.Concrete(            d=0.3)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end GarageWall;

      record GarageWallWithIns
        "INFRAX garage concrete walls with insulation for outer part"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          mats={Data.Materials.Concrete(            d=0.12),
                Data.Insulation.Xps(            d=0.12),
                Data.Materials.Concrete(            d=0.3)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end GarageWallWithIns;

      record ConcreteWall "INFRAX reinforced concrete walls"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          nLay(min=1)=size(mats,1),
          incLastLay = IDEAS.Types.Tilt.Wall,
          mats={Data.Materials.Concrete(            d=0.2)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end ConcreteWall;

      record SilicateWall "INFRAX silicate stone walls"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          nLay(min=1)=size(mats,1),
          incLastLay = IDEAS.Types.Tilt.Wall,
          mats={Data.Materials.Silicate(            d=0.2)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end SilicateWall;

      record GlassWall "INFRAX glass walls"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          incLastLay = IDEAS.Types.Tilt.Wall,
          mats={IDEAS.Buildings.Data.Materials.Glass(d=0.006,epsLw_a=0.04),
          IDEAS.Buildings.Data.Materials.Air(d=0.016),
          IDEAS.Buildings.Data.Materials.Glass(d=0.006,epsLw_b=0.04)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end GlassWall;

      record GlasswoolWall "INFRAX glasswool walls"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          incLastLay = IDEAS.Types.Tilt.Wall,
          mats={Data.Materials.Glass(            d=0.01),
          Data.Insulation.Glasswool(            d=0.2),
          Data.Materials.Fiberboard(           d=0.01)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end GlasswoolWall;

      record ReinforcedGlassWall "INFRAX glass walls reinforced with wood"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          nLay(min=1)=size(mats,1),
          incLastLay = IDEAS.Types.Tilt.Wall,
          mats={Data.Materials.Timber(            d=0.02),
          Data.Materials.Glass(            d=0.00)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end ReinforcedGlassWall;

      record PlasterWallCavity "INFRAX plaster walls with air cavity"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          incLastLay = IDEAS.Types.Tilt.Wall,
          mats={Data.Materials.Gypsum(            d=0.08),
                Data.Materials.Air(            d=0.3),
                Data.Materials.Gypsum(            d=0.08)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end PlasterWallCavity;

      record PlasterWall "INFRAX plaster walls"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          incLastLay = IDEAS.Types.Tilt.Wall,
          mats={Data.Materials.Gypsum(            d=0.08)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end PlasterWall;

      record ReinforcedPlasterWall
        "INFRAX plaster walls reinforced with wood"
        extends IDEAS.Buildings.Data.Interfaces.Construction(
          incLastLay = IDEAS.Types.Tilt.Wall,
          mats={Data.Materials.Timber(            d=0.02),
          Data.Materials.Gypsum(            d=0.08)});
      annotation (Documentation(info="<html>
<p>
Example implementation of a Thermally Activated Building System.
</p>
<ul>
<li>
November 14, 2016, by Filip Jorissen:<br/>
Revised implementation: removed insulationType.
</li>
</ul>
</html>"));
      end ReinforcedPlasterWall;
    end Constructions;

    package Insulation "Library of thermal insulation materials"
    extends Modelica.Icons.MaterialPropertiesPackage;

      record Glasswool = IDEAS.Buildings.Data.Interfaces.Insulation (
          k=0.040,
          c=840,
          rho=80) "Glasswool" annotation (Documentation(info="<html>
<p>
Glass wool insulation thermal properties.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));

      record Xps = IDEAS.Buildings.Data.Interfaces.Insulation (
          k=0.024,
          c=1470,
          rho=40,
          epsLw=0.8,
          epsSw=0.8) "Extruded polystrene, XPS" annotation (Documentation(info="<html>
<p>
Extruded polystyrene (XPS) insulation thermal properties.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));

      record Pir23=IDEAS.Buildings.Data.Interfaces.Insulation (
          k=0.023,
          c=1400,
          rho=30) "Polyisocyanuraat foam, PIR" annotation (Documentation(info="<html>
<p>
Polyisocyanurate (PIR) insulation thermal properties.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));

      record Pir26=IDEAS.Buildings.Data.Interfaces.Insulation (
          k=0.026,
          c=1400,
          rho=40) "Polyisocyanuraat foam, PIR" annotation (Documentation(info="<html>
<p>
Polyisocyanurate (PIR) insulation thermal properties.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));

      record Woodwool =  IDEAS.Buildings.Data.Interfaces.Insulation (
          k=0.080,
          c=2100,
          rho=450) "Woodwool"  annotation (Documentation(info="<html>
<p>
Glass wool insulation thermal properties.
</p>
</html>",       revisions="<html>
<ul>
<li>
November 15, 2016, by Filip Jorissen:<br/>
Revised documentation for IDEAS 1.0.
</li>
</ul>
</html>"));
    end Insulation;

    package Materials "Library of construction materials"
    extends Modelica.Icons.MaterialPropertiesPackage;

      record Air = IDEAS.Buildings.Data.Interfaces.Material (
          k=0.0241,
          c=1008,
          rho=1.23,
          epsSw=0,
          epsLw=0,
          gas=true,
          mhu=18.3*10e-6) "Air" annotation (Documentation(info="<html>
<p>
Constant air thermal properties.
</p>
</html>"));

      record Concrete = IDEAS.Buildings.Data.Interfaces.Material (
          k=1.4,
          c=840,
          rho=2100,
          epsLw=0.88,
          epsSw=0.55) "Dense cast concrete, also for finishing" annotation (
          Documentation(info="<html>
<p>
Thermal properties of concrete.
</p>
</html>"));

      record Glass = IDEAS.Buildings.Data.Interfaces.Material (
          k=0.96,
          c=750,
          rho=2500,
          epsLw=0.84,
          epsSw=0.67) "Glass" annotation (Documentation(info="<html>
<p>
Thermal properties of glass.
</p>
</html>"));

      record Gypsum = IDEAS.Buildings.Data.Interfaces.Material (
          k=0.6,
          c=840,
          rho=975,
          epsLw=0.85,
          epsSw=0.65) "Gypsum plaster for finishing" annotation (Documentation(info="<html>
<p>
Thermal properties of gypsum.
</p>
</html>"));

      record Screed = IDEAS.Buildings.Data.Interfaces.Material (
          k=0.6,
          c=840,
          rho=1100,
          epsLw=0.88,
          epsSw=0.55) "Light cast concrete" annotation (Documentation(info="<html>
<p>
Thermal properties of screed.
</p>
</html>"));

      record Tile = IDEAS.Buildings.Data.Interfaces.Material (
          k=1.4,
          c=840,
          rho=2100,
          epsLw=0.88,
          epsSw=0.55) "Ceramic tile for finishing" annotation (Documentation(info="<html>
<p>
Thermal properties of tiles.
</p>
</html>"));

      record Timber = IDEAS.Buildings.Data.Interfaces.Material (
          k=0.11,
          c=1880,
          rho=550,
          epsLw=0.86,
          epsSw=0.44) "Timber finishing" annotation (Documentation(info="<html>
<p>
Thermal properties of timber.
</p>
</html>"));

      record HoledConcrete =
                        IDEAS.Buildings.Data.Interfaces.Material (
          k=0.9,
          c=840,
          rho=1357.5,
          epsLw=0.88,
          epsSw=0.55) "Dense cast concrete, also for finishing" annotation (
          Documentation(info="<html>
<p>
Thermal properties of concrete.
</p>
</html>"));

      record Silicate=IDEAS.Buildings.Data.Interfaces.Material (
          k=0.175,
          c=920,
          rho=870,
          epsLw=0.85,
          epsSw=0.65) "silicaatplaat"                annotation (Documentation(info="<html>
<p>
Thermal properties of gypsum.
</p>
</html>"));

      record ParticleBoard =
                       IDEAS.Buildings.Data.Interfaces.Material (
          k=0.12,
          c=1300,
          rho=640,
          epsLw=0.86,
          epsSw=0.44) "Particle Board finishing"
                                           annotation (Documentation(info="<html>
<p>
Thermal properties of plywood.
</p>
</html>"));

      record Fiberboard =
                       IDEAS.Buildings.Data.Interfaces.Material (
          k=0.048,
          c=2068,
          rho=270,
          epsLw=0.74,
          epsSw=0.85) "Board of treated wood against weather"
                                           annotation (Documentation(info="<html>
<p>
Thermal properties of plywood.
</p>
</html>"));

      record Sandstone =IDEAS.Buildings.Data.Interfaces.Material (
          k=0.97,
          c=840,
          rho=2000,
          epsLw=0.88,
          epsSw=0.67) "sandstone blocks"                        annotation (
          Documentation(info="<html>
<p>
Thermal properties of concrete.
</p>
</html>"));

      record Grind =  IDEAS.Buildings.Data.Interfaces.Material (
          k=1.21,
          c=920,
          rho=1700,
          epsLw=0.88,
          epsSw=0.68) annotation (Documentation(info="<html>
<p>
Thermal properties of ground/soil.
</p>
</html>"));
    end Materials;

    package Glazing "Library of building glazing systems"
    extends Modelica.Icons.MaterialPropertiesPackage;

      record SGGCLIMAPLUSONE4dash15dash6 =
                      IDEAS.Buildings.Data.Interfaces.Glazing (
          final nLay=3,
          final mats={IDEAS.Buildings.Data.Materials.Glass(
                                      d=0.004, epsLw_a=0.04),
                      IDEAS.Buildings.Data.Materials.Argon(
                                      d=0.015),
                      IDEAS.Buildings.Data.Materials.Glass(
                                      d=0.006)},
          final SwTrans=[0, 0.388;
                        10, 0.391;
                        20, 0.385;
                        30, 0.378;
                        40, 0.368;
                        50, 0.349;
                        60, 0.308;
                        70, 0.227;
                        80, 0.109;
                        90, 0.000],
          final SwAbs=[0, 0.114, 0.0, 0.083;
                      10, 0.114, 0.0, 0.084;
                      20, 0.116, 0.0, 0.090;
                      30, 0.119, 0.0, 0.094;
                      40, 0.124, 0.0, 0.095;
                      50, 0.129, 0.0, 0.097;
                      60, 0.134, 0.0, 0.105;
                      70, 0.137, 0.0, 0.109;
                      80, 0.131, 0.0, 0.078;
                      90, 0.000, 0.0, 0.000],
          final SwTransDif=0.325,
          final SwAbsDif={0.125,0.0,0.095},
          final U_value=1.0,
          final g_value=0.49) "Saint Gobain SGG CLIMAPLUS ONE 4/15/6"
        annotation (Documentation(revisions="<html>
<ul>
<li>
September 2, 2015, by Filip Jorissen:<br/>
Moved epsLw definition to solid layer to be consistent 
with changed implementation of MultiLayerLucent.
</li>
</ul>
</html>",       info="<html>
<p>
Double insulated glazing system with Argon filling.
</p>
</html>"));
    end Glazing;

    package Frames "Library of building glazing frames"
    extends Modelica.Icons.MaterialPropertiesPackage;

      record INFRAXWood "INFRAX wooden frame"
        extends IDEAS.Buildings.Data.Interfaces.Frame(
          U_value=3.23);
            annotation (Documentation(info="<html>
<p>
Wooden window frame. U value may vary.
</p>
</html>"));
      end INFRAXWood;
    end Frames;

    package Orientations "INFRAX Types"
       extends Modelica.Icons.TypesPackage;

       constant Modelica.SIunits.Angle shift = Modelica.Constants.pi*33/180
       "INFRAX orientation shift with respect to north";

       constant Modelica.SIunits.Angle E = IDEAS.Types.Azimuth.E + shift
       "INFRAX fake east orientation";

       constant Modelica.SIunits.Angle N = IDEAS.Types.Azimuth.N + shift
       "INFRAX fake north orientation";

       constant Modelica.SIunits.Angle S = IDEAS.Types.Azimuth.S + shift
       "INFRAX fake south orientation";

       constant Modelica.SIunits.Angle W = IDEAS.Types.Azimuth.W + shift
       "INFRAX fake west orientation";

       constant Modelica.SIunits.Angle inc = IDEAS.Types.Azimuth.N + shift - 71/180*
       Modelica.Constants.pi
       "INFRAX inc orientation gnd and 1st floor";
    end Orientations;

    package Shading

      model HorizontalFins "INFRAX horizontal fins shading"
        extends IDEAS.Buildings.Components.Shading.HorizontalFins(
          use_displacementInput=true,
          beta= Modelica.Constants.pi/6,
          s=0.17,
          w=0.175,
          t=0.032);

          annotation (
          Icon(coordinateSystem(preserveAspectRatio=true, extent={{-50,-100},{50,100}})),
          Documentation(info="<html>
<p>Shading model of horizontal fins in function of the inclination angle of the fins.</p>
<p><br><img src=\"modelica://IDEAS/Resources/Images/Buildings/Components/Shading/HorizontalFins.png\"/></p>
</html>",       revisions="<html>
<ul>
<li>
March, 2019 by Filip Jorissen:<br/>
Extending from IDEAS
</li>
<li>
April, 2017 by Iago Cupeiro:<br/>
Cleaned up implementation and documentation.
</li>
</ul>
</html>"));
      end HorizontalFins;
    end Shading;
  end Data;
annotation (uses(                      Modelica(version="3.2.3"), IDEAS(version=
         "2.1.1"),
    IBPSA(version="1.0.0"),
    Buildings(version="6.0.0"),
    UnitTests(version="1")),
  version="3",
  conversion(from(version="", script="ConvertFromINFRAX_.mos"), noneFromVersion=
       "1",
    noneFromVersion="2"));
end INFRAX;
model INFRAX_IBPSA_BOPTEST
 extends INFRAX.IBPSA_BOPTEST;
  annotation(experiment(
  StartTime=1262304000,
  StopTime=1293840000,
  Interval=1800,
  Tolerance=1e-06,
  __Dymola_fixedstepsize=15,
  __Dymola_Algorithm="Euler"),uses(INFRAX(version="3")));
end INFRAX_IBPSA_BOPTEST;
